commit f934d0ef5b4e8e9521312dad4ec9e7e8d74d93e5 (from ca811156a0506409e87dc25909369ac33ab48733)
Merge: e48dfcc ca81115
Author: Erik vd Zalm <erik@vdzalm.eu>
Date:   Wed Nov 21 20:36:30 2012 +0100

    Merge remote-tracking branch 'tonokip/Marlin_v1' into Marlin_v1
    
    Conflicts:
    	Marlin/Configuration.h

diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index 0efa6e8..4aff7fe 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -5,35 +5,46 @@
 // Advanced settings can be found in Configuration_adv.h 
 // BASIC SETTINGS: select your board type, temperature sensor type, axis scaling, and endstop configuration
 
-//User specified version info of THIS file to display in [Pronterface, etc] terminal window during startup.
+//User specified version info of this build to display in [Pronterface, etc] terminal window during startup.
 //Implementation of an idea by Prof Braino to inform user that any changes made
-//to THIS file by the user have been successfully uploaded into firmware.
-#define STRING_VERSION_CONFIG_H "2012-05-02" //Personal revision number for changes to THIS file.
-#define STRING_CONFIG_H_AUTHOR "erik" //Who made the changes.
+//to this build by the user have been successfully uploaded into firmware.
+#define STRING_VERSION_CONFIG_H __DATE__ " " __TIME__ // build date and time
+#define STRING_CONFIG_H_AUTHOR "(none, default config)" //Who made the changes.
+
+// SERIAL_PORT selects which serial port should be used for communication with the host.
+// This allows the connection of wireless adapters (for instance) to non-default port pins.
+// Serial port 0 is still used by the Arduino bootloader regardless of this setting.
+#define SERIAL_PORT 0
 
 // This determines the communication speed of the printer
 #define BAUDRATE 250000
 //#define BAUDRATE 115200
 
 //// The following define selects which electronics board you have. Please choose the one that matches your setup
-// Gen7 custom (Alfons3 Version) = 10 "https://github.com/Alfons3/Generation_7_Electronics"
-// Gen7 v1.1, v1.2 = 11
-// Gen7 v1.3 = 12
-// Gen7 v1.4 = 13
-// MEGA/RAMPS up to 1.2 = 3
-// RAMPS 1.3 = 33 (Power outputs: Extruder, Bed, Fan)
-// RAMPS 1.3 = 34 (Power outputs: Extruder0, Extruder1, Bed)
-// Gen6 = 5
-// Gen6 deluxe = 51
-// Sanguinololu 1.2 and above = 62
-// Melzi = 63
-// Ultimaker = 7
-// Teensylu = 8
-// Gen3+ =9
+// 10 = Gen7 custom (Alfons3 Version) "https://github.com/Alfons3/Generation_7_Electronics"
+// 11 = Gen7 v1.1, v1.2 = 11
+// 12 = Gen7 v1.3
+// 13 = Gen7 v1.4
+// 3  = MEGA/RAMPS up to 1.2 = 3
+// 33 = RAMPS 1.3 (Power outputs: Extruder, Bed, Fan)
+// 34 = RAMPS 1.3 (Power outputs: Extruder0, Extruder1, Bed)
+// 4  = Duemilanove w/ ATMega328P pin assignment
+// 5  = Gen6
+// 51 = Gen6 deluxe
+// 6  = Sanguinololu < 1.2
+// 62 = Sanguinololu 1.2 and above
+// 63 = Melzi
+// 7  = Ultimaker
+// 71 = Ultimaker (Older electronics. Pre 1.5.4. This is rare)
+// 8  = Teensylu
+// 9  = Gen3+
+// 70 = Megatronics
+// 90 = Alpha OMCA board
+// 91 = Final OMCA board
 // Rambo = 301
 
 #ifndef MOTHERBOARD
-#define MOTHERBOARD 301
+#define MOTHERBOARD 7
 #endif
 
 
@@ -99,7 +110,7 @@
 #define PID_MAX 255 // limits current to nozzle; 255=full current
 #ifdef PIDTEMP
   //#define PID_DEBUG // Sends debug data to the serial port. 
-  //#define PID_OPENLOOP 1 // Puts PID in open loop. M104 sets the output power in %
+  //#define PID_OPENLOOP 1 // Puts PID in open loop. M104/M140 sets the output power from 0 to PID_MAX
   #define PID_INTEGRAL_DRIVE_MAX 255  //limit for the integral term
   #define K1 0.95 //smoothing factor withing the PID
   #define PID_dT ((16.0 * 8.0)/(F_CPU / 64.0 / 256.0)) //sampling period of the
@@ -121,6 +132,44 @@
 //    #define  DEFAULT_Kd 440
 #endif // PIDTEMP
 
+// Bed Temperature Control
+// Select PID or bang-bang with PIDTEMPBED.  If bang-bang, BED_LIMIT_SWITCHING will enable hysteresis
+//
+// uncomment this to enable PID on the bed.   It uses the same ferquency PWM as the extruder. 
+// If your PID_dT above is the default, and correct for your hardware/configuration, that means 7.689Hz,
+// which is fine for driving a square wave into a resistive load and does not significantly impact you FET heating.
+// This also works fine on a Fotek SSR-10DA Solid State Relay into a 250W heater. 
+// If your configuration is significantly different than this and you don't understand the issues involved, you proabaly 
+// shouldn't use bed PID until someone else verifies your hardware works.
+// If this is enabled, find your own PID constants below.
+//#define PIDTEMPBED
+//
+//#define BED_LIMIT_SWITCHING
+
+// This sets the max power delived to the bed, and replaces the HEATER_BED_DUTY_CYCLE_DIVIDER option.
+// all forms of bed control obey this (PID, bang-bang, bang-bang with hysteresis)
+// setting this to anything other than 255 enables a form of PWM to the bed just like HEATER_BED_DUTY_CYCLE_DIVIDER did,
+// so you shouldn't use it unless you are OK with PWM on your bed.  (see the comment on enabling PIDTEMPBED)
+#define MAX_BED_POWER 255 // limits duty cycle to bed; 255=full current
+
+#ifdef PIDTEMPBED
+//120v 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
+//from FOPDT model - kp=.39 Tp=405 Tdead=66, Tc set to 79.2, argressive factor of .15 (vs .1, 1, 10)
+    #define  DEFAULT_bedKp 10.00
+    #define  DEFAULT_bedKi .023
+    #define  DEFAULT_bedKd 305.4
+
+//120v 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
+//from pidautotune
+//    #define  DEFAULT_bedKp 97.1
+//    #define  DEFAULT_bedKi 1.41
+//    #define  DEFAULT_bedKd 1675.16
+
+// FIND YOUR OWN: "M303 E-1 C8 S90" to run autotune on the bed at 90 degreesC for 8 cycles.
+#endif // PIDTEMPBED
+
+
+
 //this prevents dangerous Extruder moves, i.e. if the temperature is under the limit
 //can be software-disabled for whatever purposes by
 #define PREVENT_DANGEROUS_EXTRUDE
@@ -204,10 +253,14 @@ const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
 #define Y_MAX_LENGTH (Y_MAX_POS - Y_MIN_POS)
 #define Z_MAX_LENGTH (Z_MAX_POS - Z_MIN_POS)
 
-// The position of the homing switches. Use MAX_LENGTH * -0.5 if the center should be 0, 0, 0
-#define X_HOME_POS 0
-#define Y_HOME_POS 0
-#define Z_HOME_POS 0
+// The position of the homing switches
+//#define MANUAL_HOME_POSITIONS  // If defined, manualy programed locations will be used
+//#define BED_CENTER_AT_0_0  // If defined the center of the bed is defined as (0,0)
+
+//Manual homing switch locations:
+#define MANUAL_X_HOME_POS 0
+#define MANUAL_Y_HOME_POS 0
+#define MANUAL_Z_HOME_POS 0
 
 //// MOVEMENT SETTINGS
 #define NUM_AXIS 4 // The axis order in all axis related arrays is X, Y, Z, E
@@ -249,12 +302,26 @@ const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
 //#define ULTIMAKERCONTROLLER //as available from the ultimaker online store.
 //#define ULTIPANEL  //the ultipanel as on thingiverse
 
+// The RepRapDiscount Smart Controller
+// http://reprap.org/wiki/RepRapDiscount_Smart_Controller
+//#define REPRAP_DISCOUNT_SMART_CONTROLLER
+
 
-#ifdef ULTIMAKERCONTROLLER    //automatic expansion
+//automatic expansion
+#if defined(ULTIMAKERCONTROLLER) || defined(REPRAP_DISCOUNT_SMART_CONTROLLER)
  #define ULTIPANEL
  #define NEWPANEL
 #endif 
- 
+
+// Preheat Constants
+#define PLA_PREHEAT_HOTEND_TEMP 180 
+#define PLA_PREHEAT_HPB_TEMP 70
+#define PLA_PREHEAT_FAN_SPEED 255		// Insert Value between 0 and 255
+
+#define ABS_PREHEAT_HOTEND_TEMP 240
+#define ABS_PREHEAT_HPB_TEMP 100
+#define ABS_PREHEAT_FAN_SPEED 255		// Insert Value between 0 and 255
+
 
 #ifdef ULTIPANEL
 //  #define NEWPANEL  //enable this if you have a click-encoder panel
@@ -263,15 +330,6 @@ const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
   #define LCD_WIDTH 20
   #define LCD_HEIGHT 4
   
-// Preheat Constants
-  #define PLA_PREHEAT_HOTEND_TEMP 180 
-  #define PLA_PREHEAT_HPB_TEMP 70
-  #define PLA_PREHEAT_FAN_SPEED 255		// Insert Value between 0 and 255
-
-  #define ABS_PREHEAT_HOTEND_TEMP 240
-  #define ABS_PREHEAT_HPB_TEMP 100
-  #define ABS_PREHEAT_FAN_SPEED 255		// Insert Value between 0 and 255
-
 #else //no panel but just lcd 
   #ifdef ULTRA_LCD
     #define LCD_WIDTH 16
@@ -286,6 +344,9 @@ const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
 // Data from: http://www.doc-diy.net/photo/rc-1_hacked/
 // #define PHOTOGRAPH_PIN     23
 
+// SF send wrong arc g-codes when using Arc Point as fillet procedure
+//#define SF_ARC_FIX
+
 #include "Configuration_adv.h"
 #include "thermistortables.h"
 
diff --git a/Marlin/ConfigurationStore.cpp b/Marlin/ConfigurationStore.cpp
new file mode 100644
index 0000000..fe61656
--- /dev/null
+++ b/Marlin/ConfigurationStore.cpp
@@ -0,0 +1,244 @@
+#include "Marlin.h"
+#include "planner.h"
+#include "temperature.h"
+#include "ultralcd.h"
+#include "ConfigurationStore.h"
+
+void _EEPROM_writeData(int &pos, uint8_t* value, uint8_t size)
+{
+    do
+    {
+        eeprom_write_byte((unsigned char*)pos, *value);
+        pos++;
+        value++;
+    }while(--size);
+}
+#define EEPROM_WRITE_VAR(pos, value) _EEPROM_writeData(pos, (uint8_t*)&value, sizeof(value))
+void _EEPROM_readData(int &pos, uint8_t* value, uint8_t size)
+{
+    do
+    {
+        *value = eeprom_read_byte((unsigned char*)pos);
+        pos++;
+        value++;
+    }while(--size);
+}
+#define EEPROM_READ_VAR(pos, value) _EEPROM_readData(pos, (uint8_t*)&value, sizeof(value))
+//======================================================================================
+
+
+
+
+#define EEPROM_OFFSET 100
+
+
+// IMPORTANT:  Whenever there are changes made to the variables stored in EEPROM
+// in the functions below, also increment the version number. This makes sure that
+// the default values are used whenever there is a change to the data, to prevent
+// wrong data being written to the variables.
+// ALSO:  always make sure the variables in the Store and retrieve sections are in the same order.
+#define EEPROM_VERSION "V07"
+
+#ifdef EEPROM_SETTINGS
+void Config_StoreSettings() 
+{
+  char ver[4]= "000";
+  int i=EEPROM_OFFSET;
+  EEPROM_WRITE_VAR(i,ver); // invalidate data first 
+  EEPROM_WRITE_VAR(i,axis_steps_per_unit);  
+  EEPROM_WRITE_VAR(i,max_feedrate);  
+  EEPROM_WRITE_VAR(i,max_acceleration_units_per_sq_second);
+  EEPROM_WRITE_VAR(i,acceleration);
+  EEPROM_WRITE_VAR(i,retract_acceleration);
+  EEPROM_WRITE_VAR(i,minimumfeedrate);
+  EEPROM_WRITE_VAR(i,mintravelfeedrate);
+  EEPROM_WRITE_VAR(i,minsegmenttime);
+  EEPROM_WRITE_VAR(i,max_xy_jerk);
+  EEPROM_WRITE_VAR(i,max_z_jerk);
+  EEPROM_WRITE_VAR(i,max_e_jerk);
+  EEPROM_WRITE_VAR(i,add_homeing);
+  #ifndef ULTIPANEL
+  int plaPreheatHotendTemp = PLA_PREHEAT_HOTEND_TEMP, plaPreheatHPBTemp = PLA_PREHEAT_HPB_TEMP, plaPreheatFanSpeed = PLA_PREHEAT_FAN_SPEED;
+  int absPreheatHotendTemp = ABS_PREHEAT_HOTEND_TEMP, absPreheatHPBTemp = ABS_PREHEAT_HPB_TEMP, absPreheatFanSpeed = ABS_PREHEAT_FAN_SPEED;
+  #endif
+  EEPROM_WRITE_VAR(i,plaPreheatHotendTemp);
+  EEPROM_WRITE_VAR(i,plaPreheatHPBTemp);
+  EEPROM_WRITE_VAR(i,plaPreheatFanSpeed);
+  EEPROM_WRITE_VAR(i,absPreheatHotendTemp);
+  EEPROM_WRITE_VAR(i,absPreheatHPBTemp);
+  EEPROM_WRITE_VAR(i,absPreheatFanSpeed);
+  #ifdef PIDTEMP
+    EEPROM_WRITE_VAR(i,Kp);
+    EEPROM_WRITE_VAR(i,Ki);
+    EEPROM_WRITE_VAR(i,Kd);
+  #else
+    EEPROM_WRITE_VAR(i,3000);
+    EEPROM_WRITE_VAR(i,0);
+    EEPROM_WRITE_VAR(i,0);
+  #endif
+  char ver2[4]=EEPROM_VERSION;
+  i=EEPROM_OFFSET;
+  EEPROM_WRITE_VAR(i,ver2); // validate data
+  SERIAL_ECHO_START;
+  SERIAL_ECHOLNPGM("Settings Stored");
+}
+#endif //EEPROM_SETTINGS
+
+
+#ifdef EEPROM_CHITCHAT
+void Config_PrintSettings()
+{  // Always have this function, even with EEPROM_SETTINGS disabled, the current values will be shown
+    SERIAL_ECHO_START;
+    SERIAL_ECHOLNPGM("Steps per unit:");
+    SERIAL_ECHO_START;
+    SERIAL_ECHOPAIR("  M92 X",axis_steps_per_unit[0]);
+    SERIAL_ECHOPAIR(" Y",axis_steps_per_unit[1]);
+    SERIAL_ECHOPAIR(" Z",axis_steps_per_unit[2]);
+    SERIAL_ECHOPAIR(" E",axis_steps_per_unit[3]);
+    SERIAL_ECHOLN("");
+      
+    SERIAL_ECHO_START;
+    SERIAL_ECHOLNPGM("Maximum feedrates (mm/s):");
+    SERIAL_ECHO_START;
+    SERIAL_ECHOPAIR("  M203 X",max_feedrate[0]);
+    SERIAL_ECHOPAIR(" Y",max_feedrate[1] ); 
+    SERIAL_ECHOPAIR(" Z", max_feedrate[2] ); 
+    SERIAL_ECHOPAIR(" E", max_feedrate[3]);
+    SERIAL_ECHOLN("");
+
+    SERIAL_ECHO_START;
+    SERIAL_ECHOLNPGM("Maximum Acceleration (mm/s2):");
+    SERIAL_ECHO_START;
+    SERIAL_ECHOPAIR("  M201 X" ,max_acceleration_units_per_sq_second[0] ); 
+    SERIAL_ECHOPAIR(" Y" , max_acceleration_units_per_sq_second[1] ); 
+    SERIAL_ECHOPAIR(" Z" ,max_acceleration_units_per_sq_second[2] );
+    SERIAL_ECHOPAIR(" E" ,max_acceleration_units_per_sq_second[3]);
+    SERIAL_ECHOLN("");
+    SERIAL_ECHO_START;
+    SERIAL_ECHOLNPGM("Acceleration: S=acceleration, T=retract acceleration");
+    SERIAL_ECHO_START;
+    SERIAL_ECHOPAIR("  M204 S",acceleration ); 
+    SERIAL_ECHOPAIR(" T" ,retract_acceleration);
+    SERIAL_ECHOLN("");
+
+    SERIAL_ECHO_START;
+    SERIAL_ECHOLNPGM("Advanced variables: S=Min feedrate (mm/s), T=Min travel feedrate (mm/s), B=minimum segment time (ms), X=maximum xY jerk (mm/s),  Z=maximum Z jerk (mm/s)");
+    SERIAL_ECHO_START;
+    SERIAL_ECHOPAIR("  M205 S",minimumfeedrate ); 
+    SERIAL_ECHOPAIR(" T" ,mintravelfeedrate ); 
+    SERIAL_ECHOPAIR(" B" ,minsegmenttime ); 
+    SERIAL_ECHOPAIR(" X" ,max_xy_jerk ); 
+    SERIAL_ECHOPAIR(" Z" ,max_z_jerk);
+    SERIAL_ECHOPAIR(" E" ,max_e_jerk);
+    SERIAL_ECHOLN(""); 
+
+    SERIAL_ECHO_START;
+    SERIAL_ECHOLNPGM("Home offset (mm):");
+    SERIAL_ECHO_START;
+    SERIAL_ECHOPAIR("  M206 X",add_homeing[0] );
+    SERIAL_ECHOPAIR(" Y" ,add_homeing[1] );
+    SERIAL_ECHOPAIR(" Z" ,add_homeing[2] );
+    SERIAL_ECHOLN("");
+#ifdef PIDTEMP
+    SERIAL_ECHO_START;
+    SERIAL_ECHOLNPGM("PID settings:");
+    SERIAL_ECHO_START;
+    SERIAL_ECHOPAIR("   M301 P",Kp); 
+    SERIAL_ECHOPAIR(" I" ,Ki/PID_dT); 
+    SERIAL_ECHOPAIR(" D" ,Kd*PID_dT);
+    SERIAL_ECHOLN(""); 
+#endif
+} 
+#endif
+
+
+#ifdef EEPROM_SETTINGS
+void Config_RetrieveSettings()
+{
+    int i=EEPROM_OFFSET;
+    char stored_ver[4];
+    char ver[4]=EEPROM_VERSION;
+    EEPROM_READ_VAR(i,stored_ver); //read stored version
+    //  SERIAL_ECHOLN("Version: [" << ver << "] Stored version: [" << stored_ver << "]");
+    if (strncmp(ver,stored_ver,3) == 0)
+    {
+        // version number match
+        EEPROM_READ_VAR(i,axis_steps_per_unit);  
+        EEPROM_READ_VAR(i,max_feedrate);  
+        EEPROM_READ_VAR(i,max_acceleration_units_per_sq_second);
+        EEPROM_READ_VAR(i,acceleration);
+        EEPROM_READ_VAR(i,retract_acceleration);
+        EEPROM_READ_VAR(i,minimumfeedrate);
+        EEPROM_READ_VAR(i,mintravelfeedrate);
+        EEPROM_READ_VAR(i,minsegmenttime);
+        EEPROM_READ_VAR(i,max_xy_jerk);
+        EEPROM_READ_VAR(i,max_z_jerk);
+        EEPROM_READ_VAR(i,max_e_jerk);
+        EEPROM_READ_VAR(i,add_homeing);
+        #ifndef ULTIPANEL
+        int plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed;
+        int absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed;
+        #endif
+        EEPROM_READ_VAR(i,plaPreheatHotendTemp);
+        EEPROM_READ_VAR(i,plaPreheatHPBTemp);
+        EEPROM_READ_VAR(i,plaPreheatFanSpeed);
+        EEPROM_READ_VAR(i,absPreheatHotendTemp);
+        EEPROM_READ_VAR(i,absPreheatHPBTemp);
+        EEPROM_READ_VAR(i,absPreheatFanSpeed);
+        #ifndef PIDTEMP
+        float Kp,Ki,Kd;
+        #endif
+        EEPROM_READ_VAR(i,Kp);
+        EEPROM_READ_VAR(i,Ki);
+        EEPROM_READ_VAR(i,Kd);
+
+        SERIAL_ECHO_START;
+        SERIAL_ECHOLNPGM("Stored settings retreived:");
+    }
+    else
+    {
+        Config_ResetDefault();
+        SERIAL_ECHO_START;
+        SERIAL_ECHOLN("Using Default settings:");
+    }
+    Config_PrintSettings();
+}
+#endif
+
+void Config_ResetDefault()
+{
+    float tmp1[]=DEFAULT_AXIS_STEPS_PER_UNIT;
+    float tmp2[]=DEFAULT_MAX_FEEDRATE;
+    long tmp3[]=DEFAULT_MAX_ACCELERATION;
+    for (short i=0;i<4;i++) 
+    {
+        axis_steps_per_unit[i]=tmp1[i];  
+        max_feedrate[i]=tmp2[i];  
+        max_acceleration_units_per_sq_second[i]=tmp3[i];
+    }
+    acceleration=DEFAULT_ACCELERATION;
+    retract_acceleration=DEFAULT_RETRACT_ACCELERATION;
+    minimumfeedrate=DEFAULT_MINIMUMFEEDRATE;
+    minsegmenttime=DEFAULT_MINSEGMENTTIME;       
+    mintravelfeedrate=DEFAULT_MINTRAVELFEEDRATE;
+    max_xy_jerk=DEFAULT_XYJERK;
+    max_z_jerk=DEFAULT_ZJERK;
+    max_e_jerk=DEFAULT_EJERK;
+    add_homeing[0] = add_homeing[1] = add_homeing[2] = 0;
+#ifdef ULTIPANEL
+    plaPreheatHotendTemp = PLA_PREHEAT_HOTEND_TEMP;
+    plaPreheatHPBTemp = PLA_PREHEAT_HPB_TEMP;
+    plaPreheatFanSpeed = PLA_PREHEAT_FAN_SPEED;
+    absPreheatHotendTemp = ABS_PREHEAT_HOTEND_TEMP;
+    absPreheatHPBTemp = ABS_PREHEAT_HPB_TEMP;
+    absPreheatFanSpeed = ABS_PREHEAT_FAN_SPEED;
+#endif
+#ifdef PIDTEMP
+    Kp = DEFAULT_Kp;
+    Ki = (DEFAULT_Ki*PID_dT);
+    Kd = (DEFAULT_Kp/PID_dT);
+#ifdef PID_ADD_EXTRUSION_RATE
+    Kc = DEFAULT_Kc;
+#endif//PID_ADD_EXTRUSION_RATE
+#endif//PIDTEMP
+}
diff --git a/Marlin/ConfigurationStore.h b/Marlin/ConfigurationStore.h
new file mode 100644
index 0000000..db99f5b
--- /dev/null
+++ b/Marlin/ConfigurationStore.h
@@ -0,0 +1,24 @@
+#ifndef CONFIG_STORE_H
+#define CONFIG_STORE_H
+
+#include "Configuration.h"
+
+void Config_ResetDefault();
+
+#ifdef EEPROM_CHITCHAT
+void Config_PrintSettings();
+#else
+FORCE_INLINE void Config_PrintSettings() {}
+#endif
+
+#ifdef EEPROM_SETTINGS
+void Config_StoreSettings();
+void Config_RetrieveSettings();
+#else
+FORCE_INLINE void Config_StoreSettings() {}
+FORCE_INLINE void Config_RetrieveSettings() { Config_ResetDefault(); Config_PrintSettings(); }
+#endif
+
+#endif
+
+
diff --git a/Marlin/Configuration_adv.h b/Marlin/Configuration_adv.h
index 15f43f9..1727606 100644
--- a/Marlin/Configuration_adv.h
+++ b/Marlin/Configuration_adv.h
@@ -5,13 +5,10 @@
 //=============================Thermal Settings  ============================
 //===========================================================================
 
-// Select one of these only to define how the bed temp is read.
-//
-//#define BED_LIMIT_SWITCHING
 #ifdef BED_LIMIT_SWITCHING
   #define BED_HYSTERESIS 2 //only disable heating if T>target+BED_HYSTERESIS and enable heating if T>target-BED_HYSTERESIS
 #endif
-#define BED_CHECK_INTERVAL 5000 //ms
+#define BED_CHECK_INTERVAL 5000 //ms between checks in bang-bang control
 
 //// Heating sanity check:
 // This waits for the watchperiod in milliseconds whenever an M104 or M109 increases the target temperature
@@ -76,6 +73,54 @@
 
 #define ENDSTOPS_ONLY_FOR_HOMING // If defined the endstops will only be used for homing
 
+
+//// AUTOSET LOCATIONS OF LIMIT SWITCHES
+//// Added by ZetaPhoenix 09-15-2012
+#ifdef MANUAL_HOME_POSITION  //Use manual limit switch locations
+  #define X_HOME_POS MANUAL_X_HOME_POS
+  #define Y_HOME_POS MANUAL_Y_HOME_POS
+  #define Z_HOME_POS MANUAL_Z_HOME_POS
+#else //Set min/max homing switch positions based upon homing direction and min/max travel limits
+  //X axis
+  #if X_HOME_DIR == -1
+    #ifdef BED_CENTER_AT_0_0
+      #define X_HOME_POS X_MAX_LENGTH * -0.5
+    #else
+      #define X_HOME_POS X_MIN_POS
+    #endif //BED_CENTER_AT_0_0
+  #else    
+    #ifdef BED_CENTER_AT_0_0
+      #define X_HOME_POS X_MAX_LENGTH * 0.5
+    #else
+      #define X_HOME_POS X_MAX_POS
+    #endif //BED_CENTER_AT_0_0
+  #endif //X_HOME_DIR == -1
+  
+  //Y axis
+  #if Y_HOME_DIR == -1
+    #ifdef BED_CENTER_AT_0_0
+      #define Y_HOME_POS Y_MAX_LENGTH * -0.5
+    #else
+      #define Y_HOME_POS Y_MIN_POS
+    #endif //BED_CENTER_AT_0_0
+  #else    
+    #ifdef BED_CENTER_AT_0_0
+      #define Y_HOME_POS Y_MAX_LENGTH * 0.5
+    #else
+      #define Y_HOME_POS Y_MAX_POS
+    #endif //BED_CENTER_AT_0_0
+  #endif //Y_HOME_DIR == -1
+  
+  // Z axis
+  #if Z_HOME_DIR == -1 //BED_CENTER_AT_0_0 not used
+    #define Z_HOME_POS Z_MIN_POS
+  #else    
+    #define Z_HOME_POS Z_MAX_POS
+  #endif //Z_HOME_DIR == -1
+#endif //End auto min/max positions
+//END AUTOSET LOCATIONS OF LIMIT SWITCHES -ZP
+
+
 //#define Z_LATE_ENABLE // Enable Z the last moment. Needed if your Z driver overheats.
 
 // A single Z stepper driver is usually used to drive 2 stepper motors.
@@ -148,17 +193,17 @@
 
 
 #define SD_FINISHED_STEPPERRELEASE true  //if sd support and the file is finished: disable steppers?
-#define SD_FINISHED_RELEASECOMMAND "M84 X Y Z E" // no z because of layer shift.
+#define SD_FINISHED_RELEASECOMMAND "M84 X Y Z E" // You might want to keep the z enabled so your bed stays in place.
 
-// The hardware watchdog should halt the Microcontroller, in case the firmware gets stuck somewhere. However:
-// the Watchdog is not working well, so please only enable this for testing
-// this enables the watchdog interrupt.
+// The hardware watchdog should reset the Microcontroller disabling all outputs, in case the firmware gets stuck and doesn't do temperature regulation.
 //#define USE_WATCHDOG
-//#ifdef USE_WATCHDOG
-  // you cannot reboot on a mega2560 due to a bug in he bootloader. Hence, you have to reset manually, and this is done hereby:
-//#define RESET_MANUAL
-//#define WATCHDOG_TIMEOUT 4  //seconds
-//#endif
+
+#ifdef USE_WATCHDOG
+// If you have a watchdog reboot in an ArduinoMega2560 then the device will hang forever, as a watchdog reset will leave the watchdog on.
+// The "WATCHDOG_RESET_MANUAL" goes around this by not using the hardware reset.
+//  However, THIS FEATURE IS UNSAFE!, as it will only work if interrupts are disabled. And the code could hang in an interrupt routine with interrupts disabled.
+//#define WATCHDOG_RESET_MANUAL
+#endif
 
 // extruder advance constant (s2/mm3)
 //
@@ -183,7 +228,7 @@
 #define MM_PER_ARC_SEGMENT 1
 #define N_ARC_CORRECTION 25
 
-const int dropsegments=5; //everything with less than this number of steps will be ignored as move and joined with the next movement
+const unsigned int dropsegments=5; //everything with less than this number of steps will be ignored as move and joined with the next movement
 
 // If you are using a RAMPS board or cheap E-bay purchased boards that do not detect when an SD card is inserted
 // You can get round this by connecting a push button or single throw switch to the pin defined as SDCARDCARDDETECT 
diff --git a/Marlin/EEPROMwrite.h b/Marlin/EEPROMwrite.h
deleted file mode 100644
index 12674ef..0000000
--- a/Marlin/EEPROMwrite.h
+++ /dev/null
@@ -1,232 +0,0 @@
-#ifndef EEPROM_H
-#define EEPROM_H
-
-#include "Marlin.h"
-#include "planner.h"
-#include "temperature.h"
-//#include <EEPROM.h>
-
-int plaPreheatHotendTemp;
-int plaPreheatHPBTemp;
-int plaPreheatFanSpeed;
-
-int absPreheatHotendTemp;
-int absPreheatHPBTemp;
-int absPreheatFanSpeed;
-
-template <class T> int EEPROM_writeAnything(int &ee, const T& value)
-{
-  const byte* p = (const byte*)(const void*)&value;
-  int i;
-  for (i = 0; i < (int)sizeof(value); i++)
-    eeprom_write_byte((unsigned char *)ee++, *p++);
-  return i;
-}
-
-template <class T> int EEPROM_readAnything(int &ee, T& value)
-{
-  byte* p = (byte*)(void*)&value;
-  int i;
-  for (i = 0; i < (int)sizeof(value); i++)
-    *p++ = eeprom_read_byte((unsigned char *)ee++);
-  return i;
-}
-//======================================================================================
-
-
-
-
-#define EEPROM_OFFSET 100
-
-
-// IMPORTANT:  Whenever there are changes made to the variables stored in EEPROM
-// in the functions below, also increment the version number. This makes sure that
-// the default values are used whenever there is a change to the data, to prevent
-// wrong data being written to the variables.
-// ALSO:  always make sure the variables in the Store and retrieve sections are in the same order.
-#define EEPROM_VERSION "V07"
-
-inline void EEPROM_StoreSettings() 
-{
-#ifdef EEPROM_SETTINGS
-  char ver[4]= "000";
-  int i=EEPROM_OFFSET;
-  EEPROM_writeAnything(i,ver); // invalidate data first 
-  EEPROM_writeAnything(i,axis_steps_per_unit);  
-  EEPROM_writeAnything(i,max_feedrate);  
-  EEPROM_writeAnything(i,max_acceleration_units_per_sq_second);
-  EEPROM_writeAnything(i,acceleration);
-  EEPROM_writeAnything(i,retract_acceleration);
-  EEPROM_writeAnything(i,minimumfeedrate);
-  EEPROM_writeAnything(i,mintravelfeedrate);
-  EEPROM_writeAnything(i,minsegmenttime);
-  EEPROM_writeAnything(i,max_xy_jerk);
-  EEPROM_writeAnything(i,max_z_jerk);
-  EEPROM_writeAnything(i,max_e_jerk);
-  EEPROM_writeAnything(i,add_homeing);
-  EEPROM_writeAnything(i,plaPreheatHotendTemp);
-  EEPROM_writeAnything(i,plaPreheatHPBTemp);
-  EEPROM_writeAnything(i,plaPreheatFanSpeed);
-  EEPROM_writeAnything(i,absPreheatHotendTemp);
-  EEPROM_writeAnything(i,absPreheatHPBTemp);
-  EEPROM_writeAnything(i,absPreheatFanSpeed);
-  #ifdef PIDTEMP
-    EEPROM_writeAnything(i,Kp);
-    EEPROM_writeAnything(i,Ki);
-    EEPROM_writeAnything(i,Kd);
-  #else
-    EEPROM_writeAnything(i,3000);
-    EEPROM_writeAnything(i,0);
-    EEPROM_writeAnything(i,0);
-  #endif
-  char ver2[4]=EEPROM_VERSION;
-  i=EEPROM_OFFSET;
-  EEPROM_writeAnything(i,ver2); // validate data
-  SERIAL_ECHO_START;
-  SERIAL_ECHOLNPGM("Settings Stored");
-#endif //EEPROM_SETTINGS
-}
-
-
-inline void EEPROM_printSettings()
-{  // if def=true, the default values will be used
-//  #ifdef EEPROM_SETTINGS  
-      SERIAL_ECHO_START;
-      SERIAL_ECHOLNPGM("Steps per unit:");
-      SERIAL_ECHO_START;
-      SERIAL_ECHOPAIR("  M92 X",axis_steps_per_unit[0]);
-      SERIAL_ECHOPAIR(" Y",axis_steps_per_unit[1]);
-      SERIAL_ECHOPAIR(" Z",axis_steps_per_unit[2]);
-      SERIAL_ECHOPAIR(" E",axis_steps_per_unit[3]);
-      SERIAL_ECHOLN("");
-      
-    SERIAL_ECHO_START;
-      SERIAL_ECHOLNPGM("Maximum feedrates (mm/s):");
-      SERIAL_ECHO_START;
-      SERIAL_ECHOPAIR("  M203 X",max_feedrate[0]);
-      SERIAL_ECHOPAIR(" Y",max_feedrate[1] ); 
-      SERIAL_ECHOPAIR(" Z", max_feedrate[2] ); 
-      SERIAL_ECHOPAIR(" E", max_feedrate[3]);
-      SERIAL_ECHOLN("");
-    SERIAL_ECHO_START;
-      SERIAL_ECHOLNPGM("Maximum Acceleration (mm/s2):");
-      SERIAL_ECHO_START;
-      SERIAL_ECHOPAIR("  M201 X" ,max_acceleration_units_per_sq_second[0] ); 
-      SERIAL_ECHOPAIR(" Y" , max_acceleration_units_per_sq_second[1] ); 
-      SERIAL_ECHOPAIR(" Z" ,max_acceleration_units_per_sq_second[2] );
-      SERIAL_ECHOPAIR(" E" ,max_acceleration_units_per_sq_second[3]);
-      SERIAL_ECHOLN("");
-    SERIAL_ECHO_START;
-      SERIAL_ECHOLNPGM("Acceleration: S=acceleration, T=retract acceleration");
-      SERIAL_ECHO_START;
-      SERIAL_ECHOPAIR("  M204 S",acceleration ); 
-      SERIAL_ECHOPAIR(" T" ,retract_acceleration);
-      SERIAL_ECHOLN("");
-    SERIAL_ECHO_START;
-      SERIAL_ECHOLNPGM("Advanced variables: S=Min feedrate (mm/s), T=Min travel feedrate (mm/s), B=minimum segment time (ms), X=maximum xY jerk (mm/s),  Z=maximum Z jerk (mm/s)");
-      SERIAL_ECHO_START;
-      SERIAL_ECHOPAIR("  M205 S",minimumfeedrate ); 
-      SERIAL_ECHOPAIR(" T" ,mintravelfeedrate ); 
-      SERIAL_ECHOPAIR(" B" ,minsegmenttime ); 
-      SERIAL_ECHOPAIR(" X" ,max_xy_jerk ); 
-      SERIAL_ECHOPAIR(" Z" ,max_z_jerk);
-      SERIAL_ECHOPAIR(" E" ,max_e_jerk);
-      SERIAL_ECHOLN(""); 
-    SERIAL_ECHO_START;
-      SERIAL_ECHOLNPGM("Home offset (mm):");
-      SERIAL_ECHO_START;
-      SERIAL_ECHOPAIR("  M206 X",add_homeing[0] );
-      SERIAL_ECHOPAIR(" Y" ,add_homeing[1] );
-      SERIAL_ECHOPAIR(" Z" ,add_homeing[2] );
-      SERIAL_ECHOLN("");
-    #ifdef PIDTEMP
-      SERIAL_ECHO_START;
-      SERIAL_ECHOLNPGM("PID settings:");
-      SERIAL_ECHO_START;
-      SERIAL_ECHOPAIR("   M301 P",Kp); 
-      SERIAL_ECHOPAIR(" I" ,Ki/PID_dT); 
-      SERIAL_ECHOPAIR(" D" ,Kd*PID_dT);
-      SERIAL_ECHOLN(""); 
-    #endif
-//  #endif
-} 
-
-
-inline void EEPROM_RetrieveSettings(bool def=false)
-{  // if def=true, the default values will be used
-  #ifdef EEPROM_SETTINGS
-    int i=EEPROM_OFFSET;
-    char stored_ver[4];
-    char ver[4]=EEPROM_VERSION;
-    EEPROM_readAnything(i,stored_ver); //read stored version
-    //  SERIAL_ECHOLN("Version: [" << ver << "] Stored version: [" << stored_ver << "]");
-    if ((!def)&&(strncmp(ver,stored_ver,3)==0)) 
-    {   // version number match
-      EEPROM_readAnything(i,axis_steps_per_unit);  
-      EEPROM_readAnything(i,max_feedrate);  
-      EEPROM_readAnything(i,max_acceleration_units_per_sq_second);
-      EEPROM_readAnything(i,acceleration);
-      EEPROM_readAnything(i,retract_acceleration);
-      EEPROM_readAnything(i,minimumfeedrate);
-      EEPROM_readAnything(i,mintravelfeedrate);
-      EEPROM_readAnything(i,minsegmenttime);
-      EEPROM_readAnything(i,max_xy_jerk);
-      EEPROM_readAnything(i,max_z_jerk);
-      EEPROM_readAnything(i,max_e_jerk);
-      EEPROM_readAnything(i,add_homeing);
-	  EEPROM_readAnything(i,plaPreheatHotendTemp);
-	  EEPROM_readAnything(i,plaPreheatHPBTemp);
-	  EEPROM_readAnything(i,plaPreheatFanSpeed);
-	  EEPROM_readAnything(i,absPreheatHotendTemp);
-	  EEPROM_readAnything(i,absPreheatHPBTemp);
-	  EEPROM_readAnything(i,absPreheatFanSpeed);
-      #ifndef PIDTEMP
-        float Kp,Ki,Kd;
-      #endif
-      EEPROM_readAnything(i,Kp);
-      EEPROM_readAnything(i,Ki);
-      EEPROM_readAnything(i,Kd);
-
-      SERIAL_ECHO_START;
-      SERIAL_ECHOLNPGM("Stored settings retreived:");
-    }
-    else 
-  #endif
-    {
-      float tmp1[]=DEFAULT_AXIS_STEPS_PER_UNIT;
-      float tmp2[]=DEFAULT_MAX_FEEDRATE;
-      long tmp3[]=DEFAULT_MAX_ACCELERATION;
-      for (short i=0;i<4;i++) 
-      {
-        axis_steps_per_unit[i]=tmp1[i];  
-        max_feedrate[i]=tmp2[i];  
-        max_acceleration_units_per_sq_second[i]=tmp3[i];
-      }
-      acceleration=DEFAULT_ACCELERATION;
-      retract_acceleration=DEFAULT_RETRACT_ACCELERATION;
-      minimumfeedrate=DEFAULT_MINIMUMFEEDRATE;
-      minsegmenttime=DEFAULT_MINSEGMENTTIME;       
-      mintravelfeedrate=DEFAULT_MINTRAVELFEEDRATE;
-      max_xy_jerk=DEFAULT_XYJERK;
-      max_z_jerk=DEFAULT_ZJERK;
-      max_e_jerk=DEFAULT_EJERK;
-      add_homeing[0] = add_homeing[1] = add_homeing[2] = 0;
-      SERIAL_ECHO_START;
-      SERIAL_ECHOLN("Using Default settings:");
-#ifdef ULTIPANEL
-	  plaPreheatHotendTemp = PLA_PREHEAT_HOTEND_TEMP;
-	  plaPreheatHPBTemp = PLA_PREHEAT_HPB_TEMP;
-	  plaPreheatFanSpeed = PLA_PREHEAT_FAN_SPEED;
-	  absPreheatHotendTemp = ABS_PREHEAT_HOTEND_TEMP;
-	  absPreheatHPBTemp = ABS_PREHEAT_HPB_TEMP;
-	  absPreheatFanSpeed = ABS_PREHEAT_FAN_SPEED;
-#endif
-    }
-  #ifdef EEPROM_CHITCHAT
-    EEPROM_printSettings();
-  #endif
-}  
-
-#endif
-
-
diff --git a/Marlin/Gen7/cores/arduino/wiring.h b/Marlin/Gen7/cores/arduino/wiring.h
index 6309a36..48ff04a 100644
--- a/Marlin/Gen7/cores/arduino/wiring.h
+++ b/Marlin/Gen7/cores/arduino/wiring.h
@@ -70,7 +70,9 @@ extern "C"{
 #define max(a,b) ((a)>(b)?(a):(b))
 #define abs(x) ((x)>0?(x):-(x))
 #define constrain(amt,low,high) ((amt)<(low)?(low):((amt)>(high)?(high):(amt)))
+#if __AVR_LIBC_VERSION__ < 10701UL
 #define round(x)     ((x)>=0?(long)((x)+0.5):(long)((x)-0.5))
+#endif
 #define radians(deg) ((deg)*DEG_TO_RAD)
 #define degrees(rad) ((rad)*RAD_TO_DEG)
 #define sq(x) ((x)*(x))
diff --git a/Marlin/LCD Menu Tree.pdf b/Marlin/LCD Menu Tree.pdf
new file mode 100644
index 0000000..5e29d04
Binary files /dev/null and b/Marlin/LCD Menu Tree.pdf differ
diff --git a/Marlin/LiquidCrystalRus.cpp b/Marlin/LiquidCrystalRus.cpp
new file mode 100644
index 0000000..4bd8de7
--- /dev/null
+++ b/Marlin/LiquidCrystalRus.cpp
@@ -0,0 +1,389 @@
+#include "LiquidCrystalRus.h"
+
+#include <stdio.h>
+#include <string.h>
+#include <inttypes.h>
+#include <avr/pgmspace.h>
+
+#if defined(ARDUINO) && ARDUINO >= 100
+  #include "Arduino.h"
+#else
+  #include "WProgram.h"
+#endif
+
+// it is a russian alphabet translation
+// except 0401 --> 0xa2 = ╗, 0451 --> 0xb5
+const PROGMEM uint8_t utf_recode[] = 
+       { 0x41,0xa0,0x42,0xa1,0xe0,0x45,0xa3,0xa4,0xa5,0xa6,0x4b,0xa7,0x4d,0x48,0x4f,
+         0xa8,0x50,0x43,0x54,0xa9,0xaa,0x58,0xe1,0xab,0xac,0xe2,0xad,0xae,0x62,0xaf,0xb0,0xb1,
+         0x61,0xb2,0xb3,0xb4,0xe3,0x65,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0x6f,
+         0xbe,0x70,0x63,0xbf,0x79,0xe4,0x78,0xe5,0xc0,0xc1,0xe6,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7
+        };     
+
+// When the display powers up, it is configured as follows:
+//
+// 1. Display clear
+// 2. Function set: 
+//    DL = 1; 8-bit interface data 
+//    N = 0; 1-line display 
+//    F = 0; 5x8 dot character font 
+// 3. Display on/off control: 
+//    D = 0; Display off 
+//    C = 0; Cursor off 
+//    B = 0; Blinking off 
+// 4. Entry mode set: 
+//    I/D = 1; Increment by 1 
+//    S = 0; No shift 
+//
+// Note, however, that resetting the Arduino doesn't reset the LCD, so we
+// can't assume that its in that state when a sketch starts (and the
+// LiquidCrystal constructor is called).
+// 
+// modified 27 Jul 2011
+// by Ilya V. Danilov http://mk90.ru/
+
+
+LiquidCrystalRus::LiquidCrystalRus(uint8_t rs, uint8_t rw, uint8_t enable,
+			     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
+			     uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)
+{
+  init(0, rs, rw, enable, d0, d1, d2, d3, d4, d5, d6, d7);
+}
+
+LiquidCrystalRus::LiquidCrystalRus(uint8_t rs, uint8_t enable,
+			     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
+			     uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)
+{
+  init(0, rs, 255, enable, d0, d1, d2, d3, d4, d5, d6, d7);
+}
+
+LiquidCrystalRus::LiquidCrystalRus(uint8_t rs, uint8_t rw, uint8_t enable,
+			     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3)
+{
+  init(1, rs, rw, enable, d0, d1, d2, d3, 0, 0, 0, 0);
+}
+
+LiquidCrystalRus::LiquidCrystalRus(uint8_t rs,  uint8_t enable,
+			     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3)
+{
+  init(1, rs, 255, enable, d0, d1, d2, d3, 0, 0, 0, 0);
+}
+
+void LiquidCrystalRus::init(uint8_t fourbitmode, uint8_t rs, uint8_t rw, uint8_t enable,
+			 uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
+			 uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)
+{
+  _rs_pin = rs;
+  _rw_pin = rw;
+  _enable_pin = enable;
+  
+  _data_pins[0] = d0;
+  _data_pins[1] = d1;
+  _data_pins[2] = d2;
+  _data_pins[3] = d3; 
+  _data_pins[4] = d4;
+  _data_pins[5] = d5;
+  _data_pins[6] = d6;
+  _data_pins[7] = d7; 
+
+  pinMode(_rs_pin, OUTPUT);
+  // we can save 1 pin by not using RW. Indicate by passing 255 instead of pin#
+  if (_rw_pin != 255) { 
+    pinMode(_rw_pin, OUTPUT);
+  }
+  pinMode(_enable_pin, OUTPUT);
+  
+  if (fourbitmode)
+    _displayfunction = LCD_4BITMODE | LCD_1LINE | LCD_5x8DOTS;
+  else 
+    _displayfunction = LCD_8BITMODE | LCD_1LINE | LCD_5x8DOTS;
+  
+  begin(16, 1);  
+}
+
+void LiquidCrystalRus::begin(uint8_t cols, uint8_t lines, uint8_t dotsize) {
+  if (lines > 1) {
+    _displayfunction |= LCD_2LINE;
+  }
+  _numlines = lines;
+  _currline = 0;
+
+  // for some 1 line displays you can select a 10 pixel high font
+  if ((dotsize != 0) && (lines == 1)) {
+    _displayfunction |= LCD_5x10DOTS;
+  }
+
+  // SEE PAGE 45/46 FOR INITIALIZATION SPECIFICATION!
+  // according to datasheet, we need at least 40ms after power rises above 2.7V
+  // before sending commands. Arduino can turn on way befer 4.5V so we'll wait 50
+  delayMicroseconds(50000); 
+  // Now we pull both RS and R/W low to begin commands
+  digitalWrite(_rs_pin, LOW);
+  digitalWrite(_enable_pin, LOW);
+  if (_rw_pin != 255) { 
+    digitalWrite(_rw_pin, LOW);
+  }
+  
+  //put the LCD into 4 bit or 8 bit mode
+  if (! (_displayfunction & LCD_8BITMODE)) {
+    // this is according to the hitachi HD44780 datasheet
+    // figure 24, pg 46
+
+    // we start in 8bit mode, try to set 4 bit mode
+    writeNbits(0x03,4);
+    delayMicroseconds(4500); // wait min 4.1ms
+
+    // second try
+    writeNbits(0x03,4);
+    delayMicroseconds(4500); // wait min 4.1ms
+    
+    // third go!
+    writeNbits(0x03,4); 
+    delayMicroseconds(150);
+
+    // finally, set to 8-bit interface
+    writeNbits(0x02,4); 
+  } else {
+    // this is according to the hitachi HD44780 datasheet
+    // page 45 figure 23
+
+    // Send function set command sequence
+    command(LCD_FUNCTIONSET | _displayfunction);
+    delayMicroseconds(4500);  // wait more than 4.1ms
+
+    // second try
+    command(LCD_FUNCTIONSET | _displayfunction);
+    delayMicroseconds(150);
+
+    // third go
+    command(LCD_FUNCTIONSET | _displayfunction);
+  }
+
+  // finally, set # lines, font size, etc.
+  command(LCD_FUNCTIONSET | _displayfunction);  
+
+  // turn the display on with no cursor or blinking default
+  _displaycontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;  
+  display();
+
+  // clear it off
+  clear();
+
+  // Initialize to default text direction (for romance languages)
+  _displaymode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;
+  // set the entry mode
+  command(LCD_ENTRYMODESET | _displaymode);
+
+}
+
+void LiquidCrystalRus::setDRAMModel(uint8_t model) {
+  _dram_model = model;
+}
+
+/********** high level commands, for the user! */
+void LiquidCrystalRus::clear()
+{
+  command(LCD_CLEARDISPLAY);  // clear display, set cursor position to zero
+  delayMicroseconds(2000);  // this command takes a long time!
+}
+
+void LiquidCrystalRus::home()
+{
+  command(LCD_RETURNHOME);  // set cursor position to zero
+  delayMicroseconds(2000);  // this command takes a long time!
+}
+
+void LiquidCrystalRus::setCursor(uint8_t col, uint8_t row)
+{
+  int row_offsets[] = { 0x00, 0x40, 0x14, 0x54 };
+  if ( row >= _numlines ) {
+    row = _numlines-1;    // we count rows starting w/0
+  }
+  
+  command(LCD_SETDDRAMADDR | (col + row_offsets[row]));
+}
+
+// Turn the display on/off (quickly)
+void LiquidCrystalRus::noDisplay() {
+  _displaycontrol &= ~LCD_DISPLAYON;
+  command(LCD_DISPLAYCONTROL | _displaycontrol);
+}
+void LiquidCrystalRus::display() {
+  _displaycontrol |= LCD_DISPLAYON;
+  command(LCD_DISPLAYCONTROL | _displaycontrol);
+}
+
+// Turns the underline cursor on/off
+void LiquidCrystalRus::noCursor() {
+  _displaycontrol &= ~LCD_CURSORON;
+  command(LCD_DISPLAYCONTROL | _displaycontrol);
+}
+void LiquidCrystalRus::cursor() {
+  _displaycontrol |= LCD_CURSORON;
+  command(LCD_DISPLAYCONTROL | _displaycontrol);
+}
+
+// Turn on and off the blinking cursor
+void LiquidCrystalRus::noBlink() {
+  _displaycontrol &= ~LCD_BLINKON;
+  command(LCD_DISPLAYCONTROL | _displaycontrol);
+}
+void LiquidCrystalRus::blink() {
+  _displaycontrol |= LCD_BLINKON;
+  command(LCD_DISPLAYCONTROL | _displaycontrol);
+}
+
+// These commands scroll the display without changing the RAM
+void LiquidCrystalRus::scrollDisplayLeft(void) {
+  command(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVELEFT);
+}
+void LiquidCrystalRus::scrollDisplayRight(void) {
+  command(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVERIGHT);
+}
+
+// This is for text that flows Left to Right
+void LiquidCrystalRus::leftToRight(void) {
+  _displaymode |= LCD_ENTRYLEFT;
+  command(LCD_ENTRYMODESET | _displaymode);
+}
+
+// This is for text that flows Right to Left
+void LiquidCrystalRus::rightToLeft(void) {
+  _displaymode &= ~LCD_ENTRYLEFT;
+  command(LCD_ENTRYMODESET | _displaymode);
+}
+
+// This will 'right justify' text from the cursor
+void LiquidCrystalRus::autoscroll(void) {
+  _displaymode |= LCD_ENTRYSHIFTINCREMENT;
+  command(LCD_ENTRYMODESET | _displaymode);
+}
+
+// This will 'left justify' text from the cursor
+void LiquidCrystalRus::noAutoscroll(void) {
+  _displaymode &= ~LCD_ENTRYSHIFTINCREMENT;
+  command(LCD_ENTRYMODESET | _displaymode);
+}
+
+// Allows us to fill the first 8 CGRAM locations
+// with custom characters
+void LiquidCrystalRus::createChar(uint8_t location, uint8_t charmap[]) {
+  location &= 0x7; // we only have 8 locations 0-7
+  command(LCD_SETCGRAMADDR | (location << 3));
+  for (int i=0; i<8; i++) {
+    write(charmap[i]);
+  }
+}
+
+/*********** mid level commands, for sending data/cmds */
+
+inline void LiquidCrystalRus::command(uint8_t value) {
+  send(value, LOW);
+}
+
+#if defined(ARDUINO) && ARDUINO >= 100
+  size_t LiquidCrystalRus::write(uint8_t value)
+#else
+  void   LiquidCrystalRus::write(uint8_t value)
+#endif
+{
+  uint8_t out_char=value;
+
+  if (_dram_model == LCD_DRAM_WH1601) {  
+    uint8_t ac=recv(LOW) & 0x7f;
+    if (ac>7 && ac<0x14) command(LCD_SETDDRAMADDR | (0x40+ac-8));
+  }
+
+  if (value>=0x80) { // UTF-8 handling
+    if (value >= 0xc0) {
+      utf_hi_char = value - 0xd0;
+    } else {
+      value &= 0x3f;
+      if (!utf_hi_char && (value == 1)) 
+        send(0xa2,HIGH); // ╗
+      else if ((utf_hi_char == 1) && (value == 0x11)) 
+        send(0xb5,HIGH); // ╦
+      else 
+        send(pgm_read_byte_near(utf_recode + value + (utf_hi_char<<6) - 0x10), HIGH);
+    }    
+  } else send(out_char, HIGH);
+#if defined(ARDUINO) && ARDUINO >= 100
+  return 1; // assume sucess 
+#endif
+}
+
+/************ low level data pushing commands **********/
+
+// write either command or data, with automatic 4/8-bit selection
+void LiquidCrystalRus::send(uint8_t value, uint8_t mode) {
+  digitalWrite(_rs_pin, mode);
+
+  // if there is a RW pin indicated, set it low to Write
+  if (_rw_pin != 255) { 
+    digitalWrite(_rw_pin, LOW);
+  }
+  
+  if (_displayfunction & LCD_8BITMODE) {
+    writeNbits(value,8); 
+  } else {
+    writeNbits(value>>4,4);
+    writeNbits(value,4);
+  }
+}
+
+// read  data, with automatic 4/8-bit selection
+uint8_t LiquidCrystalRus::recv(uint8_t mode) {
+  uint8_t retval;
+  digitalWrite(_rs_pin, mode);
+
+  // if there is a RW pin indicated, set it low to Write
+  if (_rw_pin != 255) { 
+    digitalWrite(_rw_pin, HIGH);
+  }
+  
+  if (_displayfunction & LCD_8BITMODE) {
+    retval = readNbits(8); 
+  } else {
+    retval = readNbits(4) << 4;
+    retval |= readNbits(4);
+  }
+  return retval;
+}
+void LiquidCrystalRus::pulseEnable() {
+  digitalWrite(_enable_pin, LOW);
+  delayMicroseconds(1);    
+  digitalWrite(_enable_pin, HIGH);
+  delayMicroseconds(1);    // enable pulse must be >450ns
+  digitalWrite(_enable_pin, LOW);
+  delayMicroseconds(100);   // commands need > 37us to settle
+}
+
+void LiquidCrystalRus::writeNbits(uint8_t value, uint8_t n) {
+  for (int i = 0; i < n; i++) {
+    pinMode(_data_pins[i], OUTPUT);
+    digitalWrite(_data_pins[i], (value >> i) & 0x01);
+  }
+
+  pulseEnable();
+}
+
+uint8_t LiquidCrystalRus::readNbits(uint8_t n) {
+  uint8_t retval=0;
+  for (int i = 0; i < n; i++) {
+    pinMode(_data_pins[i], INPUT);
+  }
+
+  digitalWrite(_enable_pin, LOW);
+  delayMicroseconds(1);    
+  digitalWrite(_enable_pin, HIGH);
+  delayMicroseconds(1);    // enable pulse must be >450ns
+  
+  for (int i = 0; i < n; i++) {
+    retval |= (digitalRead(_data_pins[i]) == HIGH)?(1 << i):0;
+  }
+
+  digitalWrite(_enable_pin, LOW);
+
+  return retval;
+}
+
diff --git a/Marlin/LiquidCrystalRus.h b/Marlin/LiquidCrystalRus.h
new file mode 100644
index 0000000..ad85394
--- /dev/null
+++ b/Marlin/LiquidCrystalRus.h
@@ -0,0 +1,129 @@
+//
+// based on LiquidCrystal library from ArduinoIDE, see http://arduino.cc
+//  modified 27 Jul 2011
+// by Ilya V. Danilov http://mk90.ru/
+// 
+
+#ifndef LiquidCrystalRus_h
+#define LiquidCrystalRus_h
+
+#include <inttypes.h>
+#include "Print.h"
+
+// commands
+#define LCD_CLEARDISPLAY 0x01
+#define LCD_RETURNHOME 0x02
+#define LCD_ENTRYMODESET 0x04
+#define LCD_DISPLAYCONTROL 0x08
+#define LCD_CURSORSHIFT 0x10
+#define LCD_FUNCTIONSET 0x20
+#define LCD_SETCGRAMADDR 0x40
+#define LCD_SETDDRAMADDR 0x80
+
+// flags for display entry mode
+#define LCD_ENTRYRIGHT 0x00
+#define LCD_ENTRYLEFT 0x02
+#define LCD_ENTRYSHIFTINCREMENT 0x01
+#define LCD_ENTRYSHIFTDECREMENT 0x00
+
+// flags for display on/off control
+#define LCD_DISPLAYON 0x04
+#define LCD_DISPLAYOFF 0x00
+#define LCD_CURSORON 0x02
+#define LCD_CURSOROFF 0x00
+#define LCD_BLINKON 0x01
+#define LCD_BLINKOFF 0x00
+
+// flags for display/cursor shift
+#define LCD_DISPLAYMOVE 0x08
+#define LCD_CURSORMOVE 0x00
+#define LCD_MOVERIGHT 0x04
+#define LCD_MOVELEFT 0x00
+
+// flags for function set
+#define LCD_8BITMODE 0x10
+#define LCD_4BITMODE 0x00
+#define LCD_2LINE 0x08
+#define LCD_1LINE 0x00
+#define LCD_5x10DOTS 0x04
+#define LCD_5x8DOTS 0x00
+
+// enum for 
+#define LCD_DRAM_Normal 0x00
+#define LCD_DRAM_WH1601 0x01
+
+
+class LiquidCrystalRus : public Print {
+public:
+  LiquidCrystalRus(uint8_t rs, uint8_t enable,
+		uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
+		uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7);
+  LiquidCrystalRus(uint8_t rs, uint8_t rw, uint8_t enable,
+		uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
+		uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7);
+  LiquidCrystalRus(uint8_t rs, uint8_t rw, uint8_t enable,
+		uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3);
+  LiquidCrystalRus(uint8_t rs, uint8_t enable,
+		uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3);
+
+  void init(uint8_t fourbitmode, uint8_t rs, uint8_t rw, uint8_t enable,
+	    uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
+	    uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7);
+    
+  void begin(uint8_t cols, uint8_t rows, uint8_t charsize = LCD_5x8DOTS);
+
+  void clear();
+  void home();
+
+  void noDisplay();
+  void display();
+  void noBlink();
+  void blink();
+  void noCursor();
+  void cursor();
+  void scrollDisplayLeft();
+  void scrollDisplayRight();
+  void leftToRight();
+  void rightToLeft();
+  void autoscroll();
+  void noAutoscroll();
+
+  void createChar(uint8_t, uint8_t[]);
+  void setCursor(uint8_t, uint8_t);
+ 
+#if defined(ARDUINO) && ARDUINO >= 100
+  virtual size_t write(uint8_t);
+  using Print::write;
+#else
+  virtual void write(uint8_t);
+#endif
+
+  void command(uint8_t);
+
+  void setDRAMModel(uint8_t);
+
+private:
+  void send(uint8_t, uint8_t);
+  void writeNbits(uint8_t, uint8_t);
+  uint8_t recv(uint8_t);
+  uint8_t readNbits(uint8_t); 
+  void pulseEnable();
+
+  uint8_t _rs_pin; // LOW: command.  HIGH: character.
+  uint8_t _rw_pin; // LOW: write to LCD.  HIGH: read from LCD.
+  uint8_t _enable_pin; // activated by a HIGH pulse.
+  uint8_t _data_pins[8];
+
+  uint8_t _displayfunction;
+  uint8_t _displaycontrol;
+  uint8_t _displaymode;
+
+  uint8_t _initialized;
+
+  uint8_t _numlines,_currline;
+
+  uint8_t _dram_model;
+  uint8_t utf_hi_char; // UTF-8 high part
+};
+
+#endif
diff --git a/Marlin/Makefile b/Marlin/Makefile
index 940bb16..84231b2 100644
--- a/Marlin/Makefile
+++ b/Marlin/Makefile
@@ -3,6 +3,7 @@
 # Makefile Based on:
 # Arduino 0011 Makefile
 # Arduino adaptation by mellis, eighthave, oli.keller
+# Marlin adaption by Daid
 #
 # This has been tested with Arduino 0022.
 # 
@@ -11,14 +12,14 @@
 #
 # Detailed instructions for using the makefile:
 #
-#  1. Modify the line containg "INSTALL_DIR" to point to the directory that
+#  1. Modify the line containg "ARDUINO_INSTALL_DIR" to point to the directory that
 #     contains the Arduino installation (for example, under Mac OS X, this
 #     might be /Applications/arduino-0012).
 #
-#  2. Modify the line containing "PORT" to refer to the filename
+#  2. Modify the line containing "UPLOAD_PORT" to refer to the filename
 #     representing the USB or serial connection to your Arduino board
-#     (e.g. PORT = /dev/tty.USB0).  If the exact name of this file
-#     changes, you can use * as a wildcard (e.g. PORT = /dev/tty.usb*).
+#     (e.g. UPLOAD_PORT = /dev/tty.USB0).  If the exact name of this file
+#     changes, you can use * as a wildcard (e.g. UPLOAD_PORT = /dev/tty.usb*).
 #
 #  3. Set the line containing "MCU" to match your board's processor. 
 #     Older one's are atmega8 based, newer ones like Arduino Mini, Bluetooth
@@ -32,43 +33,139 @@
 #  5. Type "make upload", reset your Arduino board, and press enter to
 #     upload your program to the Arduino board.
 #
-# $Id$
+# Note that all settings are set with ?=, this means you can override them
+# from the commandline with "make HARDWARE_MOTHERBOARD=71" for example
 
-#For "old" Arduino Mega
-#MCU = atmega1280
-#For Arduino Mega2560
-#MCU = atmega2560
-#For Sanguinololu
-MCU = atmega644p 
+# This defined the board you are compiling for (see Configuration.h for the options)
+HARDWARE_MOTHERBOARD ?= 11
 
-# Here you select "arduino", "Sanguino", "Gen7", ...
-HARDWARE_VARIANT 		= Sanguino
-# This defined the board you are compiling for
-HARDWARE_MOTHERBOARD	= 91
+# Arduino source install directory, and version number
+ARDUINO_INSTALL_DIR  ?= ../../arduino-0022
+ARDUINO_VERSION      ?= 22
 
-# Arduino source install directory
-INSTALL_DIR = ../../arduino-0022
+# You can optionally set a path to the avr-gcc tools. Requires a trailing slash. (ex: /usr/local/avr-gcc/bin)
+AVR_TOOLS_PATH ?= 
+
+#Programmer configuration
+UPLOAD_RATE        ?= 115200
+AVRDUDE_PROGRAMMER ?= arduino
+UPLOAD_PORT        ?= /dev/arduino
+
+#Directory used to build files in, contains all the build files, from object files to the final hex file.
+BUILD_DIR          ?= applet
+
+############################################################################
+# Below here nothing should be changed...
+
+# Here the Arduino variant is selected by the board type
+# HARDWARE_VARIANT = "arduino", "Sanguino", "Gen7", ...
+# MCU = "atmega1280", "Mega2560", "atmega2560", "atmega644p", ...
+
+#Gen7
+ifeq ($(HARDWARE_MOTHERBOARD),10)
+HARDWARE_VARIANT ?= Gen7
+MCU              ?= atmega644 
+F_CPU            ?= 20000000
+else ifeq  ($(HARDWARE_MOTHERBOARD),11)
+HARDWARE_VARIANT ?= Gen7
+MCU              ?= atmega644p
+F_CPU            ?= 20000000
+else ifeq  ($(HARDWARE_MOTHERBOARD),12)
+HARDWARE_VARIANT ?= Gen7
+MCU              ?= atmega644p
+F_CPU            ?= 20000000
+else ifeq  ($(HARDWARE_MOTHERBOARD),13)
+HARDWARE_VARIANT ?= Gen7
+MCU              ?= atmega1284p
+F_CPU            ?= 20000000
+
+#RAMPS
+else ifeq  ($(HARDWARE_MOTHERBOARD),3)
+HARDWARE_VARIANT ?= arduino
+MCU              ?= atmega2560
+else ifeq  ($(HARDWARE_MOTHERBOARD),33)
+HARDWARE_VARIANT ?= arduino
+MCU              ?= atmega2560
+else ifeq  ($(HARDWARE_MOTHERBOARD),34)
+HARDWARE_VARIANT ?= arduino
+MCU              ?= atmega2560
+
+#Duemilanove w/ ATMega328P pin assignment
+else ifeq  ($(HARDWARE_MOTHERBOARD),4)
+HARDWARE_VARIANT ?= arduino
+MCU              ?= atmega328p
+
+#Gen6
+else ifeq  ($(HARDWARE_MOTHERBOARD),5)
+HARDWARE_VARIANT ?= Gen6
+MCU              ?= atmega664p
+else ifeq  ($(HARDWARE_MOTHERBOARD),51)
+HARDWARE_VARIANT ?= Gen6
+MCU              ?= atmega664p
+
+#Sanguinololu
+else ifeq  ($(HARDWARE_MOTHERBOARD),6)
+HARDWARE_VARIANT ?= Sanguino
+MCU              ?= atmega1284p
+else ifeq  ($(HARDWARE_MOTHERBOARD),62)
+HARDWARE_VARIANT ?= Sanguino
+MCU              ?= atmega1284p
+else ifeq  ($(HARDWARE_MOTHERBOARD),63)
+HARDWARE_VARIANT ?= Sanguino
+MCU              ?= atmega1284p
+
+#Ultimaker
+else ifeq  ($(HARDWARE_MOTHERBOARD),7)
+HARDWARE_VARIANT ?= arduino
+MCU              ?= atmega2560
+else ifeq  ($(HARDWARE_MOTHERBOARD),71)
+HARDWARE_VARIANT ?= arduino
+MCU              ?= atmega1280
+
+#Teensylu
+else ifeq  ($(HARDWARE_MOTHERBOARD),8)
+HARDWARE_VARIANT ?= Teensyduino
+MCU              ?= at90usb1286
+
+#Gen3+
+else ifeq  ($(HARDWARE_MOTHERBOARD),9)
+HARDWARE_VARIANT ?= Sanguino
+MCU              ?= atmega644p
+
+#Megatronics
+else ifeq  ($(HARDWARE_MOTHERBOARD),70)
+HARDWARE_VARIANT ?= arduino
+MCU              ?= atmega2560
+
+#Alpha OMCA board
+else ifeq  ($(HARDWARE_MOTHERBOARD),90)
+HARDWARE_VARIANT ?= SanguinoA
+MCU              ?= atmega644
+
+#Final OMCA board
+else ifeq  ($(HARDWARE_MOTHERBOARD),91)
+HARDWARE_VARIANT ?= Sanguino
+MCU              ?= atmega644p
+
+endif
+
+# Be sure to regenerate speed_lookuptable.h with create_speed_lookuptable.py
+# if you are setting this to something other than 16MHz
+# Set to 16Mhz if not yet set.
+F_CPU ?= 16000000
 
 # Arduino containd the main source code for the Arduino
 # Libraries, the "hardware variant" are for boards
 # that derives from that, and their source are present in
 # the main Marlin source directory
-ARDUINO = $(INSTALL_DIR)/hardware/arduino/cores/arduino
+ARDUINO = $(ARDUINO_INSTALL_DIR)/hardware/arduino/cores/arduino
 
 ifeq (${HARDWARE_VARIANT}, arduino)
-HARDWARE_SRC= $(ARDUINO)
+HARDWARE_SRC = $(ARDUINO)
 else
-HARDWARE_SRC= $(HARDWARE_VARIANT)/cores/arduino
+HARDWARE_SRC = $(HARDWARE_VARIANT)/cores/arduino
 endif
 
-# Be sure to regenerate speed_lookuptable.h with create_speed_lookuptable.py
-# if you are setting this to something other than 16MHz
-F_CPU = 16000000
-
-UPLOAD_RATE = 115200
-AVRDUDE_PROGRAMMER = arduino
-PORT = /dev/arduino
-
 TARGET = $(notdir $(CURDIR))
 
 # VPATH tells make to look into these directory for source files,
@@ -76,23 +173,21 @@ TARGET = $(notdir $(CURDIR))
 # directory is added here
 
 VPATH = .
-VPATH += applet
+VPATH += $(BUILD_DIR)
 VPATH += $(HARDWARE_SRC)
 VPATH += $(ARDUINO)
-VPATH += $(INSTALL_DIR)/libraries/LiquidCrystal
-
-############################################################################
-# Below here nothing should be changed...
+VPATH += $(ARDUINO_INSTALL_DIR)/libraries/LiquidCrystal
+#TODO: Add the path to the hardware variant when using Arduino >= 100, and adjust the files required for compilation.
+#VPATH += $(ARDUINO_INSTALL_DIR)/hardware/arduino/variants/mega
 
-AVR_TOOLS_PATH = 
-SRC =  pins_arduino.c wiring.c \
+SRC = pins_arduino.c main.c wiring.c \
 	wiring_analog.c wiring_digital.c \
 	wiring_pulse.c \
 	wiring_shift.c WInterrupts.c
-CXXSRC = WMath.cpp WString.cpp Print.cpp \
-	Marlin.cpp MarlinSerial.cpp Sd2Card.cpp SdBaseFile.cpp \
-	SdFatUtil.cpp SdFile.cpp SdVolume.cpp motion_control.cpp \
-	planner.cpp stepper.cpp temperature.cpp cardreader.cpp
+CXXSRC = WMath.cpp WString.cpp Print.cpp Marlin_main.cpp	\
+	MarlinSerial.cpp Sd2Card.cpp SdBaseFile.cpp SdFatUtil.cpp	\
+	SdFile.cpp SdVolume.cpp motion_control.cpp planner.cpp		\
+	stepper.cpp temperature.cpp cardreader.cpp ConfigurationStore.cpp
 #CXXSRC += LiquidCrystal.cpp ultralcd.cpp
 #CXXSRC += ultralcd.cpp
 FORMAT = ihex
@@ -125,8 +220,8 @@ CDEBUG = -g$(DEBUG)
 CWARN = -Wall -Wstrict-prototypes
 CTUNING = -funsigned-char -funsigned-bitfields -fpack-struct \
 	-fshort-enums -w -ffunction-sections -fdata-sections \
-	-DARDUINO=22
-ifneq (${HARDWARE_MOTHERBOARD},)
+	-DARDUINO=$(ARDUINO_VERSION)
+ifneq ($(HARDWARE_MOTHERBOARD),)
 CTUNING += -DMOTHERBOARD=${HARDWARE_MOTHERBOARD}
 endif
 #CEXTRA = -Wa,-adhlns=$(<:.c=.lst)
@@ -138,9 +233,9 @@ LDFLAGS = -lm
 
 
 # Programming support using avrdude. Settings and variables.
-AVRDUDE_PORT = $(PORT)
-AVRDUDE_WRITE_FLASH = -U flash:w:applet/$(TARGET).hex:i
-AVRDUDE_FLAGS = -D -C $(INSTALL_DIR)/hardware/tools/avrdude.conf \
+AVRDUDE_PORT = $(UPLOAD_PORT)
+AVRDUDE_WRITE_FLASH = -U flash:w:$(BUILD_DIR)/$(TARGET).hex:i
+AVRDUDE_FLAGS = -D -C $(ARDUINO_INSTALL_DIR)/hardware/tools/avrdude.conf \
 	-p $(MCU) -P $(AVRDUDE_PORT) -c $(AVRDUDE_PROGRAMMER) \
 	-b $(UPLOAD_RATE)
 
@@ -157,9 +252,9 @@ REMOVE = rm -f
 MV = mv -f
 
 # Define all object files.
-OBJ = ${patsubst %.c, applet/%.o, ${SRC}}
-OBJ += ${patsubst %.cpp, applet/%.o, ${CXXSRC}}
-OBJ += ${patsubst %.S, applet/%.o, ${ASRC}}
+OBJ = ${patsubst %.c, $(BUILD_DIR)/%.o, ${SRC}}
+OBJ += ${patsubst %.cpp, $(BUILD_DIR)/%.o, ${CXXSRC}}
+OBJ += ${patsubst %.S, $(BUILD_DIR)/%.o, ${ASRC}}
 
 # Define all listing files.
 LST = $(ASRC:.S=.lst) $(CXXSRC:.cpp=.lst) $(SRC:.c=.lst)
@@ -182,52 +277,38 @@ endif
 # Default target.
 all: sizeafter
 
-build: applet elf hex 
+build: $(BUILD_DIR) elf hex 
 
 # Creates the object directory
-applet: 
-	$P mkdir -p applet
-
-# the .cpp for Marlin depends on the .pde
-#applet/$(TARGET).cpp: $(TARGET).pde
-# ..and the .o depends from the .cpp
-#applet/%.o: applet/%.cpp
-
-applet/%.cpp: %.pde $(MAKEFILE)
-# Here is the "preprocessing".
-# It creates a .cpp file based with the same name as the .pde file.
-# On top of the new .cpp file comes the WProgram.h header.
-	$(Pecho) "  WR    $@"
-	$P echo '#include "WProgram.h"' > $@
-	$P echo '#include "$<"' >>$@
-	$P echo '#include "$(ARDUINO)/main.cpp"' >> $@
-
-elf: applet/$(TARGET).elf
-hex: applet/$(TARGET).hex
-eep: applet/$(TARGET).eep
-lss: applet/$(TARGET).lss 
-sym: applet/$(TARGET).sym
+$(BUILD_DIR): 
+	$P mkdir -p $(BUILD_DIR)
+
+elf: $(BUILD_DIR)/$(TARGET).elf
+hex: $(BUILD_DIR)/$(TARGET).hex
+eep: $(BUILD_DIR)/$(TARGET).eep
+lss: $(BUILD_DIR)/$(TARGET).lss 
+sym: $(BUILD_DIR)/$(TARGET).sym
 
 # Program the device.  
 # Do not try to reset an arduino if it's not one
-upload: applet/$(TARGET).hex
+upload: $(BUILD_DIR)/$(TARGET).hex
 ifeq (${AVRDUDE_PROGRAMMER}, arduino)
-	stty hup < $(PORT); true
+	stty hup < $(UPLOAD_PORT); true
 endif
 	$(AVRDUDE) $(AVRDUDE_FLAGS) $(AVRDUDE_WRITE_FLASH)
 ifeq (${AVRDUDE_PROGRAMMER}, arduino)
-	stty -hup < $(PORT); true
+	stty -hup < $(UPLOAD_PORT); true
 endif
 
 	# Display size of file.
-HEXSIZE = $(SIZE) --target=$(FORMAT) applet/$(TARGET).hex
-ELFSIZE = $(SIZE) --mcu=$(MCU) -C applet/$(TARGET).elf; \
-          $(SIZE)  applet/$(TARGET).elf
+HEXSIZE = $(SIZE) --target=$(FORMAT) $(BUILD_DIR)/$(TARGET).hex
+ELFSIZE = $(SIZE) --mcu=$(MCU) -C $(BUILD_DIR)/$(TARGET).elf; \
+          $(SIZE)  $(BUILD_DIR)/$(TARGET).elf
 sizebefore:
-	$P if [ -f applet/$(TARGET).elf ]; then echo; echo $(MSG_SIZE_BEFORE); $(HEXSIZE); echo; fi
+	$P if [ -f $(BUILD_DIR)/$(TARGET).elf ]; then echo; echo $(MSG_SIZE_BEFORE); $(HEXSIZE); echo; fi
 
 sizeafter: build
-	$P if [ -f applet/$(TARGET).elf ]; then echo; echo $(MSG_SIZE_AFTER); $(ELFSIZE); echo; fi
+	$P if [ -f $(BUILD_DIR)/$(TARGET).elf ]; then echo; echo $(MSG_SIZE_AFTER); $(ELFSIZE); echo; fi
 
 
 # Convert ELF to COFF for use in debugging / simulating in AVR Studio or VMLAB.
@@ -238,12 +319,12 @@ COFFCONVERT=$(OBJCOPY) --debugging \
 	--change-section-address .eeprom-0x810000 
 
 
-coff: applet/$(TARGET).elf
-	$(COFFCONVERT) -O coff-avr applet/$(TARGET).elf $(TARGET).cof
+coff: $(BUILD_DIR)/$(TARGET).elf
+	$(COFFCONVERT) -O coff-avr $(BUILD_DIR)/$(TARGET).elf $(TARGET).cof
 
 
 extcoff: $(TARGET).elf
-	$(COFFCONVERT) -O coff-ext-avr applet/$(TARGET).elf $(TARGET).cof
+	$(COFFCONVERT) -O coff-ext-avr $(BUILD_DIR)/$(TARGET).elf $(TARGET).cof
 
 
 .SUFFIXES: .elf .hex .eep .lss .sym
@@ -266,33 +347,34 @@ extcoff: $(TARGET).elf
 	$(NM) -n $< > $@
 
 	# Link: create ELF output file from library.
-applet/$(TARGET).elf: applet/$(TARGET).cpp applet/core.a Configuration.h
+$(BUILD_DIR)/$(TARGET).elf: $(OBJ) Configuration.h
 	$(Pecho) "  CXX   $@"
-	$P $(CC) $(ALL_CXXFLAGS) -Wl,--gc-sections -o $@ applet/$(TARGET).cpp -L. applet/core.a $(LDFLAGS)
-
-applet/core.a: $(OBJ)
-	$P for i in $(OBJ); do echo "  AR    $$i"; $(AR) rcs applet/core.a $$i; done
+	$P $(CC) $(ALL_CXXFLAGS) -Wl,--gc-sections -o $@ -L. $(OBJ) $(LDFLAGS)
 
-applet/%.o: %.c Configuration.h Configuration_adv.h $(MAKEFILE)
+$(BUILD_DIR)/%.o: %.c Configuration.h Configuration_adv.h $(MAKEFILE)
 	$(Pecho) "  CC    $@"
 	$P $(CC) -MMD -c $(ALL_CFLAGS) $< -o $@
 
-applet/%.o: %.cpp Configuration.h Configuration_adv.h $(MAKEFILE)
+$(BUILD_DIR)/%.o: $(BUILD_DIR)/%.cpp Configuration.h Configuration_adv.h $(MAKEFILE)
+	$(Pecho) "  CXX   $@"
+	$P $(CXX) -MMD -c $(ALL_CXXFLAGS) $< -o $@
+
+$(BUILD_DIR)/%.o: %.cpp Configuration.h Configuration_adv.h $(MAKEFILE)
 	$(Pecho) "  CXX   $@"
 	$P $(CXX) -MMD -c $(ALL_CXXFLAGS) $< -o $@
 
 
 # Target: clean project.
 clean:
-	$(Pecho) "  RM    applet/*"
-	$P $(REMOVE) applet/$(TARGET).hex applet/$(TARGET).eep applet/$(TARGET).cof applet/$(TARGET).elf \
-		applet/$(TARGET).map applet/$(TARGET).sym applet/$(TARGET).lss applet/$(TARGET).cpp applet/core.a \
+	$(Pecho) "  RM    $(BUILD_DIR)/*"
+	$P $(REMOVE) $(BUILD_DIR)/$(TARGET).hex $(BUILD_DIR)/$(TARGET).eep $(BUILD_DIR)/$(TARGET).cof $(BUILD_DIR)/$(TARGET).elf \
+		$(BUILD_DIR)/$(TARGET).map $(BUILD_DIR)/$(TARGET).sym $(BUILD_DIR)/$(TARGET).lss $(BUILD_DIR)/$(TARGET).cpp \
 		$(OBJ) $(LST) $(SRC:.c=.s) $(SRC:.c=.d) $(CXXSRC:.cpp=.s) $(CXXSRC:.cpp=.d)
-	$(Pecho) "  RMDIR applet/"
-	$P rm -rf applet
+	$(Pecho) "  RMDIR $(BUILD_DIR)/"
+	$P rm -rf $(BUILD_DIR)
 
 
-.PHONY:	all build elf hex eep lss sym program coff extcoff clean depend applet_files sizebefore sizeafter
+.PHONY:	all build elf hex eep lss sym program coff extcoff clean depend sizebefore sizeafter
 
 # Automaticaly include the dependency files created by gcc
--include ${wildcard applet/*.d}
+-include ${wildcard $(BUILD_DIR)/*.d}
diff --git a/Marlin/Marlin.h b/Marlin/Marlin.h
index 5b59885..6f7de79 100644
--- a/Marlin/Marlin.h
+++ b/Marlin/Marlin.h
@@ -17,8 +17,7 @@
 #include <util/delay.h>
 #include <avr/pgmspace.h>
 #include <avr/eeprom.h>
-#include  <avr/wdt.h>
-#include  <avr/interrupt.h>
+#include <avr/interrupt.h>
 
 
 #include "fastio.h"
@@ -52,22 +51,11 @@
   #define MYSERIAL MSerial
 #endif
 
-//this is a unfinsihed attemp to removes a lot of warning messages, see:
-// http://www.avrfreaks.net/index.php?name=PNphpBB2&file=printview&t=57011
-//typedef char prog_char PROGMEM; 
-// //#define PSTR    (s )        ((const PROGMEM char *)(s))
-// //# define MYPGM(s) (__extension__({static prog_char __c[] = (s); &__c[0];})) 
-// //#define MYPGM(s) ((const prog_char *g PROGMEM=s))
-#define MYPGM(s) PSTR(s)
-//#define MYPGM(s)  (__extension__({static char __c[] __attribute__((__progmem__)) = (s); &__c[0];}))  //This is the normal behaviour
-//#define MYPGM(s)  (__extension__({static prog_char __c[]  = (s); &__c[0];})) //this does not work but hides the warnings
-
-
 #define SERIAL_PROTOCOL(x) MYSERIAL.print(x);
 #define SERIAL_PROTOCOL_F(x,y) MYSERIAL.print(x,y);
-#define SERIAL_PROTOCOLPGM(x) serialprintPGM(MYPGM(x));
+#define SERIAL_PROTOCOLPGM(x) serialprintPGM(PSTR(x));
 #define SERIAL_PROTOCOLLN(x) {MYSERIAL.print(x);MYSERIAL.write('\n');}
-#define SERIAL_PROTOCOLLNPGM(x) {serialprintPGM(MYPGM(x));MYSERIAL.write('\n');}
+#define SERIAL_PROTOCOLLNPGM(x) {serialprintPGM(PSTR(x));MYSERIAL.write('\n');}
 
 
 const char errormagic[] PROGMEM ="Error:";
@@ -92,7 +80,6 @@ void serial_echopair_P(const char *s_P, unsigned long v);
 
 
 //things to write to serial from Programmemory. saves 400 to 2k of RAM.
-#define SerialprintPGM(x) serialprintPGM(MYPGM(x))
 FORCE_INLINE void serialprintPGM(const char *str)
 {
   char ch=pgm_read_byte(str);
@@ -197,6 +184,9 @@ extern float min_pos[3];
 extern float max_pos[3];
 extern unsigned char FanSpeed;
 
+extern unsigned long starttime;
+extern unsigned long stoptime;
+
 // Handling multiple extruders pins
 extern uint8_t active_extruder;
 
diff --git a/Marlin/Marlin.pde b/Marlin/Marlin.pde
index 34db68f..5d91345 100644
--- a/Marlin/Marlin.pde
+++ b/Marlin/Marlin.pde
@@ -26,1851 +26,11 @@
  It has preliminary support for Matthew Roberts advance algorithm 
     http://reprap.org/pipermail/reprap-dev/2011-May/003323.html
  */
-#include <SPI.h>
-#include "Marlin.h"
 
-#include "ultralcd.h"
-#include "planner.h"
-#include "stepper.h"
-#include "temperature.h"
-#include "motion_control.h"
-#include "cardreader.h"
-#include "watchdog.h"
-#include "EEPROMwrite.h"
-#include "language.h"
-#include "pins_arduino.h"
+/* All the implementation is done in *.cpp files to get better compatibility with avr-gcc without the Arduino IDE */
+/* Use this file to help the Arduino IDE find which Arduino libraries are needed and to keep documentation on GCode */
 
-#define VERSION_STRING  "1.0.0"
-
-// look here for descriptions of gcodes: http://linuxcnc.org/handbook/gcode/g-code.html
-// http://objects.reprap.org/wiki/Mendel_User_Manual:_RepRapGCodes
-
-//Implemented Codes
-//-------------------
-// G0  -> G1
-// G1  - Coordinated Movement X Y Z E
-// G2  - CW ARC
-// G3  - CCW ARC
-// G4  - Dwell S<seconds> or P<milliseconds>
-// G10 - retract filament according to settings of M207
-// G11 - retract recover filament according to settings of M208
-// G28 - Home all Axis
-// G90 - Use Absolute Coordinates
-// G91 - Use Relative Coordinates
-// G92 - Set current position to cordinates given
-
-//RepRap M Codes
-// M0   - Unconditional stop - Wait for user to press a button on the LCD (Only if ULTRA_LCD is enabled)
-// M1   - Same as M0
-// M104 - Set extruder target temp
-// M105 - Read current temp
-// M106 - Fan on
-// M107 - Fan off
-// M109 - Wait for extruder current temp to reach target temp.
-// M114 - Display current position
-
-//Custom M Codes
-// M17  - Enable/Power all stepper motors
-// M18  - Disable all stepper motors; same as M84
-// M20  - List SD card
-// M21  - Init SD card
-// M22  - Release SD card
-// M23  - Select SD file (M23 filename.g)
-// M24  - Start/resume SD print
-// M25  - Pause SD print
-// M26  - Set SD position in bytes (M26 S12345)
-// M27  - Report SD print status
-// M28  - Start SD write (M28 filename.g)
-// M29  - Stop SD write
-// M30  - Delete file from SD (M30 filename.g)
-// M31  - Output time since last M109 or SD card start to serial
-// M42  - Change pin status via gcode
-// M80  - Turn on Power Supply
-// M81  - Turn off Power Supply
-// M82  - Set E codes absolute (default)
-// M83  - Set E codes relative while in Absolute Coordinates (G90) mode
-// M84  - Disable steppers until next move, 
-//        or use S<seconds> to specify an inactivity timeout, after which the steppers will be disabled.  S0 to disable the timeout.
-// M85  - Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
-// M92  - Set axis_steps_per_unit - same syntax as G92
-// M114 - Output current position to serial port 
-// M115	- Capabilities string
-// M117 - display message
-// M119 - Output Endstop status to serial port
-// M140 - Set bed target temp
-// M190 - Wait for bed current temp to reach target temp.
-// M200 - Set filament diameter
-// M201 - Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)
-// M202 - Set max acceleration in units/s^2 for travel moves (M202 X1000 Y1000) Unused in Marlin!!
-// M203 - Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in mm/sec
-// M204 - Set default acceleration: S normal moves T filament only moves (M204 S3000 T7000) im mm/sec^2  also sets minimum segment time in ms (B20000) to prevent buffer underruns and M20 minimum feedrate
-// M205 -  advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk, E=maximum E jerk
-// M206 - set additional homeing offset
-// M207 - set retract length S[positive mm] F[feedrate mm/sec] Z[additional zlift/hop]
-// M208 - set recover=unretract length S[positive mm surplus to the M207 S*] F[feedrate mm/sec]
-// M209 - S<1=true/0=false> enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.
-// M220 S<factor in percent>- set speed factor override percentage
-// M221 S<factor in percent>- set extrude factor override percentage
-// M240 - Trigger a camera to take a photograph
-// M301 - Set PID parameters P I and D
-// M302 - Allow cold extrudes
-// M303 - PID relay autotune S<temperature> sets the target temperature. (default target temperature = 150C)
-// M400 - Finish all moves
-// M500 - stores paramters in EEPROM
-// M501 - reads parameters from EEPROM (if you need reset them after you changed them temporarily).  
-// M502 - reverts to the default "factory settings".  You still need to store them in EEPROM afterwards if you want to.
-// M503 - print the current settings (from memory not from eeprom)
-// M907 - Set digital trimpot motor current using axis codes.
-// M908 - Control digital trimpot directly.
-// M350 - Set microstepping mode.
-// M351 - Toggle MS1 MS2 pins directly.
-// M999 - Restart after being stopped by error
-
-//Stepper Movement Variables
-
-//===========================================================================
-//=============================imported variables============================
-//===========================================================================
-
-
-//===========================================================================
-//=============================public variables=============================
-//===========================================================================
-#ifdef SDSUPPORT
-CardReader card;
-#endif
-float homing_feedrate[] = HOMING_FEEDRATE;
-bool axis_relative_modes[] = AXIS_RELATIVE_MODES;
-volatile int feedmultiply=100; //100->1 200->2
-int saved_feedmultiply;
-volatile bool feedmultiplychanged=false;
-volatile int extrudemultiply=100; //100->1 200->2
-float current_position[NUM_AXIS] = { 0.0, 0.0, 0.0, 0.0 };
-float add_homeing[3]={0,0,0};
-float min_pos[3] = { X_MIN_POS, Y_MIN_POS, Z_MIN_POS };
-float max_pos[3] = { X_MAX_POS, Y_MAX_POS, Z_MAX_POS };
-uint8_t active_extruder = 0;
-unsigned char FanSpeed=0;
-
-#ifdef FWRETRACT
-  bool autoretract_enabled=true;
-  bool retracted=false;
-  float retract_length=3, retract_feedrate=17*60, retract_zlift=0.8;
-  float retract_recover_length=0, retract_recover_feedrate=8*60;
-#endif
-
-//===========================================================================
-//=============================private variables=============================
-//===========================================================================
-const char axis_codes[NUM_AXIS] = {'X', 'Y', 'Z', 'E'};
-static float destination[NUM_AXIS] = {  0.0, 0.0, 0.0, 0.0};
-static float offset[3] = {0.0, 0.0, 0.0};
-static bool home_all_axis = true;
-static float feedrate = 1500.0, next_feedrate, saved_feedrate;
-static long gcode_N, gcode_LastN, Stopped_gcode_LastN = 0;
-
-static bool relative_mode = false;  //Determines Absolute or Relative Coordinates
-static bool relative_mode_e = false;  //Determines Absolute or Relative E Codes while in Absolute Coordinates mode. E is always relative in Relative Coordinates mode.
-
-static char cmdbuffer[BUFSIZE][MAX_CMD_SIZE];
-static bool fromsd[BUFSIZE];
-static int bufindr = 0;
-static int bufindw = 0;
-static int buflen = 0;
-//static int i = 0;
-static char serial_char;
-static int serial_count = 0;
-static boolean comment_mode = false;
-static char *strchr_pointer; // just a pointer to find chars in the cmd string like X, Y, Z, E, etc
-
-const int sensitive_pins[] = SENSITIVE_PINS; // Sensitive pin list for M42
-
-//static float tt = 0;
-//static float bt = 0;
-
-//Inactivity shutdown variables
-static unsigned long previous_millis_cmd = 0;
-static unsigned long max_inactive_time = 0;
-static unsigned long stepper_inactive_time = DEFAULT_STEPPER_DEACTIVE_TIME*1000l;
-
-static unsigned long starttime=0;
-static unsigned long stoptime=0;
-
-static uint8_t tmp_extruder;
-
-
-bool Stopped=false;
-
-//===========================================================================
-//=============================ROUTINES=============================
-//===========================================================================
-
-void get_arc_coordinates();
-
-void serial_echopair_P(const char *s_P, float v)
-    { serialprintPGM(s_P); SERIAL_ECHO(v); }
-void serial_echopair_P(const char *s_P, double v)
-    { serialprintPGM(s_P); SERIAL_ECHO(v); }
-void serial_echopair_P(const char *s_P, unsigned long v)
-    { serialprintPGM(s_P); SERIAL_ECHO(v); }
-
-extern "C"{
-  extern unsigned int __bss_end;
-  extern unsigned int __heap_start;
-  extern void *__brkval;
-
-  int freeMemory() {
-    int free_memory;
-
-    if((int)__brkval == 0)
-      free_memory = ((int)&free_memory) - ((int)&__bss_end);
-    else
-      free_memory = ((int)&free_memory) - ((int)__brkval);
-
-    return free_memory;
-  }
-}
-
-//adds an command to the main command buffer
-//thats really done in a non-safe way.
-//needs overworking someday
-void enquecommand(const char *cmd)
-{
-  if(buflen < BUFSIZE)
-  {
-    //this is dangerous if a mixing of serial and this happsens
-    strcpy(&(cmdbuffer[bufindw][0]),cmd);
-    SERIAL_ECHO_START;
-    SERIAL_ECHOPGM("enqueing \"");
-    SERIAL_ECHO(cmdbuffer[bufindw]);
-    SERIAL_ECHOLNPGM("\"");
-    bufindw= (bufindw + 1)%BUFSIZE;
-    buflen += 1;
-  }
-}
-
-void setup_killpin()
-{
-  #if( KILL_PIN>-1 )
-    pinMode(KILL_PIN,INPUT);
-    WRITE(KILL_PIN,HIGH);
-  #endif
-}
-    
-void setup_photpin()
-{
-  #ifdef PHOTOGRAPH_PIN
-    #if (PHOTOGRAPH_PIN > -1)
-    SET_OUTPUT(PHOTOGRAPH_PIN);
-    WRITE(PHOTOGRAPH_PIN, LOW);
-    #endif
-  #endif 
-}
-
-void setup_powerhold()
-{
- #ifdef SUICIDE_PIN
-   #if (SUICIDE_PIN> -1)
-      SET_OUTPUT(SUICIDE_PIN);
-      WRITE(SUICIDE_PIN, HIGH);
-   #endif
- #endif
-}
-
-void suicide()
-{
- #ifdef SUICIDE_PIN
-    #if (SUICIDE_PIN> -1) 
-      SET_OUTPUT(SUICIDE_PIN);
-      WRITE(SUICIDE_PIN, LOW);
-    #endif
-  #endif
-}
-
-void setup()
-{
-  setup_killpin(); 
-  setup_powerhold();
-  MYSERIAL.begin(BAUDRATE);
-  SERIAL_PROTOCOLLNPGM("start");
-  SERIAL_ECHO_START;
-
-  // Check startup - does nothing if bootloader sets MCUSR to 0
-  byte mcu = MCUSR;
-  if(mcu & 1) SERIAL_ECHOLNPGM(MSG_POWERUP);
-  if(mcu & 2) SERIAL_ECHOLNPGM(MSG_EXTERNAL_RESET);
-  if(mcu & 4) SERIAL_ECHOLNPGM(MSG_BROWNOUT_RESET);
-  if(mcu & 8) SERIAL_ECHOLNPGM(MSG_WATCHDOG_RESET);
-  if(mcu & 32) SERIAL_ECHOLNPGM(MSG_SOFTWARE_RESET);
-  MCUSR=0;
-
-  SERIAL_ECHOPGM(MSG_MARLIN);
-  SERIAL_ECHOLNPGM(VERSION_STRING);
-  #ifdef STRING_VERSION_CONFIG_H
-    #ifdef STRING_CONFIG_H_AUTHOR
-      SERIAL_ECHO_START;
-      SERIAL_ECHOPGM(MSG_CONFIGURATION_VER);
-      SERIAL_ECHOPGM(STRING_VERSION_CONFIG_H);
-      SERIAL_ECHOPGM(MSG_AUTHOR);
-      SERIAL_ECHOLNPGM(STRING_CONFIG_H_AUTHOR);
-      SERIAL_ECHOPGM("Compiled: ");
-      SERIAL_ECHOLNPGM(__DATE__);
-    #endif
-  #endif
-  SERIAL_ECHO_START;
-  SERIAL_ECHOPGM(MSG_FREE_MEMORY);
-  SERIAL_ECHO(freeMemory());
-  SERIAL_ECHOPGM(MSG_PLANNER_BUFFER_BYTES);
-  SERIAL_ECHOLN((int)sizeof(block_t)*BLOCK_BUFFER_SIZE);
-  for(int8_t i = 0; i < BUFSIZE; i++)
-  {
-    fromsd[i] = false;
-  }
-  
-  EEPROM_RetrieveSettings(); // loads data from EEPROM if available
-
-  for(int8_t i=0; i < NUM_AXIS; i++)
-  {
-    axis_steps_per_sqr_second[i] = max_acceleration_units_per_sq_second[i] * axis_steps_per_unit[i];
-  }
-
-
-  tp_init();    // Initialize temperature loop 
-  plan_init();  // Initialize planner;
-  st_init();    // Initialize stepper;
-  wd_init();
-  setup_photpin();
-  
-  LCD_INIT;
-}
-
-
-void loop()
-{
-  if(buflen < (BUFSIZE-1))
-    get_command();
-  #ifdef SDSUPPORT
-  card.checkautostart(false);
-  #endif
-  if(buflen)
-  {
-    #ifdef SDSUPPORT
-      if(card.saving)
-      {
-	if(strstr(cmdbuffer[bufindr],"M29") == NULL)
-	{
-	  card.write_command(cmdbuffer[bufindr]);
-	  SERIAL_PROTOCOLLNPGM(MSG_OK);
-	}
-	else
-	{
-	  card.closefile();
-	  SERIAL_PROTOCOLLNPGM(MSG_FILE_SAVED);
-	}
-      }
-      else
-      {
-	process_commands();
-      }
-    #else
-      process_commands();
-    #endif //SDSUPPORT
-    buflen = (buflen-1);
-    bufindr = (bufindr + 1)%BUFSIZE;
-  }
-  //check heater every n milliseconds
-  manage_heater();
-  manage_inactivity();
-  checkHitEndstops();
-  LCD_STATUS;
-}
-
-void get_command() 
-{ 
-  while( MYSERIAL.available() > 0  && buflen < BUFSIZE) {
-    serial_char = MYSERIAL.read();
-    if(serial_char == '\n' || 
-       serial_char == '\r' || 
-       (serial_char == ':' && comment_mode == false) || 
-       serial_count >= (MAX_CMD_SIZE - 1) ) 
-    {
-      if(!serial_count) { //if empty line
-        comment_mode = false; //for new command
-        return;
-      }
-      cmdbuffer[bufindw][serial_count] = 0; //terminate string
-      if(!comment_mode){
-        comment_mode = false; //for new command
-        fromsd[bufindw] = false;
-        if(strstr(cmdbuffer[bufindw], "N") != NULL)
-        {
-          strchr_pointer = strchr(cmdbuffer[bufindw], 'N');
-          gcode_N = (strtol(&cmdbuffer[bufindw][strchr_pointer - cmdbuffer[bufindw] + 1], NULL, 10));
-          if(gcode_N != gcode_LastN+1 && (strstr(cmdbuffer[bufindw], "M110") == NULL) ) {
-            SERIAL_ERROR_START;
-            SERIAL_ERRORPGM(MSG_ERR_LINE_NO);
-            SERIAL_ERRORLN(gcode_LastN);
-            //Serial.println(gcode_N);
-            FlushSerialRequestResend();
-            serial_count = 0;
-            return;
-          }
-
-          if(strstr(cmdbuffer[bufindw], "*") != NULL)
-          {
-            byte checksum = 0;
-            byte count = 0;
-            while(cmdbuffer[bufindw][count] != '*') checksum = checksum^cmdbuffer[bufindw][count++];
-            strchr_pointer = strchr(cmdbuffer[bufindw], '*');
-
-            if( (int)(strtod(&cmdbuffer[bufindw][strchr_pointer - cmdbuffer[bufindw] + 1], NULL)) != checksum) {
-              SERIAL_ERROR_START;
-              SERIAL_ERRORPGM(MSG_ERR_CHECKSUM_MISMATCH);
-              SERIAL_ERRORLN(gcode_LastN);
-              FlushSerialRequestResend();
-              serial_count = 0;
-              return;
-            }
-            //if no errors, continue parsing
-          }
-          else 
-          {
-            SERIAL_ERROR_START;
-            SERIAL_ERRORPGM(MSG_ERR_NO_CHECKSUM);
-            SERIAL_ERRORLN(gcode_LastN);
-            FlushSerialRequestResend();
-            serial_count = 0;
-            return;
-          }
-
-          gcode_LastN = gcode_N;
-          //if no errors, continue parsing
-        }
-        else  // if we don't receive 'N' but still see '*'
-        {
-          if((strstr(cmdbuffer[bufindw], "*") != NULL))
-          {
-            SERIAL_ERROR_START;
-            SERIAL_ERRORPGM(MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM);
-            SERIAL_ERRORLN(gcode_LastN);
-            serial_count = 0;
-            return;
-          }
-        }
-        if((strstr(cmdbuffer[bufindw], "G") != NULL)){
-          strchr_pointer = strchr(cmdbuffer[bufindw], 'G');
-          switch((int)((strtod(&cmdbuffer[bufindw][strchr_pointer - cmdbuffer[bufindw] + 1], NULL)))){
-          case 0:
-          case 1:
-          case 2:
-          case 3:
-            if(Stopped == false) { // If printer is stopped by an error the G[0-3] codes are ignored.
-	      #ifdef SDSUPPORT
-              if(card.saving)
-                break;
-	      #endif //SDSUPPORT
-              SERIAL_PROTOCOLLNPGM(MSG_OK); 
-            }
-            else {
-              SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
-              LCD_MESSAGEPGM(MSG_STOPPED);
-            }
-            break;
-          default:
-            break;
-          }
-
-        }
-        bufindw = (bufindw + 1)%BUFSIZE;
-        buflen += 1;
-      }
-      serial_count = 0; //clear buffer
-    }
-    else
-    {
-      if(serial_char == ';') comment_mode = true;
-      if(!comment_mode) cmdbuffer[bufindw][serial_count++] = serial_char;
-    }
-  }
-  #ifdef SDSUPPORT
-  if(!card.sdprinting || serial_count!=0){
-    return;
-  }
-  while( !card.eof()  && buflen < BUFSIZE) {
-    int16_t n=card.get();
-    serial_char = (char)n;
-    if(serial_char == '\n' || 
-       serial_char == '\r' || 
-       (serial_char == ':' && comment_mode == false) || 
-       serial_count >= (MAX_CMD_SIZE - 1)||n==-1) 
-    {
-      if(card.eof()){
-        SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);
-        stoptime=millis();
-        char time[30];
-        unsigned long t=(stoptime-starttime)/1000;
-        int sec,min;
-        min=t/60;
-        sec=t%60;
-        sprintf(time,"%i min, %i sec",min,sec);
-        SERIAL_ECHO_START;
-        SERIAL_ECHOLN(time);
-        LCD_MESSAGE(time);
-        card.printingHasFinished();
-        card.checkautostart(true);
-        
-      }
-      if(!serial_count)
-      {
-        comment_mode = false; //for new command
-        return; //if empty line
-      }
-      cmdbuffer[bufindw][serial_count] = 0; //terminate string
-//      if(!comment_mode){
-        fromsd[bufindw] = true;
-        buflen += 1;
-        bufindw = (bufindw + 1)%BUFSIZE;
-//      }     
-      comment_mode = false; //for new command
-      serial_count = 0; //clear buffer
-    }
-    else
-    {
-      if(serial_char == ';') comment_mode = true;
-      if(!comment_mode) cmdbuffer[bufindw][serial_count++] = serial_char;
-    }
-  }
-  
-  #endif //SDSUPPORT
-
-}
-
-
-float code_value() 
-{ 
-  return (strtod(&cmdbuffer[bufindr][strchr_pointer - cmdbuffer[bufindr] + 1], NULL)); 
-}
-
-long code_value_long() 
-{ 
-  return (strtol(&cmdbuffer[bufindr][strchr_pointer - cmdbuffer[bufindr] + 1], NULL, 10)); 
-}
-
-bool code_seen(char code_string[]) //Return True if the string was found
-{ 
-  return (strstr(cmdbuffer[bufindr], code_string) != NULL); 
-}  
-
-bool code_seen(char code)
-{
-  strchr_pointer = strchr(cmdbuffer[bufindr], code);
-  return (strchr_pointer != NULL);  //Return True if a character was found
-}
-
-#define DEFINE_PGM_READ_ANY(type, reader)		\
-    static inline type pgm_read_any(const type *p)	\
-	{ return pgm_read_##reader##_near(p); }
-
-DEFINE_PGM_READ_ANY(float,       float);
-DEFINE_PGM_READ_ANY(signed char, byte);
-
-#define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG)	\
-static const PROGMEM type array##_P[3] =		\
-    { X_##CONFIG, Y_##CONFIG, Z_##CONFIG };		\
-static inline type array(int axis)			\
-    { return pgm_read_any(&array##_P[axis]); }
-
-XYZ_CONSTS_FROM_CONFIG(float, base_min_pos,    MIN_POS);
-XYZ_CONSTS_FROM_CONFIG(float, base_max_pos,    MAX_POS);
-XYZ_CONSTS_FROM_CONFIG(float, base_home_pos,   HOME_POS);
-XYZ_CONSTS_FROM_CONFIG(float, max_length,      MAX_LENGTH);
-XYZ_CONSTS_FROM_CONFIG(float, home_retract_mm, HOME_RETRACT_MM);
-XYZ_CONSTS_FROM_CONFIG(signed char, home_dir,  HOME_DIR);
-
-static void axis_is_at_home(int axis) {
-  current_position[axis] = base_home_pos(axis) + add_homeing[axis];
-  min_pos[axis] =          base_min_pos(axis) + add_homeing[axis];
-  max_pos[axis] =          base_max_pos(axis) + add_homeing[axis];
-}
-
-static void homeaxis(int axis) {
-#define HOMEAXIS_DO(LETTER) \
-  ((LETTER##_MIN_PIN > -1 && LETTER##_HOME_DIR==-1) || (LETTER##_MAX_PIN > -1 && LETTER##_HOME_DIR==1))
-
-  if (axis==X_AXIS ? HOMEAXIS_DO(X) :
-      axis==Y_AXIS ? HOMEAXIS_DO(Y) :
-      axis==Z_AXIS ? HOMEAXIS_DO(Z) :
-      0) {
-    current_position[axis] = 0;
-    plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
-    destination[axis] = 1.5 * max_length(axis) * home_dir(axis);
-    feedrate = homing_feedrate[axis];
-    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
-    st_synchronize();
-   
-    current_position[axis] = 0;
-    plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
-    destination[axis] = -home_retract_mm(axis) * home_dir(axis);
-    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
-    st_synchronize();
-   
-    destination[axis] = 2*home_retract_mm(axis) * home_dir(axis);
-    feedrate = homing_feedrate[axis]/2 ; 
-    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
-    st_synchronize();
-   
-    axis_is_at_home(axis);					
-    destination[axis] = current_position[axis];
-    feedrate = 0.0;
-    endstops_hit_on_purpose();
-  }
-}
-#define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)
-
-void process_commands()
-{
-  unsigned long codenum; //throw away variable
-  char *starpos = NULL;
-
-  if(code_seen('G'))
-  {
-    switch((int)code_value())
-    {
-    case 0: // G0 -> G1
-    case 1: // G1
-      if(Stopped == false) {
-        get_coordinates(); // For X Y Z E F
-        prepare_move();
-        //ClearToSend();
-        return;
-      }
-      //break;
-    case 2: // G2  - CW ARC
-      if(Stopped == false) {
-        get_arc_coordinates();
-        prepare_arc_move(true);
-        return;
-      }
-    case 3: // G3  - CCW ARC
-      if(Stopped == false) {
-        get_arc_coordinates();
-        prepare_arc_move(false);
-        return;
-      }
-    case 4: // G4 dwell
-      LCD_MESSAGEPGM(MSG_DWELL);
-      codenum = 0;
-      if(code_seen('P')) codenum = code_value(); // milliseconds to wait
-      if(code_seen('S')) codenum = code_value() * 1000; // seconds to wait
-      
-      st_synchronize();
-      codenum += millis();  // keep track of when we started waiting
-      previous_millis_cmd = millis();
-      while(millis()  < codenum ){
-        manage_heater();
-        manage_inactivity();
-        LCD_STATUS;
-      }
-      break;
-      #ifdef FWRETRACT  
-      case 10: // G10 retract
-      if(!retracted) 
-      {
-        destination[X_AXIS]=current_position[X_AXIS];
-        destination[Y_AXIS]=current_position[Y_AXIS];
-        destination[Z_AXIS]=current_position[Z_AXIS]; 
-        current_position[Z_AXIS]+=-retract_zlift;
-        destination[E_AXIS]=current_position[E_AXIS]-retract_length; 
-        feedrate=retract_feedrate;
-        retracted=true;
-        prepare_move();
-      }
-      
-      break;
-      case 11: // G10 retract_recover
-      if(!retracted) 
-      {
-        destination[X_AXIS]=current_position[X_AXIS];
-        destination[Y_AXIS]=current_position[Y_AXIS];
-        destination[Z_AXIS]=current_position[Z_AXIS]; 
-        
-        current_position[Z_AXIS]+=retract_zlift;
-        current_position[E_AXIS]+=-retract_recover_length; 
-        feedrate=retract_recover_feedrate;
-        retracted=false;
-        prepare_move();
-      }
-      break;
-      #endif //FWRETRACT
-    case 28: //G28 Home all Axis one at a time
-      saved_feedrate = feedrate;
-      saved_feedmultiply = feedmultiply;
-      feedmultiply = 100;
-      previous_millis_cmd = millis();
-      
-      enable_endstops(true);
-      
-      for(int8_t i=0; i < NUM_AXIS; i++) {
-        destination[i] = current_position[i];
-      }
-      feedrate = 0.0;
-      home_all_axis = !((code_seen(axis_codes[0])) || (code_seen(axis_codes[1])) || (code_seen(axis_codes[2])));
-      
-      #if Z_HOME_DIR > 0                      // If homing away from BED do Z first
-      if((home_all_axis) || (code_seen(axis_codes[Z_AXIS]))) {
-        HOMEAXIS(Z);
-      }
-      #endif
-      
-      #ifdef QUICK_HOME
-      if((home_all_axis)||( code_seen(axis_codes[X_AXIS]) && code_seen(axis_codes[Y_AXIS])) )  //first diagonal move
-      {
-        current_position[X_AXIS] = 0;current_position[Y_AXIS] = 0;  
-
-        plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]); 
-        destination[X_AXIS] = 1.5 * X_MAX_LENGTH * X_HOME_DIR;destination[Y_AXIS] = 1.5 * Y_MAX_LENGTH * Y_HOME_DIR;  
-        feedrate = homing_feedrate[X_AXIS]; 
-        if(homing_feedrate[Y_AXIS]<feedrate)
-          feedrate =homing_feedrate[Y_AXIS]; 
-        plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
-        st_synchronize();
-    
-        axis_is_at_home(X_AXIS);
-        axis_is_at_home(Y_AXIS);
-        plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
-        destination[X_AXIS] = current_position[X_AXIS];
-        destination[Y_AXIS] = current_position[Y_AXIS];
-        plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
-        feedrate = 0.0;
-        st_synchronize();
-        endstops_hit_on_purpose();
-      }
-      #endif
-      
-      if((home_all_axis) || (code_seen(axis_codes[X_AXIS]))) 
-      {
-        HOMEAXIS(X);
-      }
-
-      if((home_all_axis) || (code_seen(axis_codes[Y_AXIS]))) {
-        HOMEAXIS(Y);
-      }
-      
-      #if Z_HOME_DIR < 0                      // If homing towards BED do Z last
-      if((home_all_axis) || (code_seen(axis_codes[Z_AXIS]))) {
-        HOMEAXIS(Z);
-      }
-      #endif
-      
-      if(code_seen(axis_codes[X_AXIS])) 
-      {
-        if(code_value_long() != 0) {
-          current_position[X_AXIS]=code_value()+add_homeing[0];
-        }
-      }
-
-      if(code_seen(axis_codes[Y_AXIS])) {
-        if(code_value_long() != 0) {
-          current_position[Y_AXIS]=code_value()+add_homeing[1];
-        }
-      }
-
-      if(code_seen(axis_codes[Z_AXIS])) {
-        if(code_value_long() != 0) {
-          current_position[Z_AXIS]=code_value()+add_homeing[2];
-        }
-      }
-      plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
-      
-      #ifdef ENDSTOPS_ONLY_FOR_HOMING
-        enable_endstops(false);
-      #endif
-      
-      feedrate = saved_feedrate;
-      feedmultiply = saved_feedmultiply;
-      previous_millis_cmd = millis();
-      endstops_hit_on_purpose();
-      break;
-    case 90: // G90
-      relative_mode = false;
-      break;
-    case 91: // G91
-      relative_mode = true;
-      break;
-    case 92: // G92
-      if(!code_seen(axis_codes[E_AXIS]))
-        st_synchronize();
-      for(int8_t i=0; i < NUM_AXIS; i++) {
-        if(code_seen(axis_codes[i])) { 
-           if(i == E_AXIS) {
-             current_position[i] = code_value();  
-             plan_set_e_position(current_position[E_AXIS]);
-           }
-           else {
-             current_position[i] = code_value()+add_homeing[i];  
-             plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
-           }
-        }
-      }
-      break;
-    }
-  }
-
-  else if(code_seen('M'))
-  {
-    switch( (int)code_value() ) 
-    {
+#include "Configuration.h"
 #ifdef ULTRA_LCD
-    case 0: // M0 - Unconditional stop - Wait for user button press on LCD
-    case 1: // M1 - Conditional stop - Wait for user button press on LCD
-    {
-      LCD_MESSAGEPGM(MSG_USERWAIT);
-      codenum = 0;
-      if(code_seen('P')) codenum = code_value(); // milliseconds to wait
-      if(code_seen('S')) codenum = code_value() * 1000; // seconds to wait
-      
-      st_synchronize();
-      previous_millis_cmd = millis();
-      if (codenum > 0){
-        codenum += millis();  // keep track of when we started waiting
-        while(millis()  < codenum && !CLICKED){
-          manage_heater();
-          manage_inactivity();
-          LCD_STATUS;
-        }
-      }else{
-        while(!CLICKED){
-          manage_heater();
-          manage_inactivity();
-          LCD_STATUS;
-        }
-      }
-    }
-    break;
-#endif
-    case 17:
-        LCD_MESSAGEPGM(MSG_NO_MOVE);
-        enable_x(); 
-        enable_y(); 
-        enable_z(); 
-        enable_e0(); 
-        enable_e1(); 
-        enable_e2(); 
-      break;
-
-#ifdef SDSUPPORT
-    case 20: // M20 - list SD card
-      SERIAL_PROTOCOLLNPGM(MSG_BEGIN_FILE_LIST);
-      card.ls();
-      SERIAL_PROTOCOLLNPGM(MSG_END_FILE_LIST);
-      break;
-    case 21: // M21 - init SD card
-      
-      card.initsd();
-      
-      break;
-    case 22: //M22 - release SD card
-      card.release();
-
-      break;
-    case 23: //M23 - Select file
-      starpos = (strchr(strchr_pointer + 4,'*'));
-      if(starpos!=NULL)
-        *(starpos-1)='\0';
-      card.openFile(strchr_pointer + 4,true);
-      break;
-    case 24: //M24 - Start SD print
-      card.startFileprint();
-      starttime=millis();
-      break;
-    case 25: //M25 - Pause SD print
-      card.pauseSDPrint();
-      break;
-    case 26: //M26 - Set SD index
-      if(card.cardOK && code_seen('S')) {
-        card.setIndex(code_value_long());
-      }
-      break;
-    case 27: //M27 - Get SD status
-      card.getStatus();
-      break;
-    case 28: //M28 - Start SD write
-      starpos = (strchr(strchr_pointer + 4,'*'));
-      if(starpos != NULL){
-        char* npos = strchr(cmdbuffer[bufindr], 'N');
-        strchr_pointer = strchr(npos,' ') + 1;
-        *(starpos-1) = '\0';
-      }
-      card.openFile(strchr_pointer+4,false);
-      break;
-    case 29: //M29 - Stop SD write
-      //processed in write to file routine above
-      //card,saving = false;
-      break;
-    case 30: //M30 <filename> Delete File 
-	if (card.cardOK){
-		card.closefile();
-		starpos = (strchr(strchr_pointer + 4,'*'));
-                if(starpos != NULL){
-                char* npos = strchr(cmdbuffer[bufindr], 'N');
-                strchr_pointer = strchr(npos,' ') + 1;
-                *(starpos-1) = '\0';
-         }
-	 card.removeFile(strchr_pointer + 4);
-	}
-	break;
-	
-#endif //SDSUPPORT
-
-    case 31: //M31 take time since the start of the SD print or an M109 command
-      {
-      stoptime=millis();
-      char time[30];
-      unsigned long t=(stoptime-starttime)/1000;
-      int sec,min;
-      min=t/60;
-      sec=t%60;
-      sprintf(time,"%i min, %i sec",min,sec);
-      SERIAL_ECHO_START;
-      SERIAL_ECHOLN(time);
-      LCD_MESSAGE(time);
-      autotempShutdown();
-      }
-      break;
-    case 42: //M42 -Change pin status via gcode
-      if (code_seen('S'))
-      {
-        int pin_status = code_value();
-        if (code_seen('P') && pin_status >= 0 && pin_status <= 255)
-        {
-          int pin_number = code_value();
-          for(int8_t i = 0; i < (int8_t)sizeof(sensitive_pins); i++)
-          {
-            if (sensitive_pins[i] == pin_number)
-            {
-              pin_number = -1;
-              break;
-            }
-          }
-          
-          if (pin_number > -1)
-          {              
-            pinMode(pin_number, OUTPUT);
-            digitalWrite(pin_number, pin_status);
-            analogWrite(pin_number, pin_status);
-          }
-        }
-      }
-     break;
-    case 104: // M104
-      tmp_extruder = active_extruder;
-      if(code_seen('T')) {
-        tmp_extruder = code_value();
-        if(tmp_extruder >= EXTRUDERS) {
-          SERIAL_ECHO_START;
-          SERIAL_ECHO(MSG_M104_INVALID_EXTRUDER);
-          SERIAL_ECHOLN(tmp_extruder);
-          break;
-        }
-      }
-      if (code_seen('S')) setTargetHotend(code_value(), tmp_extruder);
-      setWatch();
-      break;
-    case 140: // M140 set bed temp
-      if (code_seen('S')) setTargetBed(code_value());
-      break;
-    case 105 : // M105
-      tmp_extruder = active_extruder;
-      if(code_seen('T')) {
-        tmp_extruder = code_value();
-        if(tmp_extruder >= EXTRUDERS) {
-          SERIAL_ECHO_START;
-          SERIAL_ECHO(MSG_M105_INVALID_EXTRUDER);
-          SERIAL_ECHOLN(tmp_extruder);
-          break;
-        }
-      }
-      #if (TEMP_0_PIN > -1)
-        SERIAL_PROTOCOLPGM("ok T:");
-        SERIAL_PROTOCOL_F(degHotend(tmp_extruder),1); 
-        SERIAL_PROTOCOLPGM(" /");
-        SERIAL_PROTOCOL_F(degTargetHotend(tmp_extruder),1); 
-        #if TEMP_BED_PIN > -1
-          SERIAL_PROTOCOLPGM(" B:");  
-          SERIAL_PROTOCOL_F(degBed(),1);
-          SERIAL_PROTOCOLPGM(" /");
-          SERIAL_PROTOCOL_F(degTargetBed(),1);
-        #endif //TEMP_BED_PIN
-      #else
-        SERIAL_ERROR_START;
-        SERIAL_ERRORLNPGM(MSG_ERR_NO_THERMISTORS);
-      #endif
-      #ifdef PIDTEMP
-        SERIAL_PROTOCOLPGM(" @:");
-        SERIAL_PROTOCOL(getHeaterPower(tmp_extruder));  
-      #endif
-        SERIAL_PROTOCOLLN("");
-      return;
-      break;
-    case 109: 
-    {// M109 - Wait for extruder heater to reach target.
-      tmp_extruder = active_extruder;
-      if(code_seen('T')) {
-        tmp_extruder = code_value();
-        if(tmp_extruder >= EXTRUDERS) {
-          SERIAL_ECHO_START;
-          SERIAL_ECHO(MSG_M109_INVALID_EXTRUDER);
-          SERIAL_ECHOLN(tmp_extruder);
-          break;
-        }
-      }
-      LCD_MESSAGEPGM(MSG_HEATING);   
-      #ifdef AUTOTEMP
-        autotemp_enabled=false;
-      #endif
-      if (code_seen('S')) setTargetHotend(code_value(), tmp_extruder);
-      #ifdef AUTOTEMP
-        if (code_seen('S')) autotemp_min=code_value();
-        if (code_seen('B')) autotemp_max=code_value();
-        if (code_seen('F')) 
-        {
-          autotemp_factor=code_value();
-          autotemp_enabled=true;
-        }
-      #endif
-      
-      setWatch();
-      codenum = millis(); 
-
-      /* See if we are heating up or cooling down */
-      bool target_direction = isHeatingHotend(tmp_extruder); // true if heating, false if cooling
-
-      #ifdef TEMP_RESIDENCY_TIME
-        long residencyStart;
-        residencyStart = -1;
-        /* continue to loop until we have reached the target temp   
-          _and_ until TEMP_RESIDENCY_TIME hasn't passed since we reached it */
-        while((residencyStart == -1) ||
-              (residencyStart >= 0 && (((unsigned int) (millis() - residencyStart)) < (TEMP_RESIDENCY_TIME * 1000UL))) ) {
-      #else
-        while ( target_direction ? (isHeatingHotend(tmp_extruder)) : (isCoolingHotend(tmp_extruder)&&(CooldownNoWait==false)) ) {
-      #endif //TEMP_RESIDENCY_TIME
-          if( (millis() - codenum) > 1000UL )
-          { //Print Temp Reading and remaining time every 1 second while heating up/cooling down
-            SERIAL_PROTOCOLPGM("T:");
-            SERIAL_PROTOCOL_F(degHotend(tmp_extruder),1); 
-            SERIAL_PROTOCOLPGM(" E:");
-            SERIAL_PROTOCOL((int)tmp_extruder); 
-            #ifdef TEMP_RESIDENCY_TIME
-              SERIAL_PROTOCOLPGM(" W:");
-              if(residencyStart > -1)
-              {
-                 codenum = ((TEMP_RESIDENCY_TIME * 1000UL) - (millis() - residencyStart)) / 1000UL;
-                 SERIAL_PROTOCOLLN( codenum );
-              }
-              else 
-              {
-                 SERIAL_PROTOCOLLN( "?" );
-              }
-            #else
-              SERIAL_PROTOCOLLN("");
-            #endif
-            codenum = millis();
-          }
-          manage_heater();
-          manage_inactivity();
-          LCD_STATUS;
-        #ifdef TEMP_RESIDENCY_TIME
-            /* start/restart the TEMP_RESIDENCY_TIME timer whenever we reach target temp for the first time
-              or when current temp falls outside the hysteresis after target temp was reached */
-          if ((residencyStart == -1 &&  target_direction && (degHotend(tmp_extruder) >= (degTargetHotend(tmp_extruder)-TEMP_WINDOW))) ||
-              (residencyStart == -1 && !target_direction && (degHotend(tmp_extruder) <= (degTargetHotend(tmp_extruder)+TEMP_WINDOW))) ||
-              (residencyStart > -1 && labs(degHotend(tmp_extruder) - degTargetHotend(tmp_extruder)) > TEMP_HYSTERESIS) ) 
-          {
-            residencyStart = millis();
-          }
-        #endif //TEMP_RESIDENCY_TIME
-        }
-        LCD_MESSAGEPGM(MSG_HEATING_COMPLETE);
-        starttime=millis();
-        previous_millis_cmd = millis();
-      }
-      break;
-    case 190: // M190 - Wait for bed heater to reach target.
-    #if TEMP_BED_PIN > -1
-        LCD_MESSAGEPGM(MSG_BED_HEATING);
-        if (code_seen('S')) setTargetBed(code_value());
-        codenum = millis(); 
-        while(isHeatingBed()) 
-        {
-          if(( millis() - codenum) > 1000 ) //Print Temp Reading every 1 second while heating up.
-          {
-            float tt=degHotend(active_extruder);
-            SERIAL_PROTOCOLPGM("T:");
-            SERIAL_PROTOCOL(tt);
-            SERIAL_PROTOCOLPGM(" E:");
-            SERIAL_PROTOCOL((int)active_extruder); 
-            SERIAL_PROTOCOLPGM(" B:");
-            SERIAL_PROTOCOL_F(degBed(),1); 
-            SERIAL_PROTOCOLLN(""); 
-            codenum = millis(); 
-          }
-          manage_heater();
-          manage_inactivity();
-          LCD_STATUS;
-        }
-        LCD_MESSAGEPGM(MSG_BED_DONE);
-        previous_millis_cmd = millis();
-    #endif
-        break;
-
-    #if FAN_PIN > -1
-      case 106: //M106 Fan On
-        if (code_seen('S')){
-           FanSpeed=constrain(code_value(),0,255);
-        }
-        else {
-          FanSpeed=255;			
-        }
-        break;
-      case 107: //M107 Fan Off
-        FanSpeed = 0;
-        break;
-    #endif //FAN_PIN
-
-    #if (PS_ON_PIN > -1)
-      case 80: // M80 - ATX Power On
-        SET_OUTPUT(PS_ON_PIN); //GND
-        WRITE(PS_ON_PIN, LOW);
-        break;
-      #endif
-      
-      case 81: // M81 - ATX Power Off
-      
-      #if defined SUICIDE_PIN && SUICIDE_PIN > -1
-        st_synchronize();
-        suicide();
-      #elif (PS_ON_PIN > -1)
-        SET_INPUT(PS_ON_PIN); //Floating
-      #endif
-		break;
-        
-    case 82:
-      axis_relative_modes[3] = false;
-      break;
-    case 83:
-      axis_relative_modes[3] = true;
-      break;
-    case 18: //compatibility
-    case 84: // M84
-      if(code_seen('S')){ 
-        stepper_inactive_time = code_value() * 1000; 
-      }
-      else
-      { 
-        bool all_axis = !((code_seen(axis_codes[0])) || (code_seen(axis_codes[1])) || (code_seen(axis_codes[2]))|| (code_seen(axis_codes[3])));
-        if(all_axis)
-        {
-          st_synchronize();
-          disable_e0();
-          disable_e1();
-          disable_e2();
-          finishAndDisableSteppers();
-        }
-        else
-        {
-          st_synchronize();
-          if(code_seen('X')) disable_x();
-          if(code_seen('Y')) disable_y();
-          if(code_seen('Z')) disable_z();
-          #if ((E0_ENABLE_PIN != X_ENABLE_PIN) && (E1_ENABLE_PIN != Y_ENABLE_PIN)) // Only enable on boards that have seperate ENABLE_PINS
-            if(code_seen('E')) {
-              disable_e0();
-              disable_e1();
-              disable_e2();
-            }
-          #endif 
-          LCD_MESSAGEPGM(MSG_PART_RELEASE);
-        }
-      }
-      break;
-    case 85: // M85
-      code_seen('S');
-      max_inactive_time = code_value() * 1000; 
-      break;
-    case 92: // M92
-      for(int8_t i=0; i < NUM_AXIS; i++) 
-      {
-        if(code_seen(axis_codes[i])) 
-          
-          if(i == 3) { // E
-            float value = code_value();
-            if(value < 20.0) {
-              float factor = axis_steps_per_unit[i] / value; // increase e constants if M92 E14 is given for netfab.
-              max_e_jerk *= factor;
-              max_feedrate[i] *= factor;
-              axis_steps_per_sqr_second[i] *= factor;
-            }
-            axis_steps_per_unit[i] = value;
-          }
-          else {
-            axis_steps_per_unit[i] = code_value();
-          }
-      }
-      break;
-    case 115: // M115
-      SerialprintPGM(MSG_M115_REPORT);
-      break;
-    case 117: // M117 display message
-      LCD_MESSAGE(cmdbuffer[bufindr]+5);
-      break;
-    case 114: // M114
-      SERIAL_PROTOCOLPGM("X:");
-      SERIAL_PROTOCOL(current_position[X_AXIS]);
-      SERIAL_PROTOCOLPGM("Y:");
-      SERIAL_PROTOCOL(current_position[Y_AXIS]);
-      SERIAL_PROTOCOLPGM("Z:");
-      SERIAL_PROTOCOL(current_position[Z_AXIS]);
-      SERIAL_PROTOCOLPGM("E:");      
-      SERIAL_PROTOCOL(current_position[E_AXIS]);
-      
-      SERIAL_PROTOCOLPGM(MSG_COUNT_X);
-      SERIAL_PROTOCOL(float(st_get_position(X_AXIS))/axis_steps_per_unit[X_AXIS]);
-      SERIAL_PROTOCOLPGM("Y:");
-      SERIAL_PROTOCOL(float(st_get_position(Y_AXIS))/axis_steps_per_unit[Y_AXIS]);
-      SERIAL_PROTOCOLPGM("Z:");
-      SERIAL_PROTOCOL(float(st_get_position(Z_AXIS))/axis_steps_per_unit[Z_AXIS]);
-      
-      SERIAL_PROTOCOLLN("");
-      break;
-    case 120: // M120
-      enable_endstops(false) ;
-      break;
-    case 121: // M121
-      enable_endstops(true) ;
-      break;
-    case 119: // M119
-      #if (X_MIN_PIN > -1)
-        SERIAL_PROTOCOLPGM(MSG_X_MIN);
-        SERIAL_PROTOCOL(((READ(X_MIN_PIN)^X_ENDSTOPS_INVERTING)?"H ":"L "));
-      #endif
-      #if (X_MAX_PIN > -1)
-        SERIAL_PROTOCOLPGM(MSG_X_MAX);
-        SERIAL_PROTOCOL(((READ(X_MAX_PIN)^X_ENDSTOPS_INVERTING)?"H ":"L "));
-      #endif
-      #if (Y_MIN_PIN > -1)
-        SERIAL_PROTOCOLPGM(MSG_Y_MIN);
-        SERIAL_PROTOCOL(((READ(Y_MIN_PIN)^Y_ENDSTOPS_INVERTING)?"H ":"L "));
-      #endif
-      #if (Y_MAX_PIN > -1)
-        SERIAL_PROTOCOLPGM(MSG_Y_MAX);
-        SERIAL_PROTOCOL(((READ(Y_MAX_PIN)^Y_ENDSTOPS_INVERTING)?"H ":"L "));
-      #endif
-      #if (Z_MIN_PIN > -1)
-        SERIAL_PROTOCOLPGM(MSG_Z_MIN);
-        SERIAL_PROTOCOL(((READ(Z_MIN_PIN)^Z_ENDSTOPS_INVERTING)?"H ":"L "));
-      #endif
-      #if (Z_MAX_PIN > -1)
-        SERIAL_PROTOCOLPGM(MSG_Z_MAX);
-        SERIAL_PROTOCOL(((READ(Z_MAX_PIN)^Z_ENDSTOPS_INVERTING)?"H ":"L "));
-      #endif
-      SERIAL_PROTOCOLLN("");
-      break;
-      //TODO: update for all axis, use for loop
-    case 201: // M201
-      for(int8_t i=0; i < NUM_AXIS; i++) 
-      {
-        if(code_seen(axis_codes[i]))
-        {
-          max_acceleration_units_per_sq_second[i] = code_value();
-          axis_steps_per_sqr_second[i] = code_value() * axis_steps_per_unit[i];
-        }
-      }
-      break;
-    #if 0 // Not used for Sprinter/grbl gen6
-    case 202: // M202
-      for(int8_t i=0; i < NUM_AXIS; i++) {
-        if(code_seen(axis_codes[i])) axis_travel_steps_per_sqr_second[i] = code_value() * axis_steps_per_unit[i];
-      }
-      break;
-    #endif
-    case 203: // M203 max feedrate mm/sec
-      for(int8_t i=0; i < NUM_AXIS; i++) {
-        if(code_seen(axis_codes[i])) max_feedrate[i] = code_value();
-      }
-      break;
-    case 204: // M204 acclereration S normal moves T filmanent only moves
-      {
-        if(code_seen('S')) acceleration = code_value() ;
-        if(code_seen('T')) retract_acceleration = code_value() ;
-      }
-      break;
-    case 205: //M205 advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk
-    {
-      if(code_seen('S')) minimumfeedrate = code_value();
-      if(code_seen('T')) mintravelfeedrate = code_value();
-      if(code_seen('B')) minsegmenttime = code_value() ;
-      if(code_seen('X')) max_xy_jerk = code_value() ;
-      if(code_seen('Z')) max_z_jerk = code_value() ;
-      if(code_seen('E')) max_e_jerk = code_value() ;
-    }
-    break;
-    case 206: // M206 additional homeing offset
-      for(int8_t i=0; i < 3; i++) 
-      {
-        if(code_seen(axis_codes[i])) add_homeing[i] = code_value();
-      }
-      break;
-    #ifdef FWRETRACT
-    case 207: //M207 - set retract length S[positive mm] F[feedrate mm/sec] Z[additional zlift/hop]
-    {
-      if(code_seen('S')) 
-      {
-        retract_length = code_value() ;
-      }
-      if(code_seen('F')) 
-      {
-        retract_feedrate = code_value() ;
-      }
-      if(code_seen('Z')) 
-      {
-        retract_zlift = code_value() ;
-      }
-    }break;
-    case 208: // M208 - set retract recover length S[positive mm surplus to the M207 S*] F[feedrate mm/sec]
-    {
-      if(code_seen('S')) 
-      {
-        retract_recover_length = code_value() ;
-      }
-      if(code_seen('F')) 
-      {
-        retract_recover_feedrate = code_value() ;
-      }
-    }break;
-    
-    case 209: // M209 - S<1=true/0=false> enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.
-    {
-      if(code_seen('S')) 
-      {
-        int t= code_value() ;
-        switch(t)
-        {
-          case 0: autoretract_enabled=false;retracted=false;break;
-          case 1: autoretract_enabled=true;retracted=false;break;
-          default: 
-            SERIAL_ECHO_START;
-            SERIAL_ECHOPGM(MSG_UNKNOWN_COMMAND);
-            SERIAL_ECHO(cmdbuffer[bufindr]);
-            SERIAL_ECHOLNPGM("\"");
-        }
-      }
-      
-    }break;
-    #endif
-    case 220: // M220 S<factor in percent>- set speed factor override percentage
-    {
-      if(code_seen('S')) 
-      {
-        feedmultiply = code_value() ;
-        feedmultiplychanged=true;
-      }
-    }
-    break;
-    case 221: // M221 S<factor in percent>- set extrude factor override percentage
-    {
-      if(code_seen('S')) 
-      {
-        extrudemultiply = code_value() ;
-      }
-    }
-    break;
-
-    #ifdef PIDTEMP
-    case 301: // M301
-      {
-        if(code_seen('P')) Kp = code_value();
-        if(code_seen('I')) Ki = code_value()*PID_dT;
-        if(code_seen('D')) Kd = code_value()/PID_dT;
-        #ifdef PID_ADD_EXTRUSION_RATE
-        if(code_seen('C')) Kc = code_value();
-        #endif
-        updatePID();
-        SERIAL_PROTOCOL(MSG_OK);
-		SERIAL_PROTOCOL(" p:");
-        SERIAL_PROTOCOL(Kp);
-        SERIAL_PROTOCOL(" i:");
-        SERIAL_PROTOCOL(Ki/PID_dT);
-        SERIAL_PROTOCOL(" d:");
-        SERIAL_PROTOCOL(Kd*PID_dT);
-        #ifdef PID_ADD_EXTRUSION_RATE
-        SERIAL_PROTOCOL(" c:");
-        SERIAL_PROTOCOL(Kc*PID_dT);
-        #endif
-        SERIAL_PROTOCOLLN("");
-      }
-      break;
-    #endif //PIDTEMP
-    case 240: // M240  Triggers a camera by emulating a Canon RC-1 : http://www.doc-diy.net/photo/rc-1_hacked/
-     {
-      #ifdef PHOTOGRAPH_PIN
-        #if (PHOTOGRAPH_PIN > -1)
-        const uint8_t NUM_PULSES=16;
-        const float PULSE_LENGTH=0.01524;
-        for(int i=0; i < NUM_PULSES; i++) {
-          WRITE(PHOTOGRAPH_PIN, HIGH);
-          _delay_ms(PULSE_LENGTH);
-          WRITE(PHOTOGRAPH_PIN, LOW);
-          _delay_ms(PULSE_LENGTH);
-        }
-        delay(7.33);
-        for(int i=0; i < NUM_PULSES; i++) {
-          WRITE(PHOTOGRAPH_PIN, HIGH);
-          _delay_ms(PULSE_LENGTH);
-          WRITE(PHOTOGRAPH_PIN, LOW);
-          _delay_ms(PULSE_LENGTH);
-        }
-        #endif
-      #endif
-     }
-    break;
-      
-    case 302: // allow cold extrudes
-    {
-      allow_cold_extrudes(true);
-    }
-    break;
-    case 303: // M303 PID autotune
-    {
-      float temp = 150.0;
-      if (code_seen('S')) temp=code_value();
-      PID_autotune(temp);
-    }
-    break;
-    case 400: // M400 finish all moves
-    {
-      st_synchronize();
-    }
-    break;
-    case 500: // Store settings in EEPROM
-    {
-        EEPROM_StoreSettings();
-    }
-    break;
-    case 501: // Read settings from EEPROM
-    {
-      EEPROM_RetrieveSettings();
-    }
-    break;
-    case 502: // Revert to default settings
-    {
-      EEPROM_RetrieveSettings(true);
-    }
-    break;
-    case 503: // print settings currently in memory
-    {
-      EEPROM_printSettings();
-    }
-    break;
-    case 907: // Set digital trimpot motor current using axis codes.
-    {
-      #if DIGIPOTSS_PIN > -1
-        for(int i=0;i<=NUM_AXIS;i++) if(code_seen(axis_codes[i])) digipot_current(i,code_value());
-        if(code_seen('B')) digipot_current(4,code_value());
-        if(code_seen('S')) for(int i=0;i<=4;i++) digipot_current(i,code_value());
-      #endif
-    }
-    case 908: // Control digital trimpot directly.
-    {
-      #if DIGIPOTSS_PIN > -1
-        uint8_t channel,current;
-        if(code_seen('P')) channel=code_value();
-        if(code_seen('S')) current=code_value();
-        digitalPotWrite(channel, current);
-      #endif
-    }
-    break;
-    case 350: // Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
-    {
-      #if X_MS1_PIN > -1
-        if(code_seen('S')) for(int i=0;i<=4;i++) microstep_mode(i,code_value()); 
-        for(int i=0;i<=NUM_AXIS;i++) if(code_seen(axis_codes[i])) microstep_mode(i,(uint8_t)code_value());
-        if(code_seen('B')) microstep_mode(4,code_value());
-        microstep_readings();
-      #endif
-    }
-    break;
-    case 351: // Toggle MS1 MS2 pins directly, S# determines MS1 or MS2, X# sets the pin high/low.
-    {
-      #if X_MS1_PIN > -1
-      if(code_seen('S')) switch((int)code_value())
-      {
-        case 1:
-          for(int i=0;i<=NUM_AXIS;i++) if(code_seen(axis_codes[i])) microstep_ms(i,code_value(),-1);
-          if(code_seen('B')) microstep_ms(4,code_value(),-1);
-          break;
-        case 2:
-          for(int i=0;i<=NUM_AXIS;i++) if(code_seen(axis_codes[i])) microstep_ms(i,-1,code_value());
-          if(code_seen('B')) microstep_ms(4,-1,code_value());
-          break;
-      }
-      microstep_readings();
-      #endif
-    }
-    break;
-    case 999: // Restart after being stopped
-      Stopped = false;
-      gcode_LastN = Stopped_gcode_LastN;
-      FlushSerialRequestResend();
-    break;
-    }
-  }
-
-  else if(code_seen('T')) 
-  {
-    tmp_extruder = code_value();
-    if(tmp_extruder >= EXTRUDERS) {
-      SERIAL_ECHO_START;
-      SERIAL_ECHO("T");
-      SERIAL_ECHO(tmp_extruder);
-      SERIAL_ECHOLN(MSG_INVALID_EXTRUDER);
-    }
-    else {
-      active_extruder = tmp_extruder;
-      SERIAL_ECHO_START;
-      SERIAL_ECHO(MSG_ACTIVE_EXTRUDER);
-      SERIAL_PROTOCOLLN((int)active_extruder);
-    }
-  }
-
-  else
-  {
-    SERIAL_ECHO_START;
-    SERIAL_ECHOPGM(MSG_UNKNOWN_COMMAND);
-    SERIAL_ECHO(cmdbuffer[bufindr]);
-    SERIAL_ECHOLNPGM("\"");
-  }
-
-  ClearToSend();
-}
-
-void FlushSerialRequestResend()
-{
-  //char cmdbuffer[bufindr][100]="Resend:";
-  MYSERIAL.flush();
-  SERIAL_PROTOCOLPGM(MSG_RESEND);
-  SERIAL_PROTOCOLLN(gcode_LastN + 1);
-  ClearToSend();
-}
-
-void ClearToSend()
-{
-  previous_millis_cmd = millis();
-  #ifdef SDSUPPORT
-  if(fromsd[bufindr])
-    return;
-  #endif //SDSUPPORT
-  SERIAL_PROTOCOLLNPGM(MSG_OK); 
-}
-
-void get_coordinates()
-{
-  bool seen[4]={false,false,false,false};
-  for(int8_t i=0; i < NUM_AXIS; i++) {
-    if(code_seen(axis_codes[i])) 
-    {
-      destination[i] = (float)code_value() + (axis_relative_modes[i] || relative_mode)*current_position[i];
-      seen[i]=true;
-    }
-    else destination[i] = current_position[i]; //Are these else lines really needed?
-  }
-  if(code_seen('F')) {
-    next_feedrate = code_value();
-    if(next_feedrate > 0.0) feedrate = next_feedrate;
-  }
-  #ifdef FWRETRACT
-  if(autoretract_enabled)
-  if( !(seen[X_AXIS] || seen[Y_AXIS] || seen[Z_AXIS]) && seen[E_AXIS])
-  {
-    float echange=destination[E_AXIS]-current_position[E_AXIS];
-    if(echange<-MIN_RETRACT) //retract
-    {
-      if(!retracted) 
-      {
-      
-      destination[Z_AXIS]+=retract_zlift; //not sure why chaninging current_position negatively does not work.
-      //if slicer retracted by echange=-1mm and you want to retract 3mm, corrrectede=-2mm additionally
-      float correctede=-echange-retract_length;
-      //to generate the additional steps, not the destination is changed, but inversely the current position
-      current_position[E_AXIS]+=-correctede; 
-      feedrate=retract_feedrate;
-      retracted=true;
-      }
-      
-    }
-    else 
-      if(echange>MIN_RETRACT) //retract_recover
-    {
-      if(retracted) 
-      {
-      //current_position[Z_AXIS]+=-retract_zlift;
-      //if slicer retracted_recovered by echange=+1mm and you want to retract_recover 3mm, corrrectede=2mm additionally
-      float correctede=-echange+1*retract_length+retract_recover_length; //total unretract=retract_length+retract_recover_length[surplus]
-      current_position[E_AXIS]+=correctede; //to generate the additional steps, not the destination is changed, but inversely the current position
-      feedrate=retract_recover_feedrate;
-      retracted=false;
-      }
-    }
-    
-  }
-  #endif //FWRETRACT
-}
-
-void get_arc_coordinates()
-{
-   get_coordinates();
-   if(code_seen('I')) {
-     offset[0] = code_value();
-   } 
-   else {
-     offset[0] = 0.0;
-   }
-   if(code_seen('J')) {
-     offset[1] = code_value();
-   }
-   else {
-     offset[1] = 0.0;
-   }
-}
-
-void clamp_to_software_endstops(float target[3])
-{
-  if (min_software_endstops) {
-    if (target[X_AXIS] < min_pos[X_AXIS]) target[X_AXIS] = min_pos[X_AXIS];
-    if (target[Y_AXIS] < min_pos[Y_AXIS]) target[Y_AXIS] = min_pos[Y_AXIS];
-    if (target[Z_AXIS] < min_pos[Z_AXIS]) target[Z_AXIS] = min_pos[Z_AXIS];
-  }
-
-  if (max_software_endstops) {
-    if (target[X_AXIS] > max_pos[X_AXIS]) target[X_AXIS] = max_pos[X_AXIS];
-    if (target[Y_AXIS] > max_pos[Y_AXIS]) target[Y_AXIS] = max_pos[Y_AXIS];
-    if (target[Z_AXIS] > max_pos[Z_AXIS]) target[Z_AXIS] = max_pos[Z_AXIS];
-  }
-}
-
-void prepare_move()
-{
-  clamp_to_software_endstops(destination);
-
-  previous_millis_cmd = millis(); 
-  // Do not use feedmultiply for E or Z only moves
-  if( (current_position[X_AXIS] == destination [X_AXIS]) && (current_position[Y_AXIS] == destination [Y_AXIS])) {
-      plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
-  }
-  else {
-    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate*feedmultiply/60/100.0, active_extruder);
-  }
-  for(int8_t i=0; i < NUM_AXIS; i++) {
-    current_position[i] = destination[i];
-  }
-}
-
-void prepare_arc_move(char isclockwise) {
-  float r = hypot(offset[X_AXIS], offset[Y_AXIS]); // Compute arc radius for mc_arc
-
-  // Trace the arc
-  mc_arc(current_position, destination, offset, X_AXIS, Y_AXIS, Z_AXIS, feedrate*feedmultiply/60/100.0, r, isclockwise, active_extruder);
-  
-  // As far as the parser is concerned, the position is now == target. In reality the
-  // motion control system might still be processing the action and the real tool position
-  // in any intermediate location.
-  for(int8_t i=0; i < NUM_AXIS; i++) {
-    current_position[i] = destination[i];
-  }
-  previous_millis_cmd = millis();
-}
-
-#ifdef CONTROLLERFAN_PIN
-unsigned long lastMotor = 0; //Save the time for when a motor was turned on last
-unsigned long lastMotorCheck = 0;
-
-void controllerFan()
-{
-  if ((millis() - lastMotorCheck) >= 2500) //Not a time critical function, so we only check every 2500ms
-  {
-    lastMotorCheck = millis();
-    
-    if(!READ(X_ENABLE_PIN) || !READ(Y_ENABLE_PIN) || !READ(Z_ENABLE_PIN)
-    #if EXTRUDERS > 2
-       || !READ(E2_ENABLE_PIN)
-    #endif
-    #if EXTRUDER > 1
-       || !READ(E2_ENABLE_PIN)
-    #endif
-       || !READ(E0_ENABLE_PIN)) //If any of the drivers are enabled...    
-    {
-      lastMotor = millis(); //... set time to NOW so the fan will turn on
-    }
-    
-    if ((millis() - lastMotor) >= (CONTROLLERFAN_SEC*1000UL) || lastMotor == 0) //If the last time any driver was enabled, is longer since than CONTROLLERSEC...   
-    {
-      WRITE(CONTROLLERFAN_PIN, LOW); //... turn the fan off
-    }
-    else
-    {
-      WRITE(CONTROLLERFAN_PIN, HIGH); //... turn the fan on
-    }
-  }
-}
-#endif
-
-void manage_inactivity() 
-{ 
-  if( (millis() - previous_millis_cmd) >  max_inactive_time ) 
-    if(max_inactive_time) 
-      kill(); 
-  if(stepper_inactive_time)  {
-    if( (millis() - previous_millis_cmd) >  stepper_inactive_time ) 
-    {
-      if(blocks_queued() == false) {
-        disable_x();
-        disable_y();
-        disable_z();
-        disable_e0();
-        disable_e1();
-        disable_e2();
-      }
-    }
-  }
-  #if( KILL_PIN>-1 )
-    if( 0 == READ(KILL_PIN) )
-      kill();
-  #endif
-  #ifdef CONTROLLERFAN_PIN
-    controllerFan(); //Check if fan should be turned on to cool stepper drivers down
-  #endif
-  #ifdef EXTRUDER_RUNOUT_PREVENT
-    if( (millis() - previous_millis_cmd) >  EXTRUDER_RUNOUT_SECONDS*1000 ) 
-    if(degHotend(active_extruder)>EXTRUDER_RUNOUT_MINTEMP)
-    {
-     bool oldstatus=READ(E0_ENABLE_PIN);
-     enable_e0();
-     float oldepos=current_position[E_AXIS];
-     float oldedes=destination[E_AXIS];
-     plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], 
-                      current_position[E_AXIS]+EXTRUDER_RUNOUT_EXTRUDE*EXTRUDER_RUNOUT_ESTEPS/axis_steps_per_unit[E_AXIS], 
-                      EXTRUDER_RUNOUT_SPEED/60.*EXTRUDER_RUNOUT_ESTEPS/axis_steps_per_unit[E_AXIS], active_extruder);
-     current_position[E_AXIS]=oldepos;
-     destination[E_AXIS]=oldedes;
-     plan_set_e_position(oldepos);
-     previous_millis_cmd=millis();
-     st_synchronize();
-     WRITE(E0_ENABLE_PIN,oldstatus);
-    }
-  #endif
-  check_axes_activity();
-}
-
-void kill()
-{
-  cli(); // Stop interrupts
-  disable_heater();
-
-  disable_x();
-  disable_y();
-  disable_z();
-  disable_e0();
-  disable_e1();
-  disable_e2();
-  
-  if(PS_ON_PIN > -1) pinMode(PS_ON_PIN,INPUT);
-  SERIAL_ERROR_START;
-  SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
-  LCD_ALERTMESSAGEPGM(MSG_KILLED);
-  suicide();
-  while(1); // Wait for reset
-}
-
-void Stop()
-{
-  disable_heater();
-  if(Stopped == false) {
-    Stopped = true;
-    Stopped_gcode_LastN = gcode_LastN; // Save last g_code for restart
-    SERIAL_ERROR_START;
-    SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
-    LCD_MESSAGEPGM(MSG_STOPPED);
-  }
-}
-
-bool IsStopped() { return Stopped; };
-
-#ifdef FAST_PWM_FAN
-void setPwmFrequency(uint8_t pin, int val)
-{
-  val &= 0x07;
-  switch(digitalPinToTimer(pin))
-  {
- 
-    #if defined(TCCR0A)
-    case TIMER0A:
-    case TIMER0B:
-//         TCCR0B &= ~(CS00 | CS01 | CS02);
-//         TCCR0B |= val;
-         break;
-    #endif
-
-    #if defined(TCCR1A)
-    case TIMER1A:
-    case TIMER1B:
-//         TCCR1B &= ~(CS10 | CS11 | CS12);
-//         TCCR1B |= val;
-         break;
-    #endif
-
-    #if defined(TCCR2)
-    case TIMER2:
-    case TIMER2:
-         TCCR2 &= ~(CS10 | CS11 | CS12);
-         TCCR2 |= val;
-         break;
-    #endif
-
-    #if defined(TCCR2A)
-    case TIMER2A:
-    case TIMER2B:
-         TCCR2B &= ~(CS20 | CS21 | CS22);
-         TCCR2B |= val;
-         break;
-    #endif
-
-    #if defined(TCCR3A)
-    case TIMER3A:
-    case TIMER3B:
-    case TIMER3C:
-         TCCR3B &= ~(CS30 | CS31 | CS32);
-         TCCR3B |= val;
-         break;
-    #endif
-
-    #if defined(TCCR4A) 
-    case TIMER4A:
-    case TIMER4B:
-    case TIMER4C:
-         TCCR4B &= ~(CS40 | CS41 | CS42);
-         TCCR4B |= val;
-         break;
-   #endif
-
-    #if defined(TCCR5A) 
-    case TIMER5A:
-    case TIMER5B:
-    case TIMER5C:
-         TCCR5B &= ~(CS50 | CS51 | CS52);
-         TCCR5B |= val;
-         break;
-   #endif
-
-  }
-}
-#endif
+#include <LiquidCrystal.h>
+#endif
diff --git a/Marlin/MarlinSerial.cpp b/Marlin/MarlinSerial.cpp
index e369800..0d2aceb 100644
--- a/Marlin/MarlinSerial.cpp
+++ b/Marlin/MarlinSerial.cpp
@@ -28,7 +28,7 @@
 // this is so I can support Attiny series and any other chip without a uart
 #if defined(UBRRH) || defined(UBRR0H) || defined(UBRR1H) || defined(UBRR2H) || defined(UBRR3H)
 
-#if defined(UBRRH) || defined(UBRR0H)
+#if UART_PRESENT(SERIAL_PORT)
   ring_buffer rx_buffer  =  { { 0 }, 0, 0 };
 #endif
 
@@ -48,18 +48,12 @@ FORCE_INLINE void store_char(unsigned char c)
 
 
 //#elif defined(SIG_USART_RECV)
-#if defined(USART0_RX_vect)
+#if defined(M_USARTx_RX_vect)
   // fixed by Mark Sproul this is on the 644/644p
   //SIGNAL(SIG_USART_RECV)
-  SIGNAL(USART0_RX_vect)
+  SIGNAL(M_USARTx_RX_vect)
   {
-  #if defined(UDR0)
-    unsigned char c  =  UDR0;
-  #elif defined(UDR)
-    unsigned char c  =  UDR;  //  atmega8, atmega32
-  #else
-    #error UDR not defined
-  #endif
+    unsigned char c  =  M_UDRx;
     store_char(c);
   }
 #endif
@@ -76,39 +70,39 @@ MarlinSerial::MarlinSerial()
 void MarlinSerial::begin(long baud)
 {
   uint16_t baud_setting;
-  bool useU2X0 = true;
+  bool useU2X = true;
 
-#if F_CPU == 16000000UL
+#if F_CPU == 16000000UL && SERIAL_PORT == 0
   // hardcoded exception for compatibility with the bootloader shipped
   // with the Duemilanove and previous boards and the firmware on the 8U2
   // on the Uno and Mega 2560.
   if (baud == 57600) {
-    useU2X0 = false;
+    useU2X = false;
   }
 #endif
   
-  if (useU2X0) {
-    UCSR0A = 1 << U2X0;
+  if (useU2X) {
+    M_UCSRxA = 1 << M_U2Xx;
     baud_setting = (F_CPU / 4 / baud - 1) / 2;
   } else {
-    UCSR0A = 0;
+    M_UCSRxA = 0;
     baud_setting = (F_CPU / 8 / baud - 1) / 2;
   }
 
   // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)
-  UBRR0H = baud_setting >> 8;
-  UBRR0L = baud_setting;
+  M_UBRRxH = baud_setting >> 8;
+  M_UBRRxL = baud_setting;
 
-  sbi(UCSR0B, RXEN0);
-  sbi(UCSR0B, TXEN0);
-  sbi(UCSR0B, RXCIE0);
+  sbi(M_UCSRxB, M_RXENx);
+  sbi(M_UCSRxB, M_TXENx);
+  sbi(M_UCSRxB, M_RXCIEx);
 }
 
 void MarlinSerial::end()
 {
-  cbi(UCSR0B, RXEN0);
-  cbi(UCSR0B, TXEN0);
-  cbi(UCSR0B, RXCIE0);  
+  cbi(M_UCSRxB, M_RXENx);
+  cbi(M_UCSRxB, M_TXENx);
+  cbi(M_UCSRxB, M_RXCIEx);  
 }
 
 
diff --git a/Marlin/MarlinSerial.h b/Marlin/MarlinSerial.h
index 8525cba..a48ffbe 100644
--- a/Marlin/MarlinSerial.h
+++ b/Marlin/MarlinSerial.h
@@ -23,6 +23,40 @@
 #define MarlinSerial_h
 #include "Marlin.h"
 
+#if !defined(SERIAL_PORT) 
+#define SERIAL_PORT 0
+#endif
+
+// The presence of the UBRRH register is used to detect a UART.
+#define UART_PRESENT(port) ((port == 0 && (defined(UBRRH) || defined(UBRR0H))) || \
+						(port == 1 && defined(UBRR1H)) || (port == 2 && defined(UBRR2H)) || \
+						(port == 3 && defined(UBRR3H)))				
+						
+// These are macros to build serial port register names for the selected SERIAL_PORT (C preprocessor
+// requires two levels of indirection to expand macro values properly)
+#define SERIAL_REGNAME(registerbase,number,suffix) SERIAL_REGNAME_INTERNAL(registerbase,number,suffix)
+#if SERIAL_PORT == 0 && (!defined(UBRR0H) || !defined(UDR0)) // use un-numbered registers if necessary
+#define SERIAL_REGNAME_INTERNAL(registerbase,number,suffix) registerbase##suffix
+#else
+#define SERIAL_REGNAME_INTERNAL(registerbase,number,suffix) registerbase##number##suffix
+#endif
+
+// Registers used by MarlinSerial class (these are expanded 
+// depending on selected serial port
+#define M_UCSRxA SERIAL_REGNAME(UCSR,SERIAL_PORT,A) // defines M_UCSRxA to be UCSRnA where n is the serial port number
+#define M_UCSRxB SERIAL_REGNAME(UCSR,SERIAL_PORT,B) 
+#define M_RXENx SERIAL_REGNAME(RXEN,SERIAL_PORT,)    
+#define M_TXENx SERIAL_REGNAME(TXEN,SERIAL_PORT,)    
+#define M_RXCIEx SERIAL_REGNAME(RXCIE,SERIAL_PORT,)    
+#define M_UDREx SERIAL_REGNAME(UDRE,SERIAL_PORT,)    
+#define M_UDRx SERIAL_REGNAME(UDR,SERIAL_PORT,)  
+#define M_UBRRxH SERIAL_REGNAME(UBRR,SERIAL_PORT,H)
+#define M_UBRRxL SERIAL_REGNAME(UBRR,SERIAL_PORT,L)
+#define M_RXCx SERIAL_REGNAME(RXC,SERIAL_PORT,)
+#define M_USARTx_RX_vect SERIAL_REGNAME(USART,SERIAL_PORT,_RX_vect)
+#define M_U2Xx SERIAL_REGNAME(U2X,SERIAL_PORT,)
+
+
 
 #define DEC 10
 #define HEX 16
@@ -46,7 +80,7 @@ struct ring_buffer
   int tail;
 };
 
-#if defined(UBRRH) || defined(UBRR0H)
+#if UART_PRESENT(SERIAL_PORT)
   extern ring_buffer rx_buffer;
 #endif
 
@@ -68,17 +102,17 @@ class MarlinSerial //: public Stream
     
     FORCE_INLINE void write(uint8_t c)
     {
-      while (!((UCSR0A) & (1 << UDRE0)))
+      while (!((M_UCSRxA) & (1 << M_UDREx)))
         ;
 
-      UDR0 = c;
+      M_UDRx = c;
     }
     
     
     FORCE_INLINE void checkRx(void)
     {
-      if((UCSR0A & (1<<RXC0)) != 0) {
-        unsigned char c  =  UDR0;
+      if((M_UCSRxA & (1<<M_RXCx)) != 0) {
+        unsigned char c  =  M_UDRx;
         int i = (unsigned int)(rx_buffer.head + 1) % RX_BUFFER_SIZE;
 
         // if we should be storing the received character into the location
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
new file mode 100644
index 0000000..5ddc819
--- /dev/null
+++ b/Marlin/Marlin_main.cpp
@@ -0,0 +1,1917 @@
+/* -*- c++ -*- */
+
+/*
+    Reprap firmware based on Sprinter and grbl.
+ Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ 
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+ 
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ This firmware is a mashup between Sprinter and grbl.
+  (https://github.com/kliment/Sprinter)
+  (https://github.com/simen/grbl/tree)
+ 
+ It has preliminary support for Matthew Roberts advance algorithm 
+    http://reprap.org/pipermail/reprap-dev/2011-May/003323.html
+ */
+#include <SPI.h>
+#include "Marlin.h"
+
+#include "ultralcd.h"
+#include "planner.h"
+#include "stepper.h"
+#include "temperature.h"
+#include "motion_control.h"
+#include "cardreader.h"
+#include "watchdog.h"
+#include "ConfigurationStore.h"
+#include "language.h"
+#include "pins_arduino.h"
+
+#define VERSION_STRING  "1.0.0"
+
+// look here for descriptions of gcodes: http://linuxcnc.org/handbook/gcode/g-code.html
+// http://objects.reprap.org/wiki/Mendel_User_Manual:_RepRapGCodes
+
+//Implemented Codes
+//-------------------
+// G0  -> G1
+// G1  - Coordinated Movement X Y Z E
+// G2  - CW ARC
+// G3  - CCW ARC
+// G4  - Dwell S<seconds> or P<milliseconds>
+// G10 - retract filament according to settings of M207
+// G11 - retract recover filament according to settings of M208
+// G28 - Home all Axis
+// G90 - Use Absolute Coordinates
+// G91 - Use Relative Coordinates
+// G92 - Set current position to cordinates given
+
+//RepRap M Codes
+// M0   - Unconditional stop - Wait for user to press a button on the LCD (Only if ULTRA_LCD is enabled)
+// M1   - Same as M0
+// M104 - Set extruder target temp
+// M105 - Read current temp
+// M106 - Fan on
+// M107 - Fan off
+// M109 - Wait for extruder current temp to reach target temp.
+// M114 - Display current position
+
+//Custom M Codes
+// M17  - Enable/Power all stepper motors
+// M18  - Disable all stepper motors; same as M84
+// M20  - List SD card
+// M21  - Init SD card
+// M22  - Release SD card
+// M23  - Select SD file (M23 filename.g)
+// M24  - Start/resume SD print
+// M25  - Pause SD print
+// M26  - Set SD position in bytes (M26 S12345)
+// M27  - Report SD print status
+// M28  - Start SD write (M28 filename.g)
+// M29  - Stop SD write
+// M30  - Delete file from SD (M30 filename.g)
+// M31  - Output time since last M109 or SD card start to serial
+// M42  - Change pin status via gcode
+// M80  - Turn on Power Supply
+// M81  - Turn off Power Supply
+// M82  - Set E codes absolute (default)
+// M83  - Set E codes relative while in Absolute Coordinates (G90) mode
+// M84  - Disable steppers until next move, 
+//        or use S<seconds> to specify an inactivity timeout, after which the steppers will be disabled.  S0 to disable the timeout.
+// M85  - Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
+// M92  - Set axis_steps_per_unit - same syntax as G92
+// M114 - Output current position to serial port 
+// M115	- Capabilities string
+// M117 - display message
+// M119 - Output Endstop status to serial port
+// M140 - Set bed target temp
+// M190 - Wait for bed current temp to reach target temp.
+// M200 - Set filament diameter
+// M201 - Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)
+// M202 - Set max acceleration in units/s^2 for travel moves (M202 X1000 Y1000) Unused in Marlin!!
+// M203 - Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in mm/sec
+// M204 - Set default acceleration: S normal moves T filament only moves (M204 S3000 T7000) im mm/sec^2  also sets minimum segment time in ms (B20000) to prevent buffer underruns and M20 minimum feedrate
+// M205 -  advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk, E=maximum E jerk
+// M206 - set additional homeing offset
+// M207 - set retract length S[positive mm] F[feedrate mm/sec] Z[additional zlift/hop]
+// M208 - set recover=unretract length S[positive mm surplus to the M207 S*] F[feedrate mm/sec]
+// M209 - S<1=true/0=false> enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.
+// M220 S<factor in percent>- set speed factor override percentage
+// M221 S<factor in percent>- set extrude factor override percentage
+// M240 - Trigger a camera to take a photograph
+// M301 - Set PID parameters P I and D
+// M302 - Allow cold extrudes
+// M303 - PID relay autotune S<temperature> sets the target temperature. (default target temperature = 150C)
+// M304 - Set bed PID parameters P I and D
+// M400 - Finish all moves
+// M500 - stores paramters in EEPROM
+// M501 - reads parameters from EEPROM (if you need reset them after you changed them temporarily).  
+// M502 - reverts to the default "factory settings".  You still need to store them in EEPROM afterwards if you want to.
+// M503 - print the current settings (from memory not from eeprom)
+// M907 - Set digital trimpot motor current using axis codes.
+// M908 - Control digital trimpot directly.
+// M350 - Set microstepping mode.
+// M351 - Toggle MS1 MS2 pins directly.
+// M999 - Restart after being stopped by error
+
+//Stepper Movement Variables
+
+//===========================================================================
+//=============================imported variables============================
+//===========================================================================
+
+
+//===========================================================================
+//=============================public variables=============================
+//===========================================================================
+#ifdef SDSUPPORT
+CardReader card;
+#endif
+float homing_feedrate[] = HOMING_FEEDRATE;
+bool axis_relative_modes[] = AXIS_RELATIVE_MODES;
+volatile int feedmultiply=100; //100->1 200->2
+int saved_feedmultiply;
+volatile bool feedmultiplychanged=false;
+volatile int extrudemultiply=100; //100->1 200->2
+float current_position[NUM_AXIS] = { 0.0, 0.0, 0.0, 0.0 };
+float add_homeing[3]={0,0,0};
+float min_pos[3] = { X_MIN_POS, Y_MIN_POS, Z_MIN_POS };
+float max_pos[3] = { X_MAX_POS, Y_MAX_POS, Z_MAX_POS };
+uint8_t active_extruder = 0;
+unsigned char FanSpeed=0;
+
+#ifdef FWRETRACT
+  bool autoretract_enabled=true;
+  bool retracted=false;
+  float retract_length=3, retract_feedrate=17*60, retract_zlift=0.8;
+  float retract_recover_length=0, retract_recover_feedrate=8*60;
+#endif
+
+//===========================================================================
+//=============================private variables=============================
+//===========================================================================
+const char axis_codes[NUM_AXIS] = {'X', 'Y', 'Z', 'E'};
+static float destination[NUM_AXIS] = {  0.0, 0.0, 0.0, 0.0};
+static float offset[3] = {0.0, 0.0, 0.0};
+static bool home_all_axis = true;
+static float feedrate = 1500.0, next_feedrate, saved_feedrate;
+static long gcode_N, gcode_LastN, Stopped_gcode_LastN = 0;
+
+static bool relative_mode = false;  //Determines Absolute or Relative Coordinates
+
+static char cmdbuffer[BUFSIZE][MAX_CMD_SIZE];
+static bool fromsd[BUFSIZE];
+static int bufindr = 0;
+static int bufindw = 0;
+static int buflen = 0;
+//static int i = 0;
+static char serial_char;
+static int serial_count = 0;
+static boolean comment_mode = false;
+static char *strchr_pointer; // just a pointer to find chars in the cmd string like X, Y, Z, E, etc
+
+const int sensitive_pins[] = SENSITIVE_PINS; // Sensitive pin list for M42
+
+//static float tt = 0;
+//static float bt = 0;
+
+//Inactivity shutdown variables
+static unsigned long previous_millis_cmd = 0;
+static unsigned long max_inactive_time = 0;
+static unsigned long stepper_inactive_time = DEFAULT_STEPPER_DEACTIVE_TIME*1000l;
+
+unsigned long starttime=0;
+unsigned long stoptime=0;
+
+static uint8_t tmp_extruder;
+
+
+bool Stopped=false;
+
+//===========================================================================
+//=============================ROUTINES=============================
+//===========================================================================
+
+void get_arc_coordinates();
+bool setTargetedHotend(int code);
+
+void serial_echopair_P(const char *s_P, float v)
+    { serialprintPGM(s_P); SERIAL_ECHO(v); }
+void serial_echopair_P(const char *s_P, double v)
+    { serialprintPGM(s_P); SERIAL_ECHO(v); }
+void serial_echopair_P(const char *s_P, unsigned long v)
+    { serialprintPGM(s_P); SERIAL_ECHO(v); }
+
+extern "C"{
+  extern unsigned int __bss_end;
+  extern unsigned int __heap_start;
+  extern void *__brkval;
+
+  int freeMemory() {
+    int free_memory;
+
+    if((int)__brkval == 0)
+      free_memory = ((int)&free_memory) - ((int)&__bss_end);
+    else
+      free_memory = ((int)&free_memory) - ((int)__brkval);
+
+    return free_memory;
+  }
+}
+
+//adds an command to the main command buffer
+//thats really done in a non-safe way.
+//needs overworking someday
+void enquecommand(const char *cmd)
+{
+  if(buflen < BUFSIZE)
+  {
+    //this is dangerous if a mixing of serial and this happsens
+    strcpy(&(cmdbuffer[bufindw][0]),cmd);
+    SERIAL_ECHO_START;
+    SERIAL_ECHOPGM("enqueing \"");
+    SERIAL_ECHO(cmdbuffer[bufindw]);
+    SERIAL_ECHOLNPGM("\"");
+    bufindw= (bufindw + 1)%BUFSIZE;
+    buflen += 1;
+  }
+}
+
+void setup_killpin()
+{
+  #if( KILL_PIN>-1 )
+    pinMode(KILL_PIN,INPUT);
+    WRITE(KILL_PIN,HIGH);
+  #endif
+}
+    
+void setup_photpin()
+{
+  #ifdef PHOTOGRAPH_PIN
+    #if (PHOTOGRAPH_PIN > -1)
+    SET_OUTPUT(PHOTOGRAPH_PIN);
+    WRITE(PHOTOGRAPH_PIN, LOW);
+    #endif
+  #endif 
+}
+
+void setup_powerhold()
+{
+ #ifdef SUICIDE_PIN
+   #if (SUICIDE_PIN> -1)
+      SET_OUTPUT(SUICIDE_PIN);
+      WRITE(SUICIDE_PIN, HIGH);
+   #endif
+ #endif
+}
+
+void suicide()
+{
+ #ifdef SUICIDE_PIN
+    #if (SUICIDE_PIN> -1) 
+      SET_OUTPUT(SUICIDE_PIN);
+      WRITE(SUICIDE_PIN, LOW);
+    #endif
+  #endif
+}
+
+void setup()
+{
+  setup_killpin(); 
+  setup_powerhold();
+  MYSERIAL.begin(BAUDRATE);
+  SERIAL_PROTOCOLLNPGM("start");
+  SERIAL_ECHO_START;
+
+  // Check startup - does nothing if bootloader sets MCUSR to 0
+  byte mcu = MCUSR;
+  if(mcu & 1) SERIAL_ECHOLNPGM(MSG_POWERUP);
+  if(mcu & 2) SERIAL_ECHOLNPGM(MSG_EXTERNAL_RESET);
+  if(mcu & 4) SERIAL_ECHOLNPGM(MSG_BROWNOUT_RESET);
+  if(mcu & 8) SERIAL_ECHOLNPGM(MSG_WATCHDOG_RESET);
+  if(mcu & 32) SERIAL_ECHOLNPGM(MSG_SOFTWARE_RESET);
+  MCUSR=0;
+
+  SERIAL_ECHOPGM(MSG_MARLIN);
+  SERIAL_ECHOLNPGM(VERSION_STRING);
+  #ifdef STRING_VERSION_CONFIG_H
+    #ifdef STRING_CONFIG_H_AUTHOR
+      SERIAL_ECHO_START;
+      SERIAL_ECHOPGM(MSG_CONFIGURATION_VER);
+      SERIAL_ECHOPGM(STRING_VERSION_CONFIG_H);
+      SERIAL_ECHOPGM(MSG_AUTHOR);
+      SERIAL_ECHOLNPGM(STRING_CONFIG_H_AUTHOR);
+      SERIAL_ECHOPGM("Compiled: ");
+      SERIAL_ECHOLNPGM(__DATE__);
+    #endif
+  #endif
+  SERIAL_ECHO_START;
+  SERIAL_ECHOPGM(MSG_FREE_MEMORY);
+  SERIAL_ECHO(freeMemory());
+  SERIAL_ECHOPGM(MSG_PLANNER_BUFFER_BYTES);
+  SERIAL_ECHOLN((int)sizeof(block_t)*BLOCK_BUFFER_SIZE);
+  for(int8_t i = 0; i < BUFSIZE; i++)
+  {
+    fromsd[i] = false;
+  }
+  
+  Config_RetrieveSettings(); // loads data from EEPROM if available
+
+  for(int8_t i=0; i < NUM_AXIS; i++)
+  {
+    axis_steps_per_sqr_second[i] = max_acceleration_units_per_sq_second[i] * axis_steps_per_unit[i];
+  }
+
+
+  tp_init();    // Initialize temperature loop 
+  plan_init();  // Initialize planner;
+  watchdog_init();
+  st_init();    // Initialize stepper, this enables interrupts!
+  setup_photpin();
+  
+  LCD_INIT;
+}
+
+
+void loop()
+{
+  if(buflen < (BUFSIZE-1))
+    get_command();
+  #ifdef SDSUPPORT
+  card.checkautostart(false);
+  #endif
+  if(buflen)
+  {
+    #ifdef SDSUPPORT
+      if(card.saving)
+      {
+	if(strstr(cmdbuffer[bufindr],"M29") == NULL)
+	{
+	  card.write_command(cmdbuffer[bufindr]);
+	  SERIAL_PROTOCOLLNPGM(MSG_OK);
+	}
+	else
+	{
+	  card.closefile();
+	  SERIAL_PROTOCOLLNPGM(MSG_FILE_SAVED);
+	}
+      }
+      else
+      {
+	process_commands();
+      }
+    #else
+      process_commands();
+    #endif //SDSUPPORT
+    buflen = (buflen-1);
+    bufindr = (bufindr + 1)%BUFSIZE;
+  }
+  //check heater every n milliseconds
+  manage_heater();
+  manage_inactivity();
+  checkHitEndstops();
+  LCD_STATUS;
+}
+
+void get_command() 
+{ 
+  while( MYSERIAL.available() > 0  && buflen < BUFSIZE) {
+    serial_char = MYSERIAL.read();
+    if(serial_char == '\n' || 
+       serial_char == '\r' || 
+       (serial_char == ':' && comment_mode == false) || 
+       serial_count >= (MAX_CMD_SIZE - 1) ) 
+    {
+      if(!serial_count) { //if empty line
+        comment_mode = false; //for new command
+        return;
+      }
+      cmdbuffer[bufindw][serial_count] = 0; //terminate string
+      if(!comment_mode){
+        comment_mode = false; //for new command
+        fromsd[bufindw] = false;
+        if(strstr(cmdbuffer[bufindw], "N") != NULL)
+        {
+          strchr_pointer = strchr(cmdbuffer[bufindw], 'N');
+          gcode_N = (strtol(&cmdbuffer[bufindw][strchr_pointer - cmdbuffer[bufindw] + 1], NULL, 10));
+          if(gcode_N != gcode_LastN+1 && (strstr(cmdbuffer[bufindw], "M110") == NULL) ) {
+            SERIAL_ERROR_START;
+            SERIAL_ERRORPGM(MSG_ERR_LINE_NO);
+            SERIAL_ERRORLN(gcode_LastN);
+            //Serial.println(gcode_N);
+            FlushSerialRequestResend();
+            serial_count = 0;
+            return;
+          }
+
+          if(strstr(cmdbuffer[bufindw], "*") != NULL)
+          {
+            byte checksum = 0;
+            byte count = 0;
+            while(cmdbuffer[bufindw][count] != '*') checksum = checksum^cmdbuffer[bufindw][count++];
+            strchr_pointer = strchr(cmdbuffer[bufindw], '*');
+
+            if( (int)(strtod(&cmdbuffer[bufindw][strchr_pointer - cmdbuffer[bufindw] + 1], NULL)) != checksum) {
+              SERIAL_ERROR_START;
+              SERIAL_ERRORPGM(MSG_ERR_CHECKSUM_MISMATCH);
+              SERIAL_ERRORLN(gcode_LastN);
+              FlushSerialRequestResend();
+              serial_count = 0;
+              return;
+            }
+            //if no errors, continue parsing
+          }
+          else 
+          {
+            SERIAL_ERROR_START;
+            SERIAL_ERRORPGM(MSG_ERR_NO_CHECKSUM);
+            SERIAL_ERRORLN(gcode_LastN);
+            FlushSerialRequestResend();
+            serial_count = 0;
+            return;
+          }
+
+          gcode_LastN = gcode_N;
+          //if no errors, continue parsing
+        }
+        else  // if we don't receive 'N' but still see '*'
+        {
+          if((strstr(cmdbuffer[bufindw], "*") != NULL))
+          {
+            SERIAL_ERROR_START;
+            SERIAL_ERRORPGM(MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM);
+            SERIAL_ERRORLN(gcode_LastN);
+            serial_count = 0;
+            return;
+          }
+        }
+        if((strstr(cmdbuffer[bufindw], "G") != NULL)){
+          strchr_pointer = strchr(cmdbuffer[bufindw], 'G');
+          switch((int)((strtod(&cmdbuffer[bufindw][strchr_pointer - cmdbuffer[bufindw] + 1], NULL)))){
+          case 0:
+          case 1:
+          case 2:
+          case 3:
+            if(Stopped == false) { // If printer is stopped by an error the G[0-3] codes are ignored.
+	      #ifdef SDSUPPORT
+              if(card.saving)
+                break;
+	      #endif //SDSUPPORT
+              SERIAL_PROTOCOLLNPGM(MSG_OK); 
+            }
+            else {
+              SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
+              LCD_MESSAGEPGM(MSG_STOPPED);
+            }
+            break;
+          default:
+            break;
+          }
+
+        }
+        bufindw = (bufindw + 1)%BUFSIZE;
+        buflen += 1;
+      }
+      serial_count = 0; //clear buffer
+    }
+    else
+    {
+      if(serial_char == ';') comment_mode = true;
+      if(!comment_mode) cmdbuffer[bufindw][serial_count++] = serial_char;
+    }
+  }
+  #ifdef SDSUPPORT
+  if(!card.sdprinting || serial_count!=0){
+    return;
+  }
+  while( !card.eof()  && buflen < BUFSIZE) {
+    int16_t n=card.get();
+    serial_char = (char)n;
+    if(serial_char == '\n' || 
+       serial_char == '\r' || 
+       (serial_char == ':' && comment_mode == false) || 
+       serial_count >= (MAX_CMD_SIZE - 1)||n==-1) 
+    {
+      if(card.eof()){
+        SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);
+        stoptime=millis();
+        char time[30];
+        unsigned long t=(stoptime-starttime)/1000;
+        int sec,min;
+        min=t/60;
+        sec=t%60;
+        sprintf(time,"%i min, %i sec",min,sec);
+        SERIAL_ECHO_START;
+        SERIAL_ECHOLN(time);
+        LCD_MESSAGE(time);
+        card.printingHasFinished();
+        card.checkautostart(true);
+        
+      }
+      if(!serial_count)
+      {
+        comment_mode = false; //for new command
+        return; //if empty line
+      }
+      cmdbuffer[bufindw][serial_count] = 0; //terminate string
+//      if(!comment_mode){
+        fromsd[bufindw] = true;
+        buflen += 1;
+        bufindw = (bufindw + 1)%BUFSIZE;
+//      }     
+      comment_mode = false; //for new command
+      serial_count = 0; //clear buffer
+    }
+    else
+    {
+      if(serial_char == ';') comment_mode = true;
+      if(!comment_mode) cmdbuffer[bufindw][serial_count++] = serial_char;
+    }
+  }
+  
+  #endif //SDSUPPORT
+
+}
+
+
+float code_value() 
+{ 
+  return (strtod(&cmdbuffer[bufindr][strchr_pointer - cmdbuffer[bufindr] + 1], NULL)); 
+}
+
+long code_value_long() 
+{ 
+  return (strtol(&cmdbuffer[bufindr][strchr_pointer - cmdbuffer[bufindr] + 1], NULL, 10)); 
+}
+
+bool code_seen(char code_string[]) //Return True if the string was found
+{ 
+  return (strstr(cmdbuffer[bufindr], code_string) != NULL); 
+}  
+
+bool code_seen(char code)
+{
+  strchr_pointer = strchr(cmdbuffer[bufindr], code);
+  return (strchr_pointer != NULL);  //Return True if a character was found
+}
+
+#define DEFINE_PGM_READ_ANY(type, reader)		\
+    static inline type pgm_read_any(const type *p)	\
+	{ return pgm_read_##reader##_near(p); }
+
+DEFINE_PGM_READ_ANY(float,       float);
+DEFINE_PGM_READ_ANY(signed char, byte);
+
+#define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG)	\
+static const PROGMEM type array##_P[3] =		\
+    { X_##CONFIG, Y_##CONFIG, Z_##CONFIG };		\
+static inline type array(int axis)			\
+    { return pgm_read_any(&array##_P[axis]); }
+
+XYZ_CONSTS_FROM_CONFIG(float, base_min_pos,    MIN_POS);
+XYZ_CONSTS_FROM_CONFIG(float, base_max_pos,    MAX_POS);
+XYZ_CONSTS_FROM_CONFIG(float, base_home_pos,   HOME_POS);
+XYZ_CONSTS_FROM_CONFIG(float, max_length,      MAX_LENGTH);
+XYZ_CONSTS_FROM_CONFIG(float, home_retract_mm, HOME_RETRACT_MM);
+XYZ_CONSTS_FROM_CONFIG(signed char, home_dir,  HOME_DIR);
+
+static void axis_is_at_home(int axis) {
+  current_position[axis] = base_home_pos(axis) + add_homeing[axis];
+  min_pos[axis] =          base_min_pos(axis) + add_homeing[axis];
+  max_pos[axis] =          base_max_pos(axis) + add_homeing[axis];
+}
+
+static void homeaxis(int axis) {
+#define HOMEAXIS_DO(LETTER) \
+  ((LETTER##_MIN_PIN > -1 && LETTER##_HOME_DIR==-1) || (LETTER##_MAX_PIN > -1 && LETTER##_HOME_DIR==1))
+
+  if (axis==X_AXIS ? HOMEAXIS_DO(X) :
+      axis==Y_AXIS ? HOMEAXIS_DO(Y) :
+      axis==Z_AXIS ? HOMEAXIS_DO(Z) :
+      0) {
+    current_position[axis] = 0;
+    plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+    destination[axis] = 1.5 * max_length(axis) * home_dir(axis);
+    feedrate = homing_feedrate[axis];
+    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
+    st_synchronize();
+   
+    current_position[axis] = 0;
+    plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+    destination[axis] = -home_retract_mm(axis) * home_dir(axis);
+    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
+    st_synchronize();
+   
+    destination[axis] = 2*home_retract_mm(axis) * home_dir(axis);
+    feedrate = homing_feedrate[axis]/2 ; 
+    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
+    st_synchronize();
+   
+    axis_is_at_home(axis);					
+    destination[axis] = current_position[axis];
+    feedrate = 0.0;
+    endstops_hit_on_purpose();
+  }
+}
+#define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)
+
+void process_commands()
+{
+  unsigned long codenum; //throw away variable
+  char *starpos = NULL;
+
+  if(code_seen('G'))
+  {
+    switch((int)code_value())
+    {
+    case 0: // G0 -> G1
+    case 1: // G1
+      if(Stopped == false) {
+        get_coordinates(); // For X Y Z E F
+        prepare_move();
+        //ClearToSend();
+        return;
+      }
+      //break;
+    case 2: // G2  - CW ARC
+      if(Stopped == false) {
+        get_arc_coordinates();
+        prepare_arc_move(true);
+        return;
+      }
+    case 3: // G3  - CCW ARC
+      if(Stopped == false) {
+        get_arc_coordinates();
+        prepare_arc_move(false);
+        return;
+      }
+    case 4: // G4 dwell
+      LCD_MESSAGEPGM(MSG_DWELL);
+      codenum = 0;
+      if(code_seen('P')) codenum = code_value(); // milliseconds to wait
+      if(code_seen('S')) codenum = code_value() * 1000; // seconds to wait
+      
+      st_synchronize();
+      codenum += millis();  // keep track of when we started waiting
+      previous_millis_cmd = millis();
+      while(millis()  < codenum ){
+        manage_heater();
+        manage_inactivity();
+        LCD_STATUS;
+      }
+      break;
+      #ifdef FWRETRACT  
+      case 10: // G10 retract
+      if(!retracted) 
+      {
+        destination[X_AXIS]=current_position[X_AXIS];
+        destination[Y_AXIS]=current_position[Y_AXIS];
+        destination[Z_AXIS]=current_position[Z_AXIS]; 
+        current_position[Z_AXIS]+=-retract_zlift;
+        destination[E_AXIS]=current_position[E_AXIS]-retract_length; 
+        feedrate=retract_feedrate;
+        retracted=true;
+        prepare_move();
+      }
+      
+      break;
+      case 11: // G10 retract_recover
+      if(!retracted) 
+      {
+        destination[X_AXIS]=current_position[X_AXIS];
+        destination[Y_AXIS]=current_position[Y_AXIS];
+        destination[Z_AXIS]=current_position[Z_AXIS]; 
+        
+        current_position[Z_AXIS]+=retract_zlift;
+        current_position[E_AXIS]+=-retract_recover_length; 
+        feedrate=retract_recover_feedrate;
+        retracted=false;
+        prepare_move();
+      }
+      break;
+      #endif //FWRETRACT
+    case 28: //G28 Home all Axis one at a time
+      saved_feedrate = feedrate;
+      saved_feedmultiply = feedmultiply;
+      feedmultiply = 100;
+      previous_millis_cmd = millis();
+      
+      enable_endstops(true);
+      
+      for(int8_t i=0; i < NUM_AXIS; i++) {
+        destination[i] = current_position[i];
+      }
+      feedrate = 0.0;
+      home_all_axis = !((code_seen(axis_codes[0])) || (code_seen(axis_codes[1])) || (code_seen(axis_codes[2])));
+      
+      #if Z_HOME_DIR > 0                      // If homing away from BED do Z first
+      if((home_all_axis) || (code_seen(axis_codes[Z_AXIS]))) {
+        HOMEAXIS(Z);
+      }
+      #endif
+      
+      #ifdef QUICK_HOME
+      if((home_all_axis)||( code_seen(axis_codes[X_AXIS]) && code_seen(axis_codes[Y_AXIS])) )  //first diagonal move
+      {
+        current_position[X_AXIS] = 0;current_position[Y_AXIS] = 0;  
+
+        plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]); 
+        destination[X_AXIS] = 1.5 * X_MAX_LENGTH * X_HOME_DIR;destination[Y_AXIS] = 1.5 * Y_MAX_LENGTH * Y_HOME_DIR;  
+        feedrate = homing_feedrate[X_AXIS]; 
+        if(homing_feedrate[Y_AXIS]<feedrate)
+          feedrate =homing_feedrate[Y_AXIS]; 
+        plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
+        st_synchronize();
+    
+        axis_is_at_home(X_AXIS);
+        axis_is_at_home(Y_AXIS);
+        plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+        destination[X_AXIS] = current_position[X_AXIS];
+        destination[Y_AXIS] = current_position[Y_AXIS];
+        plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
+        feedrate = 0.0;
+        st_synchronize();
+        endstops_hit_on_purpose();
+      }
+      #endif
+      
+      if((home_all_axis) || (code_seen(axis_codes[X_AXIS]))) 
+      {
+        HOMEAXIS(X);
+      }
+
+      if((home_all_axis) || (code_seen(axis_codes[Y_AXIS]))) {
+        HOMEAXIS(Y);
+      }
+      
+      #if Z_HOME_DIR < 0                      // If homing towards BED do Z last
+      if((home_all_axis) || (code_seen(axis_codes[Z_AXIS]))) {
+        HOMEAXIS(Z);
+      }
+      #endif
+      
+      if(code_seen(axis_codes[X_AXIS])) 
+      {
+        if(code_value_long() != 0) {
+          current_position[X_AXIS]=code_value()+add_homeing[0];
+        }
+      }
+
+      if(code_seen(axis_codes[Y_AXIS])) {
+        if(code_value_long() != 0) {
+          current_position[Y_AXIS]=code_value()+add_homeing[1];
+        }
+      }
+
+      if(code_seen(axis_codes[Z_AXIS])) {
+        if(code_value_long() != 0) {
+          current_position[Z_AXIS]=code_value()+add_homeing[2];
+        }
+      }
+      plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+      
+      #ifdef ENDSTOPS_ONLY_FOR_HOMING
+        enable_endstops(false);
+      #endif
+      
+      feedrate = saved_feedrate;
+      feedmultiply = saved_feedmultiply;
+      previous_millis_cmd = millis();
+      endstops_hit_on_purpose();
+      break;
+    case 90: // G90
+      relative_mode = false;
+      break;
+    case 91: // G91
+      relative_mode = true;
+      break;
+    case 92: // G92
+      if(!code_seen(axis_codes[E_AXIS]))
+        st_synchronize();
+      for(int8_t i=0; i < NUM_AXIS; i++) {
+        if(code_seen(axis_codes[i])) { 
+           if(i == E_AXIS) {
+             current_position[i] = code_value();  
+             plan_set_e_position(current_position[E_AXIS]);
+           }
+           else {
+             current_position[i] = code_value()+add_homeing[i];  
+             plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+           }
+        }
+      }
+      break;
+    }
+  }
+
+  else if(code_seen('M'))
+  {
+    switch( (int)code_value() ) 
+    {
+#ifdef ULTRA_LCD
+    case 0: // M0 - Unconditional stop - Wait for user button press on LCD
+    case 1: // M1 - Conditional stop - Wait for user button press on LCD
+    {
+      LCD_MESSAGEPGM(MSG_USERWAIT);
+      codenum = 0;
+      if(code_seen('P')) codenum = code_value(); // milliseconds to wait
+      if(code_seen('S')) codenum = code_value() * 1000; // seconds to wait
+      
+      st_synchronize();
+      previous_millis_cmd = millis();
+      if (codenum > 0){
+        codenum += millis();  // keep track of when we started waiting
+        while(millis()  < codenum && !CLICKED){
+          manage_heater();
+          manage_inactivity();
+          LCD_STATUS;
+        }
+      }else{
+        while(!CLICKED){
+          manage_heater();
+          manage_inactivity();
+          LCD_STATUS;
+        }
+      }
+    }
+    break;
+#endif
+    case 17:
+        LCD_MESSAGEPGM(MSG_NO_MOVE);
+        enable_x(); 
+        enable_y(); 
+        enable_z(); 
+        enable_e0(); 
+        enable_e1(); 
+        enable_e2(); 
+      break;
+
+#ifdef SDSUPPORT
+    case 20: // M20 - list SD card
+      SERIAL_PROTOCOLLNPGM(MSG_BEGIN_FILE_LIST);
+      card.ls();
+      SERIAL_PROTOCOLLNPGM(MSG_END_FILE_LIST);
+      break;
+    case 21: // M21 - init SD card
+      
+      card.initsd();
+      
+      break;
+    case 22: //M22 - release SD card
+      card.release();
+
+      break;
+    case 23: //M23 - Select file
+      starpos = (strchr(strchr_pointer + 4,'*'));
+      if(starpos!=NULL)
+        *(starpos-1)='\0';
+      card.openFile(strchr_pointer + 4,true);
+      break;
+    case 24: //M24 - Start SD print
+      card.startFileprint();
+      starttime=millis();
+      break;
+    case 25: //M25 - Pause SD print
+      card.pauseSDPrint();
+      break;
+    case 26: //M26 - Set SD index
+      if(card.cardOK && code_seen('S')) {
+        card.setIndex(code_value_long());
+      }
+      break;
+    case 27: //M27 - Get SD status
+      card.getStatus();
+      break;
+    case 28: //M28 - Start SD write
+      starpos = (strchr(strchr_pointer + 4,'*'));
+      if(starpos != NULL){
+        char* npos = strchr(cmdbuffer[bufindr], 'N');
+        strchr_pointer = strchr(npos,' ') + 1;
+        *(starpos-1) = '\0';
+      }
+      card.openFile(strchr_pointer+4,false);
+      break;
+    case 29: //M29 - Stop SD write
+      //processed in write to file routine above
+      //card,saving = false;
+      break;
+    case 30: //M30 <filename> Delete File 
+	if (card.cardOK){
+		card.closefile();
+		starpos = (strchr(strchr_pointer + 4,'*'));
+                if(starpos != NULL){
+                char* npos = strchr(cmdbuffer[bufindr], 'N');
+                strchr_pointer = strchr(npos,' ') + 1;
+                *(starpos-1) = '\0';
+         }
+	 card.removeFile(strchr_pointer + 4);
+	}
+	break;
+	
+#endif //SDSUPPORT
+
+    case 31: //M31 take time since the start of the SD print or an M109 command
+      {
+      stoptime=millis();
+      char time[30];
+      unsigned long t=(stoptime-starttime)/1000;
+      int sec,min;
+      min=t/60;
+      sec=t%60;
+      sprintf(time,"%i min, %i sec",min,sec);
+      SERIAL_ECHO_START;
+      SERIAL_ECHOLN(time);
+      LCD_MESSAGE(time);
+      autotempShutdown();
+      }
+      break;
+    case 42: //M42 -Change pin status via gcode
+      if (code_seen('S'))
+      {
+        int pin_status = code_value();
+        if (code_seen('P') && pin_status >= 0 && pin_status <= 255)
+        {
+          int pin_number = code_value();
+          for(int8_t i = 0; i < (int8_t)sizeof(sensitive_pins); i++)
+          {
+            if (sensitive_pins[i] == pin_number)
+            {
+              pin_number = -1;
+              break;
+            }
+          }
+          
+          if (pin_number > -1)
+          {              
+            pinMode(pin_number, OUTPUT);
+            digitalWrite(pin_number, pin_status);
+            analogWrite(pin_number, pin_status);
+          }
+        }
+      }
+     break;
+    case 104: // M104
+      if(setTargetedHotend(104)){
+        break;
+      }
+      if (code_seen('S')) setTargetHotend(code_value(), tmp_extruder);
+      setWatch();
+      break;
+    case 140: // M140 set bed temp
+      if (code_seen('S')) setTargetBed(code_value());
+      break;
+    case 105 : // M105
+      if(setTargetedHotend(105)){
+        break;
+      }
+      #if (TEMP_0_PIN > -1)
+        SERIAL_PROTOCOLPGM("ok T:");
+        SERIAL_PROTOCOL_F(degHotend(tmp_extruder),1); 
+        SERIAL_PROTOCOLPGM(" /");
+        SERIAL_PROTOCOL_F(degTargetHotend(tmp_extruder),1); 
+        #if TEMP_BED_PIN > -1
+          SERIAL_PROTOCOLPGM(" B:");  
+          SERIAL_PROTOCOL_F(degBed(),1);
+          SERIAL_PROTOCOLPGM(" /");
+          SERIAL_PROTOCOL_F(degTargetBed(),1);
+        #endif //TEMP_BED_PIN
+      #else
+        SERIAL_ERROR_START;
+        SERIAL_ERRORLNPGM(MSG_ERR_NO_THERMISTORS);
+      #endif
+
+        SERIAL_PROTOCOLPGM(" @:");
+        SERIAL_PROTOCOL(getHeaterPower(tmp_extruder));  
+
+        SERIAL_PROTOCOLPGM(" B@:");
+        SERIAL_PROTOCOL(getHeaterPower(-1));  
+
+        SERIAL_PROTOCOLLN("");
+      return;
+      break;
+    case 109: 
+    {// M109 - Wait for extruder heater to reach target.
+      if(setTargetedHotend(109)){
+        break;
+      }
+      LCD_MESSAGEPGM(MSG_HEATING);   
+      #ifdef AUTOTEMP
+        autotemp_enabled=false;
+      #endif
+      if (code_seen('S')) setTargetHotend(code_value(), tmp_extruder);
+      #ifdef AUTOTEMP
+        if (code_seen('S')) autotemp_min=code_value();
+        if (code_seen('B')) autotemp_max=code_value();
+        if (code_seen('F')) 
+        {
+          autotemp_factor=code_value();
+          autotemp_enabled=true;
+        }
+      #endif
+      
+      setWatch();
+      codenum = millis(); 
+
+      /* See if we are heating up or cooling down */
+      bool target_direction = isHeatingHotend(tmp_extruder); // true if heating, false if cooling
+
+      #ifdef TEMP_RESIDENCY_TIME
+        long residencyStart;
+        residencyStart = -1;
+        /* continue to loop until we have reached the target temp   
+          _and_ until TEMP_RESIDENCY_TIME hasn't passed since we reached it */
+        while((residencyStart == -1) ||
+              (residencyStart >= 0 && (((unsigned int) (millis() - residencyStart)) < (TEMP_RESIDENCY_TIME * 1000UL))) ) {
+      #else
+        while ( target_direction ? (isHeatingHotend(tmp_extruder)) : (isCoolingHotend(tmp_extruder)&&(CooldownNoWait==false)) ) {
+      #endif //TEMP_RESIDENCY_TIME
+          if( (millis() - codenum) > 1000UL )
+          { //Print Temp Reading and remaining time every 1 second while heating up/cooling down
+            SERIAL_PROTOCOLPGM("T:");
+            SERIAL_PROTOCOL_F(degHotend(tmp_extruder),1); 
+            SERIAL_PROTOCOLPGM(" E:");
+            SERIAL_PROTOCOL((int)tmp_extruder); 
+            #ifdef TEMP_RESIDENCY_TIME
+              SERIAL_PROTOCOLPGM(" W:");
+              if(residencyStart > -1)
+              {
+                 codenum = ((TEMP_RESIDENCY_TIME * 1000UL) - (millis() - residencyStart)) / 1000UL;
+                 SERIAL_PROTOCOLLN( codenum );
+              }
+              else 
+              {
+                 SERIAL_PROTOCOLLN( "?" );
+              }
+            #else
+              SERIAL_PROTOCOLLN("");
+            #endif
+            codenum = millis();
+          }
+          manage_heater();
+          manage_inactivity();
+          LCD_STATUS;
+        #ifdef TEMP_RESIDENCY_TIME
+            /* start/restart the TEMP_RESIDENCY_TIME timer whenever we reach target temp for the first time
+              or when current temp falls outside the hysteresis after target temp was reached */
+          if ((residencyStart == -1 &&  target_direction && (degHotend(tmp_extruder) >= (degTargetHotend(tmp_extruder)-TEMP_WINDOW))) ||
+              (residencyStart == -1 && !target_direction && (degHotend(tmp_extruder) <= (degTargetHotend(tmp_extruder)+TEMP_WINDOW))) ||
+              (residencyStart > -1 && labs(degHotend(tmp_extruder) - degTargetHotend(tmp_extruder)) > TEMP_HYSTERESIS) ) 
+          {
+            residencyStart = millis();
+          }
+        #endif //TEMP_RESIDENCY_TIME
+        }
+        LCD_MESSAGEPGM(MSG_HEATING_COMPLETE);
+        starttime=millis();
+        previous_millis_cmd = millis();
+      }
+      break;
+    case 190: // M190 - Wait for bed heater to reach target.
+    #if TEMP_BED_PIN > -1
+        LCD_MESSAGEPGM(MSG_BED_HEATING);
+        if (code_seen('S')) setTargetBed(code_value());
+        codenum = millis(); 
+        while(isHeatingBed()) 
+        {
+          if(( millis() - codenum) > 1000 ) //Print Temp Reading every 1 second while heating up.
+          {
+            float tt=degHotend(active_extruder);
+            SERIAL_PROTOCOLPGM("T:");
+            SERIAL_PROTOCOL(tt);
+            SERIAL_PROTOCOLPGM(" E:");
+            SERIAL_PROTOCOL((int)active_extruder); 
+            SERIAL_PROTOCOLPGM(" B:");
+            SERIAL_PROTOCOL_F(degBed(),1); 
+            SERIAL_PROTOCOLLN(""); 
+            codenum = millis(); 
+          }
+          manage_heater();
+          manage_inactivity();
+          LCD_STATUS;
+        }
+        LCD_MESSAGEPGM(MSG_BED_DONE);
+        previous_millis_cmd = millis();
+    #endif
+        break;
+
+    #if FAN_PIN > -1
+      case 106: //M106 Fan On
+        if (code_seen('S')){
+           FanSpeed=constrain(code_value(),0,255);
+        }
+        else {
+          FanSpeed=255;			
+        }
+        break;
+      case 107: //M107 Fan Off
+        FanSpeed = 0;
+        break;
+    #endif //FAN_PIN
+
+    #if (PS_ON_PIN > -1)
+      case 80: // M80 - ATX Power On
+        SET_OUTPUT(PS_ON_PIN); //GND
+        WRITE(PS_ON_PIN, LOW);
+        break;
+      #endif
+      
+      case 81: // M81 - ATX Power Off
+      
+      #if defined SUICIDE_PIN && SUICIDE_PIN > -1
+        st_synchronize();
+        suicide();
+      #elif (PS_ON_PIN > -1)
+        SET_OUTPUT(PS_ON_PIN); 
+        WRITE(PS_ON_PIN, HIGH);
+      #endif
+		break;
+        
+    case 82:
+      axis_relative_modes[3] = false;
+      break;
+    case 83:
+      axis_relative_modes[3] = true;
+      break;
+    case 18: //compatibility
+    case 84: // M84
+      if(code_seen('S')){ 
+        stepper_inactive_time = code_value() * 1000; 
+      }
+      else
+      { 
+        bool all_axis = !((code_seen(axis_codes[0])) || (code_seen(axis_codes[1])) || (code_seen(axis_codes[2]))|| (code_seen(axis_codes[3])));
+        if(all_axis)
+        {
+          st_synchronize();
+          disable_e0();
+          disable_e1();
+          disable_e2();
+          finishAndDisableSteppers();
+        }
+        else
+        {
+          st_synchronize();
+          if(code_seen('X')) disable_x();
+          if(code_seen('Y')) disable_y();
+          if(code_seen('Z')) disable_z();
+          #if ((E0_ENABLE_PIN != X_ENABLE_PIN) && (E1_ENABLE_PIN != Y_ENABLE_PIN)) // Only enable on boards that have seperate ENABLE_PINS
+            if(code_seen('E')) {
+              disable_e0();
+              disable_e1();
+              disable_e2();
+            }
+          #endif 
+          LCD_MESSAGEPGM(MSG_PART_RELEASE);
+        }
+      }
+      break;
+    case 85: // M85
+      code_seen('S');
+      max_inactive_time = code_value() * 1000; 
+      break;
+    case 92: // M92
+      for(int8_t i=0; i < NUM_AXIS; i++) 
+      {
+        if(code_seen(axis_codes[i])) 
+        {
+          if(i == 3) { // E
+            float value = code_value();
+            if(value < 20.0) {
+              float factor = axis_steps_per_unit[i] / value; // increase e constants if M92 E14 is given for netfab.
+              max_e_jerk *= factor;
+              max_feedrate[i] *= factor;
+              axis_steps_per_sqr_second[i] *= factor;
+            }
+            axis_steps_per_unit[i] = value;
+          }
+          else {
+            axis_steps_per_unit[i] = code_value();
+          }
+        }
+      }
+      break;
+    case 115: // M115
+      SERIAL_PROTOCOLPGM(MSG_M115_REPORT);
+      break;
+    case 117: // M117 display message
+      LCD_MESSAGE(cmdbuffer[bufindr]+5);
+      break;
+    case 114: // M114
+      SERIAL_PROTOCOLPGM("X:");
+      SERIAL_PROTOCOL(current_position[X_AXIS]);
+      SERIAL_PROTOCOLPGM("Y:");
+      SERIAL_PROTOCOL(current_position[Y_AXIS]);
+      SERIAL_PROTOCOLPGM("Z:");
+      SERIAL_PROTOCOL(current_position[Z_AXIS]);
+      SERIAL_PROTOCOLPGM("E:");      
+      SERIAL_PROTOCOL(current_position[E_AXIS]);
+      
+      SERIAL_PROTOCOLPGM(MSG_COUNT_X);
+      SERIAL_PROTOCOL(float(st_get_position(X_AXIS))/axis_steps_per_unit[X_AXIS]);
+      SERIAL_PROTOCOLPGM("Y:");
+      SERIAL_PROTOCOL(float(st_get_position(Y_AXIS))/axis_steps_per_unit[Y_AXIS]);
+      SERIAL_PROTOCOLPGM("Z:");
+      SERIAL_PROTOCOL(float(st_get_position(Z_AXIS))/axis_steps_per_unit[Z_AXIS]);
+      
+      SERIAL_PROTOCOLLN("");
+      break;
+    case 120: // M120
+      enable_endstops(false) ;
+      break;
+    case 121: // M121
+      enable_endstops(true) ;
+      break;
+    case 119: // M119
+    SERIAL_PROTOCOLLN(MSG_M119_REPORT);
+      #if (X_MIN_PIN > -1)
+        SERIAL_PROTOCOLPGM(MSG_X_MIN);
+        SERIAL_PROTOCOLLN(((READ(X_MIN_PIN)^X_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
+      #endif
+      #if (X_MAX_PIN > -1)
+        SERIAL_PROTOCOLPGM(MSG_X_MAX);
+        SERIAL_PROTOCOLLN(((READ(X_MAX_PIN)^X_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
+      #endif
+      #if (Y_MIN_PIN > -1)
+        SERIAL_PROTOCOLPGM(MSG_Y_MIN);
+        SERIAL_PROTOCOLLN(((READ(Y_MIN_PIN)^Y_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
+      #endif
+      #if (Y_MAX_PIN > -1)
+        SERIAL_PROTOCOLPGM(MSG_Y_MAX);
+        SERIAL_PROTOCOLLN(((READ(Y_MAX_PIN)^Y_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
+      #endif
+      #if (Z_MIN_PIN > -1)
+        SERIAL_PROTOCOLPGM(MSG_Z_MIN);
+        SERIAL_PROTOCOLLN(((READ(Z_MIN_PIN)^Z_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
+      #endif
+      #if (Z_MAX_PIN > -1)
+        SERIAL_PROTOCOLPGM(MSG_Z_MAX);
+        SERIAL_PROTOCOLLN(((READ(Z_MAX_PIN)^Z_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
+      #endif
+      break;
+      //TODO: update for all axis, use for loop
+    case 201: // M201
+      for(int8_t i=0; i < NUM_AXIS; i++) 
+      {
+        if(code_seen(axis_codes[i]))
+        {
+          max_acceleration_units_per_sq_second[i] = code_value();
+          axis_steps_per_sqr_second[i] = code_value() * axis_steps_per_unit[i];
+        }
+      }
+      break;
+    #if 0 // Not used for Sprinter/grbl gen6
+    case 202: // M202
+      for(int8_t i=0; i < NUM_AXIS; i++) {
+        if(code_seen(axis_codes[i])) axis_travel_steps_per_sqr_second[i] = code_value() * axis_steps_per_unit[i];
+      }
+      break;
+    #endif
+    case 203: // M203 max feedrate mm/sec
+      for(int8_t i=0; i < NUM_AXIS; i++) {
+        if(code_seen(axis_codes[i])) max_feedrate[i] = code_value();
+      }
+      break;
+    case 204: // M204 acclereration S normal moves T filmanent only moves
+      {
+        if(code_seen('S')) acceleration = code_value() ;
+        if(code_seen('T')) retract_acceleration = code_value() ;
+      }
+      break;
+    case 205: //M205 advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk
+    {
+      if(code_seen('S')) minimumfeedrate = code_value();
+      if(code_seen('T')) mintravelfeedrate = code_value();
+      if(code_seen('B')) minsegmenttime = code_value() ;
+      if(code_seen('X')) max_xy_jerk = code_value() ;
+      if(code_seen('Z')) max_z_jerk = code_value() ;
+      if(code_seen('E')) max_e_jerk = code_value() ;
+    }
+    break;
+    case 206: // M206 additional homeing offset
+      for(int8_t i=0; i < 3; i++) 
+      {
+        if(code_seen(axis_codes[i])) add_homeing[i] = code_value();
+      }
+      break;
+    #ifdef FWRETRACT
+    case 207: //M207 - set retract length S[positive mm] F[feedrate mm/sec] Z[additional zlift/hop]
+    {
+      if(code_seen('S')) 
+      {
+        retract_length = code_value() ;
+      }
+      if(code_seen('F')) 
+      {
+        retract_feedrate = code_value() ;
+      }
+      if(code_seen('Z')) 
+      {
+        retract_zlift = code_value() ;
+      }
+    }break;
+    case 208: // M208 - set retract recover length S[positive mm surplus to the M207 S*] F[feedrate mm/sec]
+    {
+      if(code_seen('S')) 
+      {
+        retract_recover_length = code_value() ;
+      }
+      if(code_seen('F')) 
+      {
+        retract_recover_feedrate = code_value() ;
+      }
+    }break;
+    
+    case 209: // M209 - S<1=true/0=false> enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.
+    {
+      if(code_seen('S')) 
+      {
+        int t= code_value() ;
+        switch(t)
+        {
+          case 0: autoretract_enabled=false;retracted=false;break;
+          case 1: autoretract_enabled=true;retracted=false;break;
+          default: 
+            SERIAL_ECHO_START;
+            SERIAL_ECHOPGM(MSG_UNKNOWN_COMMAND);
+            SERIAL_ECHO(cmdbuffer[bufindr]);
+            SERIAL_ECHOLNPGM("\"");
+        }
+      }
+      
+    }break;
+    #endif
+    case 220: // M220 S<factor in percent>- set speed factor override percentage
+    {
+      if(code_seen('S')) 
+      {
+        feedmultiply = code_value() ;
+        feedmultiplychanged=true;
+      }
+    }
+    break;
+    case 221: // M221 S<factor in percent>- set extrude factor override percentage
+    {
+      if(code_seen('S')) 
+      {
+        extrudemultiply = code_value() ;
+      }
+    }
+    break;
+
+    #ifdef PIDTEMP
+    case 301: // M301
+      {
+        if(code_seen('P')) Kp = code_value();
+        if(code_seen('I')) Ki = code_value()*PID_dT;
+        if(code_seen('D')) Kd = code_value()/PID_dT;
+        #ifdef PID_ADD_EXTRUSION_RATE
+        if(code_seen('C')) Kc = code_value();
+        #endif
+        updatePID();
+        SERIAL_PROTOCOL(MSG_OK);
+		SERIAL_PROTOCOL(" p:");
+        SERIAL_PROTOCOL(Kp);
+        SERIAL_PROTOCOL(" i:");
+        SERIAL_PROTOCOL(Ki/PID_dT);
+        SERIAL_PROTOCOL(" d:");
+        SERIAL_PROTOCOL(Kd*PID_dT);
+        #ifdef PID_ADD_EXTRUSION_RATE
+        SERIAL_PROTOCOL(" c:");
+        SERIAL_PROTOCOL(Kc*PID_dT);
+        #endif
+        SERIAL_PROTOCOLLN("");
+      }
+      break;
+    #endif //PIDTEMP
+    #ifdef PIDTEMPBED
+    case 304: // M304
+      {
+        if(code_seen('P')) bedKp = code_value();
+        if(code_seen('I')) bedKi = code_value()*PID_dT;
+        if(code_seen('D')) bedKd = code_value()/PID_dT;
+        updatePID();
+        SERIAL_PROTOCOL(MSG_OK);
+		SERIAL_PROTOCOL(" p:");
+        SERIAL_PROTOCOL(bedKp);
+        SERIAL_PROTOCOL(" i:");
+        SERIAL_PROTOCOL(bedKi/PID_dT);
+        SERIAL_PROTOCOL(" d:");
+        SERIAL_PROTOCOL(bedKd*PID_dT);
+        SERIAL_PROTOCOLLN("");
+      }
+      break;
+    #endif //PIDTEMP
+    case 240: // M240  Triggers a camera by emulating a Canon RC-1 : http://www.doc-diy.net/photo/rc-1_hacked/
+     {
+      #ifdef PHOTOGRAPH_PIN
+        #if (PHOTOGRAPH_PIN > -1)
+        const uint8_t NUM_PULSES=16;
+        const float PULSE_LENGTH=0.01524;
+        for(int i=0; i < NUM_PULSES; i++) {
+          WRITE(PHOTOGRAPH_PIN, HIGH);
+          _delay_ms(PULSE_LENGTH);
+          WRITE(PHOTOGRAPH_PIN, LOW);
+          _delay_ms(PULSE_LENGTH);
+        }
+        delay(7.33);
+        for(int i=0; i < NUM_PULSES; i++) {
+          WRITE(PHOTOGRAPH_PIN, HIGH);
+          _delay_ms(PULSE_LENGTH);
+          WRITE(PHOTOGRAPH_PIN, LOW);
+          _delay_ms(PULSE_LENGTH);
+        }
+        #endif
+      #endif
+     }
+    break;
+      
+    case 302: // allow cold extrudes
+    {
+      allow_cold_extrudes(true);
+    }
+    break;
+    case 303: // M303 PID autotune
+    {
+      float temp = 150.0;
+      int e=0;
+      int c=5;
+      if (code_seen('E')) e=code_value();
+			if (e<0)
+				temp=70;
+      if (code_seen('S')) temp=code_value();
+      if (code_seen('C')) c=code_value();
+      PID_autotune(temp, e, c);
+    }
+    break;
+    case 400: // M400 finish all moves
+    {
+      st_synchronize();
+    }
+    break;
+    case 500: // Store settings in EEPROM
+    {
+        Config_StoreSettings();
+    }
+    break;
+    case 501: // Read settings from EEPROM
+    {
+        Config_RetrieveSettings();
+    }
+    break;
+    case 502: // Revert to default settings
+    {
+        Config_ResetDefault();
+    }
+    break;
+    case 503: // print settings currently in memory
+    {
+        Config_PrintSettings();
+    }
+    break;
+    case 907: // Set digital trimpot motor current using axis codes.
+    {
+      #if DIGIPOTSS_PIN > -1
+        for(int i=0;i<=NUM_AXIS;i++) if(code_seen(axis_codes[i])) digipot_current(i,code_value());
+        if(code_seen('B')) digipot_current(4,code_value());
+        if(code_seen('S')) for(int i=0;i<=4;i++) digipot_current(i,code_value());
+      #endif
+    }
+    case 908: // Control digital trimpot directly.
+    {
+      #if DIGIPOTSS_PIN > -1
+        uint8_t channel,current;
+        if(code_seen('P')) channel=code_value();
+        if(code_seen('S')) current=code_value();
+        digitalPotWrite(channel, current);
+      #endif
+    }
+    break;
+    case 350: // Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
+    {
+      #if X_MS1_PIN > -1
+        if(code_seen('S')) for(int i=0;i<=4;i++) microstep_mode(i,code_value()); 
+        for(int i=0;i<=NUM_AXIS;i++) if(code_seen(axis_codes[i])) microstep_mode(i,(uint8_t)code_value());
+        if(code_seen('B')) microstep_mode(4,code_value());
+        microstep_readings();
+      #endif
+    }
+    break;
+    case 351: // Toggle MS1 MS2 pins directly, S# determines MS1 or MS2, X# sets the pin high/low.
+    {
+      #if X_MS1_PIN > -1
+      if(code_seen('S')) switch((int)code_value())
+      {
+        case 1:
+          for(int i=0;i<=NUM_AXIS;i++) if(code_seen(axis_codes[i])) microstep_ms(i,code_value(),-1);
+          if(code_seen('B')) microstep_ms(4,code_value(),-1);
+          break;
+        case 2:
+          for(int i=0;i<=NUM_AXIS;i++) if(code_seen(axis_codes[i])) microstep_ms(i,-1,code_value());
+          if(code_seen('B')) microstep_ms(4,-1,code_value());
+          break;
+      }
+      microstep_readings();
+      #endif
+    }
+    break;
+    case 999: // Restart after being stopped
+      Stopped = false;
+      gcode_LastN = Stopped_gcode_LastN;
+      FlushSerialRequestResend();
+    break;
+    }
+  }
+
+  else if(code_seen('T')) 
+  {
+    tmp_extruder = code_value();
+    if(tmp_extruder >= EXTRUDERS) {
+      SERIAL_ECHO_START;
+      SERIAL_ECHO("T");
+      SERIAL_ECHO(tmp_extruder);
+      SERIAL_ECHOLN(MSG_INVALID_EXTRUDER);
+    }
+    else {
+      active_extruder = tmp_extruder;
+      SERIAL_ECHO_START;
+      SERIAL_ECHO(MSG_ACTIVE_EXTRUDER);
+      SERIAL_PROTOCOLLN((int)active_extruder);
+    }
+  }
+
+  else
+  {
+    SERIAL_ECHO_START;
+    SERIAL_ECHOPGM(MSG_UNKNOWN_COMMAND);
+    SERIAL_ECHO(cmdbuffer[bufindr]);
+    SERIAL_ECHOLNPGM("\"");
+  }
+
+  ClearToSend();
+}
+
+void FlushSerialRequestResend()
+{
+  //char cmdbuffer[bufindr][100]="Resend:";
+  MYSERIAL.flush();
+  SERIAL_PROTOCOLPGM(MSG_RESEND);
+  SERIAL_PROTOCOLLN(gcode_LastN + 1);
+  ClearToSend();
+}
+
+void ClearToSend()
+{
+  previous_millis_cmd = millis();
+  #ifdef SDSUPPORT
+  if(fromsd[bufindr])
+    return;
+  #endif //SDSUPPORT
+  SERIAL_PROTOCOLLNPGM(MSG_OK); 
+}
+
+void get_coordinates()
+{
+  bool seen[4]={false,false,false,false};
+  for(int8_t i=0; i < NUM_AXIS; i++) {
+    if(code_seen(axis_codes[i])) 
+    {
+      destination[i] = (float)code_value() + (axis_relative_modes[i] || relative_mode)*current_position[i];
+      seen[i]=true;
+    }
+    else destination[i] = current_position[i]; //Are these else lines really needed?
+  }
+  if(code_seen('F')) {
+    next_feedrate = code_value();
+    if(next_feedrate > 0.0) feedrate = next_feedrate;
+  }
+  #ifdef FWRETRACT
+  if(autoretract_enabled)
+  if( !(seen[X_AXIS] || seen[Y_AXIS] || seen[Z_AXIS]) && seen[E_AXIS])
+  {
+    float echange=destination[E_AXIS]-current_position[E_AXIS];
+    if(echange<-MIN_RETRACT) //retract
+    {
+      if(!retracted) 
+      {
+      
+      destination[Z_AXIS]+=retract_zlift; //not sure why chaninging current_position negatively does not work.
+      //if slicer retracted by echange=-1mm and you want to retract 3mm, corrrectede=-2mm additionally
+      float correctede=-echange-retract_length;
+      //to generate the additional steps, not the destination is changed, but inversely the current position
+      current_position[E_AXIS]+=-correctede; 
+      feedrate=retract_feedrate;
+      retracted=true;
+      }
+      
+    }
+    else 
+      if(echange>MIN_RETRACT) //retract_recover
+    {
+      if(retracted) 
+      {
+      //current_position[Z_AXIS]+=-retract_zlift;
+      //if slicer retracted_recovered by echange=+1mm and you want to retract_recover 3mm, corrrectede=2mm additionally
+      float correctede=-echange+1*retract_length+retract_recover_length; //total unretract=retract_length+retract_recover_length[surplus]
+      current_position[E_AXIS]+=correctede; //to generate the additional steps, not the destination is changed, but inversely the current position
+      feedrate=retract_recover_feedrate;
+      retracted=false;
+      }
+    }
+    
+  }
+  #endif //FWRETRACT
+}
+
+void get_arc_coordinates()
+{
+#ifdef SF_ARC_FIX
+   bool relative_mode_backup = relative_mode;
+   relative_mode = true;
+#endif
+   get_coordinates();
+#ifdef SF_ARC_FIX
+   relative_mode=relative_mode_backup;
+#endif
+
+   if(code_seen('I')) {
+     offset[0] = code_value();
+   } 
+   else {
+     offset[0] = 0.0;
+   }
+   if(code_seen('J')) {
+     offset[1] = code_value();
+   }
+   else {
+     offset[1] = 0.0;
+   }
+}
+
+void clamp_to_software_endstops(float target[3])
+{
+  if (min_software_endstops) {
+    if (target[X_AXIS] < min_pos[X_AXIS]) target[X_AXIS] = min_pos[X_AXIS];
+    if (target[Y_AXIS] < min_pos[Y_AXIS]) target[Y_AXIS] = min_pos[Y_AXIS];
+    if (target[Z_AXIS] < min_pos[Z_AXIS]) target[Z_AXIS] = min_pos[Z_AXIS];
+  }
+
+  if (max_software_endstops) {
+    if (target[X_AXIS] > max_pos[X_AXIS]) target[X_AXIS] = max_pos[X_AXIS];
+    if (target[Y_AXIS] > max_pos[Y_AXIS]) target[Y_AXIS] = max_pos[Y_AXIS];
+    if (target[Z_AXIS] > max_pos[Z_AXIS]) target[Z_AXIS] = max_pos[Z_AXIS];
+  }
+}
+
+void prepare_move()
+{
+  clamp_to_software_endstops(destination);
+
+  previous_millis_cmd = millis(); 
+  // Do not use feedmultiply for E or Z only moves
+  if( (current_position[X_AXIS] == destination [X_AXIS]) && (current_position[Y_AXIS] == destination [Y_AXIS])) {
+      plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
+  }
+  else {
+    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate*feedmultiply/60/100.0, active_extruder);
+  }
+  for(int8_t i=0; i < NUM_AXIS; i++) {
+    current_position[i] = destination[i];
+  }
+}
+
+void prepare_arc_move(char isclockwise) {
+  float r = hypot(offset[X_AXIS], offset[Y_AXIS]); // Compute arc radius for mc_arc
+
+  // Trace the arc
+  mc_arc(current_position, destination, offset, X_AXIS, Y_AXIS, Z_AXIS, feedrate*feedmultiply/60/100.0, r, isclockwise, active_extruder);
+  
+  // As far as the parser is concerned, the position is now == target. In reality the
+  // motion control system might still be processing the action and the real tool position
+  // in any intermediate location.
+  for(int8_t i=0; i < NUM_AXIS; i++) {
+    current_position[i] = destination[i];
+  }
+  previous_millis_cmd = millis();
+}
+
+#ifdef CONTROLLERFAN_PIN
+unsigned long lastMotor = 0; //Save the time for when a motor was turned on last
+unsigned long lastMotorCheck = 0;
+
+void controllerFan()
+{
+  if ((millis() - lastMotorCheck) >= 2500) //Not a time critical function, so we only check every 2500ms
+  {
+    lastMotorCheck = millis();
+    
+    if(!READ(X_ENABLE_PIN) || !READ(Y_ENABLE_PIN) || !READ(Z_ENABLE_PIN)
+    #if EXTRUDERS > 2
+       || !READ(E2_ENABLE_PIN)
+    #endif
+    #if EXTRUDER > 1
+       || !READ(E2_ENABLE_PIN)
+    #endif
+       || !READ(E0_ENABLE_PIN)) //If any of the drivers are enabled...    
+    {
+      lastMotor = millis(); //... set time to NOW so the fan will turn on
+    }
+    
+    if ((millis() - lastMotor) >= (CONTROLLERFAN_SEC*1000UL) || lastMotor == 0) //If the last time any driver was enabled, is longer since than CONTROLLERSEC...   
+    {
+      WRITE(CONTROLLERFAN_PIN, LOW); //... turn the fan off
+    }
+    else
+    {
+      WRITE(CONTROLLERFAN_PIN, HIGH); //... turn the fan on
+    }
+  }
+}
+#endif
+
+void manage_inactivity() 
+{ 
+  if( (millis() - previous_millis_cmd) >  max_inactive_time ) 
+    if(max_inactive_time) 
+      kill(); 
+  if(stepper_inactive_time)  {
+    if( (millis() - previous_millis_cmd) >  stepper_inactive_time ) 
+    {
+      if(blocks_queued() == false) {
+        disable_x();
+        disable_y();
+        disable_z();
+        disable_e0();
+        disable_e1();
+        disable_e2();
+      }
+    }
+  }
+  #if( KILL_PIN>-1 )
+    if( 0 == READ(KILL_PIN) )
+      kill();
+  #endif
+  #ifdef CONTROLLERFAN_PIN
+    controllerFan(); //Check if fan should be turned on to cool stepper drivers down
+  #endif
+  #ifdef EXTRUDER_RUNOUT_PREVENT
+    if( (millis() - previous_millis_cmd) >  EXTRUDER_RUNOUT_SECONDS*1000 ) 
+    if(degHotend(active_extruder)>EXTRUDER_RUNOUT_MINTEMP)
+    {
+     bool oldstatus=READ(E0_ENABLE_PIN);
+     enable_e0();
+     float oldepos=current_position[E_AXIS];
+     float oldedes=destination[E_AXIS];
+     plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], 
+                      current_position[E_AXIS]+EXTRUDER_RUNOUT_EXTRUDE*EXTRUDER_RUNOUT_ESTEPS/axis_steps_per_unit[E_AXIS], 
+                      EXTRUDER_RUNOUT_SPEED/60.*EXTRUDER_RUNOUT_ESTEPS/axis_steps_per_unit[E_AXIS], active_extruder);
+     current_position[E_AXIS]=oldepos;
+     destination[E_AXIS]=oldedes;
+     plan_set_e_position(oldepos);
+     previous_millis_cmd=millis();
+     st_synchronize();
+     WRITE(E0_ENABLE_PIN,oldstatus);
+    }
+  #endif
+  check_axes_activity();
+}
+
+void kill()
+{
+  cli(); // Stop interrupts
+  disable_heater();
+
+  disable_x();
+  disable_y();
+  disable_z();
+  disable_e0();
+  disable_e1();
+  disable_e2();
+  
+  if(PS_ON_PIN > -1) pinMode(PS_ON_PIN,INPUT);
+  SERIAL_ERROR_START;
+  SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
+  LCD_ALERTMESSAGEPGM(MSG_KILLED);
+  suicide();
+  while(1) { /* Intentionally left empty */ } // Wait for reset
+}
+
+void Stop()
+{
+  disable_heater();
+  if(Stopped == false) {
+    Stopped = true;
+    Stopped_gcode_LastN = gcode_LastN; // Save last g_code for restart
+    SERIAL_ERROR_START;
+    SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
+    LCD_MESSAGEPGM(MSG_STOPPED);
+  }
+}
+
+bool IsStopped() { return Stopped; };
+
+#ifdef FAST_PWM_FAN
+void setPwmFrequency(uint8_t pin, int val)
+{
+  val &= 0x07;
+  switch(digitalPinToTimer(pin))
+  {
+ 
+    #if defined(TCCR0A)
+    case TIMER0A:
+    case TIMER0B:
+//         TCCR0B &= ~(CS00 | CS01 | CS02);
+//         TCCR0B |= val;
+         break;
+    #endif
+
+    #if defined(TCCR1A)
+    case TIMER1A:
+    case TIMER1B:
+//         TCCR1B &= ~(CS10 | CS11 | CS12);
+//         TCCR1B |= val;
+         break;
+    #endif
+
+    #if defined(TCCR2)
+    case TIMER2:
+    case TIMER2:
+         TCCR2 &= ~(CS10 | CS11 | CS12);
+         TCCR2 |= val;
+         break;
+    #endif
+
+    #if defined(TCCR2A)
+    case TIMER2A:
+    case TIMER2B:
+         TCCR2B &= ~(CS20 | CS21 | CS22);
+         TCCR2B |= val;
+         break;
+    #endif
+
+    #if defined(TCCR3A)
+    case TIMER3A:
+    case TIMER3B:
+    case TIMER3C:
+         TCCR3B &= ~(CS30 | CS31 | CS32);
+         TCCR3B |= val;
+         break;
+    #endif
+
+    #if defined(TCCR4A) 
+    case TIMER4A:
+    case TIMER4B:
+    case TIMER4C:
+         TCCR4B &= ~(CS40 | CS41 | CS42);
+         TCCR4B |= val;
+         break;
+   #endif
+
+    #if defined(TCCR5A) 
+    case TIMER5A:
+    case TIMER5B:
+    case TIMER5C:
+         TCCR5B &= ~(CS50 | CS51 | CS52);
+         TCCR5B |= val;
+         break;
+   #endif
+
+  }
+}
+#endif //FAST_PWM_FAN
+
+bool setTargetedHotend(int code){
+  tmp_extruder = active_extruder;
+  if(code_seen('T')) {
+    tmp_extruder = code_value();
+    if(tmp_extruder >= EXTRUDERS) {
+      SERIAL_ECHO_START;
+      switch(code){
+        case 104:
+          SERIAL_ECHO(MSG_M104_INVALID_EXTRUDER);
+          break;
+        case 105:
+          SERIAL_ECHO(MSG_M105_INVALID_EXTRUDER);
+          break;
+        case 109:
+          SERIAL_ECHO(MSG_M109_INVALID_EXTRUDER);
+          break;
+      }
+      SERIAL_ECHOLN(tmp_extruder);
+      return true;
+    }
+  }
+  return false;
+}
diff --git a/Marlin/Menu Plans.xlsx b/Marlin/Menu Plans.xlsx
new file mode 100644
index 0000000..45a58e4
Binary files /dev/null and b/Marlin/Menu Plans.xlsx differ
diff --git a/Marlin/Sd2Card.cpp b/Marlin/Sd2Card.cpp
index eb38df6..72f5661 100644
--- a/Marlin/Sd2Card.cpp
+++ b/Marlin/Sd2Card.cpp
@@ -42,28 +42,28 @@ static void spiInit(uint8_t spiRate) {
 /** SPI receive a byte */
 static uint8_t spiRec() {
   SPDR = 0XFF;
-  while (!(SPSR & (1 << SPIF)));
+  while (!(SPSR & (1 << SPIF))) { /* Intentionally left empty */ }
   return SPDR;
 }
 //------------------------------------------------------------------------------
 /** SPI read data - only one call so force inline */
 static inline __attribute__((always_inline))
-  void spiRead(uint8_t* buf, uint16_t nbyte) {
+void spiRead(uint8_t* buf, uint16_t nbyte) {
   if (nbyte-- == 0) return;
   SPDR = 0XFF;
   for (uint16_t i = 0; i < nbyte; i++) {
-    while (!(SPSR & (1 << SPIF)));
+    while (!(SPSR & (1 << SPIF))) { /* Intentionally left empty */ }
     buf[i] = SPDR;
     SPDR = 0XFF;
   }
-  while (!(SPSR & (1 << SPIF)));
+  while (!(SPSR & (1 << SPIF))) { /* Intentionally left empty */ }
   buf[nbyte] = SPDR;
 }
 //------------------------------------------------------------------------------
 /** SPI send a byte */
 static void spiSend(uint8_t b) {
   SPDR = b;
-  while (!(SPSR & (1 << SPIF)));
+  while (!(SPSR & (1 << SPIF))) { /* Intentionally left empty */ }
 }
 //------------------------------------------------------------------------------
 /** SPI send block - only one call so force inline */
@@ -71,12 +71,12 @@ static inline __attribute__((always_inline))
   void spiSendBlock(uint8_t token, const uint8_t* buf) {
   SPDR = token;
   for (uint16_t i = 0; i < 512; i += 2) {
-    while (!(SPSR & (1 << SPIF)));
+    while (!(SPSR & (1 << SPIF))) { /* Intentionally left empty */ }
     SPDR = buf[i];
-    while (!(SPSR & (1 << SPIF)));
+    while (!(SPSR & (1 << SPIF))) { /* Intentionally left empty */ }
     SPDR = buf[i + 1];
   }
-  while (!(SPSR & (1 << SPIF)));
+  while (!(SPSR & (1 << SPIF))) { /* Intentionally left empty */ }
 }
 //------------------------------------------------------------------------------
 #else  // SOFTWARE_SPI
@@ -174,7 +174,7 @@ uint8_t Sd2Card::cardCommand(uint8_t cmd, uint32_t arg) {
   if (cmd == CMD12) spiRec();
 
   // wait for response
-  for (uint8_t i = 0; ((status_ = spiRec()) & 0X80) && i != 0XFF; i++);
+  for (uint8_t i = 0; ((status_ = spiRec()) & 0X80) && i != 0XFF; i++) { /* Intentionally left empty */ }
   return status_;
 }
 //------------------------------------------------------------------------------
diff --git a/Marlin/SdFile.cpp b/Marlin/SdFile.cpp
index e9439e3..29f5efa 100644
--- a/Marlin/SdFile.cpp
+++ b/Marlin/SdFile.cpp
@@ -55,13 +55,16 @@ int16_t SdFile::write(const void* buf, uint16_t nbyte) {
  * Use writeError to check for errors.
  */
 #if ARDUINO >= 100
-    size_t SdFile::write(uint8_t b)
+size_t SdFile::write(uint8_t b)
+{
+    return SdBaseFile::write(&b, 1);
+}
 #else
-  void SdFile::write(uint8_t b)
-#endif
+void SdFile::write(uint8_t b)
 {
-  SdBaseFile::write(&b, 1);
+    SdBaseFile::write(&b, 1);
 }
+#endif
 //------------------------------------------------------------------------------
 /** Write a string to a file. Used by the Arduino Print class.
  * \param[in] str Pointer to the string.
@@ -89,4 +92,4 @@ void SdFile::writeln_P(PGM_P str) {
 }
 
 
-#endif
\ No newline at end of file
+#endif
diff --git a/Marlin/cardreader.cpp b/Marlin/cardreader.cpp
index 47a3fd0..bcabe85 100644
--- a/Marlin/cardreader.cpp
+++ b/Marlin/cardreader.cpp
@@ -245,8 +245,10 @@ void CardReader::openFile(char* name,bool read)
           SERIAL_PROTOCOLLNPGM(".");
           return;
         }
-        else
-          ;//SERIAL_ECHOLN("dive ok");
+        else
+        {
+          //SERIAL_ECHOLN("dive ok");
+        }
           
         curDir=&myDir; 
         dirname_start=dirname_end+1;
@@ -339,8 +341,10 @@ void CardReader::removeFile(char* name)
           SERIAL_PROTOCOLLNPGM(".");
           return;
         }
-        else
-          ;//SERIAL_ECHOLN("dive ok");
+        else
+        {
+          //SERIAL_ECHOLN("dive ok");
+        }
           
         curDir=&myDir; 
         dirname_start=dirname_end+1;
diff --git a/Marlin/createTemperatureLookup.py b/Marlin/createTemperatureLookup.py
deleted file mode 100644
index e60a490..0000000
--- a/Marlin/createTemperatureLookup.py
+++ /dev/null
@@ -1,127 +0,0 @@
-#!/usr/bin/python
-#
-# Creates a C code lookup table for doing ADC to temperature conversion
-# on a microcontroller
-# based on: http://hydraraptor.blogspot.com/2007/10/measuring-temperature-easy-way.html
-"""Thermistor Value Lookup Table Generator
-
-Generates lookup to temperature values for use in a microcontroller in C format based on: 
-http://hydraraptor.blogspot.com/2007/10/measuring-temperature-easy-way.html
-
-The main use is for Arduino programs that read data from the circuit board described here:
-http://make.rrrf.org/ts-1.0
-
-Usage: python createTemperatureLookup.py [options]
-
-Options:
-  -h, --help            show this help
-  --r0=...          thermistor rating where # is the ohm rating of the thermistor at t0 (eg: 10K = 10000)
-  --t0=...          thermistor temp rating where # is the temperature in Celsuis to get r0 (from your datasheet)
-  --beta=...            thermistor beta rating. see http://reprap.org/bin/view/Main/MeasuringThermistorBeta
-  --r1=...          R1 rating where # is the ohm rating of R1 (eg: 10K = 10000)
-  --r2=...          R2 rating where # is the ohm rating of R2 (eg: 10K = 10000)
-  --num-temps=...   the number of temperature points to calculate (default: 20)
-  --max-adc=...     the max ADC reading to use.  if you use R1, it limits the top value for the thermistor circuit, and thus the possible range of ADC values
-"""
-
-from math import *
-import sys
-import getopt
-
-class Thermistor:
-    "Class to do the thermistor maths"
-    def __init__(self, r0, t0, beta, r1, r2):
-        self.r0 = r0                        # stated resistance, e.g. 10K
-        self.t0 = t0 + 273.15               # temperature at stated resistance, e.g. 25C
-        self.beta = beta                    # stated beta, e.g. 3500
-        self.vadc = 5.0                     # ADC reference
-        self.vcc = 5.0                      # supply voltage to potential divider
-        self.k = r0 * exp(-beta / self.t0)   # constant part of calculation
-
-        if r1 > 0:
-            self.vs = r1 * self.vcc / (r1 + r2) # effective bias voltage
-            self.rs = r1 * r2 / (r1 + r2)       # effective bias impedance
-        else:
-            self.vs = self.vcc                   # effective bias voltage
-            self.rs = r2                         # effective bias impedance
-
-    def temp(self,adc):
-        "Convert ADC reading into a temperature in Celcius"
-        v = adc * self.vadc / 1024          # convert the 10 bit ADC value to a voltage
-        r = self.rs * v / (self.vs - v)     # resistance of thermistor
-        return (self.beta / log(r / self.k)) - 273.15        # temperature
-
-    def setting(self, t):
-        "Convert a temperature into a ADC value"
-        r = self.r0 * exp(self.beta * (1 / (t + 273.15) - 1 / self.t0)) # resistance of the thermistor
-        v = self.vs * r / (self.rs + r)     # the voltage at the potential divider
-        return round(v / self.vadc * 1024)  # the ADC reading
-
-def main(argv):
-
-    r0 = 10000;
-    t0 = 25;
-    beta = 3947;
-    r1 = 680;
-    r2 = 1600;
-    num_temps = int(20);
-    
-    try:
-        opts, args = getopt.getopt(argv, "h", ["help", "r0=", "t0=", "beta=", "r1=", "r2="])
-    except getopt.GetoptError:
-        usage()
-        sys.exit(2)
-        
-    for opt, arg in opts:
-        if opt in ("-h", "--help"):
-            usage()
-            sys.exit()
-        elif opt == "--r0":
-            r0 = int(arg)
-        elif opt == "--t0":
-            t0 = int(arg)
-        elif opt == "--beta":
-            beta = int(arg)
-        elif opt == "--r1":
-            r1 = int(arg)
-        elif opt == "--r2":
-            r2 = int(arg)
-
-    if r1:
-        max_adc = int(1023 * r1 / (r1 + r2));
-    else:
-        max_adc = 1023
-    increment = int(max_adc/(num_temps-1));
-            
-    t = Thermistor(r0, t0, beta, r1, r2)
-
-    adcs = range(1, max_adc, increment);
-#   adcs = [1, 20, 25, 30, 35, 40, 45, 50, 60, 70, 80, 90, 100, 110, 130, 150, 190, 220,  250, 300]
-    first = 1
-
-    print "// Thermistor lookup table for RepRap Temperature Sensor Boards (http://make.rrrf.org/ts)"
-    print "// Made with createTemperatureLookup.py (http://svn.reprap.org/trunk/reprap/firmware/Arduino/utilities/createTemperatureLookup.py)"
-    print "// ./createTemperatureLookup.py --r0=%s --t0=%s --r1=%s --r2=%s --beta=%s --max-adc=%s" % (r0, t0, r1, r2, beta, max_adc)
-    print "// r0: %s" % (r0)
-    print "// t0: %s" % (t0)
-    print "// r1: %s" % (r1)
-    print "// r2: %s" % (r2)
-    print "// beta: %s" % (beta)
-    print "// max adc: %s" % (max_adc)
-    print "#define NUMTEMPS %s" % (len(adcs))
-    print "short temptable[NUMTEMPS][2] = {"
-
-    counter = 0
-    for adc in adcs:
-        counter = counter +1
-        if counter == len(adcs):
-            print "   {%s, %s}" % (adc, int(t.temp(adc)))
-        else:
-            print "   {%s, %s}," % (adc, int(t.temp(adc)))
-    print "};"
-    
-def usage():
-    print __doc__
-
-if __name__ == "__main__":
-    main(sys.argv[1:])
diff --git a/Marlin/createTemperatureLookupMarlin.py b/Marlin/createTemperatureLookupMarlin.py
new file mode 100644
index 0000000..e09294e
--- /dev/null
+++ b/Marlin/createTemperatureLookupMarlin.py
@@ -0,0 +1,138 @@
+#!/usr/bin/python
+#
+# Creates a C code lookup table for doing ADC to temperature conversion
+# on a microcontroller
+# based on: http://hydraraptor.blogspot.com/2007/10/measuring-temperature-easy-way.html
+"""Thermistor Value Lookup Table Generator
+
+Generates lookup to temperature values for use in a microcontroller in C format based on: 
+http://hydraraptor.blogspot.com/2007/10/measuring-temperature-easy-way.html
+
+The main use is for Arduino programs that read data from the circuit board described here:
+http://make.rrrf.org/ts-1.0
+
+Usage: python createTemperatureLookup.py [options]
+
+Options:
+  -h, --help        show this help
+  --rp=...          pull-up resistor
+  --t0=ttt:rrr      low temperature temperature:resistance point (around 25C)
+  --t1=ttt:rrr      middle temperature temperature:resistance point (around 150C)
+  --t2=ttt:rrr      high temperature temperature:resistance point (around 250C)
+  --num-temps=...   the number of temperature points to calculate (default: 20)
+"""
+
+from math import *
+import sys
+import getopt
+
+class Thermistor:
+    "Class to do the thermistor maths"
+    def __init__(self, rp, t1, r1, t2, r2, t3, r3):
+        t1 = t1 + 273.15               # low temperature (25C)
+        r1 = r1                        # resistance at low temperature
+        t2 = t2 + 273.15               # middle temperature (150C)
+        r2 = r2                        # resistance at middle temperature
+        t3 = t3 + 273.15               # high temperature (250C)
+        r3 = r3                        # resistance at high temperature
+        self.rp = rp                   # pull-up resistance
+        self.vadc = 5.0                # ADC reference
+        self.vcc = 5.0                 # supply voltage to potential divider
+        a1 = log(r1)
+        a2 = log(r2)
+        a3 = log(r3)
+        z = a1 - a2
+        y = a1 - a3
+        x = 1/t1 - 1/t2
+        w = 1/t1 - 1/t3
+        v = pow(a1,3) - pow(a2,3)
+        u = pow(a1,3) - pow(a3,3)
+        c3 = (x-z*w/y)/(v-z*u/y)
+        c2 = (x-c3*v)/z
+        c1 = 1/t1-c3*pow(a1,3)-c2*a1
+        self.c1 = c1
+        self.c2 = c2
+        self.c3 = c3
+
+    def temp(self,adc):
+        "Convert ADC reading into a temperature in Celcius"
+        v = adc * self.vadc / (1024 * 16)   # convert the 10 bit ADC value to a voltage
+        r = self.rp * v / (self.vcc - v)    # resistance of thermistor
+        lnr = log(r)
+        Tinv = self.c1 + (self.c2*lnr) + (self.c3*pow(lnr,3))
+        return (1/Tinv) - 273.15        # temperature
+
+    def adc(self,temp):
+        "Convert temperature into a ADC reading"
+        y = (self.c1 - (1/(temp+273.15))) / (2*self.c3)
+	x = sqrt(pow(self.c2 / (3*self.c3),3) + pow(y,2))
+        r = exp(pow(x-y,1.0/3) - pow(x+y,1.0/3)) # resistance of thermistor
+        return (r / (self.rp + r)) * (1024*16)
+
+def main(argv):
+
+    rp = 4700;
+    t1 = 25;
+    r1 = 100000;
+    t2 = 150;
+    r2 = 1641.9;
+    t3 = 250;
+    r3 = 226.15;
+    num_temps = int(36);
+    
+    try:
+        opts, args = getopt.getopt(argv, "h", ["help", "rp=", "t1=", "t2=", "t3=", "num-temps="])
+    except getopt.GetoptError:
+        usage()
+        sys.exit(2)
+        
+    for opt, arg in opts:
+        if opt in ("-h", "--help"):
+            usage()
+            sys.exit()
+        elif opt == "--rp":
+            rp = int(arg)
+        elif opt == "--t1":
+            arg =  arg.split(':')
+            t1 = float( arg[0])
+            r1 = float( arg[1])
+        elif opt == "--t2":
+            arg =  arg.split(':')
+            t2 = float( arg[0])
+            r2 = float( arg[1])
+        elif opt == "--t3":
+            arg =  arg.split(':')
+            t3 = float( arg[0])
+            r3 = float( arg[1])
+        elif opt == "--num-temps":
+            num_temps =  int(arg)
+
+    max_adc = (1024 * 16) - 1
+    min_temp = 0
+    max_temp = 350
+    increment = int(max_adc/(num_temps-1));
+            
+    t = Thermistor(rp, t1, r1, t2, r2, t3, r3)
+    tmp = (min_temp - max_temp) / (num_temps-1)
+    print tmp
+    temps = range(max_temp, min_temp + tmp, tmp);
+
+    print "// Thermistor lookup table for Marlin"
+    print "// ./createTemperatureLookup.py --rp=%s --t1=%s:%s --t2=%s:%s --t3=%s:%s --num-temps=%s" % (rp, t1, r1, t2, r2, t3, r3, num_temps)
+    print "#define NUMTEMPS %s" % (len(temps))
+    print "short temptable[NUMTEMPS][2] = {"
+
+    counter = 0
+    for temp in temps:
+        counter = counter +1
+        if counter == len(temps):
+            print "   {%s, %s}" % (int(t.adc(temp)), temp)
+        else:
+            print "   {%s, %s}," % (int(t.adc(temp)), temp)
+    print "};"
+    
+def usage():
+    print __doc__
+
+if __name__ == "__main__":
+    main(sys.argv[1:])
diff --git a/Marlin/fastio.h b/Marlin/fastio.h
index cb4399a..6749a28 100644
--- a/Marlin/fastio.h
+++ b/Marlin/fastio.h
@@ -3,8 +3,8 @@
   why double up on these macros? see http://gcc.gnu.org/onlinedocs/cpp/Stringification.html
 */
 
-#ifndef	_ARDUINO_H
-#define	_ARDUINO_H
+#ifndef	_FASTIO_ARDUINO_H
+#define	_FASTIO_ARDUINO_H
 
 #include <avr/io.h>
 
@@ -2579,4 +2579,4 @@ pins
 #error pins for this chip not defined in arduino.h! If you write an appropriate pin definition and have this firmware work on your chip, please submit a pull request
 #endif
 
-#endif /* _ARDUINO_H */
+#endif /* _FASTIO_ARDUINO_H */
diff --git a/Marlin/language.h b/Marlin/language.h
index 1115575..4894121 100644
--- a/Marlin/language.h
+++ b/Marlin/language.h
@@ -8,11 +8,13 @@
 
 // Languages
 // 1  English
-// 2  -
-// 3  French	(Waiting translation)
+// 2  Polish
+// 3  French	(awaiting translation!)
 // 4  German
 // 5  Spanish
-// 6  Etc
+// 6  Russian
+// 7  Italian
+// 8  Portuguese
 
 #define LANGUAGE_CHOICE 1  // Pick your language from the list above
 
@@ -133,35 +135,38 @@
 	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
 	#define MSG_OK "ok"
 	#define MSG_FILE_SAVED "Done saving file."
-	#define MSG_ERR_LINE_NO "Line Number is not Last Line Number+1, Last Line:"
-	#define MSG_ERR_CHECKSUM_MISMATCH "checksum mismatch, Last Line:"
-	#define MSG_ERR_NO_CHECKSUM "No Checksum with line number, Last Line:"
-	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "No Line Number with checksum, Last Line:"
+	#define MSG_ERR_LINE_NO "Line Number is not Last Line Number+1, Last Line: "
+	#define MSG_ERR_CHECKSUM_MISMATCH "checksum mismatch, Last Line: "
+	#define MSG_ERR_NO_CHECKSUM "No Checksum with line number, Last Line: "
+	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "No Line Number with checksum, Last Line: "
 	#define MSG_FILE_PRINTED "Done printing file"
 	#define MSG_BEGIN_FILE_LIST "Begin file list"
 	#define MSG_END_FILE_LIST "End file list"
 	#define MSG_M104_INVALID_EXTRUDER "M104 Invalid extruder "
 	#define MSG_M105_INVALID_EXTRUDER "M105 Invalid extruder "
-	#define MSG_ERR_NO_THERMISTORS "No thermistors - no temp"
+	#define MSG_ERR_NO_THERMISTORS "No thermistors - no temperature"
 	#define MSG_M109_INVALID_EXTRUDER "M109 Invalid extruder "
 	#define MSG_HEATING "Heating..."
 	#define MSG_HEATING_COMPLETE "Heating done."
 	#define MSG_BED_HEATING "Bed Heating."
 	#define MSG_BED_DONE "Bed done."
 	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
-	#define MSG_COUNT_X " Count X:"
-	#define MSG_ERR_KILLED "Printer halted. kill() called !!"
-	#define MSG_ERR_STOPPED "Printer stopped deu to errors. Fix the error and use M999 to restart!. (Temperature is reset. Set it before restarting)"
-	#define MSG_RESEND "Resend:"
-	#define MSG_UNKNOWN_COMMAND "Unknown command:\""
+	#define MSG_COUNT_X " Count X: "
+	#define MSG_ERR_KILLED "Printer halted. kill() called!"
+	#define MSG_ERR_STOPPED "Printer stopped due to errors. Fix the error and use M999 to restart. (Temperature is reset. Set it after restarting)"
+	#define MSG_RESEND "Resend: "
+	#define MSG_UNKNOWN_COMMAND "Unknown command: \""
 	#define MSG_ACTIVE_EXTRUDER "Active Extruder: "
 	#define MSG_INVALID_EXTRUDER "Invalid extruder"
-	#define MSG_X_MIN "x_min:"
-	#define MSG_X_MAX "x_max:"
-	#define MSG_Y_MIN "y_min:"
-	#define MSG_Y_MAX "y_max:"
-	#define MSG_Z_MIN "z_min:"
-	#define MSG_Z_MAX "z_max:"
+	#define MSG_X_MIN "x_min: "
+	#define MSG_X_MAX "x_max: "
+	#define MSG_Y_MIN "y_min: "
+	#define MSG_Y_MAX "y_max: "
+	#define MSG_Z_MIN "z_min: "
+	#define MSG_Z_MAX "z_max: "
+	#define MSG_M119_REPORT "Reporting endstop status"
+	#define MSG_ENDSTOP_HIT "TRIGGERED"
+	#define MSG_ENDSTOP_OPEN "open"
 
 	#define MSG_SD_CANT_OPEN_SUBDIR "Cannot open subdir"
 	#define MSG_SD_INIT_FAIL "SD init fail"
@@ -170,21 +175,342 @@
 	#define MSG_SD_CARD_OK "SD card ok"
 	#define MSG_SD_WORKDIR_FAIL "workDir open failed"
 	#define MSG_SD_OPEN_FILE_FAIL "open failed, File: "
-	#define MSG_SD_FILE_OPENED "File opened:"
-	#define MSG_SD_SIZE " Size:"
+	#define MSG_SD_FILE_OPENED "File opened: "
+	#define MSG_SD_SIZE " Size: "
 	#define MSG_SD_FILE_SELECTED "File selected"
 	#define MSG_SD_WRITE_TO_FILE "Writing to file: "
 	#define MSG_SD_PRINTING_BYTE "SD printing byte "
 	#define MSG_SD_NOT_PRINTING "Not SD printing"
 	#define MSG_SD_ERR_WRITE_TO_FILE "error writing to file"
-	#define MSG_SD_CANT_ENTER_SUBDIR "Cannot enter subdir:"
+	#define MSG_SD_CANT_ENTER_SUBDIR "Cannot enter subdir: "
 
-	#define MSG_STEPPER_TO_HIGH "Steprate to high : "
+	#define MSG_STEPPER_TO_HIGH "Steprate to high: "
 	#define MSG_ENDSTOPS_HIT "endstops hit: "
 	#define MSG_ERR_COLD_EXTRUDE_STOP " cold extrusion prevented"
 	#define MSG_ERR_LONG_EXTRUDE_STOP " too long extrusion prevented"
 
 #endif
+
+
+#if LANGUAGE_CHOICE == 2
+
+// LCD Menu Messages
+	#define WELCOME_MSG MACHINE_NAME " Gotowe."
+	#define MSG_SD_INSERTED "Karta wlozona"
+	#define MSG_SD_REMOVED "Karta usunieta"
+	#define MSG_MAIN " Menu \003"
+	#define MSG_AUTOSTART " Autostart"
+	#define MSG_DISABLE_STEPPERS " Wylacz silniki"
+	#define MSG_AUTO_HOME " Auto. poz. zerowa"
+	#define MSG_SET_ORIGIN " Ustaw punkt zerowy"
+	#define MSG_PREHEAT_PLA " Rozgrzej PLA"
+	#define MSG_PREHEAT_PLA_SETTINGS " Ustawienia roz. PLA"
+	#define MSG_PREHEAT_ABS " Rozgrzej ABS"
+	#define MSG_PREHEAT_ABS_SETTINGS " Ustawienia roz. ABS"
+	#define MSG_COOLDOWN " Chlodzenie"
+	#define MSG_EXTRUDE " Ekstruzja"
+	#define MSG_RETRACT " Cofanie"
+	#define MSG_MOVE_AXIS " Ruch osi       \x7E"
+	#define MSG_SPEED " Predkosc:"
+	#define MSG_NOZZLE " \002Dysza:"
+	#define MSG_NOZZLE1 " \002Dysza2:"
+	#define MSG_NOZZLE2 " \002Dysza3:"
+	#define MSG_BED " \002Loze:"
+	#define MSG_FAN_SPEED " Obroty wiatraka:"
+	#define MSG_FLOW " Przeplyw:"
+	#define MSG_CONTROL " Kontrola \003"
+	#define MSG_MIN " \002 Min:"
+	#define MSG_MAX " \002 Max:"
+	#define MSG_FACTOR " \002 Mnoznik:"
+	#define MSG_AUTOTEMP " Auto. temp.:"
+	#define MSG_ON "Wl. "
+	#define MSG_OFF "Wyl."
+	#define MSG_PID_P " PID-P: "
+	#define MSG_PID_I " PID-I: "
+	#define MSG_PID_D " PID-D: "
+	#define MSG_PID_C " PID-C: "
+	#define MSG_ACC  " Acc:"
+	#define MSG_VXY_JERK " Zryw Vxy: "
+	#define MSG_VMAX " Vmax "
+	#define MSG_X "x:"
+	#define MSG_Y "y:"
+	#define MSG_Z "z:"
+	#define MSG_E "e:"
+	#define MSG_VMIN " Vmin:"
+	#define MSG_VTRAV_MIN " Vskok min:"
+	#define MSG_AMAX " Amax "
+	#define MSG_A_RETRACT " A-wycofanie:"
+	#define MSG_XSTEPS " krokiX/mm:"
+	#define MSG_YSTEPS " krokiY/mm:"
+	#define MSG_ZSTEPS " krokiZ/mm:"
+	#define MSG_ESTEPS " krokiE/mm:"
+	#define MSG_MAIN_WIDE " Menu        \003"
+	#define MSG_RECTRACT_WIDE " Wycofanie   \x7E"
+	#define MSG_TEMPERATURE_WIDE " Temperatura \x7E"
+	#define MSG_TEMPERATURE_RTN " Temperatura  \003"
+	#define MSG_MOTION_WIDE " Ruch        \x7E"
+	#define MSG_STORE_EPROM " Zapisz w pamieci"
+	#define MSG_LOAD_EPROM " Wczytaj z pamieci"
+	#define MSG_RESTORE_FAILSAFE " Ustawienia fabryczne"
+	#define MSG_REFRESH "\004Odswiez"
+	#define MSG_WATCH " Obserwuj   \003"
+	#define MSG_PREPARE " Przygotuj \x7E"
+	#define MSG_PREPARE_ALT " Przygotuj \003"
+	#define MSG_CONTROL_ARROW " Kontroluj \x7E"
+	#define MSG_RETRACT_ARROW " Wycofaj \x7E"
+	#define MSG_TUNE "Strojenie\x7E"
+	#define MSG_PAUSE_PRINT "    Pauza    \x7E"
+	#define MSG_RESUME_PRINT "  Wznowienie  \x7E"
+	#define MSG_STOP_PRINT "     Stop     \x7E"
+	#define MSG_CARD_MENU " Menu SDCard  \x7E"
+	#define MSG_NO_CARD " Brak karty"
+	#define MSG_DWELL "Uspij..."
+	#define MSG_USERWAIT "Czekaj na uzytkownika..."
+	#define MSG_NO_MOVE "Brak ruchu."
+	#define MSG_PART_RELEASE "Czesciowe zwolnienie"
+	#define MSG_KILLED "Ubity. "
+	#define MSG_STOPPED "Zatrzymany. "
+	#define MSG_STEPPER_RELEASED "Zwolniony."
+	#define MSG_CONTROL_RETRACT  " Wycofaj mm:"
+	#define MSG_CONTROL_RETRACTF " Wycofaj  F:"
+	#define MSG_CONTROL_RETRACT_ZLIFT " Skok Z mm:"
+	#define MSG_CONTROL_RETRACT_RECOVER " Cof. wycof. +mm:"
+	#define MSG_CONTROL_RETRACT_RECOVERF " Cof. wycof.  F:"
+	#define MSG_AUTORETRACT " Auto. wycofanie:"
+        #define MSG_SERIAL_ERROR_MENU_STRUCTURE "Cos jest nie tak ze struktura menu."
+
+// Serial Console Messages
+
+	#define MSG_Enqueing "Kolejkowanie \""
+	#define MSG_POWERUP "Zasilanie wlaczone"
+	#define MSG_EXTERNAL_RESET " Reset (zewnetrzny)"
+	#define MSG_BROWNOUT_RESET " Reset (spadek napiecia)"
+	#define MSG_WATCHDOG_RESET " Reset (watchdog)"
+	#define MSG_SOFTWARE_RESET " Reset (programowy)"
+	#define MSG_MARLIN "Marlin "
+	#define MSG_AUTHOR " | Autor: "
+	#define MSG_CONFIGURATION_VER " Ostatnia aktualizacja: "
+	#define MSG_FREE_MEMORY " Wolna pamiec: "
+	#define MSG_PLANNER_BUFFER_BYTES "  Bufor planisty krokow (w bajtach): "
+	#define MSG_OK "ok"
+	#define MSG_FILE_SAVED "Plik zapisany."
+	#define MSG_ERR_LINE_NO "Numer linijki nie jest ostatnim numerem linijki+1; ostatnia linijka:"
+	#define MSG_ERR_CHECKSUM_MISMATCH "Niezgodna suma kontrolna; ostatnia linijka: "
+	#define MSG_ERR_NO_CHECKSUM "Brak sumy kontrolnej w linijce; ostatnia linijka:"
+	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Brak numery linijki przy sumie kontrolnej; ostatnia linijka:"
+	#define MSG_FILE_PRINTED "Ukonczono wydruk z pliku"
+	#define MSG_BEGIN_FILE_LIST "Start listy plikow"
+	#define MSG_END_FILE_LIST "Koniec listy plikow"
+	#define MSG_M104_INVALID_EXTRUDER "M104 Niepoprawny ekstruder "
+	#define MSG_M105_INVALID_EXTRUDER "M105 Niepoprawny ekstruder "
+	#define MSG_ERR_NO_THERMISTORS "Brak termistorow - brak temperatury :("
+	#define MSG_M109_INVALID_EXTRUDER "M109 Niepoprawny ekstruder "
+	#define MSG_HEATING "Nagrzewanie ekstrudera..."
+	#define MSG_HEATING_COMPLETE "Nagrzewanie ekstrudera zakonczone."
+	#define MSG_BED_HEATING "Nagrzewanie loza..."
+	#define MSG_BED_DONE "Nagrzewanie loza zakonczone."
+	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
+	#define MSG_COUNT_X " Liczenie X: "
+	#define MSG_ERR_KILLED "Drukarka zatrzymana. Wywolano kill()"
+	#define MSG_ERR_STOPPED "Drukarka zatrzymana z powodu bledu. Usun problem i zrestartuj drukartke komenda M999. (temperatura zostala zresetowana; ustaw temperature po restarcie)"
+	#define MSG_RESEND "Wyslij ponownie: "
+	#define MSG_UNKNOWN_COMMAND "Nieznane polecenie: \""
+	#define MSG_ACTIVE_EXTRUDER "Aktywny ekstruder: "
+	#define MSG_INVALID_EXTRUDER "Niepoprawny ekstruder"
+	#define MSG_X_MIN "x_min: "
+	#define MSG_X_MAX "x_max: "
+	#define MSG_Y_MIN "y_min: "
+	#define MSG_Y_MAX "y_max: "
+	#define MSG_Z_MIN "z_min: "
+	#define MSG_Z_MAX "z_max: "
+	#define MSG_M119_REPORT "Zgloszenie statusu wylacznikow krancowych"
+	#define MSG_ENDSTOP_HIT "WYZWOLONY"
+	#define MSG_ENDSTOP_OPEN "otwarty"
+
+	#define MSG_SD_CANT_OPEN_SUBDIR "Nie mozna otworzyc podkatalogu"
+	#define MSG_SD_INIT_FAIL "Blad inicjalizacji karty SD"
+	#define MSG_SD_VOL_INIT_FAIL "Blad inizjalizacji wolumenu"
+	#define MSG_SD_OPENROOT_FAIL "Blad odczytywania katalogu glownego"
+	#define MSG_SD_CARD_OK "Karta SD zainicjalizowana"
+	#define MSG_SD_WORKDIR_FAIL "Blad odczytywania katalogu roboczego"
+	#define MSG_SD_OPEN_FILE_FAIL "Nie mozna otworzyc pliku: "
+	#define MSG_SD_FILE_OPENED "Otwarto plik:"
+	#define MSG_SD_SIZE " Rozmiar:"
+	#define MSG_SD_FILE_SELECTED "Wybrano plik"
+	#define MSG_SD_WRITE_TO_FILE "Zapisywanie do pliku: "
+	#define MSG_SD_PRINTING_BYTE "Drukowanie z karty SD, bajt "
+	#define MSG_SD_NOT_PRINTING "Nie trwa drukowanie z karty SD"
+	#define MSG_SD_ERR_WRITE_TO_FILE "blad podczas zapisu do pliku"
+	#define MSG_SD_CANT_ENTER_SUBDIR "Nie mozna odczytac podkatalogu: "
+
+	#define MSG_STEPPER_TO_HIGH "Za duza czestotliwosc krokow: "
+	#define MSG_ENDSTOPS_HIT "Wylacznik krancowy zostal wyzwolony na pozycji: "
+	#define MSG_ERR_COLD_EXTRUDE_STOP " uniemozliwiono zimna ekstruzje"
+	#define MSG_ERR_LONG_EXTRUDE_STOP " uniemozliwiono zbyt dluga ekstruzje"
+
+#endif
+
+
+#if LANGUAGE_CHOICE == 3
+
+#define WELCOME_MSG MACHINE_NAME " Pret."
+#define MSG_SD_INSERTED "Carte inseree"
+#define MSG_SD_REMOVED "Carte retiree"
+#define MSG_MAIN " Principal \003"
+#define MSG_AUTOSTART " Demarrage auto."
+#define MSG_DISABLE_STEPPERS " Desactiver moteurs"
+#define MSG_AUTO_HOME " Home auto."
+#define MSG_SET_ORIGIN " Regler origine"
+#define MSG_PREHEAT_PLA " Prechauffage PLA"
+#define MSG_PREHEAT_PLA_SETTINGS " Regl. prechauffe PLA"
+#define MSG_PREHEAT_ABS " Prechauffage ABS"
+#define MSG_PREHEAT_ABS_SETTINGS " Regl. prechauffe ABS"
+#define MSG_COOLDOWN " Refroidissement"
+#define MSG_EXTRUDE " Extrusion"
+#define MSG_RETRACT " Retractation"
+#define MSG_PREHEAT_PLA " Prechauffage PLA"
+#define MSG_PREHEAT_ABS " Prechauffage ABS"
+#define MSG_MOVE_AXIS " Deplacer axe \x7E"
+#define MSG_SPEED " Vitesse:"
+#define MSG_NOZZLE " \002Buse:"
+#define MSG_NOZZLE1 " \002Buse2:"
+#define MSG_NOZZLE2 " \002Buse3:"
+#define MSG_BED " \002Lit:"
+#define MSG_FAN_SPEED " Vitesse ventilateur:"
+#define MSG_FLOW " Flux:"
+#define MSG_CONTROL " Controle \003"
+#define MSG_MIN " \002 Min:"
+#define MSG_MAX " \002 Max:"
+#define MSG_FACTOR " \002 Facteur:"
+#define MSG_AUTOTEMP " Temp. Auto.:"
+#define MSG_ON "Marche "
+#define MSG_OFF "Arret"
+#define MSG_PID_P " PID-P: "
+#define MSG_PID_I " PID-I: "
+#define MSG_PID_D " PID-D: "
+#define MSG_PID_C " PID-C: "
+#define MSG_ACC " Acc:"
+#define MSG_VXY_JERK " Vxy-jerk: "
+#define MSG_VMAX " Vmax "
+#define MSG_X "x:"
+#define MSG_Y "y:"
+#define MSG_Z "z:"
+#define MSG_E "e:"
+#define MSG_VMIN " Vmin:"
+#define MSG_VTRAV_MIN " Vdepl min:"
+#define MSG_AMAX " Amax "
+#define MSG_A_RETRACT " A-retract:"
+#define MSG_XSTEPS " Xpas/mm:"
+#define MSG_YSTEPS " Ypas/mm:"
+#define MSG_ZSTEPS " Zpas/mm:"
+#define MSG_ESTEPS " Epas/mm:"
+#define MSG_MAIN_WIDE " Principal \003"
+#define MSG_RECTRACT_WIDE " Rectractater \x7E"
+#define MSG_TEMPERATURE_WIDE " Temperature \x7E"
+#define MSG_TEMPERATURE_RTN " Temperature \003"
+#define MSG_MOTION_WIDE " Mouvement \x7E"
+#define MSG_STORE_EPROM " Sauvegarder memoire"
+#define MSG_LOAD_EPROM " Lire memoire"
+#define MSG_RESTORE_FAILSAFE " Restaurer memoire"
+#define MSG_REFRESH "\004Actualiser"
+#define MSG_WATCH " Surveiller \003"
+#define MSG_PREPARE " Preparer \x7E"
+#define MSG_PREPARE_ALT " Prepare \003"
+#define MSG_CONTROL_ARROW " Controle \x7E"
+#define MSG_RETRACT_ARROW " Retracter \x7E"
+#define MSG_TUNE " Regler \x7E"
+#define MSG_PAUSE_PRINT " Pause impression \x7E"
+#define MSG_RESUME_PRINT " Reprendre impression \x7E"
+#define MSG_STOP_PRINT " Arreter impression \x7E"
+#define MSG_CARD_MENU " Menu carte \x7E"
+#define MSG_NO_CARD " Pas de carte"
+#define MSG_DWELL "Repos..."
+#define MSG_USERWAIT "Attente de l'utilisateur..."
+#define MSG_NO_MOVE "Aucun mouvement."
+#define MSG_PART_RELEASE "Relache partielle"
+#define MSG_KILLED "TUE."
+#define MSG_STOPPED "STOPPE."
+#define MSG_STEPPER_RELEASED "RELACHE."
+#define MSG_CONTROL_RETRACT " Retractation mm:"
+#define MSG_CONTROL_RETRACTF " Retractation F:"
+#define MSG_CONTROL_RETRACT_ZLIFT " Hop mm:"
+#define MSG_CONTROL_RETRACT_RECOVER " UnRet +mm:"
+#define MSG_CONTROL_RETRACT_RECOVERF " UnRet F:"
+#define MSG_AUTORETRACT " Retract. Auto.:"
+        #define MSG_SERIAL_ERROR_MENU_STRUCTURE "Erreur avec MenuStructure."
+
+// Serial Console Messages
+
+#define MSG_Enqueing "Mise en tampon \""
+#define MSG_POWERUP "Allumage"
+#define MSG_EXTERNAL_RESET " RAZ Externe"
+#define MSG_BROWNOUT_RESET " RAZ defaut alim."
+#define MSG_WATCHDOG_RESET " RAZ Watchdog"
+#define MSG_SOFTWARE_RESET " RAZ logicielle"
+#define MSG_MARLIN "Marlin "
+#define MSG_AUTHOR " | Auteur: "
+#define MSG_CONFIGURATION_VER " Derniere MaJ: "
+#define MSG_FREE_MEMORY " Memoire libre: "
+#define MSG_PLANNER_BUFFER_BYTES " PlannerBufferBytes: "
+#define MSG_OK "ok"
+#define MSG_FILE_SAVED "Fichier enregistre."
+#define MSG_ERR_LINE_NO "Le numero de ligne n'est pas la derniere ligne + 1, derniere ligne: "
+#define MSG_ERR_CHECKSUM_MISMATCH "Erreur somme de controle, derniere ligne: "
+#define MSG_ERR_NO_CHECKSUM "Pas de somme de controle avec le numero de ligne, derniere ligne: "
+#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Pas de numero de ligne avec somme de controle, derniere ligne: "
+#define MSG_FILE_PRINTED "Impression terminee"
+#define MSG_BEGIN_FILE_LIST "Debut de la liste de fichiers"
+#define MSG_END_FILE_LIST "Fin de la liste de fichiers"
+#define MSG_M104_INVALID_EXTRUDER "M104 Extruder invalide"
+#define MSG_M105_INVALID_EXTRUDER "M105 Extruder invalide"
+#define MSG_ERR_NO_THERMISTORS "Pas de thermistor, pas de temperature"
+#define MSG_M109_INVALID_EXTRUDER "M109 Extruder invalide "
+#define MSG_HEATING "En chauffe..."
+#define MSG_HEATING_COMPLETE "Chauffe terminee."
+#define MSG_BED_HEATING "Chauffe du lit."
+#define MSG_BED_DONE "Chauffe du lit terminee."
+#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
+#define MSG_COUNT_X " Compteur X: "
+#define MSG_ERR_KILLED "Impression arretee. kill() appelee!"
+#define MSG_ERR_STOPPED "Impression arretee a cause d'erreurs. Corriger les erreurs et utiliser M999 pour la reprendre. (Temperature remise a zero. Reactivez la apres redemarrage)"
+#define MSG_RESEND "Renvoie: "
+#define MSG_UNKNOWN_COMMAND "Commande inconnue: \""
+#define MSG_ACTIVE_EXTRUDER "Extrudeur actif: "
+#define MSG_INVALID_EXTRUDER "Extrudeur invalide"
+#define MSG_X_MIN "x_min: "
+#define MSG_X_MAX "x_max: "
+#define MSG_Y_MIN "y_min: "
+#define MSG_Y_MAX "y_max: "
+#define MSG_Z_MIN "z_min: "
+#define MSG_Z_MAX "z_max: "
+#define MSG_M119_REPORT "Affichage du status des fin de course"
+#define MSG_ENDSTOP_HIT "DECLENCHE"
+#define MSG_ENDSTOP_OPEN "OUVERT"
+
+#define MSG_SD_CANT_OPEN_SUBDIR "Impossible d'ouvrir le sous-repertoire"
+#define MSG_SD_INIT_FAIL "Echec de l'initialisation de la SD"
+#define MSG_SD_VOL_INIT_FAIL "Echec de volume.init"
+#define MSG_SD_OPENROOT_FAIL "Echec openRoot"
+#define MSG_SD_CARD_OK "Carte SD Ok"
+#define MSG_SD_WORKDIR_FAIL "Echec d'ouverture workDir"
+#define MSG_SD_OPEN_FILE_FAIL "Echec d'ouverture, Fichier: "
+#define MSG_SD_FILE_OPENED "Fichier ouvert: "
+#define MSG_SD_SIZE " Taille: "
+#define MSG_SD_FILE_SELECTED "Fichier selectionne"
+#define MSG_SD_WRITE_TO_FILE "Ecriture dans le fichier: "
+#define MSG_SD_PRINTING_BYTE "Octet impression SD "
+#define MSG_SD_NOT_PRINTING "Pas d'impression SD"
+#define MSG_SD_ERR_WRITE_TO_FILE "Erreur d'ecriture dans le fichier"
+#define MSG_SD_CANT_ENTER_SUBDIR "Impossible d'entrer dans le sous-repertoire: "
+
+#define MSG_STEPPER_TO_HIGH "Steprate trop eleve: "
+#define MSG_ENDSTOPS_HIT "Fin de course atteint: "
+#define MSG_ERR_COLD_EXTRUDE_STOP " Extrusion a froid evitee"
+#define MSG_ERR_LONG_EXTRUDE_STOP " Extrusion longue evitee"
+	
+#endif
+
+
 #if LANGUAGE_CHOICE == 4
 
 // LCD Menu Messages
@@ -311,12 +637,15 @@
 	#define MSG_UNKNOWN_COMMAND "Unknown command:\""
 	#define MSG_ACTIVE_EXTRUDER "Active Extruder: "
 	#define MSG_INVALID_EXTRUDER "Invalid extruder"
-	#define MSG_X_MIN "x_min:"
-	#define MSG_X_MAX "x_max:"
-	#define MSG_Y_MIN "y_min:"
-	#define MSG_Y_MAX "y_max:"
-	#define MSG_Z_MIN "z_min:"
-	#define MSG_Z_MAX "z_max:"
+	#define MSG_X_MIN "x_min: "
+	#define MSG_X_MAX "x_max: "
+	#define MSG_Y_MIN "y_min: "
+	#define MSG_Y_MAX "y_max: "
+	#define MSG_Z_MIN "z_min: "
+	#define MSG_Z_MAX "z_max: "
+	#define MSG_M119_REPORT "Reporting endstop status"
+	#define MSG_ENDSTOP_HIT "TRIGGERED"
+	#define MSG_ENDSTOP_OPEN "open"
 
 	#define MSG_SD_CANT_OPEN_SUBDIR "Cannot open subdir"
 	#define MSG_SD_INIT_FAIL "SD init fail"
@@ -341,6 +670,7 @@
 
 #endif
 
+
 #if LANGUAGE_CHOICE == 5
 
 // LCD Menu Messages
@@ -354,11 +684,11 @@
 #define MSG_SET_ORIGIN " Establecer Cero"
 #define MSG_COOLDOWN " Enfriar"
 #define MSG_EXTRUDE " Extruir"
-#define MSG_RETRACT " Retract"
+#define MSG_RETRACT " Retraer"
 #define MSG_PREHEAT_PLA " Precalentar PLA"
-#define MSG_PREHEAT_PLA_SETTINGS " Precalentar PLA Setting"
+#define MSG_PREHEAT_PLA_SETTINGS " Ajustar temp. PLA"
 #define MSG_PREHEAT_ABS " Precalentar ABS"
-#define MSG_PREHEAT_ABS_SETTINGS " Precalentar ABS Setting"
+#define MSG_PREHEAT_ABS_SETTINGS " Ajustar temp. ABS"
 #define MSG_MOVE_AXIS " Mover Ejes      \x7E"
 #define MSG_SPEED " Velocidad:"
 #define MSG_NOZZLE " \002Nozzle:"
@@ -406,10 +736,10 @@
 #define MSG_PREPARE " Preparar \x7E"
 #define MSG_PREPARE_ALT " Preparar \003"
 #define MSG_CONTROL_ARROW " Control  \x7E"
-#define MSG_RETRACT_ARROW " Control  \x7E"
+#define MSG_RETRACT_ARROW " Retraer  \x7E"
 #define MSG_TUNE " Ajustar \x7E"
-#define MSG_PAUSE_PRINT " Pause Print \x7E"
-#define MSG_RESUME_PRINT " Resume Print \x7E"
+#define MSG_PAUSE_PRINT " Pausar Impresion \x7E"
+#define MSG_RESUME_PRINT " Reanudar Impresion \x7E"
 #define MSG_STOP_PRINT " Detener Impresion \x7E"
 #define MSG_CARD_MENU " Menu de SD    \x7E"
 #define MSG_NO_CARD " No hay Tarjeta SD"
@@ -466,13 +796,15 @@
 #define MSG_UNKNOWN_COMMAND "Comando Desconocido:\""
 #define MSG_ACTIVE_EXTRUDER "Extrusor Activo: "
 #define MSG_INVALID_EXTRUDER "Extrusor Invalido"
-#define MSG_X_MIN "x_min:"
-#define MSG_X_MAX "x_max:"
-#define MSG_Y_MIN "y_min:"
-#define MSG_Y_MAX "y_max:"
-#define MSG_Z_MIN "z_min:"
-#define MSG_Z_MAX "z_max:"
-
+#define MSG_X_MIN "x_min: "
+#define MSG_X_MAX "x_max: "
+#define MSG_Y_MIN "y_min: "
+#define MSG_Y_MAX "y_max: "
+#define MSG_Z_MIN "z_min: "
+#define MSG_M119_REPORT "Comprobando fines de carrera."
+#define MSG_ENDSTOP_HIT "PULSADO"
+#define MSG_ENDSTOP_OPEN "abierto"
+        
 #define MSG_SD_CANT_OPEN_SUBDIR "No se pudo abrir la subcarpeta."
 #define MSG_SD_INIT_FAIL "Fallo al iniciar la SD"
 #define MSG_SD_VOL_INIT_FAIL "Fallo al montar el volumen"
@@ -487,7 +819,7 @@
 #define MSG_SD_PRINTING_BYTE "SD imprimiendo el byte "
 #define MSG_SD_NOT_PRINTING "No se esta imprimiendo con SD"
 #define MSG_SD_ERR_WRITE_TO_FILE "Error al escribir en el archivo"
-#define MSG_SD_CANT_ENTER_SUBDIR "No se puede entrar en la carpeta:"
+#define MSG_SD_CANT_ENTER_SUBDIR "No se puede abrir la carpeta:"
 
 #define MSG_STEPPER_TO_HIGH "Steprate demasiado alto : "
 #define MSG_ENDSTOPS_HIT "Se ha tocado el fin de carril: "
@@ -495,4 +827,484 @@
 #define MSG_ERR_LONG_EXTRUDE_STOP " extrusion demasiado larga evitada"
 
 #endif
+
+#if LANGUAGE_CHOICE == 6
+
+// LCD Menu Messages
+#define WELCOME_MSG MACHINE_NAME			" Готов."
+#define MSG_SD_INSERTED						"Карта вставлена"
+#define MSG_SD_REMOVED						"Карта извлечена"
+#define MSG_MAIN							" Меню              \003"
+#define MSG_AUTOSTART						" Автостарт          "
+#define MSG_DISABLE_STEPPERS				" Выключить двигатели"
+#define MSG_AUTO_HOME						" Парковка           "
+#define MSG_SET_ORIGIN						" Запомнить ноль     "
+#define MSG_PREHEAT_PLA						" Преднагрев PLA     "
+#define MSG_PREHEAT_PLA_SETTINGS			" Настр. преднагр.PLA"
+#define MSG_PREHEAT_ABS						" Преднагрев ABS     "
+#define MSG_PREHEAT_ABS_SETTINGS			" Настр. преднагр.ABS"
+#define MSG_COOLDOWN						" Охлаждение         "
+#define MSG_EXTRUDE							" Экструзия          "
+#define MSG_RETRACT							" Откат"
+#define MSG_MOVE_AXIS						" Движение по осям  \x7E"
+#define MSG_SPEED							" Скорость:"
+#define MSG_NOZZLE							" \002 Фильера:"
+#define MSG_NOZZLE1							" \002 Фильера2:"
+#define MSG_NOZZLE2							" \002 Фильера3:"
+#define MSG_BED								" \002 Кровать:"
+#define MSG_FAN_SPEED						" Куллер:"
+#define MSG_FLOW							" Поток:"
+#define MSG_CONTROL							" Настройки \003"
+#define MSG_MIN								" \002 Минимум:"
+#define MSG_MAX								" \002 Максимум:"
+#define MSG_FACTOR							" \002 Фактор:"
+#define MSG_AUTOTEMP						" Autotemp:"
+#define MSG_ON								"Вкл. "
+#define MSG_OFF								"Выкл. "
+#define MSG_PID_P							" PID-P: "
+#define MSG_PID_I							" PID-I: "
+#define MSG_PID_D							" PID-D: "
+#define MSG_PID_C							" PID-C: "
+#define MSG_ACC								" Acc:"
+#define MSG_VXY_JERK						" Vxy-jerk: "
+#define MSG_VMAX							" Vmax "
+#define MSG_X								"x:"
+#define MSG_Y								"y:"
+#define MSG_Z								"z:"
+#define MSG_E								"e:"
+#define MSG_VMIN							" Vmin:"
+#define MSG_VTRAV_MIN						" VTrav min:"
+#define MSG_AMAX							" Amax "
+#define MSG_A_RETRACT						" A-retract:"
+#define MSG_XSTEPS							" X шаг/mm:"
+#define MSG_YSTEPS							" Y шаг/mm:"
+#define MSG_ZSTEPS							" Z шаг/mm:"
+#define MSG_ESTEPS							" E шаг/mm:"
+#define MSG_MAIN_WIDE						" Меню              \003"
+#define MSG_RECTRACT_WIDE					" Откат подачи      \x7E"
+#define MSG_TEMPERATURE_WIDE				" Температура       \x7E"
+#define MSG_TEMPERATURE_RTN					" Температура       \003"
+#define MSG_MOTION_WIDE						" Скорости          \x7E"
+#define MSG_STORE_EPROM						" Сохранить настройки"
+#define MSG_LOAD_EPROM						" Загрузить настройки"
+#define MSG_RESTORE_FAILSAFE				" Сброс настроек     "
+#define MSG_REFRESH							"\004Обновить           "
+#define MSG_WATCH							" Обзор             \003"
+#define MSG_PREPARE							" Действия          \x7E"
+#define MSG_PREPARE_ALT						" Действия          \003"
+#define MSG_CONTROL_ARROW					" Настройки         \x7E"
+#define MSG_RETRACT_ARROW					" Настройки отката  \x7E"
+#define MSG_TUNE							" Tune              \x7E"
+#define MSG_PAUSE_PRINT						" Пауза печати      \x7E"
+#define MSG_RESUME_PRINT					" Продолжить печать \x7E"
+#define MSG_STOP_PRINT						" Остановить печать \x7E"
+#define MSG_CARD_MENU						" Меню карты        \x7E"
+#define MSG_NO_CARD							" Нет карты"
+#define MSG_DWELL							"Сон..."
+#define MSG_USERWAIT						"Нажмите для продолж."
+#define MSG_NO_MOVE							"Нет движения.       "
+#define MSG_PART_RELEASE					" Извлечение принта  "
+#define MSG_KILLED							"УБИТО. "
+#define MSG_STOPPED							"ОСТАНОВЛЕНО. "
+#define MSG_STEPPER_RELEASED				"Двигатели отключены."
+#define MSG_CONTROL_RETRACT					" Откат mm:"
+#define MSG_CONTROL_RETRACTF				" Откат  F:"
+#define MSG_CONTROL_RETRACT_ZLIFT			" Прыжок mm:"
+#define MSG_CONTROL_RETRACT_RECOVER			" Возврат +mm:"
+#define MSG_CONTROL_RETRACT_RECOVERF		" Возврат  F:"
+#define MSG_AUTORETRACT						" АвтоОткат:"
+#define MSG_SERIAL_ERROR_MENU_STRUCTURE		"Ошибка в структуре меню."
+
+// Serial Console Messages
+
+#define MSG_Enqueing						"Запланировано \""
+#define MSG_POWERUP							"Включение питания"
+#define MSG_EXTERNAL_RESET					" Внешний сброс"
+#define MSG_BROWNOUT_RESET					" Brown out сброс"
+#define MSG_WATCHDOG_RESET					" Watchdog сброс"
+#define MSG_SOFTWARE_RESET					" программный сброс"
+#define MSG_MARLIN							"Marlin "
+#define MSG_AUTHOR							" | Автор: "
+#define MSG_CONFIGURATION_VER				" Последнее обновление: "
+#define MSG_FREE_MEMORY						" Памяти свободно: "
+#define MSG_PLANNER_BUFFER_BYTES			"  Буффер очереди команд Bytes: "
+#define MSG_OK								"ok"
+#define MSG_FILE_SAVED						"Файл записан."
+#define MSG_ERR_LINE_NO						"Номен строки это не последняя строка+1, последняя строка:"
+#define MSG_ERR_CHECKSUM_MISMATCH			"контрольная сумма не совпадает, последняя строка:"
+#define MSG_ERR_NO_CHECKSUM					"нет контрольной суммы для строки, последняя строка:"
+#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM	"нет строки для контрольной суммы, последняя строка:"
+#define MSG_FILE_PRINTED					"Печать файла завершена"
+#define MSG_BEGIN_FILE_LIST					"Список файлов"
+#define MSG_END_FILE_LIST					"Конец списка файлов"
+#define MSG_M104_INVALID_EXTRUDER			"M104 ошибка экструдера "
+#define MSG_M105_INVALID_EXTRUDER			"M105 ошибка экструдера "
+#define MSG_ERR_NO_THERMISTORS				"Нет термистра - нет температуры"
+#define MSG_M109_INVALID_EXTRUDER			"M109 ошибка экструдера "
+#define MSG_HEATING							"Нагрев...  "
+#define MSG_HEATING_COMPLETE				"Наргето.    "
+#define MSG_BED_HEATING						"Нагрев стола...     "
+#define MSG_BED_DONE						"Стол нагрет.        "
+#define MSG_M115_REPORT						"FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
+#define MSG_COUNT_X							" Count X:"
+#define MSG_ERR_KILLED						"Принтер остановлен. вызов kill() !!"
+#define MSG_ERR_STOPPED						"Ошибка принтера, останов. Устраните неисправность и используйте M999 для перезагрузки!. (Температура недоступна. Проверьте датчики)"
+#define MSG_RESEND							"Переотправка:"
+#define MSG_UNKNOWN_COMMAND					"Неизвестная команда:\""
+#define MSG_ACTIVE_EXTRUDER					"Активный экструдер: "
+#define MSG_INVALID_EXTRUDER				"Ошибка экструдера"
+#define MSG_X_MIN							"x_min:"
+#define MSG_X_MAX							"x_max:"
+#define MSG_Y_MIN							"y_min:"
+#define MSG_Y_MAX							"y_max:"
+#define MSG_Z_MIN							"z_min:"
+#define MSG_Z_MAX							"z_max:"
+
+#define MSG_SD_CANT_OPEN_SUBDIR				"Не открыть папку"
+#define MSG_SD_INIT_FAIL					"Ошибка инициализации SD"
+#define MSG_SD_VOL_INIT_FAIL				"Ошибка инициализации раздела"
+#define MSG_SD_OPENROOT_FAIL				"Не прочесть содержимое корня"
+#define MSG_SD_CARD_OK						"SD карта в порядке"
+#define MSG_SD_WORKDIR_FAIL					"не открыть рабочую папку"
+#define MSG_SD_OPEN_FILE_FAIL				"Ошибка чтения, файл: "
+#define MSG_SD_FILE_OPENED					"Файл открыт:"
+#define MSG_SD_SIZE							" Размер:"
+#define MSG_SD_FILE_SELECTED				"Файл выбран"
+#define MSG_SD_WRITE_TO_FILE				"Запись в файл: "
+#define MSG_SD_PRINTING_BYTE				"SD печать byte "
+#define MSG_SD_NOT_PRINTING					"нет SD печати"
+#define MSG_SD_ERR_WRITE_TO_FILE			"ошибка записи в файл"
+#define MSG_SD_CANT_ENTER_SUBDIR			"Не зайти в папку:"
+
+#define MSG_STEPPER_TO_HIGH					"Частота шагов очень высока : "
+#define MSG_ENDSTOPS_HIT					"концевик сработал: "
+#define MSG_ERR_COLD_EXTRUDE_STOP			" защита холодной экструзии"
+#define MSG_ERR_LONG_EXTRUDE_STOP			" защита превышения длинны экструзии"
+#define MSG_M119_REPORT						"Статус концевиков"
+#define MSG_ENDSTOP_HIT						"Срабатывание концевика"
+#define MSG_ENDSTOP_OPEN					"Концевик освобожден"
+
+#endif
+
+
+#if LANGUAGE_CHOICE == 7
+
+	// LCD Menu Messages
+	#define WELCOME_MSG MACHINE_NAME " Pronto."
+	#define MSG_SD_INSERTED          "SD Card inserita"
+	#define MSG_SD_REMOVED           "SD Card rimossa"
+	#define MSG_MAIN                 " Menu principale \003"
+	#define MSG_AUTOSTART            " Autostart"
+	#define MSG_DISABLE_STEPPERS     " Disabilita Motori Passo-Passo"
+	#define MSG_AUTO_HOME            " Auto Home"
+	#define MSG_SET_ORIGIN           " Imposta Origini Assi"
+	#define MSG_PREHEAT_PLA          " Preriscalda PLA"
+	#define MSG_PREHEAT_PLA_SETTINGS " Impostazioni Preriscaldamento PLA"
+	#define MSG_PREHEAT_ABS          " Preriscalda ABS"
+	#define MSG_PREHEAT_ABS_SETTINGS " Impostazioni Preriscaldamento ABS"
+	#define MSG_COOLDOWN             " Rafredda"
+	#define MSG_EXTRUDE              " Estrudi"
+	#define MSG_RETRACT              " Ritrai"
+	#define MSG_MOVE_AXIS            " Muovi Asse      \x7E"
+	#define MSG_SPEED                " Velcità:"
+	#define MSG_NOZZLE               " \002Ugello:"
+	#define MSG_NOZZLE1              " \002Ugello2:"
+	#define MSG_NOZZLE2              " \002Ugello3:"
+	#define MSG_BED                  " \002Piatto:"
+	#define MSG_FAN_SPEED            " Velocità Ventola:"
+	#define MSG_FLOW                 " Flusso:"
+	#define MSG_CONTROL              " Controllo \003"
+	#define MSG_MIN                  " \002 Min:"
+	#define MSG_MAX                  " \002 Max:"
+	#define MSG_FACTOR               " \002 Fact:"
+	#define MSG_AUTOTEMP             " Autotemp:"
+	#define MSG_ON                   "On "
+	#define MSG_OFF                  "Off"
+	#define MSG_PID_P                " PID-P: "
+	#define MSG_PID_I                " PID-I: "
+	#define MSG_PID_D                " PID-D: "
+	#define MSG_PID_C                " PID-C: "
+	#define MSG_ACC                  " Acc:"
+	#define MSG_VXY_JERK             " Vxy-jerk: "
+	#define MSG_VMAX                 " Vmax "
+	#define MSG_X                    "x:"
+	#define MSG_Y                    "y:"
+	#define MSG_Z                    "z:"
+	#define MSG_E                    "e:"
+	#define MSG_VMIN                 " Vmin:"
+	#define MSG_VTRAV_MIN            " VTrav min:"
+	#define MSG_AMAX                 " Amax "
+	#define MSG_A_RETRACT            " A-ritrai:"
+	#define MSG_XSTEPS               " Xpassi/mm:"
+	#define MSG_YSTEPS               " Ypassi/mm:"
+	#define MSG_ZSTEPS               " Zpassi/mm:"
+	#define MSG_ESTEPS               " Epassi/mm:"
+	#define MSG_MAIN_WIDE            " Menu Principale        \003"
+	#define MSG_RECTRACT_WIDE        " Ritrai    \x7E"
+	#define MSG_TEMPERATURE_WIDE     " Temperatura \x7E"
+	#define MSG_TEMPERATURE_RTN      " Temperatura  \003"
+	#define MSG_MOTION_WIDE          " Movimento      \x7E"
+	#define MSG_STORE_EPROM          " Salva in memoria"
+	#define MSG_LOAD_EPROM           " Carica dalla memoria"
+	#define MSG_RESTORE_FAILSAFE     " Configurazioni di default"
+	#define MSG_REFRESH              "\004Aggiorna"
+	#define MSG_WATCH                " Guarda   \003"
+	#define MSG_PREPARE              " Prepara \x7E"
+	#define MSG_PREPARE_ALT          " Prepara \003"
+	#define MSG_CONTROL_ARROW        " Controllo \x7E"
+	#define MSG_RETRACT_ARROW        " Ritrai \x7E"
+	#define MSG_TUNE                 " Tune    \x7E"
+	#define MSG_PAUSE_PRINT          " Metti in Pausa la Stampa \x7E"
+	#define MSG_RESUME_PRINT         " Riprendi Stampa \x7E"
+	#define MSG_STOP_PRINT           " Arresta Stampa   \x7E"
+	#define MSG_CARD_MENU            " Card Menu    \x7E"
+	#define MSG_NO_CARD              " No Card"
+	#define MSG_DWELL                " Sospensione..."
+	#define MSG_USERWAIT             "Attendi utente..."
+	#define MSG_NO_MOVE              "Nessun movimento."
+	#define MSG_PART_RELEASE         "Rilascio Parziale"
+	#define MSG_KILLED               "UCCISO. "
+	#define MSG_STOPPED              "ARRESTATO. "
+	#define MSG_STEPPER_RELEASED     "Rilasciato."
+	#define MSG_CONTROL_RETRACT      " Ritrai mm:"
+	#define MSG_CONTROL_RETRACTF     " Ritrai  F:"
+	#define MSG_CONTROL_RETRACT_ZLIFT " Salta mm:"
+	#define MSG_CONTROL_RETRACT_RECOVER " UnRet +mm:"
+	#define MSG_CONTROL_RETRACT_RECOVERF " UnRet  F:"
+	#define MSG_AUTORETRACT          " AutoRilascio.:"
+	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Qualcosa non va in MenuStructure."
+
+	// Serial Console Messages
+
+	#define MSG_Enqueing             "accodamento \""
+	#define MSG_POWERUP              "Accensione"
+	#define MSG_EXTERNAL_RESET       " Reset Esterno"
+	#define MSG_BROWNOUT_RESET       " Brown out Reset"
+	#define MSG_WATCHDOG_RESET       " Watchdog Reset"
+	#define MSG_SOFTWARE_RESET       " Software Reset"
+	#define MSG_MARLIN               "Marlin "
+	#define MSG_AUTHOR               " | Autore: "
+	#define MSG_CONFIGURATION_VER    " Ultimo Aggiornamento: "
+	#define MSG_FREE_MEMORY          " Memoria Libera: "
+	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
+	#define MSG_OK                   "ok"
+	#define MSG_FILE_SAVED           "File Salvato."
+	#define MSG_ERR_LINE_NO          "Il Numero della Linea non corrisponde al Numero dell'Ultima Linea+1, Ultima Linea:"
+	#define MSG_ERR_CHECKSUM_MISMATCH "checksum non corrispondente, Ultima Linea:"
+	#define MSG_ERR_NO_CHECKSUM      "Nessun Checksum con Numero di Linea, Ultima Linea:"
+	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Nessun Numero di Linea con Checksum, Ultima Linea:"
+	#define MSG_FILE_PRINTED         "File stampato"
+	#define MSG_BEGIN_FILE_LIST      "Inizio Lista File"
+	#define MSG_END_FILE_LIST        "Fine Lista File"
+	#define MSG_M104_INVALID_EXTRUDER "M104 Estrusore non valido "
+	#define MSG_M105_INVALID_EXTRUDER "M105 Estrusore non valido "
+	#define MSG_ERR_NO_THERMISTORS   "Nessun Termistore - nessuna temperatura"
+	#define MSG_M109_INVALID_EXTRUDER "M109 Estrusore non valido "
+	#define MSG_HEATING              "Riscaldamento..."
+	#define MSG_HEATING_COMPLETE     "Riscaldamento concluso."
+	#define MSG_BED_HEATING          "Riscaldamento Piatto."
+	#define MSG_BED_DONE             "Piatto Pronto."
+	#define MSG_M115_REPORT          "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
+	#define MSG_COUNT_X              " Calcola X:"
+	#define MSG_ERR_KILLED           "Stampante Calda. kill() chiamata !!"
+	#define MSG_ERR_STOPPED          "Stampante fermata a causa di errori. Risolvi l'errore e usa M999 per ripartire!. (Reset temperatura. Impostala prima di ripartire)"
+	#define MSG_RESEND               "Reinviato:"
+	#define MSG_UNKNOWN_COMMAND      "Comando sconosciuto:\""
+	#define MSG_ACTIVE_EXTRUDER      "Attiva Estrusore: "
+	#define MSG_INVALID_EXTRUDER     "Estrusore non valido"
+	#define MSG_X_MIN                "x_min: "
+	#define MSG_X_MAX                "x_max: "
+	#define MSG_Y_MIN                "y_min: "
+	#define MSG_Y_MAX                "y_max: "
+	#define MSG_Z_MIN                "z_min: "
+	#define MSG_Z_MAX                "z_max: "
+	#define MSG_M119_REPORT          "Segnalazione stato degli endstop"
+	#define MSG_ENDSTOP_HIT          "INNESCATO"
+	#define MSG_ENDSTOP_OPEN         "aperto"
+
+	#define MSG_SD_CANT_OPEN_SUBDIR  "Impossibile aprire sottocartella"
+	#define MSG_SD_INIT_FAIL         "Fallita Inizializzazione SD"
+	#define MSG_SD_VOL_INIT_FAIL     "Fallito il montaggio del Volume"
+	#define MSG_SD_OPENROOT_FAIL     "Fallita l'apertura Cartella Principale"
+	#define MSG_SD_CARD_OK           "SD card ok"
+	#define MSG_SD_WORKDIR_FAIL      "Fallita l'apertura Cartella di Lavoro"
+	#define MSG_SD_OPEN_FILE_FAIL    "Fallita l'apertura del File: "
+	#define MSG_SD_FILE_OPENED       "File aperto:"
+	#define MSG_SD_SIZE              " Dimensione:"
+	#define MSG_SD_FILE_SELECTED     "File selezionato"
+	#define MSG_SD_WRITE_TO_FILE     "Scrittura su file: "
+	#define MSG_SD_PRINTING_BYTE     "Si sta scrivendo il byte su SD "
+	#define MSG_SD_NOT_PRINTING      "Non si sta scrivendo su SD"
+	#define MSG_SD_ERR_WRITE_TO_FILE "Errore nella scrittura su file"
+	#define MSG_SD_CANT_ENTER_SUBDIR "Impossibile entrare nella sottocartella:"
+
+	#define MSG_STEPPER_TO_HIGH      "Steprate troppo alto : "
+	#define MSG_ENDSTOPS_HIT         "Raggiunto il fondo carrello: "
+	#define MSG_ERR_COLD_EXTRUDE_STOP " prevenuta estrusione fredda"
+	#define MSG_ERR_LONG_EXTRUDE_STOP " prevenuta estrusione troppo lunga"
+
+#endif
+
+
+#if LANGUAGE_CHOICE == 8
+
+// LCD Menu Messages
+	#define WELCOME_MSG MACHINE_NAME " Pronta."
+	#define MSG_SD_INSERTED "Cartao SD inserido"
+	#define MSG_SD_REMOVED "Cartao SD removido"
+	#define MSG_MAIN " Menu Principal \003"
+	#define MSG_AUTOSTART " Autostart"
+	#define MSG_DISABLE_STEPPERS " Apagar Motores"
+	#define MSG_AUTO_HOME " Ir para Origen"
+	#define MSG_SET_ORIGIN " Estabelecer Origen"
+	#define MSG_PREHEAT_PLA " pre-aquecer PLA"
+	#define MSG_PREHEAT_PLA_SETTINGS " pre-aquecer PLA Setting"
+	#define MSG_PREHEAT_ABS " pre-aquecer ABS"
+	#define MSG_PREHEAT_ABS_SETTINGS " pre-aquecer ABS Setting"
+	#define MSG_COOLDOWN " Esfriar"
+	#define MSG_EXTRUDE " Extrudar"
+	#define MSG_RETRACT " Retrair"
+	#define MSG_PREHEAT_PLA " pre-aquecer PLA"
+	#define MSG_PREHEAT_ABS " pre-aquecer ABS"
+	#define MSG_MOVE_AXIS " Mover eixo      \x7E"
+	#define MSG_SPEED " Velocidade:"
+	#define MSG_NOZZLE " \002Nozzle:"
+	#define MSG_NOZZLE1 " \002Nozzle2:"
+	#define MSG_NOZZLE2 " \002Nozzle3:"
+	#define MSG_BED " \002Base:"
+	#define MSG_FAN_SPEED " Velocidade Ventoinha:"
+	#define MSG_FLOW " Fluxo:"
+	#define MSG_CONTROL " Controle \003"
+	#define MSG_MIN " \002 Min:"
+	#define MSG_MAX " \002 Max:"
+	#define MSG_FACTOR " \002 Fact:"
+	#define MSG_AUTOTEMP " Autotemp:"
+	#define MSG_ON "On "
+	#define MSG_OFF "Off"
+	#define MSG_PID_P " PID-P: "
+	#define MSG_PID_I " PID-I: "
+	#define MSG_PID_D " PID-D: "
+	#define MSG_PID_C " PID-C: "
+	#define MSG_ACC  " Acc:"
+	#define MSG_VXY_JERK " Vxy-jerk: "
+	#define MSG_VMAX " Vmax "
+	#define MSG_X "x:"
+	#define MSG_Y "y:"
+	#define MSG_Z "z:"
+	#define MSG_E "e:"
+	#define MSG_VMIN " Vmin:"
+	#define MSG_VTRAV_MIN " VTrav min:"
+	#define MSG_AMAX " Amax "
+	#define MSG_A_RETRACT " A-retract:"
+	#define MSG_XSTEPS " Xpasso/mm:"
+	#define MSG_YSTEPS " Ypasso/mm:"
+	#define MSG_ZSTEPS " Zpasso/mm:"
+	#define MSG_ESTEPS " Epasso/mm:"
+	#define MSG_MAIN_WIDE " Menu Principal  \003"
+	#define MSG_RECTRACT_WIDE " Retrair    \x7E"
+	#define MSG_TEMPERATURE_WIDE " Temperatura \x7E"
+	#define MSG_TEMPERATURE_RTN " Temperatura  \003"
+	#define MSG_MOTION_WIDE " Movimento     \x7E"
+	#define MSG_STORE_EPROM " Guardar memoria"
+	#define MSG_LOAD_EPROM " Carregar memoria"
+	#define MSG_RESTORE_FAILSAFE " Rest. de emergencia"
+	#define MSG_REFRESH "\004Recarregar"
+	#define MSG_WATCH " Monitorar   \003"
+	#define MSG_PREPARE " Preparar \x7E"
+	#define MSG_PREPARE_ALT " Preparar \003"
+	#define MSG_CONTROL_ARROW " Controle \x7E"
+	#define MSG_RETRACT_ARROW " Retrair \x7E"
+	#define MSG_TUNE " Tune    \x7E"
+	#define MSG_PAUSE_PRINT " Pausar Impressao \x7E"
+	#define MSG_RESUME_PRINT " Resumir Impressao \x7E"
+	#define MSG_STOP_PRINT " Parar Impressao   \x7E"
+	#define MSG_CARD_MENU " Menu cartao SD    \x7E"
+	#define MSG_NO_CARD " Sem cartao SD"
+	#define MSG_DWELL "Repouso..."
+	#define MSG_USERWAIT "Esperando Ordem..."
+	#define MSG_NO_MOVE "Sem movimento."
+	#define MSG_PART_RELEASE "Lancamento Parcial"
+	#define MSG_KILLED "PARADA DE EMERGENCIA. "
+	#define MSG_STOPPED "PARADA. "
+	#define MSG_STEPPER_RELEASED "Lancado."
+	#define MSG_CONTROL_RETRACT  " Retrair mm:"
+	#define MSG_CONTROL_RETRACTF " Retrair  F:"
+	#define MSG_CONTROL_RETRACT_ZLIFT " Levantar mm:"
+	#define MSG_CONTROL_RETRACT_RECOVER " DesRet +mm:"
+	#define MSG_CONTROL_RETRACT_RECOVERF " DesRet  F:"
+	#define MSG_AUTORETRACT " AutoRetr.:"
+        #define MSG_SERIAL_ERROR_MENU_STRUCTURE "Algo esta errado na estrutura do Menu."
+
+// Serial Console Messages
+
+	#define MSG_Enqueing "enqueing \""
+	#define MSG_POWERUP "PowerUp"
+	#define MSG_EXTERNAL_RESET " Reset Externo"
+	#define MSG_BROWNOUT_RESET " Reset por voltagem incorreta"
+	#define MSG_WATCHDOG_RESET " Reset por Bloqueio"
+	#define MSG_SOFTWARE_RESET " Reset por Software"
+	#define MSG_MARLIN "Marlin "
+	#define MSG_AUTHOR " | Author: "
+	#define MSG_CONFIGURATION_VER " Ultima atualizacao: "
+	#define MSG_FREE_MEMORY " memoria Livre: "
+	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
+	#define MSG_OK "ok"
+	#define MSG_FILE_SAVED "Guardado."
+	#define MSG_ERR_LINE_NO "O Numero da linha Nao e igual ao ultimo Numero da linha+1, Ultima linha:"
+	#define MSG_ERR_CHECKSUM_MISMATCH "O checksum Nao coincide, Ultima linha:"
+	#define MSG_ERR_NO_CHECKSUM "Nao foi possivel encontrar o checksum com o numero da linha, Ultima linha :"
+	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Nao ha o numero da linha com o checksum, Ultima linha:"
+	#define MSG_FILE_PRINTED "Impressao terminada"
+	#define MSG_BEGIN_FILE_LIST "Começo da lista de arquivos"
+	#define MSG_END_FILE_LIST "Fim da lista de arquivos"
+	#define MSG_M104_INVALID_EXTRUDER "M104 Extrusor inválido "
+	#define MSG_M105_INVALID_EXTRUDER "M105 Extrusor inválido "
+	#define MSG_ERR_NO_THERMISTORS "Nao ha termistor - no temp"
+	#define MSG_M109_INVALID_EXTRUDER "M109 Extrusor inválido "
+	#define MSG_HEATING "Aquecendo..."
+	#define MSG_HEATING_COMPLETE "Aquecido."
+	#define MSG_BED_HEATING "Aquecendo a Base."
+	#define MSG_BED_DONE "Base quente."
+	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
+	#define MSG_COUNT_X " Conta X:"
+	#define MSG_ERR_KILLED "Impressora parada com kill() !!"
+	#define MSG_ERR_STOPPED "Impressora parada por erros. Coserte o erro e use M999 para recomeçar!. (Temperatura reiniciada. Ajuste antes de recomeçar)"
+	#define MSG_RESEND "Reenviar:"
+	#define MSG_UNKNOWN_COMMAND "Comando desconhecido:\""
+	#define MSG_ACTIVE_EXTRUDER "Extrusor ativo: "
+	#define MSG_INVALID_EXTRUDER "Extrusor invalido"
+	#define MSG_X_MIN "x_min: "
+	#define MSG_X_MAX "x_max: "
+	#define MSG_Y_MIN "y_min: "
+	#define MSG_Y_MAX "y_max: "
+	#define MSG_Z_MIN "z_min: "
+	#define MSG_Z_MAX "z_max: "
+	#define MSG_M119_REPORT "Relatando estado do ponto final"
+	#define MSG_ENDSTOP_HIT "PULSADO"
+	#define MSG_ENDSTOP_OPEN "Aberto"
+
+	#define MSG_SD_CANT_OPEN_SUBDIR "Nao pode abrir sub diretorio"
+	#define MSG_SD_INIT_FAIL "Falha ao iniciar SD"
+	#define MSG_SD_VOL_INIT_FAIL "Falha ao montar volume"
+	#define MSG_SD_OPENROOT_FAIL "Falha ao abrir diretorio raiz"
+	#define MSG_SD_CARD_OK "cartao SD ok"
+	#define MSG_SD_WORKDIR_FAIL "Falha ao abrir diretorio de trabalho"
+	#define MSG_SD_OPEN_FILE_FAIL "Erro ao abrir, Arquivo: "
+	#define MSG_SD_FILE_OPENED "Arquivo aberto:"
+	#define MSG_SD_SIZE " Size:"
+	#define MSG_SD_FILE_SELECTED "Arquivo selecionado"
+	#define MSG_SD_WRITE_TO_FILE "Escrevendo no arquivo: "
+	#define MSG_SD_PRINTING_BYTE "SD imprimindo o byte "
+	#define MSG_SD_NOT_PRINTING "Nao esta se imprimindo com o SD"
+	#define MSG_SD_ERR_WRITE_TO_FILE "Erro ao escrever no arquivo"
+	#define MSG_SD_CANT_ENTER_SUBDIR "Nao pode abrir o sub diretorio:"
+
+	#define MSG_STEPPER_TO_HIGH "Steprate muito alto : "
+	#define MSG_ENDSTOPS_HIT "O ponto final foi tocado: "
+	#define MSG_ERR_COLD_EXTRUDE_STOP " Extrusao a frio evitada"
+	#define MSG_ERR_LONG_EXTRUDE_STOP " Extrusao muito larga evitada"
+
+
+#endif
+
 #endif // ifndef LANGUAGE_H
diff --git a/Marlin/pins.h b/Marlin/pins.h
index d16fd26..2ac7ef9 100644
--- a/Marlin/pins.h
+++ b/Marlin/pins.h
@@ -57,16 +57,11 @@
 #endif /* 99 */
 
 /****************************************************************************************
-* Gen7 v1.1, v1.2, v1.3, v1.4 pin assignment
+* Gen7 v1.1, v1.2, v1.3 pin assignment
 *
 ****************************************************************************************/
 
 
-#if MOTHERBOARD == 13
-#define MOTHERBOARD 11
-#define GEN7_VERSION 14 // v1.4
-#endif
-
 #if MOTHERBOARD == 12
 #define MOTHERBOARD 11
 #define GEN7_VERSION 13 // v1.3
@@ -120,6 +115,7 @@
 #define HEATER_2_PIN -1
 #define HEATER_BED_PIN 3
 
+#define KILL_PIN -1
 
 #define SDPOWER -1
 #define SDSS -1 // SCL pin of I2C header
@@ -133,12 +129,86 @@
 #endif
 #define PS_ON_PIN 15
 
-#if (GEN7_VERSION < 14)
-// Gen 1.3 and earlier supplied thermistor power via PS_ON
-// Need to ignore the bad thermistor readings on those units
+//All these generations of Gen7 supply thermistor power
+//via PS_ON, so ignore bad thermistor readings
 #define BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE
+
+//our pin for debugging.
+#define DEBUG_PIN 0
+
+//our RS485 pins
+#define TX_ENABLE_PIN 12
+#define RX_ENABLE_PIN 13
+
+#endif
+
+/****************************************************************************************
+* Gen7 v1.4 pin assignment
+*
+****************************************************************************************/
+
+#if MOTHERBOARD == 13
+#define GEN7_VERSION 14 // v1.4
+#endif
+
+#if MOTHERBOARD == 13
+#define KNOWN_BOARD
+
+#if !defined(__AVR_ATmega644P__) && !defined(__AVR_ATmega644__) && !defined(__AVR_ATmega1284P__)
+#error Oops! Make sure you have 'Gen7' selected from the 'Tools -> Boards' menu.
+
 #endif
 
+#ifndef GEN7_VERSION
+#define GEN7_VERSION 14 // v1.x
+#endif
+
+//x axis pins
+#define X_STEP_PIN 29
+#define X_DIR_PIN 28
+#define X_ENABLE_PIN 25
+#define X_MIN_PIN 0
+#define X_MAX_PIN -1
+
+//y axis pins
+#define Y_STEP_PIN 27
+#define Y_DIR_PIN 26
+#define Y_ENABLE_PIN 25
+#define Y_MIN_PIN 1
+#define Y_MAX_PIN -1
+
+//z axis pins
+#define Z_STEP_PIN 23
+#define Z_DIR_PIN 22
+#define Z_ENABLE_PIN 25
+#define Z_MIN_PIN 2
+#define Z_MAX_PIN -1
+
+//extruder pins
+#define E0_STEP_PIN 19
+#define E0_DIR_PIN 18
+#define E0_ENABLE_PIN 25
+
+#define TEMP_0_PIN 0
+#define TEMP_1_PIN -1
+#define TEMP_2_PIN -1
+#define TEMP_BED_PIN 1
+
+#define HEATER_0_PIN 4
+#define HEATER_1_PIN -1
+#define HEATER_2_PIN -1
+#define HEATER_BED_PIN 3
+
+#define KILL_PIN -1
+
+#define SDPOWER -1
+#define SDSS -1 // SCL pin of I2C header
+#define LED_PIN -1
+
+#define FAN_PIN -1
+
+#define PS_ON_PIN 15
+
 //our pin for debugging.
 #define DEBUG_PIN 0
 
@@ -218,6 +288,7 @@
 	#define SDCARDDETECT -1 		
     #define SUICIDE_PIN -1						//has to be defined; otherwise Power_off doesn't work
 	
+    #define KILL_PIN -1
 	//Pins for 4bit LCD Support 
     #define LCD_PINS_RS 18 
     #define LCD_PINS_ENABLE 17
@@ -301,7 +372,12 @@
 #define FAN_PIN            4 // IO pin. Buffer needed
 #endif
 #define PS_ON_PIN          12
+
+#ifdef REPRAP_DISCOUNT_SMART_CONTROLLER
+#define KILL_PIN           41
+#else
 #define KILL_PIN           -1
+#endif
 
 #define HEATER_0_PIN       10   // EXTRUDER 1
 #if MOTHERBOARD == 33
@@ -319,8 +395,15 @@
 #ifdef ULTRA_LCD
 
   #ifdef NEWPANEL
-  //arduino pin which triggers an piezzo beeper
-    #define BEEPER 33			// Beeper on AUX-4
+     //encoder rotation values
+    #define encrot0 0
+    #define encrot1 2
+    #define encrot2 3
+    #define encrot3 1
+
+    #define BLEN_A 0
+    #define BLEN_B 1
+    #define BLEN_C 2
 
     #define LCD_PINS_RS 16 
     #define LCD_PINS_ENABLE 17
@@ -329,22 +412,25 @@
     #define LCD_PINS_D6 27
     #define LCD_PINS_D7 29
     
-    //buttons are directly attached using AUX-2
-    #define BTN_EN1 37
-    #define BTN_EN2 35
-    #define BTN_ENC 31  //the click
-    
-    #define BLEN_C 2
-    #define BLEN_B 1
-    #define BLEN_A 0
-    
-    #define SDCARDDETECT -1		// Ramps does not use this port
-    
-      //encoder rotation values
-    #define encrot0 0
-    #define encrot1 2
-    #define encrot2 3
-    #define encrot3 1
+    #ifdef REPRAP_DISCOUNT_SMART_CONTROLLER
+      #define BEEPER 37
+
+      #define BTN_EN1 31
+      #define BTN_EN2 33
+      #define BTN_ENC 35
+
+      #define SDCARDDETECT 49
+    #else
+      //arduino pin which triggers an piezzo beeper
+      #define BEEPER 33	 // Beeper on AUX-4
+
+      //buttons are directly attached using AUX-2
+      #define BTN_EN1 37
+      #define BTN_EN2 35
+      #define BTN_ENC 31  //the click
+
+      #define SDCARDDETECT -1  // Ramps does not use this port
+    #endif
 
   #else //old style panel with shift register
     //arduino pin witch triggers an piezzo beeper
@@ -385,7 +471,7 @@
   #endif 
 #endif //ULTRA_LCD
 
-#else // RAMPS_V_1_1 or RAMPS_V_1_2 as default
+#else // RAMPS_V_1_1 or RAMPS_V_1_2 as default (MOTHERBOARD == 3)
 
 #define X_STEP_PIN         26
 #define X_DIR_PIN          28
@@ -430,7 +516,7 @@
 #define TEMP_1_PIN          -1   
 #define TEMP_2_PIN          -1   
 #define TEMP_BED_PIN        1    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
-#endif
+#endif// MOTHERBOARD == 33 || MOTHERBOARD == 34
 
 // SPI for Max6675 Thermocouple 
 
@@ -444,7 +530,7 @@
   #define MAX6675_SS       49
 #endif
 
-#endif
+#endif//MOTHERBOARD == 3 || MOTHERBOARD == 33 || MOTHERBOARD == 34
 
 /****************************************************************************************
 * Duemilanove w/ ATMega328P pin assignment
@@ -555,6 +641,7 @@
     #define LED_PIN         -1    //changed @ rkoeppl 20110410
     #define FAN_PIN         -1    //changed @ rkoeppl 20110410
     #define PS_ON_PIN       -1    //changed @ rkoeppl 20110410
+    #define KILL_PIN        -1    //changed @ drakelive 20120830
     //our pin for debugging.
     
     #define DEBUG_PIN        0
@@ -933,7 +1020,7 @@
 *
 ****************************************************************************************/
 #if MOTHERBOARD == 9
-#define MOTHERBOARD 6
+#define MOTHERBOARD 6   /*TODO: Figure out, Why is this done?*/
 #define KNOWN_BOARD 1
 #ifndef __AVR_ATmega644P__
 #ifndef __AVR_ATmega1284P__
@@ -1211,6 +1298,109 @@
 
 #endif
 
+/****************************************************************************************
+* MegaTronics
+*
+****************************************************************************************/
+#if MOTHERBOARD == 70
+#define KNOWN_BOARD 1
+
+//////////////////FIX THIS//////////////
+
+ #ifndef __AVR_ATmega2560__
+ #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -> Boards' menu.
+ #endif
+
+
+
+
+#define X_STEP_PIN         26
+#define X_DIR_PIN          28
+#define X_ENABLE_PIN       24
+#define X_MIN_PIN          41
+#define X_MAX_PIN          37   //2 //Max endstops default to disabled "-1", set to commented value to enable.
+
+#define Y_STEP_PIN         60 // A6
+#define Y_DIR_PIN          61 // A7
+#define Y_ENABLE_PIN       22
+#define Y_MIN_PIN          14
+#define Y_MAX_PIN          15   //15
+
+#define Z_STEP_PIN         54 // A0
+#define Z_DIR_PIN          55 // A1
+#define Z_ENABLE_PIN       56 // A2
+#define Z_MIN_PIN          18
+#define Z_MAX_PIN          19
+
+#define E0_STEP_PIN        31
+#define E0_DIR_PIN         32
+#define E0_ENABLE_PIN      38
+
+#define E1_STEP_PIN        34
+#define E1_DIR_PIN         36
+#define E1_ENABLE_PIN      30
+
+#define SDPOWER            -1
+#define SDSS               53
+#define LED_PIN            13
+
+
+#define FAN_PIN            7 // IO pin. Buffer needed
+#define PS_ON_PIN          12
+#define KILL_PIN           -1
+
+#define HEATER_0_PIN       9    // EXTRUDER 1
+#define HEATER_1_PIN       8    // EXTRUDER 2 (FAN On Sprinter)
+#define HEATER_2_PIN       -1  
+
+#if TEMP_SENSOR_0 == -1 
+#define TEMP_0_PIN         8   // ANALOG NUMBERING
+#else
+#define TEMP_0_PIN         13   // ANALOG NUMBERING
+
+#endif
+
+#define TEMP_1_PIN         15   // ANALOG NUMBERING
+#define TEMP_2_PIN         -1   // ANALOG NUMBERING
+#define HEATER_BED_PIN     10   // BED
+#define TEMP_BED_PIN       14   // ANALOG NUMBERING
+
+#define BEEPER 33			// Beeper on AUX-4
+
+
+#ifdef ULTRA_LCD
+
+  #ifdef NEWPANEL
+  //arduino pin which triggers an piezzo beeper
+    
+    #define LCD_PINS_RS 16 
+    #define LCD_PINS_ENABLE 17
+    #define LCD_PINS_D4 23
+    #define LCD_PINS_D5 25 
+    #define LCD_PINS_D6 27
+    #define LCD_PINS_D7 29
+    
+    //buttons are directly attached using AUX-2
+    #define BTN_EN1 37
+    #define BTN_EN2 35
+    #define BTN_ENC 43  //the click
+    
+    #define BLEN_C 2
+    #define BLEN_B 1
+    #define BLEN_A 0
+    
+    #define SDCARDDETECT -1		// Ramps does not use this port
+    
+      //encoder rotation values
+    #define encrot0 0
+    #define encrot1 2
+    #define encrot2 3
+    #define encrot3 1
+#endif
+#endif //ULTRA_LCD
+
+#endif
+
 #ifndef KNOWN_BOARD
 #error Unknown MOTHERBOARD value in configuration.h
 #endif
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index 6c47e29..161e1b4 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -103,12 +103,11 @@ volatile unsigned char block_buffer_tail;           // Index of the block to pro
 bool allow_cold_extrude=false;
 #endif
 #ifdef XY_FREQUENCY_LIMIT
+#define MAX_FREQ_TIME (1000000.0/XY_FREQUENCY_LIMIT)
 // Used for the frequency limit
 static unsigned char old_direction_bits = 0;               // Old direction bits. Used for speed calculations
-static long x_segment_time[3]={
-  0,0,0};                     // Segment times (in us). Used for speed calculations
-static long y_segment_time[3]={
-  0,0,0};
+static long x_segment_time[3]={MAX_FREQ_TIME + 1,0,0};     // Segment times (in us). Used for speed calculations
+static long y_segment_time[3]={MAX_FREQ_TIME + 1,0,0};
 #endif
 
 // Returns the index of the next block in the ring buffer
@@ -191,10 +190,9 @@ void calculate_trapezoid_for_block(block_t *block, float entry_factor, float exi
   // have to use intersection_distance() to calculate when to abort acceleration and start braking
   // in order to reach the final_rate exactly at the end of this block.
   if (plateau_steps < 0) {
-    accelerate_steps = ceil(
-    intersection_distance(block->initial_rate, block->final_rate, acceleration, block->step_event_count));
+    accelerate_steps = ceil(intersection_distance(block->initial_rate, block->final_rate, acceleration, block->step_event_count));
     accelerate_steps = max(accelerate_steps,0); // Check limits due to numerical round-off
-    accelerate_steps = min(accelerate_steps,block->step_event_count);
+    accelerate_steps = min((uint32_t)accelerate_steps,block->step_event_count);//(We can cast here to unsigned, because the above line ensures that we are above zero)
     plateau_steps = 0;
   }
 
@@ -436,7 +434,8 @@ void getHighESpeed()
 }
 #endif
 
-void check_axes_activity() {
+void check_axes_activity()
+{
   unsigned char x_active = 0;
   unsigned char y_active = 0;  
   unsigned char z_active = 0;
@@ -445,10 +444,12 @@ void check_axes_activity() {
   unsigned char tail_fan_speed = 0;
   block_t *block;
 
-  if(block_buffer_tail != block_buffer_head) {
+  if(block_buffer_tail != block_buffer_head)
+  {
     uint8_t block_index = block_buffer_tail;
     tail_fan_speed = block_buffer[block_index].fan_speed;
-    while(block_index != block_buffer_head) {
+    while(block_index != block_buffer_head)
+    {
       block = &block_buffer[block_index];
       if(block->steps_x != 0) x_active++;
       if(block->steps_y != 0) y_active++;
@@ -458,27 +459,31 @@ void check_axes_activity() {
       block_index = (block_index+1) & (BLOCK_BUFFER_SIZE - 1);
     }
   }
-  else {
-#if FAN_PIN > -1
+  else
+  {
+    #if FAN_PIN > -1
     if (FanSpeed != 0){
       analogWrite(FAN_PIN,FanSpeed); // If buffer is empty use current fan speed
     }
-#endif
+    #endif
   }
   if((DISABLE_X) && (x_active == 0)) disable_x();
   if((DISABLE_Y) && (y_active == 0)) disable_y();
   if((DISABLE_Z) && (z_active == 0)) disable_z();
-  if((DISABLE_E) && (e_active == 0)) { 
+  if((DISABLE_E) && (e_active == 0))
+  {
     disable_e0();
     disable_e1();
     disable_e2(); 
   }
 #if FAN_PIN > -1
-  if((FanSpeed == 0) && (fan_speed ==0)) {
+  if((FanSpeed == 0) && (fan_speed ==0))
+  {
     analogWrite(FAN_PIN, 0);
   }
 
-  if (FanSpeed != 0 && tail_fan_speed !=0) { 
+  if (FanSpeed != 0 && tail_fan_speed !=0)
+  {
     analogWrite(FAN_PIN,tail_fan_speed);
   }
 #endif
@@ -499,7 +504,8 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
 
   // If the buffer is full: good! That means we are well ahead of the robot. 
   // Rest here until there is room in the buffer.
-  while(block_buffer_tail == next_buffer_head) { 
+  while(block_buffer_tail == next_buffer_head)
+  {
     manage_heater(); 
     manage_inactivity(); 
     LCD_STATUS;
@@ -514,23 +520,26 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
   target[Z_AXIS] = lround(z*axis_steps_per_unit[Z_AXIS]);     
   target[E_AXIS] = lround(e*axis_steps_per_unit[E_AXIS]);
 
-#ifdef PREVENT_DANGEROUS_EXTRUDE
+  #ifdef PREVENT_DANGEROUS_EXTRUDE
   if(target[E_AXIS]!=position[E_AXIS])
+  {
     if(degHotend(active_extruder)<EXTRUDE_MINTEMP && !allow_cold_extrude)
     {
       position[E_AXIS]=target[E_AXIS]; //behave as if the move really took place, but ignore E part
       SERIAL_ECHO_START;
       SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
     }
-#ifdef PREVENT_LENGTHY_EXTRUDE
-  if(labs(target[E_AXIS]-position[E_AXIS])>axis_steps_per_unit[E_AXIS]*EXTRUDE_MAXLENGTH)
-  {
-    position[E_AXIS]=target[E_AXIS]; //behave as if the move really took place, but ignore E part
-    SERIAL_ECHO_START;
-    SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
+    
+    #ifdef PREVENT_LENGTHY_EXTRUDE
+    if(labs(target[E_AXIS]-position[E_AXIS])>axis_steps_per_unit[E_AXIS]*EXTRUDE_MAXLENGTH)
+    {
+      position[E_AXIS]=target[E_AXIS]; //behave as if the move really took place, but ignore E part
+      SERIAL_ECHO_START;
+      SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
+    }
+    #endif
   }
-#endif
-#endif
+  #endif
 
   // Prepare to set up new block
   block_t *block = &block_buffer[block_buffer_head];
@@ -548,24 +557,29 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
   block->step_event_count = max(block->steps_x, max(block->steps_y, max(block->steps_z, block->steps_e)));
 
   // Bail if this is a zero-length block
-  if (block->step_event_count <= dropsegments) { 
+  if (block->step_event_count <= dropsegments)
+  { 
     return; 
-  };
+  }
 
   block->fan_speed = FanSpeed;
 
   // Compute direction bits for this block 
   block->direction_bits = 0;
-  if (target[X_AXIS] < position[X_AXIS]) { 
+  if (target[X_AXIS] < position[X_AXIS])
+  {
     block->direction_bits |= (1<<X_AXIS); 
   }
-  if (target[Y_AXIS] < position[Y_AXIS]) { 
+  if (target[Y_AXIS] < position[Y_AXIS])
+  {
     block->direction_bits |= (1<<Y_AXIS); 
   }
-  if (target[Z_AXIS] < position[Z_AXIS]) { 
+  if (target[Z_AXIS] < position[Z_AXIS])
+  {
     block->direction_bits |= (1<<Z_AXIS); 
   }
-  if (target[E_AXIS] < position[E_AXIS]) { 
+  if (target[E_AXIS] < position[E_AXIS])
+  {
     block->direction_bits |= (1<<E_AXIS); 
   }
 
@@ -579,16 +593,19 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
 #endif
 
   // Enable all
-  if(block->steps_e != 0) { 
+  if(block->steps_e != 0)
+  {
     enable_e0();
     enable_e1();
     enable_e2(); 
   }
 
-  if (block->steps_e == 0) {
+  if (block->steps_e == 0)
+  {
     if(feed_rate<mintravelfeedrate) feed_rate=mintravelfeedrate;
   }
-  else {
+  else
+  {
     if(feed_rate<minimumfeedrate) feed_rate=minimumfeedrate;
   } 
 
@@ -597,10 +614,12 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
   delta_mm[Y_AXIS] = (target[Y_AXIS]-position[Y_AXIS])/axis_steps_per_unit[Y_AXIS];
   delta_mm[Z_AXIS] = (target[Z_AXIS]-position[Z_AXIS])/axis_steps_per_unit[Z_AXIS];
   delta_mm[E_AXIS] = ((target[E_AXIS]-position[E_AXIS])/axis_steps_per_unit[E_AXIS])*extrudemultiply/100.0;
-  if ( block->steps_x <=dropsegments && block->steps_y <=dropsegments && block->steps_z <=dropsegments ) {
+  if ( block->steps_x <=dropsegments && block->steps_y <=dropsegments && block->steps_z <=dropsegments )
+  {
     block->millimeters = fabs(delta_mm[E_AXIS]);
   } 
-  else {
+  else
+  {
     block->millimeters = sqrt(square(delta_mm[X_AXIS]) + square(delta_mm[Y_AXIS]) + square(delta_mm[Z_AXIS]));
   }
   float inverse_millimeters = 1.0/block->millimeters;  // Inverse millimeters to remove multiple divides 
@@ -612,15 +631,21 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
 
   // slow down when de buffer starts to empty, rather than wait at the corner for a buffer refill
 #ifdef OLD_SLOWDOWN
-  if(moves_queued < (BLOCK_BUFFER_SIZE * 0.5) && moves_queued > 1) feed_rate = feed_rate*moves_queued / (BLOCK_BUFFER_SIZE * 0.5); 
+  if(moves_queued < (BLOCK_BUFFER_SIZE * 0.5) && moves_queued > 1)
+    feed_rate = feed_rate*moves_queued / (BLOCK_BUFFER_SIZE * 0.5); 
 #endif
 
 #ifdef SLOWDOWN
   //  segment time im micro seconds
   unsigned long segment_time = lround(1000000.0/inverse_second);
-  if ((moves_queued > 1) && (moves_queued < (BLOCK_BUFFER_SIZE * 0.5))) {
-    if (segment_time < minsegmenttime)  { // buffer is draining, add extra time.  The amount of time added increases if the buffer is still emptied more.
+  if ((moves_queued > 1) && (moves_queued < (BLOCK_BUFFER_SIZE * 0.5)))
+  {
+    if (segment_time < minsegmenttime)
+    { // buffer is draining, add extra time.  The amount of time added increases if the buffer is still emptied more.
       inverse_second=1000000.0/(segment_time+lround(2*(minsegmenttime-segment_time)/moves_queued));
+      #ifdef XY_FREQUENCY_LIMIT
+         segment_time = lround(1000000.0/inverse_second);
+      #endif
     }
   }
 #endif
@@ -633,7 +658,8 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
   // Calculate and limit speed in mm/sec for each axis
   float current_speed[4];
   float speed_factor = 1.0; //factor <=1 do decrease speed
-  for(int i=0; i < 4; i++) {
+  for(int i=0; i < 4; i++)
+  {
     current_speed[i] = delta_mm[i] * inverse_second;
     if(fabs(current_speed[i]) > max_feedrate[i])
       speed_factor = min(speed_factor, max_feedrate[i] / fabs(current_speed[i]));
@@ -642,23 +668,27 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
   // Max segement time in us.
 #ifdef XY_FREQUENCY_LIMIT
 #define MAX_FREQ_TIME (1000000.0/XY_FREQUENCY_LIMIT)
-
   // Check and limit the xy direction change frequency
   unsigned char direction_change = block->direction_bits ^ old_direction_bits;
   old_direction_bits = block->direction_bits;
-
-  if((direction_change & (1<<X_AXIS)) == 0) {
+  segment_time = lround((float)segment_time / speed_factor);
+  
+  if((direction_change & (1<<X_AXIS)) == 0)
+  {
     x_segment_time[0] += segment_time;
   }
-  else {
+  else
+  {
     x_segment_time[2] = x_segment_time[1];
     x_segment_time[1] = x_segment_time[0];
     x_segment_time[0] = segment_time;
   }
-  if((direction_change & (1<<Y_AXIS)) == 0) {
+  if((direction_change & (1<<Y_AXIS)) == 0)
+  {
     y_segment_time[0] += segment_time;
   }
-  else {
+  else
+  {
     y_segment_time[2] = y_segment_time[1];
     y_segment_time[1] = y_segment_time[0];
     y_segment_time[0] = segment_time;
@@ -666,12 +696,15 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
   long max_x_segment_time = max(x_segment_time[0], max(x_segment_time[1], x_segment_time[2]));
   long max_y_segment_time = max(y_segment_time[0], max(y_segment_time[1], y_segment_time[2]));
   long min_xy_segment_time =min(max_x_segment_time, max_y_segment_time);
-  if(min_xy_segment_time < MAX_FREQ_TIME) speed_factor = min(speed_factor, speed_factor * (float)min_xy_segment_time / (float)MAX_FREQ_TIME);
+  if(min_xy_segment_time < MAX_FREQ_TIME)
+    speed_factor = min(speed_factor, speed_factor * (float)min_xy_segment_time / (float)MAX_FREQ_TIME);
 #endif
 
   // Correct the speed  
-  if( speed_factor < 1.0) {
-    for(unsigned char i=0; i < 4; i++) {
+  if( speed_factor < 1.0)
+  {
+    for(unsigned char i=0; i < 4; i++)
+    {
       current_speed[i] *= speed_factor;
     }
     block->nominal_speed *= speed_factor;
@@ -680,10 +713,12 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
 
   // Compute and limit the acceleration rate for the trapezoid generator.  
   float steps_per_mm = block->step_event_count/block->millimeters;
-  if(block->steps_x == 0 && block->steps_y == 0 && block->steps_z == 0) {
+  if(block->steps_x == 0 && block->steps_y == 0 && block->steps_z == 0)
+  {
     block->acceleration_st = ceil(retract_acceleration * steps_per_mm); // convert to: acceleration steps/sec^2
   }
-  else {
+  else
+  {
     block->acceleration_st = ceil(acceleration * steps_per_mm); // convert to: acceleration steps/sec^2
     // Limit acceleration per axis
     if(((float)block->acceleration_st * (float)block->steps_x / (float)block->step_event_count) > axis_steps_per_sqr_second[X_AXIS])
diff --git a/Marlin/speed_lookuptable.h b/Marlin/speed_lookuptable.h
index 670e744..b7c00f1 100644
--- a/Marlin/speed_lookuptable.h
+++ b/Marlin/speed_lookuptable.h
@@ -75,7 +75,7 @@ const uint16_t speed_lookuptable_slow[256][2] PROGMEM = {\
 { 992, 4}, { 988, 4}, { 984, 4}, { 980, 4}, { 976, 4}, { 972, 4}, { 968, 3}, { 965, 3}
 };
 
-#else
+#elif F_CPU == 20000000
 
 const uint16_t speed_lookuptable_fast[256][2] PROGMEM = {
    {62500, 54055}, {8445, 3917}, {4528, 1434}, {3094, 745}, {2349, 456}, {1893, 307}, {1586, 222}, {1364, 167},
diff --git a/Marlin/stepper.cpp b/Marlin/stepper.cpp
index d302e70..94eaba3 100644
--- a/Marlin/stepper.cpp
+++ b/Marlin/stepper.cpp
@@ -52,8 +52,8 @@ volatile static unsigned long step_events_completed; // The number of step event
 #ifdef ADVANCE
   static long advance_rate, advance, final_advance = 0;
   static long old_advance = 0;
+  static long e_steps[3];
 #endif
-static long e_steps[3];
 static long acceleration_time, deceleration_time;
 //static unsigned long accelerate_until, decelerate_after, acceleration_rate, initial_rate, final_rate, nominal_rate;
 static unsigned short acc_step_rate; // needed for deccelaration start point
diff --git a/Marlin/stepper.h b/Marlin/stepper.h
index f22f513..65c36d4 100644
--- a/Marlin/stepper.h
+++ b/Marlin/stepper.h
@@ -25,7 +25,7 @@
 
 #if EXTRUDERS > 2
   #define WRITE_E_STEP(v) { if(current_block->active_extruder == 2) { WRITE(E2_STEP_PIN, v); } else { if(current_block->active_extruder == 1) { WRITE(E1_STEP_PIN, v); } else { WRITE(E0_STEP_PIN, v); }}}
-  #define NORM_E_DIR() { if(current_block->active_extruder == 2) { WRITE(!E2_DIR_PIN, INVERT_E2_DIR); } else { if(current_block->active_extruder == 1) { WRITE(!E1_DIR_PIN, INVERT_E1_DIR); } else { WRITE(E0_DIR_PIN, !INVERT_E0_DIR); }}}
+  #define NORM_E_DIR() { if(current_block->active_extruder == 2) { WRITE(E2_DIR_PIN, !INVERT_E2_DIR); } else { if(current_block->active_extruder == 1) { WRITE(E1_DIR_PIN, !INVERT_E1_DIR); } else { WRITE(E0_DIR_PIN, !INVERT_E0_DIR); }}}
   #define REV_E_DIR() { if(current_block->active_extruder == 2) { WRITE(E2_DIR_PIN, INVERT_E2_DIR); } else { if(current_block->active_extruder == 1) { WRITE(E1_DIR_PIN, INVERT_E1_DIR); } else { WRITE(E0_DIR_PIN, INVERT_E0_DIR); }}}
 #elif EXTRUDERS > 1
   #define WRITE_E_STEP(v) { if(current_block->active_extruder == 1) { WRITE(E1_STEP_PIN, v); } else { WRITE(E0_STEP_PIN, v); }}
diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index 7307b24..bc46c9f 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -57,6 +57,15 @@ int current_raw_bed = 0;
     float Kc=DEFAULT_Kc;
   #endif
 #endif //PIDTEMP
+
+#ifdef PIDTEMPBED
+  // used external
+  float pid_setpoint_bed = { 0.0 };
+  
+  float bedKp=DEFAULT_bedKp;
+  float bedKi=(DEFAULT_bedKi*PID_dT);
+  float bedKd=(DEFAULT_bedKd/PID_dT);
+#endif //PIDTEMPBED
   
   
 //===========================================================================
@@ -64,9 +73,6 @@ int current_raw_bed = 0;
 //===========================================================================
 static volatile bool temp_meas_ready = false;
 
-static unsigned long  previous_millis_bed_heater;
-//static unsigned long previous_millis_heater;
-
 #ifdef PIDTEMP
   //static cannot be external:
   static float temp_iState[EXTRUDERS] = { 0 };
@@ -82,7 +88,22 @@ static unsigned long  previous_millis_bed_heater;
   // static float pid_output[EXTRUDERS];
   static bool pid_reset[EXTRUDERS];
 #endif //PIDTEMP
+#ifdef PIDTEMPBED
+  //static cannot be external:
+  static float temp_iState_bed = { 0 };
+  static float temp_dState_bed = { 0 };
+  static float pTerm_bed;
+  static float iTerm_bed;
+  static float dTerm_bed;
+  //int output;
+  static float pid_error_bed;
+  static float temp_iState_min_bed;
+  static float temp_iState_max_bed;
+#else //PIDTEMPBED
+	static unsigned long  previous_millis_bed_heater;
+#endif //PIDTEMPBED
   static unsigned char soft_pwm[EXTRUDERS];
+  static unsigned char soft_pwm_bed;
   
 #ifdef WATCHPERIOD
   int watch_raw[EXTRUDERS] = { -1000 }; // the first value used for all
@@ -122,44 +143,67 @@ static unsigned long  previous_millis_bed_heater;
 //=============================   functions      ============================
 //===========================================================================
 
-void PID_autotune(float temp)
+void PID_autotune(float temp, int extruder, int ncycles)
 {
-  float input;
+  float input = 0.0;
   int cycles=0;
   bool heating = true;
 
   unsigned long temp_millis = millis();
   unsigned long t1=temp_millis;
   unsigned long t2=temp_millis;
-  long t_high;
-  long t_low;
+  long t_high = 0;
+  long t_low = 0;
 
-  long bias=PID_MAX/2;
-  long d = PID_MAX/2;
+  long bias, d;
   float Ku, Tu;
   float Kp, Ki, Kd;
-  float max, min;
-  
+  float max = 0, min = 10000;
+
+	if ((extruder > EXTRUDERS)
+  #if (TEMP_BED_PIN <= -1)
+		||(extruder < 0)
+	#endif
+	){
+  	SERIAL_ECHOLN("PID Autotune failed. Bad extruder number.");
+  	return;
+	}
+	
   SERIAL_ECHOLN("PID Autotune start");
   
   disable_heater(); // switch off all heaters.
-  
-  soft_pwm[0] = PID_MAX/2;
-    
-  for(;;) {
+
+	if (extruder<0)
+	{
+	 	soft_pwm_bed = (MAX_BED_POWER)/2;
+		bias = d = (MAX_BED_POWER)/2;
+  }
+	else
+	{
+	  soft_pwm[extruder] = (PID_MAX)/2;
+		bias = d = (PID_MAX)/2;
+  }
+
+
+
+
+ for(;;) {
 
     if(temp_meas_ready == true) { // temp sample ready
       CRITICAL_SECTION_START;
       temp_meas_ready = false;
       CRITICAL_SECTION_END;
-      input = analog2temp(current_raw[0], 0);
-      
+      input = (extruder<0)?analog2tempBed(current_raw_bed):analog2temp(current_raw[extruder], extruder);
+
       max=max(max,input);
       min=min(min,input);
       if(heating == true && input > temp) {
         if(millis() - t2 > 5000) { 
           heating=false;
-          soft_pwm[0] = (bias - d) >> 1;
+					if (extruder<0)
+						soft_pwm_bed = (bias - d) >> 1;
+					else
+						soft_pwm[extruder] = (bias - d) >> 1;
           t1=millis();
           t_high=t1 - t2;
           max=temp;
@@ -172,8 +216,8 @@ void PID_autotune(float temp)
           t_low=t2 - t1;
           if(cycles > 0) {
             bias += (d*(t_high - t_low))/(t_low + t_high);
-            bias = constrain(bias, 20 ,PID_MAX-20);
-            if(bias > PID_MAX/2) d = PID_MAX - 1 - bias;
+            bias = constrain(bias, 20 ,(extruder<0?(MAX_BED_POWER):(PID_MAX))-20);
+            if(bias > (extruder<0?(MAX_BED_POWER):(PID_MAX))/2) d = (extruder<0?(MAX_BED_POWER):(PID_MAX)) - 1 - bias;
             else d = bias;
 
             SERIAL_PROTOCOLPGM(" bias: "); SERIAL_PROTOCOL(bias);
@@ -210,7 +254,10 @@ void PID_autotune(float temp)
               */
             }
           }
-          soft_pwm[0] = (bias + d) >> 1;
+					if (extruder<0)
+						soft_pwm_bed = (bias + d) >> 1;
+					else
+						soft_pwm[extruder] = (bias + d) >> 1;
           cycles++;
           min=temp;
         }
@@ -221,17 +268,26 @@ void PID_autotune(float temp)
       return;
     }
     if(millis() - temp_millis > 2000) {
-      temp_millis = millis();
-      SERIAL_PROTOCOLPGM("ok T:");
-      SERIAL_PROTOCOL(degHotend(0));   
+			int p;
+			if (extruder<0){
+	      p=soft_pwm_bed;       
+	      SERIAL_PROTOCOLPGM("ok B:");
+			}else{
+	      p=soft_pwm[extruder];       
+	      SERIAL_PROTOCOLPGM("ok T:");
+			}
+			
+      SERIAL_PROTOCOL(input);   
       SERIAL_PROTOCOLPGM(" @:");
-      SERIAL_PROTOCOLLN(getHeaterPower(0));       
+      SERIAL_PROTOCOLLN(p);       
+
+      temp_millis = millis();
     }
     if(((millis() - t1) + (millis() - t2)) > (10L*60L*1000L*2L)) {
       SERIAL_PROTOCOLLNPGM("PID Autotune failed! timeout");
       return;
     }
-    if(cycles > 5) {
+    if(cycles > ncycles) {
       SERIAL_PROTOCOLLNPGM("PID Autotune finished ! Place the Kp, Ki and Kd constants in the configuration.h");
       return;
     }
@@ -246,29 +302,28 @@ void updatePID()
      temp_iState_max[e] = PID_INTEGRAL_DRIVE_MAX / Ki;  
   }
 #endif
+#ifdef PIDTEMPBED
+  temp_iState_max_bed = PID_INTEGRAL_DRIVE_MAX / bedKi;  
+#endif
 }
   
 int getHeaterPower(int heater) {
+	if (heater<0)
+		return soft_pwm_bed;
   return soft_pwm[heater];
 }
 
 void manage_heater()
 {
-#ifdef HEATER_BED_DUTY_CYCLE_DIVIDER
-  static int bed_needs_heating=0;
-  static int bed_is_on=0;
-#endif
-
-  #ifdef USE_WATCHDOG
-    wd_reset();
-  #endif
-  
   float pid_input;
   float pid_output;
 
   if(temp_meas_ready != true)   //better readability
     return; 
 
+  //Reset the watchdog after we know we have a temperature measurement.
+  watchdog_reset();
+
   CRITICAL_SECTION_START;
   temp_meas_ready = false;
   CRITICAL_SECTION_END;
@@ -298,12 +353,16 @@ void manage_heater()
           temp_iState[e] += pid_error[e];
           temp_iState[e] = constrain(temp_iState[e], temp_iState_min[e], temp_iState_max[e]);
           iTerm[e] = Ki * temp_iState[e];
+
           //K1 defined in Configuration.h in the PID settings
           #define K2 (1.0-K1)
           dTerm[e] = (Kd * (pid_input - temp_dState[e]))*K2 + (K1 * dTerm[e]);
           temp_dState[e] = pid_input;
+
           pid_output = constrain(pTerm[e] + iTerm[e] - dTerm[e], 0, PID_MAX);
         }
+    #else 
+          pid_output = constrain(pid_setpoint[e], 0, PID_MAX);
     #endif //PID_OPENLOOP
     #ifdef PID_DEBUG
     SERIAL_ECHOLN(" PIDDEBUG "<<e<<": Input "<<pid_input<<" Output "<<pid_output" pTerm "<<pTerm[e]<<" iTerm "<<iTerm[e]<<" dTerm "<<dTerm[e]);  
@@ -338,42 +397,58 @@ void manage_heater()
     }
   #endif
   
-#ifdef HEATER_BED_DUTY_CYCLE_DIVIDER
-  if (bed_needs_heating){
-    if (bed_is_on==0)
-        WRITE(HEATER_BED_PIN,HIGH);
-    if (bed_is_on==1)
-        WRITE(HEATER_BED_PIN,LOW);
-    bed_is_on=(bed_is_on+1) % HEATER_BED_DUTY_CYCLE_DIVIDER;
-  }
-#endif
 
+		#ifndef PIDTEMPBED
   if(millis() - previous_millis_bed_heater < BED_CHECK_INTERVAL)
     return;
   previous_millis_bed_heater = millis();
-  
+    #endif
+
   #if TEMP_BED_PIN > -1
   
-    #ifdef HEATER_BED_DUTY_CYCLE_DIVIDER
-    bed_needs_heating=0;
-    #endif
+		#ifdef PIDTEMPBED
+    pid_input = analog2tempBed(current_raw_bed);
+
+    #ifndef PID_OPENLOOP
+		  pid_error_bed = pid_setpoint_bed - pid_input;
+		  pTerm_bed = bedKp * pid_error_bed;
+		  temp_iState_bed += pid_error_bed;
+		  temp_iState_bed = constrain(temp_iState_bed, temp_iState_min_bed, temp_iState_max_bed);
+		  iTerm_bed = bedKi * temp_iState_bed;
 
-    #ifndef BED_LIMIT_SWITCHING
+		  //K1 defined in Configuration.h in the PID settings
+		  #define K2 (1.0-K1)
+		  dTerm_bed= (bedKd * (pid_input - temp_dState_bed))*K2 + (K1 * dTerm_bed);
+		  temp_dState_bed = pid_input;
+
+		  pid_output = constrain(pTerm_bed + iTerm_bed - dTerm_bed, 0, MAX_BED_POWER);
+
+    #else 
+      pid_output = constrain(pid_setpoint_bed, 0, MAX_BED_POWER);
+    #endif //PID_OPENLOOP
+
+	  if((current_raw_bed > bed_minttemp) && (current_raw_bed < bed_maxttemp)) 
+	  {
+	    soft_pwm_bed = (int)pid_output >> 1;
+	  }
+	  else {
+	    soft_pwm_bed = 0;
+	  }
+
+    #elif not defined BED_LIMIT_SWITCHING
       // Check if temperature is within the correct range
       if((current_raw_bed > bed_minttemp) && (current_raw_bed < bed_maxttemp)) {
         if(current_raw_bed >= target_raw_bed)
         {
-          WRITE(HEATER_BED_PIN,LOW);
+					soft_pwm_bed = 0;
         }
         else 
         {
-          #ifdef HEATER_BED_DUTY_CYCLE_DIVIDER
-          bed_needs_heating=1;
-          #endif
-          WRITE(HEATER_BED_PIN,HIGH);
+					soft_pwm_bed = MAX_BED_POWER>>1;
         }
       }
       else {
+					soft_pwm_bed = 0;
         WRITE(HEATER_BED_PIN,LOW);
       }
     #else //#ifdef BED_LIMIT_SWITCHING
@@ -381,18 +456,16 @@ void manage_heater()
       if((current_raw_bed > bed_minttemp) && (current_raw_bed < bed_maxttemp)) {
         if(current_raw_bed > target_bed_high_temp)
         {
-          WRITE(HEATER_BED_PIN,LOW);
+					soft_pwm_bed = 0;
         }
         else 
           if(current_raw_bed <= target_bed_low_temp)
         {
-          #ifdef HEATER_BED_DUTY_CYCLE_DIVIDER
-          bed_needs_heating=1;
-          #endif
-          WRITE(HEATER_BED_PIN,HIGH);
+					soft_pwm_bed = MAX_BED_POWER>>1;
         }
       }
       else {
+					soft_pwm_bed = 0;
         WRITE(HEATER_BED_PIN,LOW);
       }
     #endif
@@ -473,7 +546,6 @@ int temp2analogBed(int celsius) {
 #elif defined BED_USES_AD595
     return lround(((celsius-TEMP_SENSOR_AD595_OFFSET)/TEMP_SENSOR_AD595_GAIN) * (1024.0 * OVERSAMPLENR/ (5.0 * 100.0) ) );
 #else
-    #warning No heater-type defined for the bed.
     return 0;
 #endif
 }
@@ -550,7 +622,6 @@ float analog2tempBed(int raw) {
   #elif defined BED_USES_AD595
     return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET;
   #else
-    #warning No heater-type defined for the bed.
     return 0;
   #endif
 }
@@ -568,6 +639,10 @@ void tp_init()
     temp_iState_min[e] = 0.0;
     temp_iState_max[e] = PID_INTEGRAL_DRIVE_MAX / Ki;
 #endif //PIDTEMP
+#ifdef PIDTEMPBED
+    temp_iState_min_bed = 0.0;
+    temp_iState_max_bed = PID_INTEGRAL_DRIVE_MAX / bedKi;
+#endif //PIDTEMPBED
   }
 
   #if (HEATER_0_PIN > -1) 
@@ -728,6 +803,7 @@ void disable_heater()
 
   #if TEMP_BED_PIN > -1
     target_raw_bed=0;
+    soft_pwm_bed=0;
     #if HEATER_BED_PIN > -1  
       WRITE(HEATER_BED_PIN,LOW);
     #endif
@@ -830,8 +906,15 @@ ISR(TIMER0_COMPB_vect)
   static unsigned char temp_state = 0;
   static unsigned char pwm_count = 1;
   static unsigned char soft_pwm_0;
+  #if EXTRUDERS > 1
   static unsigned char soft_pwm_1;
+  #endif
+  #if EXTRUDERS > 2
   static unsigned char soft_pwm_2;
+  #endif
+  #if HEATER_BED_PIN > -1
+  static unsigned char soft_pwm_b;
+  #endif
   
   if(pwm_count == 0){
     soft_pwm_0 = soft_pwm[0];
@@ -844,6 +927,10 @@ ISR(TIMER0_COMPB_vect)
     soft_pwm_2 = soft_pwm[2];
     if(soft_pwm_2 > 0) WRITE(HEATER_2_PIN,1);
     #endif
+    #if HEATER_BED_PIN > -1
+    soft_pwm_b = soft_pwm_bed;
+    if(soft_pwm_b > 0) WRITE(HEATER_BED_PIN,1);
+    #endif
   }
   if(soft_pwm_0 <= pwm_count) WRITE(HEATER_0_PIN,0);
   #if EXTRUDERS > 1
@@ -852,6 +939,9 @@ ISR(TIMER0_COMPB_vect)
   #if EXTRUDERS > 2
   if(soft_pwm_2 <= pwm_count) WRITE(HEATER_2_PIN,0);
   #endif
+  #if HEATER_BED_PIN > -1
+  if(soft_pwm_b <= pwm_count) WRITE(HEATER_BED_PIN,0);
+  #endif
   
   pwm_count++;
   pwm_count &= 0x7f;
@@ -885,6 +975,8 @@ ISR(TIMER0_COMPB_vect)
       #if (TEMP_BED_PIN > -1)
         #if TEMP_BED_PIN > 7
           ADCSRB = 1<<MUX5;
+        #else
+          ADCSRB = 0;
         #endif
         ADMUX = ((1 << REFS0) | (TEMP_BED_PIN & 0x07));
         ADCSRA |= 1<<ADSC; // Start conversion
diff --git a/Marlin/temperature.h b/Marlin/temperature.h
index 1848c70..ae289de 100644
--- a/Marlin/temperature.h
+++ b/Marlin/temperature.h
@@ -46,11 +46,15 @@ extern int current_raw_bed;
   extern int target_bed_low_temp ;  
   extern int target_bed_high_temp ;
 #endif
-extern float Kp,Ki,Kd,Kc;
 
 #ifdef PIDTEMP
+  extern float Kp,Ki,Kd,Kc;
   extern float pid_setpoint[EXTRUDERS];
 #endif
+#ifdef PIDTEMPBED
+  extern float bedKp,bedKi,bedKd;
+  extern float pid_setpoint_bed;
+#endif
   
 // #ifdef WATCHPERIOD
   extern int watch_raw[EXTRUDERS] ;
@@ -88,7 +92,9 @@ FORCE_INLINE void setTargetHotend(const float &celsius, uint8_t extruder) {
 FORCE_INLINE void setTargetBed(const float &celsius) {  
   
   target_raw_bed = temp2analogBed(celsius);
-  #ifdef BED_LIMIT_SWITCHING
+	#ifdef PIDTEMPBED
+  pid_setpoint_bed = celsius;
+  #elif defined BED_LIMIT_SWITCHING
     if(celsius>BED_HYSTERESIS)
     {
     target_bed_low_temp= temp2analogBed(celsius-BED_HYSTERESIS);
@@ -163,7 +169,7 @@ FORCE_INLINE void autotempShutdown(){
  #endif
 }
 
-void PID_autotune(float temp);
+void PID_autotune(float temp, int extruder, int ncycles);
 
 #endif
-
+
diff --git a/Marlin/thermistortables.h b/Marlin/thermistortables.h
index 941b239..698506f 100644
--- a/Marlin/thermistortables.h
+++ b/Marlin/thermistortables.h
@@ -247,7 +247,8 @@ const short temptable_6[][2] PROGMEM = {
    {954*OVERSAMPLENR, 30},
    {970*OVERSAMPLENR, 25},
    {978*OVERSAMPLENR, 22},
-   {1008*OVERSAMPLENR, 3}
+   {1008*OVERSAMPLENR, 3},
+   {1023*OVERSAMPLENR, 0}  //to allow internal 0C
 };
 #endif
 
@@ -307,7 +308,8 @@ const short temptable_7[][2] PROGMEM = {
    {989*OVERSAMPLENR, 20},
    {994*OVERSAMPLENR, 15},
    {1001*OVERSAMPLENR, 10},
-   {1005*OVERSAMPLENR, 5}
+   {1005*OVERSAMPLENR, 5},
+   {1023*OVERSAMPLENR, 0}  //to allow internal 0C
 };
 #endif
 
diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
new file mode 100644
index 0000000..819568e
--- /dev/null
+++ b/Marlin/ultralcd.cpp
@@ -0,0 +1,3045 @@
+#include "language.h"
+#include "temperature.h"
+#include "ultralcd.h"
+#ifdef ULTRA_LCD
+#include "Marlin.h"
+#include "language.h"
+#include "temperature.h"
+#include "ConfigurationStore.h"
+
+//===========================================================================
+//=============================imported variables============================
+//===========================================================================
+
+extern volatile int feedmultiply;
+extern volatile bool feedmultiplychanged;
+
+extern volatile int extrudemultiply;
+
+extern long position[4];   
+#ifdef SDSUPPORT
+#include "cardreader.h"
+extern CardReader card;
+#endif
+
+//===========================================================================
+//=============================public variables============================
+//===========================================================================
+volatile char buttons=0;  //the last checked buttons in a bit array.
+long encoderpos=0;
+short lastenc=0;
+
+//TODO: This should be in a preferences file.
+int plaPreheatHotendTemp;
+int plaPreheatHPBTemp;
+int plaPreheatFanSpeed;
+
+int absPreheatHotendTemp;
+int absPreheatHPBTemp;
+int absPreheatFanSpeed;
+
+//===========================================================================
+//=============================private  variables============================
+//===========================================================================
+static char messagetext[LCD_WIDTH]="";
+
+//return for string conversion routines
+static char conv[8];
+
+LCD_CLASS lcd(LCD_PINS_RS, LCD_PINS_ENABLE, LCD_PINS_D4, LCD_PINS_D5,LCD_PINS_D6,LCD_PINS_D7);  //RS,Enable,D4,D5,D6,D7
+
+static unsigned long previous_millis_lcd=0;
+//static long previous_millis_buttons=0;
+
+
+#ifdef NEWPANEL
+ static unsigned long blocking=0;
+#else
+ static unsigned long blocking[8]={0,0,0,0,0,0,0,0};
+#endif
+ 
+static MainMenu menu;
+
+
+void lcdProgMemprint(const char *str)
+{
+  char ch=pgm_read_byte(str);
+  while(ch)
+  {
+    lcd.print(ch);
+    ch=pgm_read_byte(++str);
+  }
+}
+#define LCD_PRINT_PGM(x) lcdProgMemprint(PSTR(x))
+
+
+//===========================================================================
+//=============================functions         ============================
+//===========================================================================
+
+int intround(const float &x){return int(0.5+x);}
+
+void lcd_status(const char* message)
+{
+  strncpy(messagetext,message,LCD_WIDTH);
+  messagetext[strlen(message)]=0;
+}
+
+void lcd_statuspgm(const char* message)
+{
+  char ch=pgm_read_byte(message);
+  char *target=messagetext;
+  uint8_t cnt=0;
+  while(ch &&cnt<LCD_WIDTH)
+  {
+    *target=ch;
+    target++;
+    cnt++;
+    ch=pgm_read_byte(++message);
+  }
+  *target=0;
+}
+
+void lcd_alertstatuspgm(const char* message)
+{
+  lcd_statuspgm(message); 
+  menu.showStatus(); 
+}
+
+FORCE_INLINE void clear()
+{
+  lcd.clear();
+}
+
+
+void lcd_init()
+{
+  //beep();
+  #ifdef ULTIPANEL
+    buttons_init();
+  #endif
+  
+  byte Degree[8] =
+  {
+    B01100,
+    B10010,
+    B10010,
+    B01100,
+    B00000,
+    B00000,
+    B00000,
+    B00000
+  };
+  byte Thermometer[8] =
+  {
+    B00100,
+    B01010,
+    B01010,
+    B01010,
+    B01010,
+    B10001,
+    B10001,
+    B01110
+  };
+  byte uplevel[8]={
+    B00100,
+    B01110,
+    B11111,
+    B00100,
+    B11100,
+    B00000,
+    B00000,
+    B00000
+  }; //thanks joris
+  byte refresh[8]={
+    B00000,
+    B00110,
+    B11001,
+    B11000,
+    B00011,
+    B10011,
+    B01100,
+    B00000,
+  }; //thanks joris
+  byte folder [8]={
+    B00000,
+    B11100,
+    B11111,
+    B10001,
+    B10001,
+    B11111,
+    B00000,
+    B00000
+  }; //thanks joris
+  lcd.begin(LCD_WIDTH, LCD_HEIGHT);
+  lcd.createChar(1,Degree);
+  lcd.createChar(2,Thermometer);
+  lcd.createChar(3,uplevel);
+  lcd.createChar(4,refresh);
+  lcd.createChar(5,folder);
+  LCD_MESSAGEPGM(WELCOME_MSG);
+}
+
+
+void beep()
+{
+  //return;
+  #ifdef ULTIPANEL
+	#if (BEEPER > -1)
+	{
+		pinMode(BEEPER,OUTPUT);
+		for(int8_t i=0;i<20;i++){
+		WRITE(BEEPER,HIGH);
+		delay(5);
+		WRITE(BEEPER,LOW);
+		delay(5);
+		}
+	}
+        #endif
+  #endif
+}
+
+void beepshort()
+{
+  //return;
+  #ifdef ULTIPANEL
+	#if (BEEPER > -1)
+	{
+		pinMode(BEEPER,OUTPUT);
+		for(int8_t i=0;i<10;i++){
+		WRITE(BEEPER,HIGH);
+		delay(3);
+		WRITE(BEEPER,LOW);
+		delay(3);
+		}
+	}
+        #endif
+  #endif  
+}
+
+void lcd_status()
+{
+  #ifdef ULTIPANEL
+    static uint8_t oldbuttons=0;
+    //static long previous_millis_buttons=0;
+    //static long previous_lcdinit=0;
+  //  buttons_check(); // Done in temperature interrupt
+    //previous_millis_buttons=millis();
+    unsigned long ms=millis();
+    for(int8_t i=0; i<8; i++) {
+      #ifndef NEWPANEL
+      if((blocking[i]>ms))
+        buttons &= ~(1<<i);
+      #else
+      if((blocking>ms))
+        buttons &= ~(1<<i);        
+      #endif
+    }
+    if((buttons==oldbuttons) &&  ((millis() - previous_millis_lcd) < LCD_UPDATE_INTERVAL)   )
+      return;
+    oldbuttons=buttons;
+  #else
+  
+    if(((millis() - previous_millis_lcd) < LCD_UPDATE_INTERVAL)   )
+      return;
+  #endif
+    
+  previous_millis_lcd=millis();
+  menu.update();
+}
+#ifdef ULTIPANEL  
+
+
+void buttons_init()
+{
+  #ifdef NEWPANEL
+    pinMode(BTN_EN1,INPUT);
+    pinMode(BTN_EN2,INPUT); 
+    pinMode(BTN_ENC,INPUT); 
+    pinMode(SDCARDDETECT,INPUT);
+    WRITE(BTN_EN1,HIGH);
+    WRITE(BTN_EN2,HIGH);
+    WRITE(BTN_ENC,HIGH);
+    #if (SDCARDDETECT > -1)
+    {
+      WRITE(SDCARDDETECT,HIGH);
+    }
+    #endif
+  #else
+    pinMode(SHIFT_CLK,OUTPUT);
+    pinMode(SHIFT_LD,OUTPUT);
+    pinMode(SHIFT_EN,OUTPUT);
+    pinMode(SHIFT_OUT,INPUT);
+    WRITE(SHIFT_OUT,HIGH);
+    WRITE(SHIFT_LD,HIGH); 
+    WRITE(SHIFT_EN,LOW); 
+  #endif
+}
+
+
+void buttons_check()
+{
+  
+  #ifdef NEWPANEL
+    uint8_t newbutton=0;
+    if(READ(BTN_EN1)==0)  newbutton|=EN_A;
+    if(READ(BTN_EN2)==0)  newbutton|=EN_B;
+    if((blocking<millis()) &&(READ(BTN_ENC)==0))
+      newbutton|=EN_C;
+    buttons=newbutton;
+  #else   //read it from the shift register
+    uint8_t newbutton=0;
+    WRITE(SHIFT_LD,LOW);
+    WRITE(SHIFT_LD,HIGH);
+    unsigned char tmp_buttons=0;
+    for(int8_t i=0;i<8;i++)
+    { 
+      newbutton = newbutton>>1;
+      if(READ(SHIFT_OUT))
+        newbutton|=(1<<7);
+      WRITE(SHIFT_CLK,HIGH);
+      WRITE(SHIFT_CLK,LOW);
+    }
+    buttons=~newbutton; //invert it, because a pressed switch produces a logical 0
+  #endif
+  
+  //manage encoder rotation
+  char enc=0;
+  if(buttons&EN_A)
+    enc|=(1<<0);
+  if(buttons&EN_B)
+    enc|=(1<<1);
+  if(enc!=lastenc)
+	{
+    switch(enc)
+    {
+    case encrot0:
+      if(lastenc==encrot3)
+        encoderpos++;
+      else if(lastenc==encrot1)
+        encoderpos--;
+      break;
+    case encrot1:
+      if(lastenc==encrot0)
+        encoderpos++;
+      else if(lastenc==encrot2)
+        encoderpos--;
+      break;
+    case encrot2:
+      if(lastenc==encrot1)
+        encoderpos++;
+      else if(lastenc==encrot3)
+        encoderpos--;
+      break;
+    case encrot3:
+      if(lastenc==encrot2)
+        encoderpos++;
+      else if(lastenc==encrot0)
+        encoderpos--;
+      break;
+    default:
+      ;
+    }
+  }
+  lastenc=enc;
+}
+
+#endif
+
+MainMenu::MainMenu()
+{
+  status=Main_Status;
+  displayStartingRow=0;
+  activeline=0;
+  force_lcd_update=true;
+  linechanging=false;
+  tune=false;
+}
+
+void MainMenu::showStatus()
+{ 
+#if LCD_HEIGHT==4
+  static int olddegHotEnd0=-1;
+  static int oldtargetHotEnd0=-1;
+  //force_lcd_update=true;
+  if(force_lcd_update)  //initial display of content
+  {
+    encoderpos=feedmultiply;
+    clear();
+    lcd.setCursor(0,0);LCD_PRINT_PGM("\002000/000\001 ");
+    #if defined BED_USES_THERMISTOR || defined BED_USES_AD595 
+      lcd.setCursor(10,0);LCD_PRINT_PGM("B000/000\001 ");
+    #elif EXTRUDERS > 1
+      lcd.setCursor(10,0);LCD_PRINT_PGM("\002000/000\001 ");
+    #endif
+  }
+    
+  int tHotEnd0=intround(degHotend0());
+  if((tHotEnd0!=olddegHotEnd0)||force_lcd_update)
+  {
+    lcd.setCursor(1,0);
+    lcd.print(ftostr3(tHotEnd0));
+    olddegHotEnd0=tHotEnd0;
+  }
+  int ttHotEnd0=intround(degTargetHotend0());
+  if((ttHotEnd0!=oldtargetHotEnd0)||force_lcd_update)
+  {
+    lcd.setCursor(5,0);
+    lcd.print(ftostr3(ttHotEnd0));
+    oldtargetHotEnd0=ttHotEnd0;
+  }
+  #if defined BED_USES_THERMISTOR || defined BED_USES_AD595 
+    static int oldtBed=-1;
+    static int oldtargetBed=-1; 
+    int tBed=intround(degBed());
+    if((tBed!=oldtBed)||force_lcd_update)
+    {
+      lcd.setCursor(11,0);
+      lcd.print(ftostr3(tBed));
+      oldtBed=tBed;
+    }
+    int targetBed=intround(degTargetBed());
+    if((targetBed!=oldtargetBed)||force_lcd_update)
+    {
+      lcd.setCursor(15,0);
+      lcd.print(ftostr3(targetBed));
+      oldtargetBed=targetBed;
+    }
+  #elif EXTRUDERS > 1
+    static int olddegHotEnd1=-1;
+    static int oldtargetHotEnd1=-1;
+    int tHotEnd1=intround(degHotend1());
+    if((tHotEnd1!=olddegHotEnd1)||force_lcd_update)
+    {
+      lcd.setCursor(11,0);
+      lcd.print(ftostr3(tHotEnd1));
+      olddegHotEnd1=tHotEnd1;
+    }
+    int ttHotEnd1=intround(degTargetHotend1());
+    if((ttHotEnd1!=oldtargetHotEnd1)||force_lcd_update)
+    {
+      lcd.setCursor(15,0);
+      lcd.print(ftostr3(ttHotEnd1));
+      oldtargetHotEnd1=ttHotEnd1;
+    }
+  #endif
+  //starttime=2;
+  static uint16_t oldtime=0;
+  if(starttime!=0)
+  {
+    lcd.setCursor(0,1);
+    uint16_t time=millis()/60000-starttime/60000;
+    
+    if(starttime!=oldtime)
+    {
+      lcd.print(itostr2(time/60));LCD_PRINT_PGM("h ");lcd.print(itostr2(time%60));LCD_PRINT_PGM("m");
+      oldtime=time;
+    }
+  }
+  static int oldzpos=0;
+  int currentz=current_position[2]*100;
+  if((currentz!=oldzpos)||force_lcd_update)
+  {
+    lcd.setCursor(10,1);
+    LCD_PRINT_PGM("Z:");lcd.print(ftostr52(current_position[2]));
+    oldzpos=currentz;
+  }
+  
+  static int oldfeedmultiply=0;
+  int curfeedmultiply=feedmultiply;
+  
+  if(feedmultiplychanged == true) {
+    feedmultiplychanged = false;
+    encoderpos = curfeedmultiply;
+  }
+  
+  if(encoderpos!=curfeedmultiply||force_lcd_update)
+  {
+   curfeedmultiply=encoderpos;
+   if(curfeedmultiply<10)
+     curfeedmultiply=10;
+   if(curfeedmultiply>999)
+     curfeedmultiply=999;
+   feedmultiply=curfeedmultiply;
+   encoderpos=curfeedmultiply;
+  }
+  
+  if((curfeedmultiply!=oldfeedmultiply)||force_lcd_update)
+  {
+   oldfeedmultiply=curfeedmultiply;
+   lcd.setCursor(0,2);
+   lcd.print(itostr3(curfeedmultiply));LCD_PRINT_PGM("% ");
+  }
+  
+  if(messagetext[0]!='\0')
+  {
+    lcd.setCursor(0,LCD_HEIGHT-1);
+    lcd.print(messagetext);
+    uint8_t n=strlen(messagetext);
+    for(int8_t i=0;i<LCD_WIDTH-n;i++)
+      lcd.print(" ");
+    messagetext[0]='\0';
+  }
+#ifdef SDSUPPORT
+  static uint8_t oldpercent=101;
+  uint8_t percent=card.percentDone();
+  if(oldpercent!=percent ||force_lcd_update)
+  {
+     lcd.setCursor(10,2);
+    lcd.print(itostr3((int)percent));
+    LCD_PRINT_PGM("%SD");
+  }
+#endif
+#else //smaller LCDS----------------------------------
+  static int olddegHotEnd0=-1;
+  static int oldtargetHotEnd0=-1;
+  if(force_lcd_update)  //initial display of content
+  {
+    encoderpos=feedmultiply;
+    lcd.setCursor(0,0);LCD_PRINT_PGM("\002---/---\001 ");
+  }
+    
+  int tHotEnd0=intround(degHotend0());
+  int ttHotEnd0=intround(degTargetHotend0());
+
+
+  if((abs(tHotEnd0-olddegHotEnd0)>1)||force_lcd_update)
+  {
+    lcd.setCursor(1,0);
+    lcd.print(ftostr3(tHotEnd0));
+    olddegHotEnd0=tHotEnd0;
+  }
+  if((ttHotEnd0!=oldtargetHotEnd0)||force_lcd_update)
+  {
+    lcd.setCursor(5,0);
+    lcd.print(ftostr3(ttHotEnd0));
+    oldtargetHotEnd0=ttHotEnd0;
+  }
+
+  if(messagetext[0]!='\0')
+  {
+    lcd.setCursor(0,LCD_HEIGHT-1);
+    lcd.print(messagetext);
+    uint8_t n=strlen(messagetext);
+    for(int8_t i=0;i<LCD_WIDTH-n;i++)
+      lcd.print(" ");
+    messagetext[0]='\0';
+  }
+
+#endif
+  force_lcd_update=false;
+}
+
+enum {ItemP_exit, ItemP_autostart,ItemP_disstep,ItemP_home, ItemP_origin, ItemP_preheat_pla, ItemP_preheat_abs, ItemP_cooldown,/*ItemP_extrude,*/ItemP_move};
+
+//any action must not contain a ',' character anywhere, or this breaks:
+#define MENUITEM(repaint_action, click_action) \
+  {\
+    if(force_lcd_update)  { lcd.setCursor(0,line);  repaint_action; } \
+    if((activeline==line) && CLICKED) {click_action} \
+  }
+  
+void MainMenu::showPrepare()
+{
+#ifdef ULTIPANEL
+ uint8_t line=0;
+ clearIfNecessary();
+ for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
+ {
+   //Serial.println((int)(line-lineoffset));
+  switch(i)
+  {
+    case ItemP_exit:
+      MENUITEM(  LCD_PRINT_PGM(MSG_MAIN)  ,  BLOCK;status=Main_Menu;beepshort(); ) ;
+      break;
+    case ItemP_autostart:
+      MENUITEM(  LCD_PRINT_PGM(MSG_AUTOSTART)  ,  BLOCK;
+#ifdef SDSUPPORT
+          card.lastnr=0;card.setroot();card.checkautostart(true);
+#endif
+          beepshort(); ) ;
+      break;
+    case ItemP_disstep:
+      MENUITEM(  LCD_PRINT_PGM(MSG_DISABLE_STEPPERS)  ,  BLOCK;enquecommand("M84");beepshort(); ) ;
+      break;
+    case ItemP_home:
+      MENUITEM(  LCD_PRINT_PGM(MSG_AUTO_HOME)  ,  BLOCK;enquecommand("G28");beepshort(); ) ;
+      break;
+    case ItemP_origin:
+      MENUITEM(  LCD_PRINT_PGM(MSG_SET_ORIGIN)  ,  BLOCK;enquecommand("G92 X0 Y0 Z0");beepshort(); ) ;
+      break;
+    case ItemP_preheat_pla:
+		MENUITEM(  LCD_PRINT_PGM(MSG_PREHEAT_PLA)  ,  BLOCK;setTargetHotend0(plaPreheatHotendTemp);setTargetBed(plaPreheatHPBTemp);
+      #if FAN_PIN > -1
+		FanSpeed = plaPreheatFanSpeed;
+        analogWrite(FAN_PIN,  FanSpeed);
+      #endif
+      beepshort(); );
+      break;
+    case ItemP_preheat_abs:
+      MENUITEM(  LCD_PRINT_PGM(MSG_PREHEAT_ABS)  ,  BLOCK;setTargetHotend0(absPreheatHotendTemp);setTargetBed(absPreheatHPBTemp); 
+      #if FAN_PIN > -1
+	  	FanSpeed = absPreheatFanSpeed;
+        analogWrite(FAN_PIN,  FanSpeed);
+      #endif
+      beepshort(); );
+      break;
+    case ItemP_cooldown:
+      MENUITEM(  LCD_PRINT_PGM(MSG_COOLDOWN)  ,  BLOCK;setTargetHotend0(0);setTargetHotend1(0);setTargetHotend2(0);setTargetBed(0);beepshort(); ) ;
+      break;
+//    case ItemP_extrude:
+  //    MENUITEM(  LCD_PRINT_PGM(" Extrude")  ,  BLOCK;enquecommand("G92 E0");enquecommand("G1 F700 E50");beepshort(); ) ;
+    //  break;
+    case ItemP_move:
+      MENUITEM(  LCD_PRINT_PGM(MSG_MOVE_AXIS) , BLOCK;status=Sub_PrepareMove;beepshort(); );
+      break;
+        default:   
+      break;
+  }
+  line++;
+ }
+ updateActiveLines(ItemP_move,encoderpos);
+#endif
+}
+
+enum {
+  ItemAM_exit,
+  ItemAM_X, ItemAM_Y, ItemAM_Z, ItemAM_E, ItemAM_ERetract
+};
+
+void MainMenu::showAxisMove()
+{
+   uint8_t line=0;
+   int oldencoderpos=0;
+   clearIfNecessary();
+   for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
+   {
+     switch(i)
+      {
+          case ItemAM_exit:
+          MENUITEM(  LCD_PRINT_PGM(MSG_PREPARE_ALT)  ,  BLOCK;status=Main_Prepare;beepshort(); ) ;
+          break;
+          case ItemAM_X:
+          {
+	 	  //oldencoderpos=0;
+                  if(force_lcd_update)
+                  {
+                    lcd.setCursor(0,line);LCD_PRINT_PGM(" X:");
+                    lcd.setCursor(11,line);lcd.print(ftostr52(current_position[X_AXIS]));
+                  }
+      
+                  if((activeline!=line) )
+                  break;
+                  
+                  if(CLICKED) 
+                  {
+                    linechanging=!linechanging;
+                    if(linechanging)
+                    {
+			enquecommand("G91");
+                    }
+                    else
+                    {
+		      enquecommand("G90");
+                      encoderpos=activeline*lcdslow;
+                      beepshort();
+                    }
+                    BLOCK;
+                  }
+                  if(linechanging)
+                  {
+                    if (encoderpos >0) 
+                   { 
+		    	enquecommand("G1 F700 X0.1");
+			oldencoderpos=encoderpos;
+                        encoderpos=0;
+		    }
+		  
+		    else if (encoderpos < 0)
+                    {
+		    	enquecommand("G1 F700 X-0.1");
+			oldencoderpos=encoderpos;
+                        encoderpos=0;
+		    }
+                    lcd.setCursor(11,line);lcd.print(ftostr52(current_position[X_AXIS]));
+                  }
+          }
+          break;
+          case ItemAM_Y:
+            {
+                  if(force_lcd_update)
+                  {
+                    lcd.setCursor(0,line);LCD_PRINT_PGM(" Y:");
+                    lcd.setCursor(11,line);lcd.print(ftostr52(current_position[Y_AXIS]));
+                  }
+      
+                  if((activeline!=line) )
+                  break;
+                  
+                  if(CLICKED) 
+                  {
+                    linechanging=!linechanging;
+                    if(linechanging)
+                    {
+			enquecommand("G91");
+                    }
+                    else
+                    {
+		      enquecommand("G90");
+                      encoderpos=activeline*lcdslow;
+                      beepshort();
+                    }
+                    BLOCK;
+                  }
+                  if(linechanging)
+                  {
+                    if (encoderpos >0) 
+                   { 
+		    	enquecommand("G1 F700 Y0.1");
+			oldencoderpos=encoderpos;
+                        encoderpos=0;
+		    }
+		  
+		    else if (encoderpos < 0)
+                    {
+		    	enquecommand("G1 F700 Y-0.1");
+			oldencoderpos=encoderpos;
+                        encoderpos=0;
+		    }
+                    lcd.setCursor(11,line);lcd.print(ftostr52(current_position[Y_AXIS]));
+                  }
+          }
+          break;
+          case ItemAM_Z:
+          {
+                  if(force_lcd_update)
+                  {
+                    lcd.setCursor(0,line);LCD_PRINT_PGM(" Z:");
+                    lcd.setCursor(11,line);lcd.print(ftostr52(current_position[Z_AXIS]));
+                  }
+      
+                  if((activeline!=line) )
+                  break;
+                  
+                   if(CLICKED) 
+                  {
+                    linechanging=!linechanging;
+                    if(linechanging)
+                    {
+			enquecommand("G91");
+                    }
+                    else
+                    {
+		      enquecommand("G90");
+                      encoderpos=activeline*lcdslow;
+                      beepshort();
+                    }
+                    BLOCK;
+                  }
+                  if(linechanging)
+                  {
+                    if (encoderpos >0) 
+                   { 
+		    	enquecommand("G1 F70 Z0.1");
+			oldencoderpos=encoderpos;
+                        encoderpos=0;
+		    }
+		  
+		    else if (encoderpos < 0)
+                    {
+		    	enquecommand("G1 F70 Z-0.1");
+			oldencoderpos=encoderpos;
+                        encoderpos=0;
+		    }
+                    lcd.setCursor(11,line);lcd.print(ftostr52(current_position[Z_AXIS]));
+                  }
+          }
+          break;
+          case ItemAM_E:
+          // ErikDB: TODO: this length should be changed for volumetric.
+          MENUITEM(  LCD_PRINT_PGM(MSG_EXTRUDE)  ,  BLOCK;enquecommand("G92 E0");enquecommand("G1 F70 E1");beepshort(); ) ;
+          break;
+          case ItemAM_ERetract:
+              // ErikDB: TODO: this length should be changed for volumetric.
+              MENUITEM(  LCD_PRINT_PGM(MSG_RETRACT)  ,  BLOCK;enquecommand("G92 E0");enquecommand("G1 F700 E-1");beepshort(); ) ;
+              break;
+          default:
+          break;
+      }
+      line++;
+   }
+   updateActiveLines(ItemAM_ERetract,encoderpos);
+}
+
+enum {ItemT_exit,ItemT_speed,ItemT_flow,ItemT_nozzle,
+#if (HEATER_BED_PIN > -1)
+ItemT_bed,
+#endif
+ItemT_fan};
+
+void MainMenu::showTune()
+{ 
+  uint8_t line=0;
+  clearIfNecessary();
+ for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
+ {
+   //Serial.println((int)(line-lineoffset));
+  switch(i)
+  {
+  case ItemT_exit:
+      MENUITEM(  LCD_PRINT_PGM(MSG_MAIN)  ,  BLOCK;status=Main_Menu;beepshort(); ) ;
+      break;
+  case ItemT_speed:
+    {
+      if(force_lcd_update)
+      {
+        lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_SPEED);
+        lcd.setCursor(13,line);lcd.print(ftostr3(feedmultiply));
+      }
+      
+      if((activeline!=line) )
+        break;
+      
+      if(CLICKED) //AnalogWrite(FAN_PIN,  fanpwm);
+      {
+        linechanging=!linechanging;
+        if(linechanging)
+        {
+            encoderpos=feedmultiply;
+        }
+        else
+        {
+          encoderpos=activeline*lcdslow;
+          beepshort();
+        }
+        BLOCK;
+      }
+      if(linechanging)
+      {
+        if(encoderpos<1) encoderpos=1;
+        if(encoderpos>400) encoderpos=400;
+        feedmultiply = encoderpos;
+        feedmultiplychanged=true;
+        lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+      }
+      
+    }break;
+    case ItemT_nozzle:
+      {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_NOZZLE);
+          lcd.setCursor(13,line);lcd.print(ftostr3(intround(degTargetHotend0())));
+        } 
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=intround(degTargetHotend0());
+          }
+          else
+          {
+            setTargetHotend0(encoderpos);
+            encoderpos=activeline*lcdslow;
+            beepshort();
+          }
+          BLOCK;
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>260) encoderpos=260;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+        }
+      }break;
+      #if (HEATER_BED_PIN > -1)
+      case ItemT_bed:
+      {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_BED);
+          lcd.setCursor(13,line);lcd.print(ftostr3(intround(degTargetBed())));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=intround(degTargetBed());
+          }
+          else
+          {
+            setTargetBed(encoderpos);
+            encoderpos=activeline*lcdslow;
+            beepshort();
+          }
+          BLOCK;
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>260) encoderpos=260;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+        }
+      }break;
+      #endif
+
+      
+      case ItemT_fan:
+      {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_FAN_SPEED);
+          lcd.setCursor(13,line);lcd.print(ftostr3(FanSpeed));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED) //nalogWrite(FAN_PIN,  fanpwm);
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=FanSpeed;
+          }
+          else
+          {
+            encoderpos=activeline*lcdslow;
+            beepshort();
+          }
+          BLOCK;
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>255) encoderpos=255;
+          FanSpeed=encoderpos;
+            analogWrite(FAN_PIN,  FanSpeed);
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+        }
+        
+      }break;
+      case ItemT_flow://axis_steps_per_unit[i] = code_value();
+         {
+      if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_FLOW);
+          lcd.setCursor(13,line);lcd.print(ftostr52(axis_steps_per_unit[E_AXIS]));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(long)(axis_steps_per_unit[E_AXIS]*100.0);
+          }
+          else
+          {
+            float factor=float(encoderpos)/100.0/float(axis_steps_per_unit[E_AXIS]);
+            position[E_AXIS]=lround(position[E_AXIS]*factor);
+            //current_position[E_AXIS]*=factor;
+            axis_steps_per_unit[E_AXIS]= encoderpos/100.0;
+            encoderpos=activeline*lcdslow;
+              
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<5) encoderpos=5;
+          if(encoderpos>999999) encoderpos=999999;
+          lcd.setCursor(13,line);lcd.print(ftostr52(encoderpos/100.0));
+        }
+        
+      }break; 
+    default:   
+      break;
+  }
+  line++;
+ }
+ updateActiveLines(ItemT_fan,encoderpos);
+}
+
+/*does not work
+#define MENUCHANGEITEM(repaint_action,  enter_action, accept_action,  change_action) \
+   {\
+     if(force_lcd_update)  { lcd.setCursor(0,line);  repaint_action; } \
+     if(activeline==line)  \
+     { \
+       if(CLICKED) \
+       { \
+         linechanging=!linechanging; \
+         if(linechanging)  {enter_action;} \
+         else {accept_action;} \
+       }  \
+       else \
+       if(linechanging) {change_action};}\
+   }
+*/   
+
+enum {
+  ItemCT_exit,ItemCT_nozzle0,
+#ifdef AUTOTEMP
+  ItemCT_autotempactive,
+  ItemCT_autotempmin,ItemCT_autotempmax,ItemCT_autotempfact,
+#endif
+#if EXTRUDERS > 1
+  ItemCT_nozzle1,
+#endif
+#if EXTRUDERS > 2
+  ItemCT_nozzle2,
+#endif
+#if defined BED_USES_THERMISTOR || defined BED_USES_AD595
+ItemCT_bed,
+#endif  
+  ItemCT_fan,
+  ItemCT_PID_P,ItemCT_PID_I,ItemCT_PID_D,ItemCT_PID_C,
+  ItemCT_PLA_PreHeat_Setting, 
+  ItemCT_ABS_PreHeat_Setting,
+};
+
+void MainMenu::showControlTemp()
+{
+  uint8_t line=0;
+ clearIfNecessary();
+ for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
+ {
+  switch(i)
+  {
+    case ItemCT_exit:
+      MENUITEM(  LCD_PRINT_PGM(MSG_CONTROL)  ,  BLOCK;status=Main_Control;beepshort(); ) ;
+      break;
+    case ItemCT_nozzle0:
+      {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_NOZZLE);
+          lcd.setCursor(13,line);lcd.print(ftostr3(intround(degTargetHotend0())));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=intround(degTargetHotend0());
+          }
+          else
+          {
+            setTargetHotend0(encoderpos);
+            encoderpos=activeline*lcdslow;
+            beepshort();
+          }
+          BLOCK;
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>260) encoderpos=260;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+        }
+        
+      }break;
+    #if EXTRUDERS > 1
+    case ItemCT_nozzle1:
+      {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_NOZZLE1);
+          lcd.setCursor(13,line);lcd.print(ftostr3(intround(degTargetHotend1())));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=intround(degTargetHotend1());
+          }
+          else
+          {
+            setTargetHotend1(encoderpos);
+            encoderpos=activeline*lcdslow;
+            beepshort();
+          }
+          BLOCK;
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>260) encoderpos=260;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+        }
+        
+      }break;
+    #endif
+    #if EXTRUDERS > 2
+    case ItemCT_nozzle2:
+      {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_NOZZLE2);
+          lcd.setCursor(13,line);lcd.print(ftostr3(intround(degTargetHotend2())));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=intround(degTargetHotend2());
+          }
+          else
+          {
+            setTargetHotend2(encoderpos);
+            encoderpos=activeline*lcdslow;
+            beepshort();
+          }
+          BLOCK;
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>260) encoderpos=260;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+        }
+        
+      }break;
+    #endif
+    #ifdef AUTOTEMP
+    case ItemCT_autotempmin:
+      {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_MIN);
+          lcd.setCursor(13,line);lcd.print(ftostr3(autotemp_min));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=intround(autotemp_min);
+          }
+          else
+          {
+            autotemp_min=encoderpos;
+            encoderpos=activeline*lcdslow;
+            beepshort();
+          }
+          BLOCK;
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>260) encoderpos=260;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+        }
+        
+      }break;  
+    case ItemCT_autotempmax:
+      {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_MAX);
+          lcd.setCursor(13,line);lcd.print(ftostr3(autotemp_max));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=intround(autotemp_max);
+          }
+          else
+          {
+            autotemp_max=encoderpos;
+            encoderpos=activeline*lcdslow;
+            beepshort();
+          }
+          BLOCK;
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>260) encoderpos=260;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+        }
+        
+      }break;  
+    case ItemCT_autotempfact:
+      {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_FACTOR);
+          lcd.setCursor(13,line);lcd.print(ftostr32(autotemp_factor));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=intround(autotemp_factor*100);
+          }
+          else
+          {
+            autotemp_max=encoderpos;
+            encoderpos=activeline*lcdslow;
+            beepshort();
+          }
+          BLOCK;
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>99) encoderpos=99;
+          lcd.setCursor(13,line);lcd.print(ftostr32(encoderpos/100.));
+        }
+        
+      }break;
+    case ItemCT_autotempactive:
+      {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_AUTOTEMP);
+          lcd.setCursor(13,line);
+          if(autotemp_enabled)
+            LCD_PRINT_PGM(MSG_ON);
+          else
+            LCD_PRINT_PGM(MSG_OFF);
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          autotemp_enabled=!autotemp_enabled;
+          lcd.setCursor(13,line);
+          if(autotemp_enabled)
+            LCD_PRINT_PGM(MSG_ON);
+          else
+            LCD_PRINT_PGM(MSG_OFF);
+          BLOCK;
+        }
+        
+      }break;  
+    #endif //autotemp
+    #if defined BED_USES_THERMISTOR || defined BED_USES_AD595
+    case ItemCT_bed:
+      {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_BED);
+          lcd.setCursor(13,line);lcd.print(ftostr3(intround(degTargetBed())));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=intround(degTargetBed());
+          }
+          else
+          {
+            setTargetBed(encoderpos);
+            encoderpos=activeline*lcdslow;
+            beepshort();
+          }
+          BLOCK;
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>260) encoderpos=260;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+        }
+      }break;
+    #endif
+    case ItemCT_fan:
+      {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_FAN_SPEED);
+          lcd.setCursor(13,line);lcd.print(ftostr3(FanSpeed));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED) //nalogWrite(FAN_PIN,  fanpwm);
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=FanSpeed;
+          }
+          else
+          {
+            encoderpos=activeline*lcdslow;
+            beepshort();
+          }
+          BLOCK;
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>255) encoderpos=255;
+          FanSpeed=encoderpos;
+            analogWrite(FAN_PIN,  FanSpeed);
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+        }
+        
+      }break;
+    #ifdef PIDTEMP
+    case ItemCT_PID_P: 
+      {
+      if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(" PID-P: ");
+          lcd.setCursor(13,line);lcd.print(itostr4(Kp));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(long)Kp;
+          }
+          else
+          {
+            Kp= encoderpos;
+            encoderpos=activeline*lcdslow;
+              
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<1) encoderpos=1;
+          if(encoderpos>9990) encoderpos=9990;
+          lcd.setCursor(13,line);lcd.print(itostr4(encoderpos));
+        }
+        
+      }break;
+    case ItemCT_PID_I: 
+      {
+      if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_PID_I);
+          lcd.setCursor(13,line);lcd.print(ftostr51(Ki/PID_dT));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(long)(Ki*10/PID_dT);
+          }
+          else
+          {
+            Ki= encoderpos/10.*PID_dT;
+            encoderpos=activeline*lcdslow;
+              
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>9990) encoderpos=9990;
+          lcd.setCursor(13,line);lcd.print(ftostr51(encoderpos/10.));
+        }
+        
+      }break;
+    case ItemCT_PID_D: 
+      {
+      if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_PID_D);
+          lcd.setCursor(13,line);lcd.print(itostr4(Kd*PID_dT));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(long)(Kd/5./PID_dT);
+          }
+          else
+          {
+            Kd= encoderpos;
+            encoderpos=activeline*lcdslow;
+              
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>9990) encoderpos=9990;
+          lcd.setCursor(13,line);lcd.print(itostr4(encoderpos));
+        }
+       
+      }break;   
+    case ItemCT_PID_C: 
+      #ifdef PID_ADD_EXTRUSION_RATE
+      {
+      if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_PID_C);
+          lcd.setCursor(13,line);lcd.print(itostr3(Kc));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(long)Kc;
+          }
+          else
+          {
+            Kc= encoderpos;
+            encoderpos=activeline*lcdslow;
+              
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>990) encoderpos=990;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+        }
+        
+      }
+      #endif
+    #endif
+      break;
+	  case ItemCT_PLA_PreHeat_Setting:
+        MENUITEM(  LCD_PRINT_PGM(MSG_PREHEAT_PLA_SETTINGS)  ,  BLOCK;status=Sub_PreheatPLASettings;beepshort(); ) ;
+	  break;
+	  case ItemCT_ABS_PreHeat_Setting:
+        MENUITEM(  LCD_PRINT_PGM(MSG_PREHEAT_ABS_SETTINGS)  ,  BLOCK;status=Sub_PreheatABSSettings;beepshort(); ) ;
+	  break;
+    default:   
+      break;
+  }
+  line++;
+ }
+
+  updateActiveLines(ItemCT_ABS_PreHeat_Setting,encoderpos);
+}
+
+
+enum {
+  ItemCM_exit, 
+  ItemCM_acc, ItemCM_xyjerk, 
+  ItemCM_vmaxx, ItemCM_vmaxy, ItemCM_vmaxz, ItemCM_vmaxe, 
+  ItemCM_vtravmin,ItemCM_vmin,  
+  ItemCM_amaxx, ItemCM_amaxy, ItemCM_amaxz, ItemCM_amaxe, 
+  ItemCM_aret, ItemCM_xsteps,ItemCM_ysteps, ItemCM_zsteps, ItemCM_esteps
+};
+
+
+
+void MainMenu::showControlMotion()
+{
+ uint8_t line=0;
+ clearIfNecessary();
+ for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
+ {
+  switch(i)
+  {
+    case ItemCM_exit:
+      MENUITEM(  LCD_PRINT_PGM(MSG_CONTROL)  ,  BLOCK;status=Main_Control;beepshort(); ) ;
+      break;
+    case ItemCM_acc:
+    {
+      if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_ACC);
+          lcd.setCursor(13,line);lcd.print(itostr3(acceleration/100));LCD_PRINT_PGM("00");
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(long)acceleration/100;
+          }
+          else
+          {
+            acceleration= encoderpos*100;
+            encoderpos=activeline*lcdslow;
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<5) encoderpos=5;
+          if(encoderpos>990) encoderpos=990;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));LCD_PRINT_PGM("00");
+        }
+        
+      }break;
+    case ItemCM_xyjerk: //max_xy_jerk
+      {
+      if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_VXY_JERK);
+          lcd.setCursor(13,line);lcd.print(itostr3(max_xy_jerk));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(long)max_xy_jerk;
+          }
+          else
+          {
+            max_xy_jerk= encoderpos;
+            encoderpos=activeline*lcdslow;
+              
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<1) encoderpos=1;
+          if(encoderpos>990) encoderpos=990;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+        }
+        
+      }break;
+      
+    case ItemCM_vmaxx:
+    case ItemCM_vmaxy:
+    case ItemCM_vmaxz:
+    case ItemCM_vmaxe:
+      {
+      if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_VMAX);
+          if(i==ItemCM_vmaxx)LCD_PRINT_PGM(MSG_X);
+          if(i==ItemCM_vmaxy)LCD_PRINT_PGM(MSG_Y);
+          if(i==ItemCM_vmaxz)LCD_PRINT_PGM(MSG_Z);
+          if(i==ItemCM_vmaxe)LCD_PRINT_PGM(MSG_E);
+          lcd.setCursor(13,line);lcd.print(itostr3(max_feedrate[i-ItemCM_vmaxx]));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(long)max_feedrate[i-ItemCM_vmaxx];
+          }
+          else
+          {
+            max_feedrate[i-ItemCM_vmaxx]= encoderpos;
+            encoderpos=activeline*lcdslow;
+              
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<1) encoderpos=1;
+          if(encoderpos>990) encoderpos=990;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+        }
+        
+      }break;
+    
+    case ItemCM_vmin:
+    {
+      if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_VMIN);
+          lcd.setCursor(13,line);lcd.print(itostr3(minimumfeedrate));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(long)(minimumfeedrate);
+          }
+          else
+          {
+            minimumfeedrate= encoderpos;
+            encoderpos=activeline*lcdslow;
+              
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>990) encoderpos=990;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+        }
+        
+      }break;
+    case ItemCM_vtravmin:
+    {
+      if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_VTRAV_MIN);
+          lcd.setCursor(13,line);lcd.print(itostr3(mintravelfeedrate));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(long)mintravelfeedrate;
+          }
+          else
+          {
+            mintravelfeedrate= encoderpos;
+            encoderpos=activeline*lcdslow;
+              
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>990) encoderpos=990;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+        }
+        
+      }break;
+    
+    case ItemCM_amaxx:      
+    case ItemCM_amaxy:
+    case ItemCM_amaxz:
+    case ItemCM_amaxe:
+    {
+      if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(" Amax ");
+          if(i==ItemCM_amaxx)LCD_PRINT_PGM(MSG_X);
+          if(i==ItemCM_amaxy)LCD_PRINT_PGM(MSG_Y);
+          if(i==ItemCM_amaxz)LCD_PRINT_PGM(MSG_Z);
+          if(i==ItemCM_amaxe)LCD_PRINT_PGM(MSG_E);
+          lcd.setCursor(13,line);lcd.print(itostr3(max_acceleration_units_per_sq_second[i-ItemCM_amaxx]/100));LCD_PRINT_PGM("00");
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(long)max_acceleration_units_per_sq_second[i-ItemCM_amaxx]/100;
+          }
+          else
+          {
+            max_acceleration_units_per_sq_second[i-ItemCM_amaxx]= encoderpos*100;
+            encoderpos=activeline*lcdslow;
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<1) encoderpos=1;
+          if(encoderpos>990) encoderpos=990;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));LCD_PRINT_PGM("00");
+        }
+        
+      }break;
+     
+    
+    case ItemCM_aret://float retract_acceleration = 7000;
+    {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_A_RETRACT);
+          lcd.setCursor(13,line);lcd.print(ftostr3(retract_acceleration/100));LCD_PRINT_PGM("00");
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(long)retract_acceleration/100;
+          }
+          else
+          {
+            retract_acceleration= encoderpos*100;
+            encoderpos=activeline*lcdslow;
+              
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<10) encoderpos=10;
+          if(encoderpos>990) encoderpos=990;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));LCD_PRINT_PGM("00");
+        }
+        
+      }break;
+       case ItemCM_xsteps://axis_steps_per_unit[i] = code_value();
+         {
+      if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_XSTEPS);
+          lcd.setCursor(11,line);lcd.print(ftostr52(axis_steps_per_unit[X_AXIS]));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(long)(axis_steps_per_unit[X_AXIS]*100.0);
+          }
+          else
+          {
+            float factor=float(encoderpos)/100.0/float(axis_steps_per_unit[X_AXIS]);
+            position[X_AXIS]=lround(position[X_AXIS]*factor);
+            //current_position[X_AXIS]*=factor;
+            axis_steps_per_unit[X_AXIS]= encoderpos/100.0;
+            encoderpos=activeline*lcdslow;
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<5) encoderpos=5;
+          if(encoderpos>999999) encoderpos=999999;
+          lcd.setCursor(11,line);lcd.print(ftostr52(encoderpos/100.0));
+        }
+        
+      }break;
+       case ItemCM_ysteps://axis_steps_per_unit[i] = code_value();
+         {
+      if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_YSTEPS);
+          lcd.setCursor(11,line);lcd.print(ftostr52(axis_steps_per_unit[Y_AXIS]));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(long)(axis_steps_per_unit[Y_AXIS]*100.0);
+          }
+          else
+          {
+            float factor=float(encoderpos)/100.0/float(axis_steps_per_unit[Y_AXIS]);
+            position[Y_AXIS]=lround(position[Y_AXIS]*factor);
+            //current_position[Y_AXIS]*=factor;
+            axis_steps_per_unit[Y_AXIS]= encoderpos/100.0;
+            encoderpos=activeline*lcdslow;
+              
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<5) encoderpos=5;
+          if(encoderpos>999999) encoderpos=999999;
+          lcd.setCursor(11,line);lcd.print(ftostr52(encoderpos/100.0));
+        }
+        
+      }break;
+       case ItemCM_zsteps://axis_steps_per_unit[i] = code_value();
+         {
+      if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_ZSTEPS);
+          lcd.setCursor(11,line);lcd.print(ftostr51(axis_steps_per_unit[Z_AXIS]));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(long)(axis_steps_per_unit[Z_AXIS]*100.0);
+          }
+          else
+          {
+            float factor=float(encoderpos)/100.0/float(axis_steps_per_unit[Z_AXIS]);
+            position[Z_AXIS]=lround(position[Z_AXIS]*factor);
+            //current_position[Z_AXIS]*=factor;
+            axis_steps_per_unit[Z_AXIS]= encoderpos/100.0;
+            encoderpos=activeline*lcdslow;
+              
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<5) encoderpos=5;
+          if(encoderpos>999999) encoderpos=999999;
+          lcd.setCursor(11,line);lcd.print(ftostr52(encoderpos/100.0));
+        }
+        
+      }break;
+      
+    case ItemCM_esteps://axis_steps_per_unit[i] = code_value();
+         {
+      if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_ESTEPS);
+          lcd.setCursor(11,line);lcd.print(ftostr51(axis_steps_per_unit[E_AXIS]));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(long)(axis_steps_per_unit[E_AXIS]*100.0);
+          }
+          else
+          {
+            float factor=float(encoderpos)/100.0/float(axis_steps_per_unit[E_AXIS]);
+            position[E_AXIS]=lround(position[E_AXIS]*factor);
+            //current_position[E_AXIS]*=factor;
+            axis_steps_per_unit[E_AXIS]= encoderpos/100.0;
+            encoderpos=activeline*lcdslow;
+              
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<5) encoderpos=5;
+          if(encoderpos>999999) encoderpos=999999;
+          lcd.setCursor(11,line);lcd.print(ftostr52(encoderpos/100.0));
+        }
+        
+      }break; 
+    default:   
+      break;
+  }
+  line++;
+ }
+ updateActiveLines(ItemCM_esteps,encoderpos);
+}
+
+
+enum {
+  ItemR_exit,
+  ItemR_autoretract,
+  ItemR_retract_length,ItemR_retract_feedrate,ItemR_retract_zlift,
+  ItemR_unretract_length,ItemR_unretract_feedrate,
+  
+};
+
+
+
+void MainMenu::showControlRetract()
+{
+#ifdef FWRETRACT
+ uint8_t line=0;
+ clearIfNecessary();
+ for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
+ {
+  switch(i)
+  {
+    case ItemR_exit:
+      MENUITEM(  LCD_PRINT_PGM(MSG_CONTROL)  ,  BLOCK;status=Main_Control;beepshort(); ) ;
+      break;
+    
+      //float retract_length=2, retract_feedrate=1200, retract_zlift=0.4;
+  //float retract_recover_length=0, retract_recover_feedrate=500;
+      case ItemR_autoretract:
+      {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_AUTORETRACT);
+          lcd.setCursor(13,line);
+          if(autoretract_enabled)
+            LCD_PRINT_PGM(MSG_ON);
+          else
+            LCD_PRINT_PGM(MSG_OFF);
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          autoretract_enabled=!autoretract_enabled;
+          lcd.setCursor(13,line);
+          if(autoretract_enabled)
+            LCD_PRINT_PGM(MSG_ON);
+          else
+            LCD_PRINT_PGM(MSG_OFF);
+          BLOCK;
+        }
+        
+      }break;  
+    
+      case ItemR_retract_length:
+    {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_CONTROL_RETRACT);
+          lcd.setCursor(13,line);lcd.print(ftostr52(retract_length));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(long)(retract_length*100);
+          }
+          else
+          {
+            retract_length= encoderpos/100.;
+            encoderpos=activeline*lcdslow;
+              
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<1) encoderpos=1;
+          if(encoderpos>990) encoderpos=990;
+          lcd.setCursor(13,line);lcd.print(ftostr52(encoderpos/100.));
+        }
+        
+      }break;
+      case ItemR_retract_feedrate:
+    {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_CONTROL_RETRACTF);
+          lcd.setCursor(13,line);lcd.print(itostr4(retract_feedrate));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(long)(retract_feedrate/5);
+          }
+          else
+          {
+            retract_feedrate= encoderpos*5.;
+            encoderpos=activeline*lcdslow;
+              
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<1) encoderpos=1;
+          if(encoderpos>990) encoderpos=990;
+          lcd.setCursor(13,line);lcd.print(itostr4(encoderpos*5));
+        }
+        
+      }break;
+      case ItemR_retract_zlift://float retract_acceleration = 7000;
+    {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_CONTROL_RETRACT_ZLIFT);
+          lcd.setCursor(13,line);lcd.print(ftostr52(retract_zlift));;
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(long)(retract_zlift*10);
+          }
+          else
+          {
+            retract_zlift= encoderpos/10.;
+            encoderpos=activeline*lcdslow;
+              
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>990) encoderpos=990;
+          lcd.setCursor(13,line);lcd.print(ftostr52(encoderpos/10.));
+        }
+        
+      }break;
+      case ItemR_unretract_length:
+    {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_CONTROL_RETRACT_RECOVER);
+          lcd.setCursor(13,line);lcd.print(ftostr52(retract_recover_length));;
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(long)(retract_recover_length*100);
+          }
+          else
+          {
+            retract_recover_length= encoderpos/100.;
+            encoderpos=activeline*lcdslow;
+              
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>990) encoderpos=990;
+          lcd.setCursor(13,line);lcd.print(ftostr52(encoderpos/100.));
+        }
+        
+      }break;
+      
+      case ItemR_unretract_feedrate:
+    {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_CONTROL_RETRACT_RECOVERF);
+          lcd.setCursor(13,line);lcd.print(itostr4(retract_recover_feedrate));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(long)retract_recover_feedrate/5;
+          }
+          else
+          {
+            retract_recover_feedrate= encoderpos*5.;
+            encoderpos=activeline*lcdslow;
+              
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<1) encoderpos=1;
+          if(encoderpos>990) encoderpos=990;
+          lcd.setCursor(13,line);lcd.print(itostr4(encoderpos*5));
+        }
+        
+      }break;
+    
+    default:   
+      break;
+  }
+  line++;
+ }
+ updateActiveLines(ItemR_unretract_feedrate,encoderpos);
+#endif
+}
+
+
+
+enum {
+  ItemC_exit,ItemC_temp,ItemC_move,
+#ifdef FWRETRACT
+  ItemC_rectract,
+#endif
+  ItemC_store, ItemC_load,ItemC_failsafe
+};
+
+void MainMenu::showControl()
+{
+ uint8_t line=0;
+ clearIfNecessary();
+ for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
+ {
+  switch(i)
+  {
+    case ItemC_exit:
+      MENUITEM(  LCD_PRINT_PGM(MSG_MAIN_WIDE)  ,  BLOCK;status=Main_Menu;beepshort(); ) ;
+      break;
+    case ItemC_temp:
+      MENUITEM(  LCD_PRINT_PGM(MSG_TEMPERATURE_WIDE)  ,  BLOCK;status=Sub_TempControl;beepshort(); ) ;
+      break;
+   case ItemC_move:
+      MENUITEM(  LCD_PRINT_PGM(MSG_MOTION_WIDE)  ,  BLOCK;status=Sub_MotionControl;beepshort(); ) ;
+      break;
+#ifdef FWRETRACT
+    case ItemC_rectract:
+      MENUITEM(  LCD_PRINT_PGM(MSG_RECTRACT_WIDE)  ,  BLOCK;status=Sub_RetractControl;beepshort(); ) ;
+      break;
+#endif
+    case ItemC_store:
+    {
+      if(force_lcd_update)
+      {
+        lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_STORE_EPROM);
+      }
+      if((activeline==line) && CLICKED)
+      {
+        //enquecommand("M84");
+        beepshort();
+        BLOCK;
+        Config_StoreSettings();
+      }
+    }break;
+    case ItemC_load:
+    {
+      if(force_lcd_update)
+      {
+        lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_LOAD_EPROM);
+      }
+      if((activeline==line) && CLICKED)
+      {
+        //enquecommand("M84");
+        beepshort();
+        BLOCK;
+        Config_RetrieveSettings();
+      }
+    }break;
+    case ItemC_failsafe:
+    {
+      if(force_lcd_update)
+      {
+        lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_RESTORE_FAILSAFE);
+      }
+      if((activeline==line) && CLICKED)
+      {
+        //enquecommand("M84");
+        beepshort();
+        BLOCK;
+        Config_ResetDefault();
+      }
+    }break;
+    default:   
+      break;
+  }
+  line++;
+ }
+ updateActiveLines(ItemC_failsafe,encoderpos);
+}
+
+
+
+
+
+void MainMenu::showSD()
+{
+#ifdef SDSUPPORT
+ uint8_t line=0;
+
+ clearIfNecessary();
+ static uint8_t nrfiles=0;
+ if(force_lcd_update)
+ {
+  if(card.cardOK)
+  {
+    nrfiles=card.getnrfilenames();
+  }
+  else
+  {
+    nrfiles=0;
+    lineoffset=0;
+  }
+ }
+ bool enforceupdate=false;
+ for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
+ {
+  switch(i)
+  {
+    case 0:
+      MENUITEM(  LCD_PRINT_PGM(MSG_MAIN)  ,  BLOCK;status=Main_Menu;beepshort(); ) ;
+      break;
+//     case 1:
+//       {
+//         if(force_lcd_update)
+//         {
+//           lcd.setCursor(0,line);
+//           if(CARDINSERTED)
+//           {
+//             LCD_PRINT_PGM(" \004Refresh");
+//           }
+//           else
+//           {
+//             LCD_PRINT_PGM(" \004Insert Card");
+//           }
+//           
+//         }
+//         if((activeline==line) && CLICKED)
+//         {
+//           BLOCK;
+//           beepshort();
+//           card.initsd();
+//           force_lcd_update=true;
+//            nrfiles=card.getnrfilenames();
+//         }
+//       }break;
+    case 1:
+      MENUITEM(  lcd.print(" ");card.getWorkDirName();
+	  if(card.filename[0]=='/') LCD_PRINT_PGM(MSG_REFRESH);
+	  else {
+		  lcd.print("\005");
+		  lcd.print(card.filename);
+		  lcd.print("/..");
+			}  ,  
+	BLOCK;
+			if(SDCARDDETECT == -1) card.initsd();
+			card.updir();
+			enforceupdate=true;
+			lineoffset=0;
+			beepshort(); ) ;
+      
+      break;
+    default:
+    {
+      #define FIRSTITEM 2
+      if(i-FIRSTITEM<nrfiles)
+      {
+        if(force_lcd_update)
+        {
+          card.getfilename(i-FIRSTITEM);
+          //Serial.print("Filenr:");Serial.println(i-2);
+          lcd.setCursor(0,line);LCD_PRINT_PGM(" ");
+          if(card.filenameIsDir)
+          {
+            lcd.print("\005");
+            card.longFilename[LCD_WIDTH-2] = '\0';
+          }
+          if (card.longFilename[0])
+          {
+            card.longFilename[LCD_WIDTH-1] = '\0';
+            lcd.print(card.longFilename);
+          }
+          else
+          {
+            lcd.print(card.filename);
+          }
+        }
+        if((activeline==line) && CLICKED)
+        {
+          BLOCK
+          card.getfilename(i-FIRSTITEM);
+          if(card.filenameIsDir)
+          {
+            for(uint8_t i=0;i<strlen(card.filename);i++)
+              card.filename[i]=tolower(card.filename[i]);
+            card.chdir(card.filename);
+            lineoffset=0;
+            enforceupdate=true;
+          }
+          else
+          {
+            char cmd[30];
+            for(uint8_t i=0;i<strlen(card.filename);i++)
+              card.filename[i]=tolower(card.filename[i]);
+            sprintf(cmd,"M23 %s",card.filename);
+            //sprintf(cmd,"M115");
+            enquecommand(cmd);
+            enquecommand("M24");
+            beep(); 
+            status=Main_Status;
+            if (card.longFilename[0])
+            {
+              card.longFilename[LCD_WIDTH-1] = '\0';
+              lcd_status(card.longFilename);
+            }
+            else
+            {
+              lcd_status(card.filename);
+            }
+          }
+        } 
+      }
+      
+    }
+      break;
+  }
+  line++;
+ }
+ updateActiveLines(FIRSTITEM+nrfiles-1,encoderpos);
+ if(enforceupdate)
+ {
+   force_lcd_update=true;
+   enforceupdate=false;
+ }
+#endif
+}
+
+
+enum {ItemM_watch, ItemM_prepare, ItemM_control, ItemM_file, ItemM_pause};
+void MainMenu::showMainMenu()
+{
+
+  #ifndef ULTIPANEL
+    force_lcd_update=false;
+  #endif
+  if(tune)
+  {
+    if(!(movesplanned() || IS_SD_PRINTING))
+    {
+      force_lcd_update=true;
+      tune=false;
+    }
+  }
+  else 
+  {
+    if(movesplanned() || IS_SD_PRINTING)
+    {
+      force_lcd_update=true;
+      tune=true;
+    }
+  } 
+  clearIfNecessary();
+  uint8_t line=0;
+  for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
+  {
+    switch(i)
+    { 
+      case ItemM_watch:
+        MENUITEM(  LCD_PRINT_PGM(MSG_WATCH)  ,  BLOCK;status=Main_Status;beepshort(); ) ;
+       break;
+      case ItemM_prepare:
+        MENUITEM(  if(!tune) LCD_PRINT_PGM(MSG_PREPARE);else  LCD_PRINT_PGM(MSG_TUNE); ,  BLOCK;status=Main_Prepare;beepshort(); ) ;
+      break;
+       
+      case ItemM_control:
+        MENUITEM(  LCD_PRINT_PGM(MSG_CONTROL_ARROW)  ,  BLOCK;status=Main_Control;beepshort(); ) ;
+      break;
+      #ifdef SDSUPPORT
+      case ItemM_file:    
+      {
+        if(force_lcd_update) 
+        {
+          lcd.setCursor(0,line);
+          if(CARDINSERTED)
+          {
+            if(card.sdprinting)
+              LCD_PRINT_PGM(MSG_STOP_PRINT);
+            else
+              LCD_PRINT_PGM(MSG_CARD_MENU);
+          }
+          else
+          {
+           LCD_PRINT_PGM(MSG_NO_CARD); 
+          }
+        }
+        if(CARDINSERTED&&(activeline==line)&&CLICKED)
+        {
+          card.printingHasFinished();
+          BLOCK;
+          status=Main_SD;
+          beepshort();
+        }
+      }break;
+        case ItemM_pause:
+        {
+            if(force_lcd_update)
+            {
+                lcd.setCursor(0,line);
+                if(CARDINSERTED)
+                {
+                    if(card.sdprinting)
+                        LCD_PRINT_PGM(MSG_PAUSE_PRINT);
+                    else
+                        LCD_PRINT_PGM(MSG_RESUME_PRINT);
+                }
+                else
+                {
+                    //LCD_PRINT_PGM(MSG_NO_CARD);
+                }
+            }
+            if(CARDINSERTED && (activeline==line) && CLICKED)
+            {
+                if(card.sdprinting)
+                {
+                    card.pauseSDPrint();
+                    beepshort();
+                    status = Main_Status;
+                }
+                else
+                {
+                    card.startFileprint();
+                    starttime=millis();
+                    beepshort();
+                    status = Main_Status;
+                }
+            }
+        }break;
+      #else
+      case ItemM_file:
+        break;
+        case ItemM_pause:
+            break;
+      #endif
+      default:
+        SERIAL_ERROR_START;
+        SERIAL_ERRORLNPGM(MSG_SERIAL_ERROR_MENU_STRUCTURE);
+      break;
+    }
+    line++;
+  }
+    
+    uint8_t numberOfLines = 4;
+#ifdef SDSUPPORT
+    numberOfLines = 4;
+#else
+    numberOfLines = 3;
+#endif
+    updateActiveLines(numberOfLines,encoderpos);
+}
+
+void MainMenu::update()
+{
+  static MainStatus oldstatus=Main_Menu;  //init automatically causes foce_lcd_update=true
+  static unsigned long timeoutToStatus=0;
+  #if (SDCARDDETECT > -1)
+    //This code is only relivant if you have an SDcard detect pin.
+    static bool oldcardstatus=false;
+    if((CARDINSERTED != oldcardstatus))
+    {
+      force_lcd_update=true;
+      oldcardstatus=CARDINSERTED;
+      lcd_init(); // to maybe revive the lcd if static electricty killed it.
+      //Serial.println("echo: SD CHANGE");
+      if(CARDINSERTED)
+      {
+        card.initsd();
+        LCD_MESSAGEPGM(MSG_SD_INSERTED);
+      }
+      else
+      {
+        card.release();
+        LCD_MESSAGEPGM(MSG_SD_REMOVED);
+      }
+    }
+  #endif
+ 
+  if(status!=oldstatus)
+  {
+    force_lcd_update=true;
+    encoderpos=0;
+    lineoffset=0;
+    
+    oldstatus=status;
+  }
+  if( (encoderpos!=lastencoderpos) || CLICKED)
+    timeoutToStatus=millis()+STATUSTIMEOUT;
+
+  switch(status)
+  { 
+      case Main_Status: 
+      {  
+        showStatus();
+        if(CLICKED)
+        {
+           linechanging=false;
+           BLOCK
+           status=Main_Menu;
+           timeoutToStatus=millis()+STATUSTIMEOUT;
+        }
+      }break;
+      case Main_Menu: 
+      {
+        showMainMenu();
+        linechanging=false;
+      }break;
+      case Main_Prepare: 
+      {
+        if(tune)
+        {
+          showTune();
+        }
+        else
+        {
+          showPrepare(); 
+        }
+      }break;
+      case Sub_PrepareMove:
+      {        
+            showAxisMove();
+      }break;
+      case Main_Control:
+      {
+        showControl(); 
+      }break;
+      case Sub_MotionControl:
+      {
+        showControlMotion(); 
+      }break;
+      case Sub_RetractControl:
+      {
+        showControlRetract(); 
+      }break;
+      case Sub_TempControl:
+      {
+        showControlTemp(); 
+      }break;
+      case Main_SD: 
+      {
+        showSD();
+      }break;
+	  case Sub_PreheatPLASettings: 
+      {
+        showPLAsettings();
+      }break;
+	  case Sub_PreheatABSSettings: 
+      {
+        showABSsettings();
+      }break;
+  }
+  
+  if(timeoutToStatus<millis())
+    status=Main_Status;
+  //force_lcd_update=false;
+  lastencoderpos=encoderpos;
+}
+
+enum {
+	ItemPLAPreHeat_Exit, 
+	ItemPLAPreHeat_set_PLA_FanSpeed, 
+	ItemPLAPreHeat_set_nozzle, 
+	ItemPLAPreHeat_set_HPB,
+	ItemPLAPreHeat_Store_Eprom
+	};
+  
+void MainMenu::showPLAsettings()
+{
+#ifdef ULTIPANEL
+ uint8_t line=0;
+ clearIfNecessary();
+ for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
+ {
+  switch(i)
+  {
+
+	case ItemPLAPreHeat_Exit:
+      MENUITEM(  LCD_PRINT_PGM(MSG_TEMPERATURE_RTN)  ,  BLOCK;status=Sub_TempControl;beepshort(); ) ;
+      break;
+
+    case ItemPLAPreHeat_set_PLA_FanSpeed:
+       {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_FAN_SPEED);
+          lcd.setCursor(13,line);lcd.print(ftostr3(plaPreheatFanSpeed));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED) 
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+			  encoderpos=plaPreheatFanSpeed;
+          }
+          else
+          {
+            encoderpos=activeline*lcdslow;
+            beepshort();
+          }
+          BLOCK;
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>255) encoderpos=255;
+          plaPreheatFanSpeed=encoderpos;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+        }
+      }break;
+
+    case ItemPLAPreHeat_set_nozzle:
+      {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_NOZZLE);
+          lcd.setCursor(13,line);lcd.print(ftostr3(plaPreheatHotendTemp));
+        } 
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=plaPreheatHotendTemp;
+          }
+          else
+          {
+            encoderpos=activeline*lcdslow;
+            beepshort();
+          }
+          BLOCK;
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>260) encoderpos=260;
+		  plaPreheatHotendTemp = encoderpos;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+        }
+      }break;
+
+    case ItemPLAPreHeat_set_HPB:
+      {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_BED);
+          lcd.setCursor(13,line);lcd.print(ftostr3(plaPreheatHPBTemp));
+        } 
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=plaPreheatHPBTemp;
+          }
+          else
+          {
+            encoderpos=activeline*lcdslow;
+            beepshort();
+          }
+          BLOCK;
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>250) encoderpos=150;
+		  plaPreheatHPBTemp = encoderpos;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+        }
+      }break;
+	case ItemPLAPreHeat_Store_Eprom:
+    {
+      if(force_lcd_update)
+      {
+        lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_STORE_EPROM);
+      }
+      if((activeline==line) && CLICKED)
+      {
+        //enquecommand("M84");
+        beepshort();
+        BLOCK;
+        Config_StoreSettings();
+      }
+    }break;
+      default:   
+      break;
+  }
+  line++;
+ }
+ updateActiveLines(ItemPLAPreHeat_Store_Eprom,encoderpos);
+#endif
+}
+
+enum {
+	ItemABSPreHeat_Exit, 
+	ItemABSPreHeat_set_FanSpeed, 
+	ItemABSPreHeat_set_nozzle, 
+	ItemABSPreHeat_set_HPB,
+	ItemABSPreHeat_Store_Eprom
+	};
+
+void MainMenu::showABSsettings()
+{
+#ifdef ULTIPANEL
+ uint8_t line=0;
+ clearIfNecessary();
+ for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
+ {
+  switch(i)
+  {
+
+	case ItemABSPreHeat_Exit:
+      MENUITEM(  LCD_PRINT_PGM(MSG_TEMPERATURE_RTN)  ,  BLOCK;status=Sub_TempControl;beepshort(); ) ;
+      break;
+
+    case ItemABSPreHeat_set_FanSpeed:
+       {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_FAN_SPEED);
+          lcd.setCursor(13,line);lcd.print(ftostr3(absPreheatFanSpeed));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED) 
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+			  encoderpos=absPreheatFanSpeed;
+          }
+          else
+          {
+            encoderpos=activeline*lcdslow;
+            beepshort();
+          }
+          BLOCK;
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>255) encoderpos=255;
+          absPreheatFanSpeed=encoderpos;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+        }
+      }break;
+
+    case ItemABSPreHeat_set_nozzle:
+      {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_NOZZLE);
+          lcd.setCursor(13,line);lcd.print(ftostr3(absPreheatHotendTemp));
+        } 
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=absPreheatHotendTemp;
+          }
+          else
+          {
+            encoderpos=activeline*lcdslow;
+            beepshort();
+          }
+          BLOCK;
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>260) encoderpos=260;
+		  absPreheatHotendTemp = encoderpos;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+        }
+      }break;
+
+    case ItemABSPreHeat_set_HPB:
+      {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_BED);
+          lcd.setCursor(13,line);lcd.print(ftostr3(absPreheatHPBTemp));
+        } 
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=absPreheatHPBTemp;
+          }
+          else
+          {
+            encoderpos=activeline*lcdslow;
+            beepshort();
+          }
+          BLOCK;
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>250) encoderpos=150;
+		  absPreheatHPBTemp = encoderpos;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+        }
+      }break;
+	case ItemABSPreHeat_Store_Eprom:
+    {
+      if(force_lcd_update)
+      {
+        lcd.setCursor(0,line);LCD_PRINT_PGM(MSG_STORE_EPROM);
+      }
+      if((activeline==line) && CLICKED)
+      {
+        //enquecommand("M84");
+        beepshort();
+        BLOCK;
+        Config_StoreSettings();
+      }
+    }break;
+      default:   
+      break;
+  }
+  line++;
+ }
+ updateActiveLines(ItemABSPreHeat_Store_Eprom,encoderpos);
+#endif
+}
+
+//**********************************************************************************************************
+//  convert float to string with +123.4 format
+char *ftostr3(const float &x)
+{
+  //sprintf(conv,"%5.1f",x);
+  int xx=x;
+  conv[0]=(xx/100)%10+'0';
+  conv[1]=(xx/10)%10+'0';
+  conv[2]=(xx)%10+'0';
+  conv[3]=0;
+  return conv;
+}
+
+char *itostr2(const uint8_t &x)
+{
+  //sprintf(conv,"%5.1f",x);
+  int xx=x;
+  conv[0]=(xx/10)%10+'0';
+  conv[1]=(xx)%10+'0';
+  conv[2]=0;
+  return conv;
+}
+
+//  convert float to string with +123.4 format
+char *ftostr31(const float &x)
+{
+  int xx=x*10;
+  conv[0]=(xx>=0)?'+':'-';
+  xx=abs(xx);
+  conv[1]=(xx/1000)%10+'0';
+  conv[2]=(xx/100)%10+'0';
+  conv[3]=(xx/10)%10+'0';
+  conv[4]='.';
+  conv[5]=(xx)%10+'0';
+  conv[6]=0;
+  return conv;
+}
+
+char *ftostr32(const float &x)
+{
+  long xx=x*100;
+  conv[0]=(xx>=0)?'+':'-';
+  xx=abs(xx);
+  conv[1]=(xx/100)%10+'0';
+  conv[2]='.';
+  conv[3]=(xx/10)%10+'0';
+  conv[4]=(xx)%10+'0';
+  conv[6]=0;
+  return conv;
+}
+
+char *itostr31(const int &xx)
+{
+  conv[0]=(xx>=0)?'+':'-';
+  conv[1]=(xx/1000)%10+'0';
+  conv[2]=(xx/100)%10+'0';
+  conv[3]=(xx/10)%10+'0';
+  conv[4]='.';
+  conv[5]=(xx)%10+'0';
+  conv[6]=0;
+  return conv;
+}
+
+char *itostr3(const int &xx)
+{
+  conv[0]=(xx/100)%10+'0';
+  conv[1]=(xx/10)%10+'0';
+  conv[2]=(xx)%10+'0';
+  conv[3]=0;
+  return conv;
+}
+
+char *itostr4(const int &xx)
+{
+  conv[0]=(xx/1000)%10+'0';
+  conv[1]=(xx/100)%10+'0';
+  conv[2]=(xx/10)%10+'0';
+  conv[3]=(xx)%10+'0';
+  conv[4]=0;
+  return conv;
+}
+
+//  convert float to string with +1234.5 format
+char *ftostr51(const float &x)
+{
+  long xx=x*10;
+  conv[0]=(xx>=0)?'+':'-';
+  xx=abs(xx);
+  conv[1]=(xx/10000)%10+'0';
+  conv[2]=(xx/1000)%10+'0';
+  conv[3]=(xx/100)%10+'0';
+  conv[4]=(xx/10)%10+'0';
+  conv[5]='.';
+  conv[6]=(xx)%10+'0';
+  conv[7]=0;
+  return conv;
+}
+
+//  convert float to string with +123.45 format
+char *ftostr52(const float &x)
+{
+  long xx=x*100;
+  conv[0]=(xx>=0)?'+':'-';
+  xx=abs(xx);
+  conv[1]=(xx/10000)%10+'0';
+  conv[2]=(xx/1000)%10+'0';
+  conv[3]=(xx/100)%10+'0';
+  conv[4]='.';
+  conv[5]=(xx/10)%10+'0';
+  conv[6]=(xx)%10+'0';
+  conv[7]=0;
+  return conv;
+}
+
+#endif //ULTRA_LCD
+
+
diff --git a/Marlin/ultralcd.h b/Marlin/ultralcd.h
index d44c2c3..8b9feea 100644
--- a/Marlin/ultralcd.h
+++ b/Marlin/ultralcd.h
@@ -1,37 +1,41 @@
 #ifndef ULTRALCD_H
 #define ULTRALCD_H
+
 #include "Marlin.h"
+
 #ifdef ULTRA_LCD
-  #include <LiquidCrystal.h>
-  void lcd_status();
-  void lcd_init();
-  void lcd_status(const char* message);
-  void beep();
-  void buttons_init();
-  void buttons_check();
-
-  #define LCD_UPDATE_INTERVAL 100
-  #define STATUSTIMEOUT 15000
-  extern LiquidCrystal lcd;
-  extern volatile char buttons;  //the last checked buttons in a bit array.
+#include "language.h"
+
+#if LANGUAGE_CHOICE == 6
+#include "LiquidCrystalRus.h"
+#define LCD_CLASS LiquidCrystalRus
+#else
+#include <LiquidCrystal.h>
+#define LCD_CLASS LiquidCrystal
+#endif
+
+void lcd_status();
+void lcd_init();
+void lcd_status(const char* message);
+void beep();
+void buttons_init();
+void buttons_check();
+
+#define LCD_UPDATE_INTERVAL 100
+#define STATUSTIMEOUT 15000
+
+extern LCD_CLASS lcd;
+
+extern volatile char buttons;  //the last checked buttons in a bit array.
   
-  #ifdef NEWPANEL
+#ifdef NEWPANEL
     #define EN_C (1<<BLEN_C)
     #define EN_B (1<<BLEN_B)
     #define EN_A (1<<BLEN_A)
-    
+
     #define CLICKED (buttons&EN_C)
     #define BLOCK {blocking=millis()+blocktime;}
-    #if (SDCARDDETECT > -1)
-      #ifdef SDCARDDETECTINVERTED 
-        #define CARDINSERTED (READ(SDCARDDETECT)!=0)
-      #else
-        #define CARDINSERTED (READ(SDCARDDETECT)==0)
-      #endif
-    #endif  //SDCARDTETECTINVERTED
-
-  #else
-
+#else
     //atomatic, do not change
     #define B_LE (1<<BL_LE)
     #define B_UP (1<<BL_UP)
@@ -44,9 +48,18 @@
     
     #define CLICKED ((buttons&B_MI)||(buttons&B_ST))
     #define BLOCK {blocking[BL_MI]=millis()+blocktime;blocking[BL_ST]=millis()+blocktime;}
-    
-  #endif
+#endif
 
+#if (SDCARDDETECT > -1)
+#ifdef SDCARDDETECTINVERTED 
+#define CARDINSERTED (READ(SDCARDDETECT)!=0)
+#else
+#define CARDINSERTED (READ(SDCARDDETECT)==0)
+#endif //SDCARDTETECTINVERTED
+#else
+//If we don't have a card detect line, aways asume the card is inserted
+#define CARDINSERTED true
+#endif
 
     
   // blocking time for recognizing a new keypress of one key, ms
@@ -143,8 +156,8 @@
 
   #define LCD_INIT lcd_init();
   #define LCD_MESSAGE(x) lcd_status(x);
-  #define LCD_MESSAGEPGM(x) lcd_statuspgm(MYPGM(x));
-  #define LCD_ALERTMESSAGEPGM(x) lcd_alertstatuspgm(MYPGM(x));
+  #define LCD_MESSAGEPGM(x) lcd_statuspgm(PSTR(x));
+  #define LCD_ALERTMESSAGEPGM(x) lcd_alertstatuspgm(PSTR(x));
   #define LCD_STATUS lcd_status()
 #else //no lcd
   #define LCD_INIT
@@ -169,4 +182,14 @@ char *itostr31(const int &xx);
 char *itostr3(const int &xx);
 char *itostr4(const int &xx);
 char *ftostr51(const float &x);
+
+//TODO: These do not belong here.
+extern int plaPreheatHotendTemp;
+extern int plaPreheatHPBTemp;
+extern int plaPreheatFanSpeed;
+
+extern int absPreheatHotendTemp;
+extern int absPreheatHPBTemp;
+extern int absPreheatFanSpeed;
+
 #endif //ULTRALCD
diff --git a/Marlin/ultralcd.pde b/Marlin/ultralcd.pde
deleted file mode 100644
index 511d47f..0000000
--- a/Marlin/ultralcd.pde
+++ /dev/null
@@ -1,3023 +0,0 @@
-#include "language.h"
-#include "temperature.h"
-#include "ultralcd.h"
-#ifdef ULTRA_LCD
-#include "Marlin.h"
-#include "language.h"
-#include "temperature.h"
-#include "EEPROMwrite.h"
-#include <LiquidCrystal.h>
-//===========================================================================
-//=============================imported variables============================
-//===========================================================================
-
-extern volatile int feedmultiply;
-extern volatile bool feedmultiplychanged;
-
-extern volatile int extrudemultiply;
-
-extern long position[4];   
-#ifdef SDSUPPORT
-#include "cardreader.h"
-extern CardReader card;
-#endif
-
-//===========================================================================
-//=============================public variables============================
-//===========================================================================
-volatile char buttons=0;  //the last checked buttons in a bit array.
-long encoderpos=0;
-short lastenc=0;
-
-
-//===========================================================================
-//=============================private  variables============================
-//===========================================================================
-static char messagetext[LCD_WIDTH]="";
-
-//return for string conversion routines
-static char conv[8];
-
-LiquidCrystal lcd(LCD_PINS_RS, LCD_PINS_ENABLE, LCD_PINS_D4, LCD_PINS_D5,LCD_PINS_D6,LCD_PINS_D7);  //RS,Enable,D4,D5,D6,D7 
-
-static unsigned long previous_millis_lcd=0;
-//static long previous_millis_buttons=0;
-
-
-#ifdef NEWPANEL
- static long blocking=0;
-#else
- static long blocking[8]={0,0,0,0,0,0,0,0};
-#endif
- 
-static MainMenu menu;
-
-
-void lcdProgMemprint(const char *str)
-{
-  char ch=pgm_read_byte(str);
-  while(ch)
-  {
-    lcd.print(ch);
-    ch=pgm_read_byte(++str);
-  }
-}
-#define lcdprintPGM(x) lcdProgMemprint(MYPGM(x))
-
-
-//===========================================================================
-//=============================functions         ============================
-//===========================================================================
-
-int intround(const float &x){return int(0.5+x);}
-
-void lcd_status(const char* message)
-{
-  strncpy(messagetext,message,LCD_WIDTH);
-  messagetext[strlen(message)]=0;
-}
-
-void lcd_statuspgm(const char* message)
-{
-  char ch=pgm_read_byte(message);
-  char *target=messagetext;
-  uint8_t cnt=0;
-  while(ch &&cnt<LCD_WIDTH)
-  {
-    *target=ch;
-    target++;
-    cnt++;
-    ch=pgm_read_byte(++message);
-  }
-  *target=0;
-}
-
-void lcd_alertstatuspgm(const char* message)
-{
-  lcd_statuspgm(message); 
-  menu.showStatus(); 
-}
-
-FORCE_INLINE void clear()
-{
-  lcd.clear();
-}
-
-
-void lcd_init()
-{
-  //beep();
-  #ifdef ULTIPANEL
-    buttons_init();
-  #endif
-  
-  byte Degree[8] =
-  {
-    B01100,
-    B10010,
-    B10010,
-    B01100,
-    B00000,
-    B00000,
-    B00000,
-    B00000
-  };
-  byte Thermometer[8] =
-  {
-    B00100,
-    B01010,
-    B01010,
-    B01010,
-    B01010,
-    B10001,
-    B10001,
-    B01110
-  };
-  byte uplevel[8]={0x04, 0x0e, 0x1f, 0x04, 0x1c, 0x00, 0x00, 0x00};//thanks joris
-  byte refresh[8]={0x00, 0x06, 0x19, 0x18, 0x03, 0x13, 0x0c, 0x00}; //thanks joris
-  byte folder [8]={0x00, 0x1c, 0x1f, 0x11, 0x11, 0x1f, 0x00, 0x00}; //thanks joris
-  lcd.begin(LCD_WIDTH, LCD_HEIGHT);
-  lcd.createChar(1,Degree);
-  lcd.createChar(2,Thermometer);
-  lcd.createChar(3,uplevel);
-  lcd.createChar(4,refresh);
-  lcd.createChar(5,folder);
-  LCD_MESSAGEPGM(WELCOME_MSG);
-}
-
-
-void beep()
-{
-  //return;
-  #ifdef ULTIPANEL
-	#if (BEEPER > -1)
-	{
-		pinMode(BEEPER,OUTPUT);
-		for(int8_t i=0;i<20;i++){
-		WRITE(BEEPER,HIGH);
-		delay(5);
-		WRITE(BEEPER,LOW);
-		delay(5);
-		}
-	}
-        #endif
-  #endif
-}
-
-void beepshort()
-{
-  //return;
-  #ifdef ULTIPANEL
-	#if (BEEPER > -1)
-	{
-		pinMode(BEEPER,OUTPUT);
-		for(int8_t i=0;i<10;i++){
-		WRITE(BEEPER,HIGH);
-		delay(3);
-		WRITE(BEEPER,LOW);
-		delay(3);
-		}
-	}
-        #endif
-  #endif  
-}
-
-void lcd_status()
-{
-  #ifdef ULTIPANEL
-    static uint8_t oldbuttons=0;
-    //static long previous_millis_buttons=0;
-    //static long previous_lcdinit=0;
-  //  buttons_check(); // Done in temperature interrupt
-    //previous_millis_buttons=millis();
-    long ms=millis();
-    for(int8_t i=0; i<8; i++) {
-      #ifndef NEWPANEL
-      if((blocking[i]>ms))
-        buttons &= ~(1<<i);
-      #else
-      if((blocking>ms))
-        buttons &= ~(1<<i);        
-      #endif
-    }
-    if((buttons==oldbuttons) &&  ((millis() - previous_millis_lcd) < LCD_UPDATE_INTERVAL)   )
-      return;
-    oldbuttons=buttons;
-  #else
-  
-    if(((millis() - previous_millis_lcd) < LCD_UPDATE_INTERVAL)   )
-      return;
-  #endif
-    
-  previous_millis_lcd=millis();
-  menu.update();
-}
-#ifdef ULTIPANEL  
-
-
-void buttons_init()
-{
-  #ifdef NEWPANEL
-    pinMode(BTN_EN1,INPUT);
-    pinMode(BTN_EN2,INPUT); 
-    pinMode(BTN_ENC,INPUT); 
-    pinMode(SDCARDDETECT,INPUT);
-    WRITE(BTN_EN1,HIGH);
-    WRITE(BTN_EN2,HIGH);
-    WRITE(BTN_ENC,HIGH);
-    #if (SDCARDDETECT > -1)
-    {
-      WRITE(SDCARDDETECT,HIGH);
-    }
-    #endif
-  #else
-    pinMode(SHIFT_CLK,OUTPUT);
-    pinMode(SHIFT_LD,OUTPUT);
-    pinMode(SHIFT_EN,OUTPUT);
-    pinMode(SHIFT_OUT,INPUT);
-    WRITE(SHIFT_OUT,HIGH);
-    WRITE(SHIFT_LD,HIGH); 
-    WRITE(SHIFT_EN,LOW); 
-  #endif
-}
-
-
-void buttons_check()
-{
-  
-  #ifdef NEWPANEL
-    uint8_t newbutton=0;
-    if(READ(BTN_EN1)==0)  newbutton|=EN_A;
-    if(READ(BTN_EN2)==0)  newbutton|=EN_B;
-    if((blocking<millis()) &&(READ(BTN_ENC)==0))
-      newbutton|=EN_C;
-    buttons=newbutton;
-  #else   //read it from the shift register
-    uint8_t newbutton=0;
-    WRITE(SHIFT_LD,LOW);
-    WRITE(SHIFT_LD,HIGH);
-    unsigned char tmp_buttons=0;
-    for(int8_t i=0;i<8;i++)
-    { 
-      newbutton = newbutton>>1;
-      if(READ(SHIFT_OUT))
-        newbutton|=(1<<7);
-      WRITE(SHIFT_CLK,HIGH);
-      WRITE(SHIFT_CLK,LOW);
-    }
-    buttons=~newbutton; //invert it, because a pressed switch produces a logical 0
-  #endif
-  
-  //manage encoder rotation
-  char enc=0;
-  if(buttons&EN_A)
-    enc|=(1<<0);
-  if(buttons&EN_B)
-    enc|=(1<<1);
-  if(enc!=lastenc)
-	{
-    switch(enc)
-    {
-    case encrot0:
-      if(lastenc==encrot3)
-        encoderpos++;
-      else if(lastenc==encrot1)
-        encoderpos--;
-      break;
-    case encrot1:
-      if(lastenc==encrot0)
-        encoderpos++;
-      else if(lastenc==encrot2)
-        encoderpos--;
-      break;
-    case encrot2:
-      if(lastenc==encrot1)
-        encoderpos++;
-      else if(lastenc==encrot3)
-        encoderpos--;
-      break;
-    case encrot3:
-      if(lastenc==encrot2)
-        encoderpos++;
-      else if(lastenc==encrot0)
-        encoderpos--;
-      break;
-    default:
-      ;
-    }
-  }
-  lastenc=enc;
-}
-
-#endif
-
-MainMenu::MainMenu()
-{
-  status=Main_Status;
-  displayStartingRow=0;
-  activeline=0;
-  force_lcd_update=true;
-  linechanging=false;
-  tune=false;
-}
-
-void MainMenu::showStatus()
-{ 
-#if LCD_HEIGHT==4
-  static int olddegHotEnd0=-1;
-  static int oldtargetHotEnd0=-1;
-  //force_lcd_update=true;
-  if(force_lcd_update)  //initial display of content
-  {
-    encoderpos=feedmultiply;
-    clear();
-    lcd.setCursor(0,0);lcdprintPGM("\002---/---\001 ");
-    #if defined BED_USES_THERMISTOR || defined BED_USES_AD595 
-      lcd.setCursor(10,0);lcdprintPGM("B---/---\001 ");
-    #elif EXTRUDERS > 1
-      lcd.setCursor(10,0);lcdprintPGM("\002---/---\001 ");
-    #endif
-  }
-    
-  int tHotEnd0=intround(degHotend0());
-  if((tHotEnd0!=olddegHotEnd0)||force_lcd_update)
-  {
-    lcd.setCursor(1,0);
-    lcd.print(ftostr3(tHotEnd0));
-    olddegHotEnd0=tHotEnd0;
-  }
-  int ttHotEnd0=intround(degTargetHotend0());
-  if((ttHotEnd0!=oldtargetHotEnd0)||force_lcd_update)
-  {
-    lcd.setCursor(5,0);
-    lcd.print(ftostr3(ttHotEnd0));
-    oldtargetHotEnd0=ttHotEnd0;
-  }
-  #if defined BED_USES_THERMISTOR || defined BED_USES_AD595 
-    static int oldtBed=-1;
-    static int oldtargetBed=-1; 
-    int tBed=intround(degBed());
-    if((tBed!=oldtBed)||force_lcd_update)
-    {
-      lcd.setCursor(11,0);
-      lcd.print(ftostr3(tBed));
-      oldtBed=tBed;
-    }
-    int targetBed=intround(degTargetBed());
-    if((targetBed!=oldtargetBed)||force_lcd_update)
-    {
-      lcd.setCursor(15,0);
-      lcd.print(ftostr3(targetBed));
-      oldtargetBed=targetBed;
-    }
-  #elif EXTRUDERS > 1
-    static int olddegHotEnd1=-1;
-    static int oldtargetHotEnd1=-1;
-    int tHotEnd1=intround(degHotend1());
-    if((tHotEnd1!=olddegHotEnd1)||force_lcd_update)
-    {
-      lcd.setCursor(11,0);
-      lcd.print(ftostr3(tHotEnd1));
-      olddegHotEnd1=tHotEnd1;
-    }
-    int ttHotEnd1=intround(degTargetHotend1());
-    if((ttHotEnd1!=oldtargetHotEnd1)||force_lcd_update)
-    {
-      lcd.setCursor(15,0);
-      lcd.print(ftostr3(ttHotEnd1));
-      oldtargetHotEnd1=ttHotEnd1;
-    }
-  #endif
-  //starttime=2;
-  static uint16_t oldtime=0;
-  if(starttime!=0)
-  {
-    lcd.setCursor(0,1);
-    uint16_t time=millis()/60000-starttime/60000;
-    
-    if(starttime!=oldtime)
-    {
-      lcd.print(itostr2(time/60));lcdprintPGM("h ");lcd.print(itostr2(time%60));lcdprintPGM("m");
-      oldtime=time;
-    }
-  }
-  static int oldzpos=0;
-  int currentz=current_position[2]*100;
-  if((currentz!=oldzpos)||force_lcd_update)
-  {
-    lcd.setCursor(10,1);
-    lcdprintPGM("Z:");lcd.print(ftostr52(current_position[2]));
-    oldzpos=currentz;
-  }
-  
-  static int oldfeedmultiply=0;
-  int curfeedmultiply=feedmultiply;
-  
-  if(feedmultiplychanged == true) {
-    feedmultiplychanged = false;
-    encoderpos = curfeedmultiply;
-  }
-  
-  if(encoderpos!=curfeedmultiply||force_lcd_update)
-  {
-   curfeedmultiply=encoderpos;
-   if(curfeedmultiply<10)
-     curfeedmultiply=10;
-   if(curfeedmultiply>999)
-     curfeedmultiply=999;
-   feedmultiply=curfeedmultiply;
-   encoderpos=curfeedmultiply;
-  }
-  
-  if((curfeedmultiply!=oldfeedmultiply)||force_lcd_update)
-  {
-   oldfeedmultiply=curfeedmultiply;
-   lcd.setCursor(0,2);
-   lcd.print(itostr3(curfeedmultiply));lcdprintPGM("% ");
-  }
-  
-  if(messagetext[0]!='\0')
-  {
-    lcd.setCursor(0,LCD_HEIGHT-1);
-    lcd.print(messagetext);
-    uint8_t n=strlen(messagetext);
-    for(int8_t i=0;i<LCD_WIDTH-n;i++)
-      lcd.print(" ");
-    messagetext[0]='\0';
-  }
-#ifdef SDSUPPORT
-  static uint8_t oldpercent=101;
-  uint8_t percent=card.percentDone();
-  if(oldpercent!=percent ||force_lcd_update)
-  {
-     lcd.setCursor(10,2);
-    lcd.print(itostr3((int)percent));
-    lcdprintPGM("%SD");
-  }
-#endif
-#else //smaller LCDS----------------------------------
-  static int olddegHotEnd0=-1;
-  static int oldtargetHotEnd0=-1;
-  if(force_lcd_update)  //initial display of content
-  {
-    encoderpos=feedmultiply;
-    lcd.setCursor(0,0);lcdprintPGM("\002---/---\001 ");
-  }
-    
-  int tHotEnd0=intround(degHotend0());
-  int ttHotEnd0=intround(degTargetHotend0());
-
-
-  if((abs(tHotEnd0-olddegHotEnd0)>1)||force_lcd_update)
-  {
-    lcd.setCursor(1,0);
-    lcd.print(ftostr3(tHotEnd0));
-    olddegHotEnd0=tHotEnd0;
-  }
-  if((ttHotEnd0!=oldtargetHotEnd0)||force_lcd_update)
-  {
-    lcd.setCursor(5,0);
-    lcd.print(ftostr3(ttHotEnd0));
-    oldtargetHotEnd0=ttHotEnd0;
-  }
-
-  if(messagetext[0]!='\0')
-  {
-    lcd.setCursor(0,LCD_HEIGHT-1);
-    lcd.print(messagetext);
-    uint8_t n=strlen(messagetext);
-    for(int8_t i=0;i<LCD_WIDTH-n;i++)
-      lcd.print(" ");
-    messagetext[0]='\0';
-  }
-
-#endif
-  force_lcd_update=false;
-}
-
-enum {ItemP_exit, ItemP_autostart,ItemP_disstep,ItemP_home, ItemP_origin, ItemP_preheat_pla, ItemP_preheat_abs, ItemP_cooldown,/*ItemP_extrude,*/ItemP_move};
-
-//any action must not contain a ',' character anywhere, or this breaks:
-#define MENUITEM(repaint_action, click_action) \
-  {\
-    if(force_lcd_update)  { lcd.setCursor(0,line);  repaint_action; } \
-    if((activeline==line) && CLICKED) {click_action} \
-  }
-  
-void MainMenu::showPrepare()
-{
-#ifdef ULTIPANEL
- uint8_t line=0;
- clearIfNecessary();
- for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
- {
-   //Serial.println((int)(line-lineoffset));
-  switch(i)
-  {
-    case ItemP_exit:
-      MENUITEM(  lcdprintPGM(MSG_MAIN)  ,  BLOCK;status=Main_Menu;beepshort(); ) ;
-      break;
-    case ItemP_autostart:
-      MENUITEM(  lcdprintPGM(MSG_AUTOSTART)  ,  BLOCK;
-#ifdef SDSUPPORT
-          card.lastnr=0;card.setroot();card.checkautostart(true);
-#endif
-          beepshort(); ) ;
-      break;
-    case ItemP_disstep:
-      MENUITEM(  lcdprintPGM(MSG_DISABLE_STEPPERS)  ,  BLOCK;enquecommand("M84");beepshort(); ) ;
-      break;
-    case ItemP_home:
-      MENUITEM(  lcdprintPGM(MSG_AUTO_HOME)  ,  BLOCK;enquecommand("G28");beepshort(); ) ;
-      break;
-    case ItemP_origin:
-      MENUITEM(  lcdprintPGM(MSG_SET_ORIGIN)  ,  BLOCK;enquecommand("G92 X0 Y0 Z0");beepshort(); ) ;
-      break;
-    case ItemP_preheat_pla:
-		MENUITEM(  lcdprintPGM(MSG_PREHEAT_PLA)  ,  BLOCK;setTargetHotend0(plaPreheatHotendTemp);setTargetBed(plaPreheatHPBTemp);
-      #if FAN_PIN > -1
-		FanSpeed = plaPreheatFanSpeed;
-        analogWrite(FAN_PIN,  FanSpeed);
-      #endif
-      beepshort(); );
-      break;
-    case ItemP_preheat_abs:
-      MENUITEM(  lcdprintPGM(MSG_PREHEAT_ABS)  ,  BLOCK;setTargetHotend0(absPreheatHotendTemp);setTargetBed(absPreheatHPBTemp); 
-      #if FAN_PIN > -1
-	  	FanSpeed = absPreheatFanSpeed;
-        analogWrite(FAN_PIN,  FanSpeed);
-      #endif
-      beepshort(); );
-      break;
-    case ItemP_cooldown:
-      MENUITEM(  lcdprintPGM(MSG_COOLDOWN)  ,  BLOCK;setTargetHotend0(0);setTargetHotend1(0);setTargetHotend2(0);setTargetBed(0);beepshort(); ) ;
-      break;
-//    case ItemP_extrude:
-  //    MENUITEM(  lcdprintPGM(" Extrude")  ,  BLOCK;enquecommand("G92 E0");enquecommand("G1 F700 E50");beepshort(); ) ;
-    //  break;
-    case ItemP_move:
-      MENUITEM(  lcdprintPGM(MSG_MOVE_AXIS) , BLOCK;status=Sub_PrepareMove;beepshort(); );
-      break;
-        default:   
-      break;
-  }
-  line++;
- }
- updateActiveLines(ItemP_move,encoderpos);
-#endif
-}
-
-enum {
-  ItemAM_exit,
-  ItemAM_X, ItemAM_Y, ItemAM_Z, ItemAM_E, ItemAM_ERetract
-};
-
-void MainMenu::showAxisMove()
-{
-   uint8_t line=0;
-   int oldencoderpos=0;
-   clearIfNecessary();
-   for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
-   {
-     switch(i)
-      {
-          case ItemAM_exit:
-          MENUITEM(  lcdprintPGM(MSG_PREPARE_ALT)  ,  BLOCK;status=Main_Prepare;beepshort(); ) ;
-          break;
-          case ItemAM_X:
-          {
-	 	  //oldencoderpos=0;
-                  if(force_lcd_update)
-                  {
-                    lcd.setCursor(0,line);lcdprintPGM(" X:");
-                    lcd.setCursor(11,line);lcd.print(ftostr52(current_position[X_AXIS]));
-                  }
-      
-                  if((activeline!=line) )
-                  break;
-                  
-                  if(CLICKED) 
-                  {
-                    linechanging=!linechanging;
-                    if(linechanging)
-                    {
-			enquecommand("G91");
-                    }
-                    else
-                    {
-		      enquecommand("G90");
-                      encoderpos=activeline*lcdslow;
-                      beepshort();
-                    }
-                    BLOCK;
-                  }
-                  if(linechanging)
-                  {
-                    if (encoderpos >0) 
-                   { 
-		    	enquecommand("G1 F700 X0.1");
-			oldencoderpos=encoderpos;
-                        encoderpos=0;
-		    }
-		  
-		    else if (encoderpos < 0)
-                    {
-		    	enquecommand("G1 F700 X-0.1");
-			oldencoderpos=encoderpos;
-                        encoderpos=0;
-		    }
-                    lcd.setCursor(11,line);lcd.print(ftostr52(current_position[X_AXIS]));
-                  }
-          }
-          break;
-          case ItemAM_Y:
-            {
-                  if(force_lcd_update)
-                  {
-                    lcd.setCursor(0,line);lcdprintPGM(" Y:");
-                    lcd.setCursor(11,line);lcd.print(ftostr52(current_position[Y_AXIS]));
-                  }
-      
-                  if((activeline!=line) )
-                  break;
-                  
-                  if(CLICKED) 
-                  {
-                    linechanging=!linechanging;
-                    if(linechanging)
-                    {
-			enquecommand("G91");
-                    }
-                    else
-                    {
-		      enquecommand("G90");
-                      encoderpos=activeline*lcdslow;
-                      beepshort();
-                    }
-                    BLOCK;
-                  }
-                  if(linechanging)
-                  {
-                    if (encoderpos >0) 
-                   { 
-		    	enquecommand("G1 F700 Y0.1");
-			oldencoderpos=encoderpos;
-                        encoderpos=0;
-		    }
-		  
-		    else if (encoderpos < 0)
-                    {
-		    	enquecommand("G1 F700 Y-0.1");
-			oldencoderpos=encoderpos;
-                        encoderpos=0;
-		    }
-                    lcd.setCursor(11,line);lcd.print(ftostr52(current_position[Y_AXIS]));
-                  }
-          }
-          break;
-          case ItemAM_Z:
-          {
-                  if(force_lcd_update)
-                  {
-                    lcd.setCursor(0,line);lcdprintPGM(" Z:");
-                    lcd.setCursor(11,line);lcd.print(ftostr52(current_position[Z_AXIS]));
-                  }
-      
-                  if((activeline!=line) )
-                  break;
-                  
-                   if(CLICKED) 
-                  {
-                    linechanging=!linechanging;
-                    if(linechanging)
-                    {
-			enquecommand("G91");
-                    }
-                    else
-                    {
-		      enquecommand("G90");
-                      encoderpos=activeline*lcdslow;
-                      beepshort();
-                    }
-                    BLOCK;
-                  }
-                  if(linechanging)
-                  {
-                    if (encoderpos >0) 
-                   { 
-		    	enquecommand("G1 F70 Z0.1");
-			oldencoderpos=encoderpos;
-                        encoderpos=0;
-		    }
-		  
-		    else if (encoderpos < 0)
-                    {
-		    	enquecommand("G1 F70 Z-0.1");
-			oldencoderpos=encoderpos;
-                        encoderpos=0;
-		    }
-                    lcd.setCursor(11,line);lcd.print(ftostr52(current_position[Z_AXIS]));
-                  }
-          }
-          break;
-          case ItemAM_E:
-          // ErikDB: TODO: this length should be changed for volumetric.
-          MENUITEM(  lcdprintPGM(MSG_EXTRUDE)  ,  BLOCK;enquecommand("G92 E0");enquecommand("G1 F70 E1");beepshort(); ) ;
-          break;
-          case ItemAM_ERetract:
-              // ErikDB: TODO: this length should be changed for volumetric.
-              MENUITEM(  lcdprintPGM(MSG_RETRACT)  ,  BLOCK;enquecommand("G92 E0");enquecommand("G1 F700 E-1");beepshort(); ) ;
-              break;
-          default:
-          break;
-      }
-      line++;
-   }
-   updateActiveLines(ItemAM_ERetract,encoderpos);
-}
-
-enum {ItemT_exit,ItemT_speed,ItemT_flow,ItemT_nozzle,
-#if (HEATER_BED_PIN > -1)
-ItemT_bed,
-#endif
-ItemT_fan};
-
-void MainMenu::showTune()
-{ 
-  uint8_t line=0;
-  clearIfNecessary();
- for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
- {
-   //Serial.println((int)(line-lineoffset));
-  switch(i)
-  {
-  case ItemT_exit:
-      MENUITEM(  lcdprintPGM(MSG_MAIN)  ,  BLOCK;status=Main_Menu;beepshort(); ) ;
-      break;
-  case ItemT_speed:
-    {
-      if(force_lcd_update)
-      {
-        lcd.setCursor(0,line);lcdprintPGM(MSG_SPEED);
-        lcd.setCursor(13,line);lcd.print(ftostr3(feedmultiply));
-      }
-      
-      if((activeline!=line) )
-        break;
-      
-      if(CLICKED) //AnalogWrite(FAN_PIN,  fanpwm);
-      {
-        linechanging=!linechanging;
-        if(linechanging)
-        {
-            encoderpos=feedmultiply;
-        }
-        else
-        {
-          encoderpos=activeline*lcdslow;
-          beepshort();
-        }
-        BLOCK;
-      }
-      if(linechanging)
-      {
-        if(encoderpos<1) encoderpos=1;
-        if(encoderpos>400) encoderpos=400;
-        feedmultiply = encoderpos;
-        feedmultiplychanged=true;
-        lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-      }
-      
-    }break;
-    case ItemT_nozzle:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_NOZZLE);
-          lcd.setCursor(13,line);lcd.print(ftostr3(intround(degTargetHotend0())));
-        } 
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=intround(degTargetHotend0());
-          }
-          else
-          {
-            setTargetHotend0(encoderpos);
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>260) encoderpos=260;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-      }break;
-      #if (HEATER_BED_PIN > -1)
-      case ItemT_bed:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_BED);
-          lcd.setCursor(13,line);lcd.print(ftostr3(intround(degTargetBed())));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=intround(degTargetBed());
-          }
-          else
-          {
-            setTargetBed(encoderpos);
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>260) encoderpos=260;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-      }break;
-      #endif
-
-      
-      case ItemT_fan:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_FAN_SPEED);
-          lcd.setCursor(13,line);lcd.print(ftostr3(FanSpeed));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED) //nalogWrite(FAN_PIN,  fanpwm);
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=FanSpeed;
-          }
-          else
-          {
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>255) encoderpos=255;
-          FanSpeed=encoderpos;
-            analogWrite(FAN_PIN,  FanSpeed);
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-        
-      }break;
-      case ItemT_flow://axis_steps_per_unit[i] = code_value();
-         {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_FLOW);
-          lcd.setCursor(13,line);lcd.print(ftostr52(axis_steps_per_unit[E_AXIS]));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)(axis_steps_per_unit[E_AXIS]*100.0);
-          }
-          else
-          {
-            float factor=float(encoderpos)/100.0/float(axis_steps_per_unit[E_AXIS]);
-            position[E_AXIS]=lround(position[E_AXIS]*factor);
-            //current_position[E_AXIS]*=factor;
-            axis_steps_per_unit[E_AXIS]= encoderpos/100.0;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<5) encoderpos=5;
-          if(encoderpos>999999) encoderpos=999999;
-          lcd.setCursor(13,line);lcd.print(ftostr52(encoderpos/100.0));
-        }
-        
-      }break; 
-    default:   
-      break;
-  }
-  line++;
- }
- updateActiveLines(ItemT_fan,encoderpos);
-}
-
-//does not work
-// #define MENUCHANGEITEM(repaint_action,  enter_action, accept_action,  change_action) \
-//   {\
-//     if(force_lcd_update)  { lcd.setCursor(0,line);  repaint_action; } \
-//     if(activeline==line)  \
-//     { \
-//       if(CLICKED) \
-//       { \
-//         linechanging=!linechanging; \
-//         if(linechanging)  {enter_action;} \
-//         else {accept_action;} \
-//       }  \
-//       else \
-//       if(linechanging) {change_action};}\
-//   }
-//   
-
-enum {
-  ItemCT_exit,ItemCT_nozzle0,
-#ifdef AUTOTEMP
-  ItemCT_autotempactive,
-  ItemCT_autotempmin,ItemCT_autotempmax,ItemCT_autotempfact,
-#endif
-#if EXTRUDERS > 1
-  ItemCT_nozzle1,
-#endif
-#if EXTRUDERS > 2
-  ItemCT_nozzle2,
-#endif
-#if defined BED_USES_THERMISTOR || defined BED_USES_AD595
-ItemCT_bed,
-#endif  
-  ItemCT_fan,
-  ItemCT_PID_P,ItemCT_PID_I,ItemCT_PID_D,ItemCT_PID_C,
-  ItemCT_PLA_PreHeat_Setting, 
-  ItemCT_ABS_PreHeat_Setting,
-};
-
-void MainMenu::showControlTemp()
-{
-  uint8_t line=0;
- clearIfNecessary();
- for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
- {
-  switch(i)
-  {
-    case ItemCT_exit:
-      MENUITEM(  lcdprintPGM(MSG_CONTROL)  ,  BLOCK;status=Main_Control;beepshort(); ) ;
-      break;
-    case ItemCT_nozzle0:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_NOZZLE);
-          lcd.setCursor(13,line);lcd.print(ftostr3(intround(degTargetHotend0())));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=intround(degTargetHotend0());
-          }
-          else
-          {
-            setTargetHotend0(encoderpos);
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>260) encoderpos=260;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-        
-      }break;
-    #if EXTRUDERS > 1
-    case ItemCT_nozzle1:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_NOZZLE1);
-          lcd.setCursor(13,line);lcd.print(ftostr3(intround(degTargetHotend1())));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=intround(degTargetHotend1());
-          }
-          else
-          {
-            setTargetHotend1(encoderpos);
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>260) encoderpos=260;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-        
-      }break;
-    #endif
-    #if EXTRUDERS > 2
-    case ItemCT_nozzle2:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_NOZZLE2);
-          lcd.setCursor(13,line);lcd.print(ftostr3(intround(degTargetHotend2())));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=intround(degTargetHotend2());
-          }
-          else
-          {
-            setTargetHotend1(encoderpos);
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>260) encoderpos=260;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-        
-      }break;
-    #endif
-    #ifdef AUTOTEMP
-    case ItemCT_autotempmin:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_MIN);
-          lcd.setCursor(13,line);lcd.print(ftostr3(autotemp_min));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=intround(autotemp_min);
-          }
-          else
-          {
-            autotemp_min=encoderpos;
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>260) encoderpos=260;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-        
-      }break;  
-    case ItemCT_autotempmax:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_MAX);
-          lcd.setCursor(13,line);lcd.print(ftostr3(autotemp_max));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=intround(autotemp_max);
-          }
-          else
-          {
-            autotemp_max=encoderpos;
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>260) encoderpos=260;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-        
-      }break;  
-    case ItemCT_autotempfact:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_FACTOR);
-          lcd.setCursor(13,line);lcd.print(ftostr32(autotemp_factor));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=intround(autotemp_factor*100);
-          }
-          else
-          {
-            autotemp_max=encoderpos;
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>99) encoderpos=99;
-          lcd.setCursor(13,line);lcd.print(ftostr32(encoderpos/100.));
-        }
-        
-      }break;
-    case ItemCT_autotempactive:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_AUTOTEMP);
-          lcd.setCursor(13,line);
-          if(autotemp_enabled)
-            lcdprintPGM(MSG_ON);
-          else
-            lcdprintPGM(MSG_OFF);
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          autotemp_enabled=!autotemp_enabled;
-          lcd.setCursor(13,line);
-          if(autotemp_enabled)
-            lcdprintPGM(MSG_ON);
-          else
-            lcdprintPGM(MSG_OFF);
-          BLOCK;
-        }
-        
-      }break;  
-    #endif //autotemp
-    #if defined BED_USES_THERMISTOR || defined BED_USES_AD595
-    case ItemCT_bed:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_BED);
-          lcd.setCursor(13,line);lcd.print(ftostr3(intround(degTargetBed())));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=intround(degTargetBed());
-          }
-          else
-          {
-            setTargetBed(encoderpos);
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>260) encoderpos=260;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-      }break;
-    #endif
-    case ItemCT_fan:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_FAN_SPEED);
-          lcd.setCursor(13,line);lcd.print(ftostr3(FanSpeed));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED) //nalogWrite(FAN_PIN,  fanpwm);
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=FanSpeed;
-          }
-          else
-          {
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>255) encoderpos=255;
-          FanSpeed=encoderpos;
-            analogWrite(FAN_PIN,  FanSpeed);
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-        
-      }break;
-    #ifdef PIDTEMP
-    case ItemCT_PID_P: 
-      {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(" PID-P: ");
-          lcd.setCursor(13,line);lcd.print(itostr4(Kp));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)Kp;
-          }
-          else
-          {
-            Kp= encoderpos;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<1) encoderpos=1;
-          if(encoderpos>9990) encoderpos=9990;
-          lcd.setCursor(13,line);lcd.print(itostr4(encoderpos));
-        }
-        
-      }break;
-    case ItemCT_PID_I: 
-      {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_PID_I);
-          lcd.setCursor(13,line);lcd.print(ftostr51(Ki/PID_dT));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)(Ki*10/PID_dT);
-          }
-          else
-          {
-            Ki= encoderpos/10.*PID_dT;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>9990) encoderpos=9990;
-          lcd.setCursor(13,line);lcd.print(ftostr51(encoderpos/10.));
-        }
-        
-      }break;
-    case ItemCT_PID_D: 
-      {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_PID_D);
-          lcd.setCursor(13,line);lcd.print(itostr4(Kd*PID_dT));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)(Kd/5./PID_dT);
-          }
-          else
-          {
-            Kd= encoderpos;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>9990) encoderpos=9990;
-          lcd.setCursor(13,line);lcd.print(itostr4(encoderpos));
-        }
-       
-      }break;   
-    case ItemCT_PID_C: 
-      #ifdef PID_ADD_EXTRUSION_RATE
-      {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_PID_C);
-          lcd.setCursor(13,line);lcd.print(itostr3(Kc));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)Kc;
-          }
-          else
-          {
-            Kc= encoderpos;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>990) encoderpos=990;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-        
-      }
-      #endif
-    #endif
-      break;
-	  case ItemCT_PLA_PreHeat_Setting:
-        MENUITEM(  lcdprintPGM(MSG_PREHEAT_PLA_SETTINGS)  ,  BLOCK;status=Sub_PreheatPLASettings;beepshort(); ) ;
-	  break;
-	  case ItemCT_ABS_PreHeat_Setting:
-        MENUITEM(  lcdprintPGM(MSG_PREHEAT_ABS_SETTINGS)  ,  BLOCK;status=Sub_PreheatABSSettings;beepshort(); ) ;
-	  break;
-    default:   
-      break;
-  }
-  line++;
- }
-
-  updateActiveLines(ItemCT_ABS_PreHeat_Setting,encoderpos);
-}
-
-
-enum {
-  ItemCM_exit, 
-  ItemCM_acc, ItemCM_xyjerk, 
-  ItemCM_vmaxx, ItemCM_vmaxy, ItemCM_vmaxz, ItemCM_vmaxe, 
-  ItemCM_vtravmin,ItemCM_vmin,  
-  ItemCM_amaxx, ItemCM_amaxy, ItemCM_amaxz, ItemCM_amaxe, 
-  ItemCM_aret, ItemCM_xsteps,ItemCM_ysteps, ItemCM_zsteps, ItemCM_esteps
-};
-
-
-
-void MainMenu::showControlMotion()
-{
- uint8_t line=0;
- clearIfNecessary();
- for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
- {
-  switch(i)
-  {
-    case ItemCM_exit:
-      MENUITEM(  lcdprintPGM(MSG_CONTROL)  ,  BLOCK;status=Main_Control;beepshort(); ) ;
-      break;
-    case ItemCM_acc:
-    {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_ACC);
-          lcd.setCursor(13,line);lcd.print(itostr3(acceleration/100));lcdprintPGM("00");
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)acceleration/100;
-          }
-          else
-          {
-            acceleration= encoderpos*100;
-            encoderpos=activeline*lcdslow;
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<5) encoderpos=5;
-          if(encoderpos>990) encoderpos=990;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));lcdprintPGM("00");
-        }
-        
-      }break;
-    case ItemCM_xyjerk: //max_xy_jerk
-      {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_VXY_JERK);
-          lcd.setCursor(13,line);lcd.print(itostr3(max_xy_jerk));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)max_xy_jerk;
-          }
-          else
-          {
-            max_xy_jerk= encoderpos;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<1) encoderpos=1;
-          if(encoderpos>990) encoderpos=990;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-        
-      }break;
-      
-    case ItemCM_vmaxx:
-    case ItemCM_vmaxy:
-    case ItemCM_vmaxz:
-    case ItemCM_vmaxe:
-      {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_VMAX);
-          if(i==ItemCM_vmaxx)lcdprintPGM(MSG_X);
-          if(i==ItemCM_vmaxy)lcdprintPGM(MSG_Y);
-          if(i==ItemCM_vmaxz)lcdprintPGM(MSG_Z);
-          if(i==ItemCM_vmaxe)lcdprintPGM(MSG_E);
-          lcd.setCursor(13,line);lcd.print(itostr3(max_feedrate[i-ItemCM_vmaxx]));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)max_feedrate[i-ItemCM_vmaxx];
-          }
-          else
-          {
-            max_feedrate[i-ItemCM_vmaxx]= encoderpos;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<1) encoderpos=1;
-          if(encoderpos>990) encoderpos=990;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-        
-      }break;
-    
-    case ItemCM_vmin:
-    {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_VMIN);
-          lcd.setCursor(13,line);lcd.print(itostr3(minimumfeedrate));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)(minimumfeedrate);
-          }
-          else
-          {
-            minimumfeedrate= encoderpos;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>990) encoderpos=990;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-        
-      }break;
-    case ItemCM_vtravmin:
-    {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_VTRAV_MIN);
-          lcd.setCursor(13,line);lcd.print(itostr3(mintravelfeedrate));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)mintravelfeedrate;
-          }
-          else
-          {
-            mintravelfeedrate= encoderpos;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>990) encoderpos=990;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-        
-      }break;
-    
-    case ItemCM_amaxx:      
-    case ItemCM_amaxy:
-    case ItemCM_amaxz:
-    case ItemCM_amaxe:
-    {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(" Amax ");
-          if(i==ItemCM_amaxx)lcdprintPGM(MSG_X);
-          if(i==ItemCM_amaxy)lcdprintPGM(MSG_Y);
-          if(i==ItemCM_amaxz)lcdprintPGM(MSG_Z);
-          if(i==ItemCM_amaxe)lcdprintPGM(MSG_E);
-          lcd.setCursor(13,line);lcd.print(itostr3(max_acceleration_units_per_sq_second[i-ItemCM_amaxx]/100));lcdprintPGM("00");
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)max_acceleration_units_per_sq_second[i-ItemCM_amaxx]/100;
-          }
-          else
-          {
-            max_acceleration_units_per_sq_second[i-ItemCM_amaxx]= encoderpos*100;
-            encoderpos=activeline*lcdslow;
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<1) encoderpos=1;
-          if(encoderpos>990) encoderpos=990;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));lcdprintPGM("00");
-        }
-        
-      }break;
-     
-    
-    case ItemCM_aret://float retract_acceleration = 7000;
-    {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_A_RETRACT);
-          lcd.setCursor(13,line);lcd.print(ftostr3(retract_acceleration/100));lcdprintPGM("00");
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)retract_acceleration/100;
-          }
-          else
-          {
-            retract_acceleration= encoderpos*100;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<10) encoderpos=10;
-          if(encoderpos>990) encoderpos=990;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));lcdprintPGM("00");
-        }
-        
-      }break;
-       case ItemCM_xsteps://axis_steps_per_unit[i] = code_value();
-         {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_XSTEPS);
-          lcd.setCursor(11,line);lcd.print(ftostr52(axis_steps_per_unit[X_AXIS]));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)(axis_steps_per_unit[X_AXIS]*100.0);
-          }
-          else
-          {
-            float factor=float(encoderpos)/100.0/float(axis_steps_per_unit[X_AXIS]);
-            position[X_AXIS]=lround(position[X_AXIS]*factor);
-            //current_position[X_AXIS]*=factor;
-            axis_steps_per_unit[X_AXIS]= encoderpos/100.0;
-            encoderpos=activeline*lcdslow;
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<5) encoderpos=5;
-          if(encoderpos>999999) encoderpos=999999;
-          lcd.setCursor(11,line);lcd.print(ftostr52(encoderpos/100.0));
-        }
-        
-      }break;
-       case ItemCM_ysteps://axis_steps_per_unit[i] = code_value();
-         {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_YSTEPS);
-          lcd.setCursor(11,line);lcd.print(ftostr52(axis_steps_per_unit[Y_AXIS]));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)(axis_steps_per_unit[Y_AXIS]*100.0);
-          }
-          else
-          {
-            float factor=float(encoderpos)/100.0/float(axis_steps_per_unit[Y_AXIS]);
-            position[Y_AXIS]=lround(position[Y_AXIS]*factor);
-            //current_position[Y_AXIS]*=factor;
-            axis_steps_per_unit[Y_AXIS]= encoderpos/100.0;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<5) encoderpos=5;
-          if(encoderpos>999999) encoderpos=999999;
-          lcd.setCursor(11,line);lcd.print(ftostr52(encoderpos/100.0));
-        }
-        
-      }break;
-       case ItemCM_zsteps://axis_steps_per_unit[i] = code_value();
-         {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_ZSTEPS);
-          lcd.setCursor(11,line);lcd.print(ftostr52(axis_steps_per_unit[Z_AXIS]));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)(axis_steps_per_unit[Z_AXIS]*100.0);
-          }
-          else
-          {
-            float factor=float(encoderpos)/100.0/float(axis_steps_per_unit[Z_AXIS]);
-            position[Z_AXIS]=lround(position[Z_AXIS]*factor);
-            //current_position[Z_AXIS]*=factor;
-            axis_steps_per_unit[Z_AXIS]= encoderpos/100.0;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<5) encoderpos=5;
-          if(encoderpos>999999) encoderpos=999999;
-          lcd.setCursor(11,line);lcd.print(ftostr52(encoderpos/100.0));
-        }
-        
-      }break;
-      
-    case ItemCM_esteps://axis_steps_per_unit[i] = code_value();
-         {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_ESTEPS);
-          lcd.setCursor(11,line);lcd.print(ftostr52(axis_steps_per_unit[E_AXIS]));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)(axis_steps_per_unit[E_AXIS]*100.0);
-          }
-          else
-          {
-            float factor=float(encoderpos)/100.0/float(axis_steps_per_unit[E_AXIS]);
-            position[E_AXIS]=lround(position[E_AXIS]*factor);
-            //current_position[E_AXIS]*=factor;
-            axis_steps_per_unit[E_AXIS]= encoderpos/100.0;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<5) encoderpos=5;
-          if(encoderpos>999999) encoderpos=999999;
-          lcd.setCursor(11,line);lcd.print(ftostr52(encoderpos/100.0));
-        }
-        
-      }break; 
-    default:   
-      break;
-  }
-  line++;
- }
- updateActiveLines(ItemCM_esteps,encoderpos);
-}
-
-
-enum {
-  ItemR_exit,
-  ItemR_autoretract,
-  ItemR_retract_length,ItemR_retract_feedrate,ItemR_retract_zlift,
-  ItemR_unretract_length,ItemR_unretract_feedrate,
-  
-};
-
-
-
-void MainMenu::showControlRetract()
-{
-#ifdef FWRETRACT
- uint8_t line=0;
- clearIfNecessary();
- for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
- {
-  switch(i)
-  {
-    case ItemR_exit:
-      MENUITEM(  lcdprintPGM(MSG_CONTROL)  ,  BLOCK;status=Main_Control;beepshort(); ) ;
-      break;
-    
-      //float retract_length=2, retract_feedrate=1200, retract_zlift=0.4;
-  //float retract_recover_length=0, retract_recover_feedrate=500;
-      case ItemR_autoretract:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_AUTORETRACT);
-          lcd.setCursor(13,line);
-          if(autoretract_enabled)
-            lcdprintPGM(MSG_ON);
-          else
-            lcdprintPGM(MSG_OFF);
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          autoretract_enabled=!autoretract_enabled;
-          lcd.setCursor(13,line);
-          if(autoretract_enabled)
-            lcdprintPGM(MSG_ON);
-          else
-            lcdprintPGM(MSG_OFF);
-          BLOCK;
-        }
-        
-      }break;  
-    
-      case ItemR_retract_length:
-    {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_CONTROL_RETRACT);
-          lcd.setCursor(13,line);lcd.print(ftostr52(retract_length));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)(retract_length*100);
-          }
-          else
-          {
-            retract_length= encoderpos/100.;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<1) encoderpos=1;
-          if(encoderpos>990) encoderpos=990;
-          lcd.setCursor(13,line);lcd.print(ftostr52(encoderpos/100.));
-        }
-        
-      }break;
-      case ItemR_retract_feedrate:
-    {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_CONTROL_RETRACTF);
-          lcd.setCursor(13,line);lcd.print(itostr4(retract_feedrate));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)(retract_feedrate/5);
-          }
-          else
-          {
-            retract_feedrate= encoderpos*5.;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<1) encoderpos=1;
-          if(encoderpos>990) encoderpos=990;
-          lcd.setCursor(13,line);lcd.print(itostr4(encoderpos*5));
-        }
-        
-      }break;
-      case ItemR_retract_zlift://float retract_acceleration = 7000;
-    {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_CONTROL_RETRACT_ZLIFT);
-          lcd.setCursor(13,line);lcd.print(ftostr52(retract_zlift));;
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)(retract_zlift*10);
-          }
-          else
-          {
-            retract_zlift= encoderpos/10.;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>990) encoderpos=990;
-          lcd.setCursor(13,line);lcd.print(ftostr52(encoderpos/10.));
-        }
-        
-      }break;
-      case ItemR_unretract_length:
-    {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_CONTROL_RETRACT_RECOVER);
-          lcd.setCursor(13,line);lcd.print(ftostr52(retract_recover_length));;
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)(retract_recover_length*100);
-          }
-          else
-          {
-            retract_recover_length= encoderpos/100.;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>990) encoderpos=990;
-          lcd.setCursor(13,line);lcd.print(ftostr52(encoderpos/100.));
-        }
-        
-      }break;
-      
-      case ItemR_unretract_feedrate:
-    {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_CONTROL_RETRACT_RECOVERF);
-          lcd.setCursor(13,line);lcd.print(itostr4(retract_recover_feedrate));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)retract_recover_feedrate/5;
-          }
-          else
-          {
-            retract_recover_feedrate= encoderpos*5.;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<1) encoderpos=1;
-          if(encoderpos>990) encoderpos=990;
-          lcd.setCursor(13,line);lcd.print(itostr4(encoderpos*5));
-        }
-        
-      }break;
-    
-    default:   
-      break;
-  }
-  line++;
- }
- updateActiveLines(ItemR_unretract_feedrate,encoderpos);
-#endif
-}
-
-
-
-enum {
-  ItemC_exit,ItemC_temp,ItemC_move,
-#ifdef FWRETRACT
-  ItemC_rectract,
-#endif
-  ItemC_store, ItemC_load,ItemC_failsafe
-};
-
-void MainMenu::showControl()
-{
- uint8_t line=0;
- clearIfNecessary();
- for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
- {
-  switch(i)
-  {
-    case ItemC_exit:
-      MENUITEM(  lcdprintPGM(MSG_MAIN_WIDE)  ,  BLOCK;status=Main_Menu;beepshort(); ) ;
-      break;
-    case ItemC_temp:
-      MENUITEM(  lcdprintPGM(MSG_TEMPERATURE_WIDE)  ,  BLOCK;status=Sub_TempControl;beepshort(); ) ;
-      break;
-   case ItemC_move:
-      MENUITEM(  lcdprintPGM(MSG_MOTION_WIDE)  ,  BLOCK;status=Sub_MotionControl;beepshort(); ) ;
-      break;
-#ifdef FWRETRACT
-    case ItemC_rectract:
-      MENUITEM(  lcdprintPGM(MSG_RECTRACT_WIDE)  ,  BLOCK;status=Sub_RetractControl;beepshort(); ) ;
-      break;
-#endif
-    case ItemC_store:
-    {
-      if(force_lcd_update)
-      {
-        lcd.setCursor(0,line);lcdprintPGM(MSG_STORE_EPROM);
-      }
-      if((activeline==line) && CLICKED)
-      {
-        //enquecommand("M84");
-        beepshort();
-        BLOCK;
-        EEPROM_StoreSettings();
-      }
-    }break;
-    case ItemC_load:
-    {
-      if(force_lcd_update)
-      {
-        lcd.setCursor(0,line);lcdprintPGM(MSG_LOAD_EPROM);
-      }
-      if((activeline==line) && CLICKED)
-      {
-        //enquecommand("M84");
-        beepshort();
-        BLOCK;
-        EEPROM_RetrieveSettings();
-      }
-    }break;
-    case ItemC_failsafe:
-    {
-      if(force_lcd_update)
-      {
-        lcd.setCursor(0,line);lcdprintPGM(MSG_RESTORE_FAILSAFE);
-      }
-      if((activeline==line) && CLICKED)
-      {
-        //enquecommand("M84");
-        beepshort();
-        BLOCK;
-        EEPROM_RetrieveSettings(true);
-      }
-    }break;
-    default:   
-      break;
-  }
-  line++;
- }
- updateActiveLines(ItemC_failsafe,encoderpos);
-}
-
-
-
-
-
-void MainMenu::showSD()
-{
-#ifdef SDSUPPORT
- uint8_t line=0;
-
- clearIfNecessary();
- static uint8_t nrfiles=0;
- if(force_lcd_update)
- {
-  if(card.cardOK)
-  {
-    nrfiles=card.getnrfilenames();
-  }
-  else
-  {
-    nrfiles=0;
-    lineoffset=0;
-  }
- }
- bool enforceupdate=false;
- for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
- {
-  switch(i)
-  {
-    case 0:
-      MENUITEM(  lcdprintPGM(MSG_MAIN)  ,  BLOCK;status=Main_Menu;beepshort(); ) ;
-      break;
-//     case 1:
-//       {
-//         if(force_lcd_update)
-//         {
-//           lcd.setCursor(0,line);
-//            #ifdef CARDINSERTED
-//           if(CARDINSERTED)
-//           #else
-//           if(true)
-//           #endif
-//           {
-//             lcdprintPGM(" \004Refresh");
-//           }
-//           else
-//           {
-//             lcdprintPGM(" \004Insert Card");
-//           }
-//           
-//         }
-//         if((activeline==line) && CLICKED)
-//         {
-//           BLOCK;
-//           beepshort();
-//           card.initsd();
-//           force_lcd_update=true;
-//            nrfiles=card.getnrfilenames();
-//         }
-//       }break;
-    case 1:
-      MENUITEM(  lcd.print(" ");card.getWorkDirName();
-	  if(card.filename[0]=='/') lcdprintPGM(MSG_REFRESH);
-	  else {
-		  lcd.print("\005");
-		  lcd.print(card.filename);
-		  lcd.print("/..");
-			}  ,  
-	BLOCK;
-			if(SDCARDDETECT == -1) card.initsd();
-			card.updir();
-			enforceupdate=true;
-			lineoffset=0;
-			beepshort(); ) ;
-      
-      break;
-    default:
-    {
-      #define FIRSTITEM 2
-      if(i-FIRSTITEM<nrfiles)
-      {
-        if(force_lcd_update)
-        {
-          card.getfilename(i-FIRSTITEM);
-          //Serial.print("Filenr:");Serial.println(i-2);
-          lcd.setCursor(0,line);lcdprintPGM(" ");
-          if(card.filenameIsDir) lcd.print("\005");
-          if (card.longFilename[0])
-          {
-            card.longFilename[LCD_WIDTH-1] = '\0';
-            lcd.print(card.longFilename);
-          }
-          else
-          {
-            lcd.print(card.filename);
-          }
-        }
-        if((activeline==line) && CLICKED)
-        {
-          BLOCK
-          card.getfilename(i-FIRSTITEM);
-          if(card.filenameIsDir)
-          {
-            for(int8_t i=0;i<strlen(card.filename);i++)
-              card.filename[i]=tolower(card.filename[i]);
-            card.chdir(card.filename);
-            lineoffset=0;
-            enforceupdate=true;
-          }
-          else
-          {
-            char cmd[30];
-            for(int8_t i=0;i<strlen(card.filename);i++)
-              card.filename[i]=tolower(card.filename[i]);
-            sprintf(cmd,"M23 %s",card.filename);
-            //sprintf(cmd,"M115");
-            enquecommand(cmd);
-            enquecommand("M24");
-            beep(); 
-            status=Main_Status;
-            if (card.longFilename[0])
-            {
-              card.longFilename[LCD_WIDTH-1] = '\0';
-              lcd_status(card.longFilename);
-            }
-            else
-            {
-              lcd_status(card.filename);
-            }
-          }
-        } 
-      }
-      
-    }
-      break;
-  }
-  line++;
- }
- updateActiveLines(FIRSTITEM+nrfiles-1,encoderpos);
- if(enforceupdate)
- {
-   force_lcd_update=true;
-   enforceupdate=false;
- }
-#endif
-}
-
-
-enum {ItemM_watch, ItemM_prepare, ItemM_control, ItemM_file, ItemM_pause};
-void MainMenu::showMainMenu()
-{
-
-  #ifndef ULTIPANEL
-    force_lcd_update=false;
-  #endif
-  if(tune)
-  {
-    if(!(movesplanned() || IS_SD_PRINTING))
-    {
-      force_lcd_update=true;
-      tune=false;
-    }
-  }
-  else 
-  {
-    if(movesplanned() || IS_SD_PRINTING)
-    {
-      force_lcd_update=true;
-      tune=true;
-    }
-  } 
-  clearIfNecessary();
-  uint8_t line=0;
-  for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
-  {
-    switch(i)
-    { 
-      case ItemM_watch:
-        MENUITEM(  lcdprintPGM(MSG_WATCH)  ,  BLOCK;status=Main_Status;beepshort(); ) ;
-       break;
-      case ItemM_prepare:
-        MENUITEM(  if(!tune) lcdprintPGM(MSG_PREPARE);else  lcdprintPGM(MSG_TUNE); ,  BLOCK;status=Main_Prepare;beepshort(); ) ;
-      break;
-       
-      case ItemM_control:
-        MENUITEM(  lcdprintPGM(MSG_CONTROL_ARROW)  ,  BLOCK;status=Main_Control;beepshort(); ) ;
-      break;
-      #ifdef SDSUPPORT
-      case ItemM_file:    
-      {
-        if(force_lcd_update) 
-        {
-          lcd.setCursor(0,line);
-          #ifdef CARDINSERTED
-            if(CARDINSERTED)
-          #else
-            if(true)
-          #endif
-          {
-            if(card.sdprinting)
-              lcdprintPGM(MSG_STOP_PRINT);
-            else
-              lcdprintPGM(MSG_CARD_MENU);
-          }
-          else
-          {
-           lcdprintPGM(MSG_NO_CARD); 
-          }
-        }
-        #ifdef CARDINSERTED
-          if(CARDINSERTED)
-        #endif
-        if((activeline==line)&&CLICKED)
-        {
-          card.printingHasFinished();
-          BLOCK;
-          status=Main_SD;
-          beepshort();
-        }
-      }break;
-        case ItemM_pause:
-        {
-            if(force_lcd_update)
-            {
-                lcd.setCursor(0,line);
-#ifdef CARDINSERTED
-                if(CARDINSERTED)
-#else
-                    if(true)
-#endif
-                    {
-                        if(card.sdprinting)
-                            lcdprintPGM(MSG_PAUSE_PRINT);
-                        else
-                            lcdprintPGM(MSG_RESUME_PRINT);
-                    }
-                    else
-                    {
-                        //lcdprintPGM(MSG_NO_CARD);
-                    }
-            }
-#ifdef CARDINSERTED
-            if(CARDINSERTED)
-#endif
-                if((activeline==line) && CLICKED)
-                {
-                    if(card.sdprinting)
-                    {
-                        card.pauseSDPrint();
-                        beepshort();
-                        status = Main_Status;
-                    }
-                    else
-                    {
-                        card.startFileprint();
-                        starttime=millis();
-                        beepshort();
-                        status = Main_Status;
-                    }
-                }
-        }break;
-      #else
-      case ItemM_file:
-        break;
-        case ItemM_pause:
-            break;
-      #endif
-      default:
-        SERIAL_ERROR_START;
-        SERIAL_ERRORLNPGM(MSG_SERIAL_ERROR_MENU_STRUCTURE);
-      break;
-    }
-    line++;
-  }
-    
-    uint8_t numberOfLines = 4;
-#ifdef SDSUPPORT
-    numberOfLines = 4;
-#else
-    numberOfLines = 3;
-#endif
-    updateActiveLines(numberOfLines,encoderpos);
-}
-
-void MainMenu::update()
-{
-  static MainStatus oldstatus=Main_Menu;  //init automatically causes foce_lcd_update=true
-  static long timeoutToStatus=0;
-  static bool oldcardstatus=false;
-  #ifdef CARDINSERTED
-    if((CARDINSERTED != oldcardstatus))
-    {
-      force_lcd_update=true;
-      oldcardstatus=CARDINSERTED;
-      lcd_init(); // to maybe revive the lcd if static electricty killed it.
-      //Serial.println("echo: SD CHANGE");
-      if(CARDINSERTED)
-      {
-        card.initsd();
-        LCD_MESSAGEPGM(MSG_SD_INSERTED);
-      }
-      else
-      {
-        card.release();
-        LCD_MESSAGEPGM(MSG_SD_REMOVED);
-      }
-    }
-  #endif
- 
-  if(status!=oldstatus)
-  {
-    force_lcd_update=true;
-    encoderpos=0;
-    lineoffset=0;
-    
-    oldstatus=status;
-  }
-  if( (encoderpos!=lastencoderpos) || CLICKED)
-    timeoutToStatus=millis()+STATUSTIMEOUT;
-
-  switch(status)
-  { 
-      case Main_Status: 
-      {  
-        showStatus();
-        if(CLICKED)
-        {
-           linechanging=false;
-           BLOCK
-           status=Main_Menu;
-           timeoutToStatus=millis()+STATUSTIMEOUT;
-        }
-      }break;
-      case Main_Menu: 
-      {
-        showMainMenu();
-        linechanging=false;
-      }break;
-      case Main_Prepare: 
-      {
-        if(tune)
-        {
-          showTune();
-        }
-        else
-        {
-          showPrepare(); 
-        }
-      }break;
-      case Sub_PrepareMove:
-      {        
-            showAxisMove();
-      }break;
-      case Main_Control:
-      {
-        showControl(); 
-      }break;
-      case Sub_MotionControl:
-      {
-        showControlMotion(); 
-      }break;
-      case Sub_RetractControl:
-      {
-        showControlRetract(); 
-      }break;
-      case Sub_TempControl:
-      {
-        showControlTemp(); 
-      }break;
-      case Main_SD: 
-      {
-        showSD();
-      }break;
-	  case Sub_PreheatPLASettings: 
-      {
-        showPLAsettings();
-      }break;
-	  case Sub_PreheatABSSettings: 
-      {
-        showABSsettings();
-      }break;
-  }
-  
-  if(timeoutToStatus<millis())
-    status=Main_Status;
-  //force_lcd_update=false;
-  lastencoderpos=encoderpos;
-}
-
-enum {
-	ItemPLAPreHeat_Exit, 
-	ItemPLAPreHeat_set_PLA_FanSpeed, 
-	ItemPLAPreHeat_set_nozzle, 
-	ItemPLAPreHeat_set_HPB,
-	ItemPLAPreHeat_Store_Eprom
-	};
-  
-void MainMenu::showPLAsettings()
-{
-#ifdef ULTIPANEL
- uint8_t line=0;
- clearIfNecessary();
- for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
- {
-  switch(i)
-  {
-
-	case ItemPLAPreHeat_Exit:
-      MENUITEM(  lcdprintPGM(MSG_TEMPERATURE_RTN)  ,  BLOCK;status=Sub_TempControl;beepshort(); ) ;
-      break;
-
-    case ItemPLAPreHeat_set_PLA_FanSpeed:
-       {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_FAN_SPEED);
-          lcd.setCursor(13,line);lcd.print(ftostr3(plaPreheatFanSpeed));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED) 
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-			  encoderpos=plaPreheatFanSpeed;
-          }
-          else
-          {
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>255) encoderpos=255;
-          plaPreheatFanSpeed=encoderpos;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-      }break;
-
-    case ItemPLAPreHeat_set_nozzle:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_NOZZLE);
-          lcd.setCursor(13,line);lcd.print(ftostr3(plaPreheatHotendTemp));
-        } 
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=plaPreheatHotendTemp;
-          }
-          else
-          {
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>260) encoderpos=260;
-		  plaPreheatHotendTemp = encoderpos;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-      }break;
-
-    case ItemPLAPreHeat_set_HPB:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_BED);
-          lcd.setCursor(13,line);lcd.print(ftostr3(plaPreheatHPBTemp));
-        } 
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=plaPreheatHPBTemp;
-          }
-          else
-          {
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>250) encoderpos=150;
-		  plaPreheatHPBTemp = encoderpos;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-      }break;
-	case ItemPLAPreHeat_Store_Eprom:
-    {
-      if(force_lcd_update)
-      {
-        lcd.setCursor(0,line);lcdprintPGM(MSG_STORE_EPROM);
-      }
-      if((activeline==line) && CLICKED)
-      {
-        //enquecommand("M84");
-        beepshort();
-        BLOCK;
-        EEPROM_StoreSettings();
-      }
-    }break;
-      default:   
-      break;
-  }
-  line++;
- }
- updateActiveLines(ItemPLAPreHeat_Store_Eprom,encoderpos);
-#endif
-}
-
-enum {
-	ItemABSPreHeat_Exit, 
-	ItemABSPreHeat_set_FanSpeed, 
-	ItemABSPreHeat_set_nozzle, 
-	ItemABSPreHeat_set_HPB,
-	ItemABSPreHeat_Store_Eprom
-	};
-
-void MainMenu::showABSsettings()
-{
-#ifdef ULTIPANEL
- uint8_t line=0;
- clearIfNecessary();
- for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
- {
-  switch(i)
-  {
-
-	case ItemABSPreHeat_Exit:
-      MENUITEM(  lcdprintPGM(MSG_TEMPERATURE_RTN)  ,  BLOCK;status=Sub_TempControl;beepshort(); ) ;
-      break;
-
-    case ItemABSPreHeat_set_FanSpeed:
-       {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_FAN_SPEED);
-          lcd.setCursor(13,line);lcd.print(ftostr3(absPreheatFanSpeed));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED) 
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-			  encoderpos=absPreheatFanSpeed;
-          }
-          else
-          {
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>255) encoderpos=255;
-          absPreheatFanSpeed=encoderpos;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-      }break;
-
-    case ItemABSPreHeat_set_nozzle:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_NOZZLE);
-          lcd.setCursor(13,line);lcd.print(ftostr3(absPreheatHotendTemp));
-        } 
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=absPreheatHotendTemp;
-          }
-          else
-          {
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>260) encoderpos=260;
-		  absPreheatHotendTemp = encoderpos;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-      }break;
-
-    case ItemABSPreHeat_set_HPB:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_BED);
-          lcd.setCursor(13,line);lcd.print(ftostr3(absPreheatHPBTemp));
-        } 
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=absPreheatHPBTemp;
-          }
-          else
-          {
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>250) encoderpos=150;
-		  absPreheatHPBTemp = encoderpos;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-      }break;
-	case ItemABSPreHeat_Store_Eprom:
-    {
-      if(force_lcd_update)
-      {
-        lcd.setCursor(0,line);lcdprintPGM(MSG_STORE_EPROM);
-      }
-      if((activeline==line) && CLICKED)
-      {
-        //enquecommand("M84");
-        beepshort();
-        BLOCK;
-        EEPROM_StoreSettings();
-      }
-    }break;
-      default:   
-      break;
-  }
-  line++;
- }
- updateActiveLines(ItemABSPreHeat_Store_Eprom,encoderpos);
-#endif
-}
-
-//**********************************************************************************************************
-//  convert float to string with +123.4 format
-char *ftostr3(const float &x)
-{
-  //sprintf(conv,"%5.1f",x);
-  int xx=x;
-  conv[0]=(xx/100)%10+'0';
-  conv[1]=(xx/10)%10+'0';
-  conv[2]=(xx)%10+'0';
-  conv[3]=0;
-  return conv;
-}
-
-char *itostr2(const uint8_t &x)
-{
-  //sprintf(conv,"%5.1f",x);
-  int xx=x;
-  conv[0]=(xx/10)%10+'0';
-  conv[1]=(xx)%10+'0';
-  conv[2]=0;
-  return conv;
-}
-
-//  convert float to string with +123.4 format
-char *ftostr31(const float &x)
-{
-  int xx=x*10;
-  conv[0]=(xx>=0)?'+':'-';
-  xx=abs(xx);
-  conv[1]=(xx/1000)%10+'0';
-  conv[2]=(xx/100)%10+'0';
-  conv[3]=(xx/10)%10+'0';
-  conv[4]='.';
-  conv[5]=(xx)%10+'0';
-  conv[6]=0;
-  return conv;
-}
-
-char *ftostr32(const float &x)
-{
-  long xx=x*100;
-  conv[0]=(xx>=0)?'+':'-';
-  xx=abs(xx);
-  conv[1]=(xx/100)%10+'0';
-  conv[2]='.';
-  conv[3]=(xx/10)%10+'0';
-  conv[4]=(xx)%10+'0';
-  conv[6]=0;
-  return conv;
-}
-
-char *itostr31(const int &xx)
-{
-  conv[0]=(xx>=0)?'+':'-';
-  conv[1]=(xx/1000)%10+'0';
-  conv[2]=(xx/100)%10+'0';
-  conv[3]=(xx/10)%10+'0';
-  conv[4]='.';
-  conv[5]=(xx)%10+'0';
-  conv[6]=0;
-  return conv;
-}
-
-char *itostr3(const int &xx)
-{
-  conv[0]=(xx/100)%10+'0';
-  conv[1]=(xx/10)%10+'0';
-  conv[2]=(xx)%10+'0';
-  conv[3]=0;
-  return conv;
-}
-
-char *itostr4(const int &xx)
-{
-  conv[0]=(xx/1000)%10+'0';
-  conv[1]=(xx/100)%10+'0';
-  conv[2]=(xx/10)%10+'0';
-  conv[3]=(xx)%10+'0';
-  conv[4]=0;
-  return conv;
-}
-
-//  convert float to string with +1234.5 format
-char *ftostr51(const float &x)
-{
-  long xx=x*10;
-  conv[0]=(xx>=0)?'+':'-';
-  xx=abs(xx);
-  conv[1]=(xx/10000)%10+'0';
-  conv[2]=(xx/1000)%10+'0';
-  conv[3]=(xx/100)%10+'0';
-  conv[4]=(xx/10)%10+'0';
-  conv[5]='.';
-  conv[6]=(xx)%10+'0';
-  conv[7]=0;
-  return conv;
-}
-
-//  convert float to string with +123.45 format
-char *ftostr52(const float &x)
-{
-  long xx=x*100;
-  conv[0]=(xx>=0)?'+':'-';
-  xx=abs(xx);
-  conv[1]=(xx/10000)%10+'0';
-  conv[2]=(xx/1000)%10+'0';
-  conv[3]=(xx/100)%10+'0';
-  conv[4]='.';
-  conv[5]=(xx/10)%10+'0';
-  conv[6]=(xx)%10+'0';
-  conv[7]=0;
-  return conv;
-}
-
-#endif //ULTRA_LCD
-
-
diff --git a/Marlin/watchdog.cpp b/Marlin/watchdog.cpp
new file mode 100644
index 0000000..f329089
--- /dev/null
+++ b/Marlin/watchdog.cpp
@@ -0,0 +1,56 @@
+#include "Marlin.h"
+
+#ifdef USE_WATCHDOG
+#include <avr/wdt.h>
+
+#include "watchdog.h"
+#include "ultralcd.h"
+
+//===========================================================================
+//=============================private variables  ============================
+//===========================================================================
+
+//===========================================================================
+//=============================functinos         ============================
+//===========================================================================
+
+
+/// intialise watch dog with a 4 sec interrupt time
+void watchdog_init()
+{
+#ifdef WATCHDOG_RESET_MANUAL
+    //We enable the watchdog timer, but only for the interrupt.
+    //Take care, as this requires the correct order of operation, with interrupts disabled. See the datasheet of any AVR chip for details.
+    wdt_reset();
+    _WD_CONTROL_REG = _BV(_WD_CHANGE_BIT) | _BV(WDE);
+    _WD_CONTROL_REG = _BV(WDIE) | WDTO_4S;
+#else
+    wdt_enable(WDTO_4S);
+#endif
+}
+
+/// reset watchdog. MUST be called every 1s after init or avr will reset.
+void watchdog_reset() 
+{
+    wdt_reset();
+}
+
+//===========================================================================
+//=============================ISR               ============================
+//===========================================================================
+
+//Watchdog timer interrupt, called if main program blocks >1sec and manual reset is enabled.
+#ifdef WATCHDOG_RESET_MANUAL
+ISR(WDT_vect)
+{ 
+    //TODO: This message gets overwritten by the kill() call
+    LCD_MESSAGEPGM("ERR:Please Reset");//16 characters so it fits on a 16x2 display
+    LCD_STATUS;
+    SERIAL_ERROR_START;
+    SERIAL_ERRORLNPGM("Something is wrong, please turn off the printer.");
+    kill(); //kill blocks
+    while(1); //wait for user or serial reset
+}
+#endif//RESET_MANUAL
+
+#endif//USE_WATCHDOG
diff --git a/Marlin/watchdog.h b/Marlin/watchdog.h
index 937379b..7f78453 100644
--- a/Marlin/watchdog.h
+++ b/Marlin/watchdog.h
@@ -1,16 +1,17 @@
 #ifndef WATCHDOG_H
 #define WATCHDOG_H
+
 #include "Marlin.h"
-#ifdef USE_WATCHDOG
 
+#ifdef USE_WATCHDOG
   // intialise watch dog with a 1 sec interrupt time
-  void wd_init();
-  // pad the dog/reset watchdog. MUST be called at least every second after the first wd_init or avr will go into emergency procedures..
-  void wd_reset();
-
+  void watchdog_init();
+  // pad the dog/reset watchdog. MUST be called at least every second after the first watchdog_init or avr will go into emergency procedures..
+  void watchdog_reset();
 #else
-  FORCE_INLINE void wd_init() {};
-  FORCE_INLINE void wd_reset() {};
+  //If we do not have a watchdog, then we can have empty functions which are optimized away.
+  FORCE_INLINE void watchdog_init() {};
+  FORCE_INLINE void watchdog_reset() {};
 #endif
 
 #endif
diff --git a/Marlin/watchdog.pde b/Marlin/watchdog.pde
deleted file mode 100644
index 356e374..0000000
--- a/Marlin/watchdog.pde
+++ /dev/null
@@ -1,63 +0,0 @@
-#ifdef USE_WATCHDOG
-#include "Marlin.h"
-#include "watchdog.h"
-
-//===========================================================================
-//=============================private variables  ============================
-//===========================================================================
-
-static volatile uint8_t timeout_seconds=0;
-
-void(* ctrlaltdelete) (void) = 0; //does not work on my atmega2560
-
-//===========================================================================
-//=============================functinos         ============================
-//===========================================================================
-
-
-/// intialise watch dog with a 1 sec interrupt time
-void wd_init() 
-{
-  WDTCSR |= (1<<WDCE )|(1<<WDE ); //allow changes
-  WDTCSR = (1<<WDCE )|(1<<WDE )|(1<<WDP3 )|(1<<WDP0); // Reset after 8 sec.
-//  WDTCSR = (1<<WDIF)|(1<<WDIE)| (1<<WDCE )|(1<<WDE )|  (1<<WDP3) | (1<<WDP0);
-}
-
-/// reset watchdog. MUST be called every 1s after init or avr will reset.
-void wd_reset() 
-{
-  wdt_reset();
-}
-
-//===========================================================================
-//=============================ISR               ============================
-//===========================================================================
-
-//Watchdog timer interrupt, called if main program blocks >1sec
-ISR(WDT_vect) 
-{ 
-  if(timeout_seconds++ >= WATCHDOG_TIMEOUT)
-  {
- 
-    #ifdef RESET_MANUAL
-      LCD_MESSAGEPGM("Please Reset!");
-      LCD_STATUS;
-      SERIAL_ERROR_START;
-      SERIAL_ERRORLNPGM("Something is wrong, please turn off the printer.");
-    #else
-      LCD_MESSAGEPGM("Timeout, resetting!");
-      LCD_STATUS;
-    #endif 
-    //disable watchdog, it will survife reboot.
-    WDTCSR |= (1<<WDCE) | (1<<WDE);
-    WDTCSR = 0;
-    #ifdef RESET_MANUAL
-      kill(); //kill blocks
-      while(1); //wait for user or serial reset
-    #else
-      ctrlaltdelete();
-    #endif
-  }
-}
-
-#endif /* USE_WATCHDOG */
diff --git a/README.md b/README.md
index fb2c189..bbc501e 100644
--- a/README.md
+++ b/README.md
@@ -45,6 +45,7 @@ Features:
 *   Heater power reporting. Useful for PID monitoring.
 *   PID tuning
 *   CoreXY kinematics (www.corexy.com/theory.html)
+*   Configurable serial port to support connection of wireless adaptors.
 
 The default baudrate is 250000. This baudrate has less jitter and hence errors than the usual 115200 baud, but is less supported by drivers and host-environments.
 

