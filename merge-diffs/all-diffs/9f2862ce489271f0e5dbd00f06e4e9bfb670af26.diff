commit 9f2862ce489271f0e5dbd00f06e4e9bfb670af26 (from 9fb8bd56854b49864ea44406d1b1ff213f843375)
Merge: 9fb8bd5 6a61a3c
Author: ErikZalm <erik@vdzalm.eu>
Date:   Mon Mar 25 13:14:49 2013 -0700

    Merge pull request #414 from whosawhatsis/Marlin_v1
    
    regenerated thermistor table 7

diff --git a/Marlin/thermistortables.h b/Marlin/thermistortables.h
index 8496ae1..0918220 100644
--- a/Marlin/thermistortables.h
+++ b/Marlin/thermistortables.h
@@ -254,61 +254,63 @@ const short temptable_6[][2] PROGMEM = {
 
 #if (THERMISTORHEATER_0 == 7) || (THERMISTORHEATER_1 == 7) || (THERMISTORHEATER_2 == 7) || (THERMISTORBED == 7) // 100k Honeywell 135-104LAG-J01
 const short temptable_7[][2] PROGMEM = {
-   {1*OVERSAMPLENR, 500},
-   {46*OVERSAMPLENR, 270}, //top rating 300C
-   {50*OVERSAMPLENR, 265},
-   {54*OVERSAMPLENR, 260},
-   {58*OVERSAMPLENR, 255},
-   {62*OVERSAMPLENR, 250},
-   {67*OVERSAMPLENR, 245},
-   {72*OVERSAMPLENR, 240},
-   {79*OVERSAMPLENR, 235},
-   {85*OVERSAMPLENR, 230},
-   {91*OVERSAMPLENR, 225},
-   {99*OVERSAMPLENR, 220},
-   {107*OVERSAMPLENR, 215},
-   {116*OVERSAMPLENR, 210},
-   {126*OVERSAMPLENR, 205},
-   {136*OVERSAMPLENR, 200},
-   {149*OVERSAMPLENR, 195},
-   {160*OVERSAMPLENR, 190},
-   {175*OVERSAMPLENR, 185},
-   {191*OVERSAMPLENR, 180},
-   {209*OVERSAMPLENR, 175},
-   {224*OVERSAMPLENR, 170},
-   {246*OVERSAMPLENR, 165},
-   {267*OVERSAMPLENR, 160},
-   {293*OVERSAMPLENR, 155},
-   {316*OVERSAMPLENR, 150},
-   {340*OVERSAMPLENR, 145},
-   {364*OVERSAMPLENR, 140},
-   {396*OVERSAMPLENR, 135},
-   {425*OVERSAMPLENR, 130},
-   {460*OVERSAMPLENR, 125},
-   {489*OVERSAMPLENR, 120},
-   {526*OVERSAMPLENR, 115},
-   {558*OVERSAMPLENR, 110},
-   {591*OVERSAMPLENR, 105},
-   {628*OVERSAMPLENR, 100},
-   {660*OVERSAMPLENR, 95},
-   {696*OVERSAMPLENR, 90},
-   {733*OVERSAMPLENR, 85},
-   {761*OVERSAMPLENR, 80},
-   {794*OVERSAMPLENR, 75},
-   {819*OVERSAMPLENR, 70},
-   {847*OVERSAMPLENR, 65},
-   {870*OVERSAMPLENR, 60},
-   {892*OVERSAMPLENR, 55},
-   {911*OVERSAMPLENR, 50},
-   {929*OVERSAMPLENR, 45},
-   {944*OVERSAMPLENR, 40},
-   {959*OVERSAMPLENR, 35},
-   {971*OVERSAMPLENR, 30},
-   {981*OVERSAMPLENR, 25},
-   {989*OVERSAMPLENR, 20},
-   {994*OVERSAMPLENR, 15},
-   {1001*OVERSAMPLENR, 10},
-   {1005*OVERSAMPLENR, 5},
+   {1*OVERSAMPLENR, 941},
+   {19*OVERSAMPLENR, 362},
+   {37*OVERSAMPLENR, 299}, //top rating 300C
+   {55*OVERSAMPLENR, 266},
+   {73*OVERSAMPLENR, 245},
+   {91*OVERSAMPLENR, 229},
+   {109*OVERSAMPLENR, 216},
+   {127*OVERSAMPLENR, 206},
+   {145*OVERSAMPLENR, 197},
+   {163*OVERSAMPLENR, 190},
+   {181*OVERSAMPLENR, 183},
+   {199*OVERSAMPLENR, 177},
+   {217*OVERSAMPLENR, 171},
+   {235*OVERSAMPLENR, 166},
+   {253*OVERSAMPLENR, 162},
+   {271*OVERSAMPLENR, 157},
+   {289*OVERSAMPLENR, 153},
+   {307*OVERSAMPLENR, 149},
+   {325*OVERSAMPLENR, 146},
+   {343*OVERSAMPLENR, 142},
+   {361*OVERSAMPLENR, 139},
+   {379*OVERSAMPLENR, 135},
+   {397*OVERSAMPLENR, 132},
+   {415*OVERSAMPLENR, 129},
+   {433*OVERSAMPLENR, 126},
+   {451*OVERSAMPLENR, 123},
+   {469*OVERSAMPLENR, 121},
+   {487*OVERSAMPLENR, 118},
+   {505*OVERSAMPLENR, 115},
+   {523*OVERSAMPLENR, 112},
+   {541*OVERSAMPLENR, 110},
+   {559*OVERSAMPLENR, 107},
+   {577*OVERSAMPLENR, 105},
+   {595*OVERSAMPLENR, 102},
+   {613*OVERSAMPLENR, 99},
+   {631*OVERSAMPLENR, 97},
+   {649*OVERSAMPLENR, 94},
+   {667*OVERSAMPLENR, 92},
+   {685*OVERSAMPLENR, 89},
+   {703*OVERSAMPLENR, 86},
+   {721*OVERSAMPLENR, 84},
+   {739*OVERSAMPLENR, 81},
+   {757*OVERSAMPLENR, 78},
+   {775*OVERSAMPLENR, 75},
+   {793*OVERSAMPLENR, 72},
+   {811*OVERSAMPLENR, 69},
+   {829*OVERSAMPLENR, 66},
+   {847*OVERSAMPLENR, 62},
+   {865*OVERSAMPLENR, 59},
+   {883*OVERSAMPLENR, 55},
+   {901*OVERSAMPLENR, 51},
+   {919*OVERSAMPLENR, 46},
+   {937*OVERSAMPLENR, 41},
+   {955*OVERSAMPLENR, 35},
+   {973*OVERSAMPLENR, 27},
+   {991*OVERSAMPLENR, 17},
+   {1009*OVERSAMPLENR, 1},
    {1023*OVERSAMPLENR, 0}  //to allow internal 0 degrees C
 };
 #endif

commit 9f2862ce489271f0e5dbd00f06e4e9bfb670af26 (from 6a61a3c0b4365d4d0887dbbff94d38e452cbe4c7)
Merge: 9fb8bd5 6a61a3c
Author: ErikZalm <erik@vdzalm.eu>
Date:   Mon Mar 25 13:14:49 2013 -0700

    Merge pull request #414 from whosawhatsis/Marlin_v1
    
    regenerated thermistor table 7

diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index 0ba908b..15518f2 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -34,9 +34,11 @@
 // 6  = Sanguinololu < 1.2
 // 62 = Sanguinololu 1.2 and above
 // 63 = Melzi
+// 64 = STB V1.1
 // 7  = Ultimaker
 // 71 = Ultimaker (Older electronics. Pre 1.5.4. This is rare)
 // 8  = Teensylu
+// 80 = Rumba
 // 81 = Printrboard (AT90USB1286)
 // 82 = Brainwave (AT90USB646)
 // 9  = Gen3+
@@ -116,7 +118,8 @@
 // PID settings:
 // Comment the following line to disable PID and enable bang-bang.
 #define PIDTEMP
-#define PID_MAX 256 // limits current to nozzle; 256=full current
+#define BANG_MAX 256 // limits current to nozzle while in bang-bang mode; 256=full current
+#define PID_MAX 256 // limits current to nozzle while PID is active (see PID_FUNCTIONAL_RANGE below); 256=full current
 #ifdef PIDTEMP
   //#define PID_DEBUG // Sends debug data to the serial port. 
   //#define PID_OPENLOOP 1 // Puts PID in open loop. M104/M140 sets the output power from 0 to PID_MAX
@@ -314,6 +317,7 @@ const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
 
 //LCD and SD support
 //#define ULTRA_LCD  //general lcd support, also 16x2
+//#define DOGLCD	// Support for SPI LCD 128x64 (Controller ST7565R graphic Display Family)
 //#define SDSUPPORT // Enable SD Card Support in Hardware Console
 
 //#define ULTIMAKERCONTROLLER //as available from the ultimaker online store.
@@ -322,9 +326,9 @@ const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
 // The RepRapDiscount Smart Controller (white PCB)
 // http://reprap.org/wiki/RepRapDiscount_Smart_Controller
 //#define REPRAP_DISCOUNT_SMART_CONTROLLER
-
-// The GADGETS3D G3D LCD/SD Controller (blue PCB)
-// http://reprap.org/wiki/RAMPS_1.3/1.4_GADGETS3D_Shield_with_Panel
+
+// The GADGETS3D G3D LCD/SD Controller (blue PCB)
+// http://reprap.org/wiki/RAMPS_1.3/1.4_GADGETS3D_Shield_with_Panel
 //#define G3D_PANEL
 
 //automatic expansion
@@ -347,13 +351,22 @@ const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
 //  #define NEWPANEL  //enable this if you have a click-encoder panel
   #define SDSUPPORT
   #define ULTRA_LCD
-  #define LCD_WIDTH 20
-  #define LCD_HEIGHT 4
-  
+	#ifdef DOGLCD	// Change number of lines to match the DOG graphic display
+		#define LCD_WIDTH 20
+		#define LCD_HEIGHT 5
+	#else
+		#define LCD_WIDTH 20
+		#define LCD_HEIGHT 4
+	#endif
 #else //no panel but just lcd 
   #ifdef ULTRA_LCD
-    #define LCD_WIDTH 16
-    #define LCD_HEIGHT 2    
+	#ifdef DOGLCD	// Change number of lines to match the 128x64 graphics display
+		#define LCD_WIDTH 20
+		#define LCD_HEIGHT 5
+	#else
+		#define LCD_WIDTH 16
+		#define LCD_HEIGHT 2
+	#endif    
   #endif
 #endif
 
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index 3725546..fa3681e 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -1,2132 +1,2161 @@
-/* -*- c++ -*- */
-
-/*
-    Reprap firmware based on Sprinter and grbl.
- Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
- 
- This program is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by
- the Free Software Foundation, either version 3 of the License, or
- (at your option) any later version.
- 
- This program is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- GNU General Public License for more details.
- 
- You should have received a copy of the GNU General Public License
- along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-/*
- This firmware is a mashup between Sprinter and grbl.
-  (https://github.com/kliment/Sprinter)
-  (https://github.com/simen/grbl/tree)
- 
- It has preliminary support for Matthew Roberts advance algorithm 
-    http://reprap.org/pipermail/reprap-dev/2011-May/003323.html
- */
-
-#include "Marlin.h"
-
-#include "ultralcd.h"
-#include "planner.h"
-#include "stepper.h"
-#include "temperature.h"
-#include "motion_control.h"
-#include "cardreader.h"
-#include "watchdog.h"
-#include "ConfigurationStore.h"
-#include "language.h"
-#include "pins_arduino.h"
-
-#if DIGIPOTSS_PIN > -1
-#include <SPI.h>
-#endif
-
-#define VERSION_STRING  "1.0.0"
-
-// look here for descriptions of gcodes: http://linuxcnc.org/handbook/gcode/g-code.html
-// http://objects.reprap.org/wiki/Mendel_User_Manual:_RepRapGCodes
-
-//Implemented Codes
-//-------------------
-// G0  -> G1
-// G1  - Coordinated Movement X Y Z E
-// G2  - CW ARC
-// G3  - CCW ARC
-// G4  - Dwell S<seconds> or P<milliseconds>
-// G10 - retract filament according to settings of M207
-// G11 - retract recover filament according to settings of M208
-// G28 - Home all Axis
-// G90 - Use Absolute Coordinates
-// G91 - Use Relative Coordinates
-// G92 - Set current position to cordinates given
-
-//RepRap M Codes
-// M0   - Unconditional stop - Wait for user to press a button on the LCD (Only if ULTRA_LCD is enabled)
-// M1   - Same as M0
-// M104 - Set extruder target temp
-// M105 - Read current temp
-// M106 - Fan on
-// M107 - Fan off
-// M109 - Wait for extruder current temp to reach target temp.
-// M114 - Display current position
-
-//Custom M Codes
-// M17  - Enable/Power all stepper motors
-// M18  - Disable all stepper motors; same as M84
-// M20  - List SD card
-// M21  - Init SD card
-// M22  - Release SD card
-// M23  - Select SD file (M23 filename.g)
-// M24  - Start/resume SD print
-// M25  - Pause SD print
-// M26  - Set SD position in bytes (M26 S12345)
-// M27  - Report SD print status
-// M28  - Start SD write (M28 filename.g)
-// M29  - Stop SD write
-// M30  - Delete file from SD (M30 filename.g)
-// M31  - Output time since last M109 or SD card start to serial
-// M42  - Change pin status via gcode Use M42 Px Sy to set pin x to value y, when omitting Px the onboard led will be used.
-// M80  - Turn on Power Supply
-// M81  - Turn off Power Supply
-// M82  - Set E codes absolute (default)
-// M83  - Set E codes relative while in Absolute Coordinates (G90) mode
-// M84  - Disable steppers until next move, 
-//        or use S<seconds> to specify an inactivity timeout, after which the steppers will be disabled.  S0 to disable the timeout.
-// M85  - Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
-// M92  - Set axis_steps_per_unit - same syntax as G92
-// M114 - Output current position to serial port 
-// M115	- Capabilities string
-// M117 - display message
-// M119 - Output Endstop status to serial port
-// M140 - Set bed target temp
-// M190 - Wait for bed current temp to reach target temp.
-// M200 - Set filament diameter
-// M201 - Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)
-// M202 - Set max acceleration in units/s^2 for travel moves (M202 X1000 Y1000) Unused in Marlin!!
-// M203 - Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in mm/sec
-// M204 - Set default acceleration: S normal moves T filament only moves (M204 S3000 T7000) im mm/sec^2  also sets minimum segment time in ms (B20000) to prevent buffer underruns and M20 minimum feedrate
-// M205 -  advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk, E=maximum E jerk
-// M206 - set additional homeing offset
-// M207 - set retract length S[positive mm] F[feedrate mm/sec] Z[additional zlift/hop]
-// M208 - set recover=unretract length S[positive mm surplus to the M207 S*] F[feedrate mm/sec]
-// M209 - S<1=true/0=false> enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.
-// M218 - set hotend offset (in mm): T<extruder_number> X<offset_on_X> Y<offset_on_Y>
-// M220 S<factor in percent>- set speed factor override percentage
-// M221 S<factor in percent>- set extrude factor override percentage
-// M240 - Trigger a camera to take a photograph
-// M301 - Set PID parameters P I and D
-// M302 - Allow cold extrudes
-// M303 - PID relay autotune S<temperature> sets the target temperature. (default target temperature = 150C)
-// M304 - Set bed PID parameters P I and D
-// M400 - Finish all moves
-// M500 - stores paramters in EEPROM
-// M501 - reads parameters from EEPROM (if you need reset them after you changed them temporarily).  
-// M502 - reverts to the default "factory settings".  You still need to store them in EEPROM afterwards if you want to.
-// M503 - print the current settings (from memory not from eeprom)
-// M540 - Use S[0|1] to enable or disable the stop SD card print on endstop hit (requires ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
-// M600 - Pause for filament change X[pos] Y[pos] Z[relative lift] E[initial retract] L[later retract distance for removal]
-// M907 - Set digital trimpot motor current using axis codes.
-// M908 - Control digital trimpot directly.
-// M350 - Set microstepping mode.
-// M351 - Toggle MS1 MS2 pins directly.
-// M999 - Restart after being stopped by error
-
-//Stepper Movement Variables
-
-//===========================================================================
-//=============================imported variables============================
-//===========================================================================
-
-
-//===========================================================================
-//=============================public variables=============================
-//===========================================================================
-#ifdef SDSUPPORT
-CardReader card;
-#endif
-float homing_feedrate[] = HOMING_FEEDRATE;
-bool axis_relative_modes[] = AXIS_RELATIVE_MODES;
-int feedmultiply=100; //100->1 200->2
-int saved_feedmultiply;
-int extrudemultiply=100; //100->1 200->2
-float current_position[NUM_AXIS] = { 0.0, 0.0, 0.0, 0.0 };
-float add_homeing[3]={0,0,0};
-float min_pos[3] = { X_MIN_POS, Y_MIN_POS, Z_MIN_POS };
-float max_pos[3] = { X_MAX_POS, Y_MAX_POS, Z_MAX_POS };
-// Extruder offset, only in XY plane
+/* -*- c++ -*- */
+
+/*
+    Reprap firmware based on Sprinter and grbl.
+ Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ 
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+ 
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ This firmware is a mashup between Sprinter and grbl.
+  (https://github.com/kliment/Sprinter)
+  (https://github.com/simen/grbl/tree)
+ 
+ It has preliminary support for Matthew Roberts advance algorithm 
+    http://reprap.org/pipermail/reprap-dev/2011-May/003323.html
+ */
+
+#include "Marlin.h"
+
+#include "ultralcd.h"
+#include "planner.h"
+#include "stepper.h"
+#include "temperature.h"
+#include "motion_control.h"
+#include "cardreader.h"
+#include "watchdog.h"
+#include "ConfigurationStore.h"
+#include "language.h"
+#include "pins_arduino.h"
+
+#if DIGIPOTSS_PIN > -1
+#include <SPI.h>
+#endif
+
+#define VERSION_STRING  "1.0.0"
+
+// look here for descriptions of gcodes: http://linuxcnc.org/handbook/gcode/g-code.html
+// http://objects.reprap.org/wiki/Mendel_User_Manual:_RepRapGCodes
+
+//Implemented Codes
+//-------------------
+// G0  -> G1
+// G1  - Coordinated Movement X Y Z E
+// G2  - CW ARC
+// G3  - CCW ARC
+// G4  - Dwell S<seconds> or P<milliseconds>
+// G10 - retract filament according to settings of M207
+// G11 - retract recover filament according to settings of M208
+// G28 - Home all Axis
+// G90 - Use Absolute Coordinates
+// G91 - Use Relative Coordinates
+// G92 - Set current position to cordinates given
+
+//RepRap M Codes
+// M0   - Unconditional stop - Wait for user to press a button on the LCD (Only if ULTRA_LCD is enabled)
+// M1   - Same as M0
+// M104 - Set extruder target temp
+// M105 - Read current temp
+// M106 - Fan on
+// M107 - Fan off
+// M109 - Wait for extruder current temp to reach target temp.
+// M114 - Display current position
+
+//Custom M Codes
+// M17  - Enable/Power all stepper motors
+// M18  - Disable all stepper motors; same as M84
+// M20  - List SD card
+// M21  - Init SD card
+// M22  - Release SD card
+// M23  - Select SD file (M23 filename.g)
+// M24  - Start/resume SD print
+// M25  - Pause SD print
+// M26  - Set SD position in bytes (M26 S12345)
+// M27  - Report SD print status
+// M28  - Start SD write (M28 filename.g)
+// M29  - Stop SD write
+// M30  - Delete file from SD (M30 filename.g)
+// M31  - Output time since last M109 or SD card start to serial
+// M42  - Change pin status via gcode Use M42 Px Sy to set pin x to value y, when omitting Px the onboard led will be used.
+// M80  - Turn on Power Supply
+// M81  - Turn off Power Supply
+// M82  - Set E codes absolute (default)
+// M83  - Set E codes relative while in Absolute Coordinates (G90) mode
+// M84  - Disable steppers until next move, 
+//        or use S<seconds> to specify an inactivity timeout, after which the steppers will be disabled.  S0 to disable the timeout.
+// M85  - Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
+// M92  - Set axis_steps_per_unit - same syntax as G92
+// M114 - Output current position to serial port 
+// M115	- Capabilities string
+// M117 - display message
+// M119 - Output Endstop status to serial port
+// M140 - Set bed target temp
+// M190 - Wait for bed current temp to reach target temp.
+// M200 - Set filament diameter
+// M201 - Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)
+// M202 - Set max acceleration in units/s^2 for travel moves (M202 X1000 Y1000) Unused in Marlin!!
+// M203 - Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in mm/sec
+// M204 - Set default acceleration: S normal moves T filament only moves (M204 S3000 T7000) im mm/sec^2  also sets minimum segment time in ms (B20000) to prevent buffer underruns and M20 minimum feedrate
+// M205 -  advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk, E=maximum E jerk
+// M206 - set additional homeing offset
+// M207 - set retract length S[positive mm] F[feedrate mm/sec] Z[additional zlift/hop]
+// M208 - set recover=unretract length S[positive mm surplus to the M207 S*] F[feedrate mm/sec]
+// M209 - S<1=true/0=false> enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.
+// M218 - set hotend offset (in mm): T<extruder_number> X<offset_on_X> Y<offset_on_Y>
+// M220 S<factor in percent>- set speed factor override percentage
+// M221 S<factor in percent>- set extrude factor override percentage
+// M240 - Trigger a camera to take a photograph
+// M301 - Set PID parameters P I and D
+// M302 - Allow cold extrudes
+// M303 - PID relay autotune S<temperature> sets the target temperature. (default target temperature = 150C)
+// M304 - Set bed PID parameters P I and D
+// M400 - Finish all moves
+// M500 - stores paramters in EEPROM
+// M501 - reads parameters from EEPROM (if you need reset them after you changed them temporarily).  
+// M502 - reverts to the default "factory settings".  You still need to store them in EEPROM afterwards if you want to.
+// M503 - print the current settings (from memory not from eeprom)
+// M540 - Use S[0|1] to enable or disable the stop SD card print on endstop hit (requires ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
+// M600 - Pause for filament change X[pos] Y[pos] Z[relative lift] E[initial retract] L[later retract distance for removal]
+// M907 - Set digital trimpot motor current using axis codes.
+// M908 - Control digital trimpot directly.
+// M350 - Set microstepping mode.
+// M351 - Toggle MS1 MS2 pins directly.
+// M999 - Restart after being stopped by error
+
+//Stepper Movement Variables
+
+//===========================================================================
+//=============================imported variables============================
+//===========================================================================
+
+
+//===========================================================================
+//=============================public variables=============================
+//===========================================================================
+#ifdef SDSUPPORT
+CardReader card;
+#endif
+float homing_feedrate[] = HOMING_FEEDRATE;
+bool axis_relative_modes[] = AXIS_RELATIVE_MODES;
+int feedmultiply=100; //100->1 200->2
+int saved_feedmultiply;
+int extrudemultiply=100; //100->1 200->2
+float current_position[NUM_AXIS] = { 0.0, 0.0, 0.0, 0.0 };
+float add_homeing[3]={0,0,0};
+float min_pos[3] = { X_MIN_POS, Y_MIN_POS, Z_MIN_POS };
+float max_pos[3] = { X_MAX_POS, Y_MAX_POS, Z_MAX_POS };
+// Extruder offset, only in XY plane
 #if EXTRUDERS > 1
-float extruder_offset[2][EXTRUDERS] = { 
-#if defined(EXTRUDER_OFFSET_X) && defined(EXTRUDER_OFFSET_Y)
-  EXTRUDER_OFFSET_X, EXTRUDER_OFFSET_Y 
-#endif
+float extruder_offset[2][EXTRUDERS] = { 
+#if defined(EXTRUDER_OFFSET_X) && defined(EXTRUDER_OFFSET_Y)
+  EXTRUDER_OFFSET_X, EXTRUDER_OFFSET_Y 
+#endif
 }; 
-#endif
-uint8_t active_extruder = 0;
-int fanSpeed=0;
-
-#ifdef FWRETRACT
-  bool autoretract_enabled=true;
-  bool retracted=false;
-  float retract_length=3, retract_feedrate=17*60, retract_zlift=0.8;
-  float retract_recover_length=0, retract_recover_feedrate=8*60;
-#endif
-
-//===========================================================================
-//=============================private variables=============================
-//===========================================================================
-const char axis_codes[NUM_AXIS] = {'X', 'Y', 'Z', 'E'};
-static float destination[NUM_AXIS] = {  0.0, 0.0, 0.0, 0.0};
-static float offset[3] = {0.0, 0.0, 0.0};
-static bool home_all_axis = true;
-static float feedrate = 1500.0, next_feedrate, saved_feedrate;
-static long gcode_N, gcode_LastN, Stopped_gcode_LastN = 0;
-
-static bool relative_mode = false;  //Determines Absolute or Relative Coordinates
-
-static char cmdbuffer[BUFSIZE][MAX_CMD_SIZE];
-static bool fromsd[BUFSIZE];
-static int bufindr = 0;
-static int bufindw = 0;
-static int buflen = 0;
-//static int i = 0;
-static char serial_char;
-static int serial_count = 0;
-static boolean comment_mode = false;
-static char *strchr_pointer; // just a pointer to find chars in the cmd string like X, Y, Z, E, etc
-
-const int sensitive_pins[] = SENSITIVE_PINS; // Sensitive pin list for M42
-
-//static float tt = 0;
-//static float bt = 0;
-
-//Inactivity shutdown variables
-static unsigned long previous_millis_cmd = 0;
-static unsigned long max_inactive_time = 0;
-static unsigned long stepper_inactive_time = DEFAULT_STEPPER_DEACTIVE_TIME*1000l;
-
-unsigned long starttime=0;
-unsigned long stoptime=0;
-
-static uint8_t tmp_extruder;
-
-
-bool Stopped=false;
-
-//===========================================================================
-//=============================ROUTINES=============================
-//===========================================================================
-
-void get_arc_coordinates();
-bool setTargetedHotend(int code);
-
-void serial_echopair_P(const char *s_P, float v)
-    { serialprintPGM(s_P); SERIAL_ECHO(v); }
-void serial_echopair_P(const char *s_P, double v)
-    { serialprintPGM(s_P); SERIAL_ECHO(v); }
-void serial_echopair_P(const char *s_P, unsigned long v)
-    { serialprintPGM(s_P); SERIAL_ECHO(v); }
-
-extern "C"{
-  extern unsigned int __bss_end;
-  extern unsigned int __heap_start;
-  extern void *__brkval;
-
-  int freeMemory() {
-    int free_memory;
-
-    if((int)__brkval == 0)
-      free_memory = ((int)&free_memory) - ((int)&__bss_end);
-    else
-      free_memory = ((int)&free_memory) - ((int)__brkval);
-
-    return free_memory;
-  }
-}
-
-//adds an command to the main command buffer
-//thats really done in a non-safe way.
-//needs overworking someday
-void enquecommand(const char *cmd)
-{
-  if(buflen < BUFSIZE)
-  {
-    //this is dangerous if a mixing of serial and this happsens
-    strcpy(&(cmdbuffer[bufindw][0]),cmd);
-    SERIAL_ECHO_START;
-    SERIAL_ECHOPGM("enqueing \"");
-    SERIAL_ECHO(cmdbuffer[bufindw]);
-    SERIAL_ECHOLNPGM("\"");
-    bufindw= (bufindw + 1)%BUFSIZE;
-    buflen += 1;
-  }
-}
-
-void enquecommand_P(const char *cmd)
-{
-  if(buflen < BUFSIZE)
-  {
-    //this is dangerous if a mixing of serial and this happsens
-    strcpy_P(&(cmdbuffer[bufindw][0]),cmd);
-    SERIAL_ECHO_START;
-    SERIAL_ECHOPGM("enqueing \"");
-    SERIAL_ECHO(cmdbuffer[bufindw]);
-    SERIAL_ECHOLNPGM("\"");
-    bufindw= (bufindw + 1)%BUFSIZE;
-    buflen += 1;
-  }
-}
-
-void setup_killpin()
-{
-  #if( KILL_PIN>-1 )
-    pinMode(KILL_PIN,INPUT);
-    WRITE(KILL_PIN,HIGH);
-  #endif
-}
-    
-void setup_photpin()
-{
-  #ifdef PHOTOGRAPH_PIN
-    #if (PHOTOGRAPH_PIN > -1)
-    SET_OUTPUT(PHOTOGRAPH_PIN);
-    WRITE(PHOTOGRAPH_PIN, LOW);
-    #endif
-  #endif 
-}
-
-void setup_powerhold()
-{
- #ifdef SUICIDE_PIN
-   #if (SUICIDE_PIN> -1)
-      SET_OUTPUT(SUICIDE_PIN);
-      WRITE(SUICIDE_PIN, HIGH);
-   #endif
- #endif
- #if (PS_ON_PIN > -1)
-   SET_OUTPUT(PS_ON_PIN);
-   WRITE(PS_ON_PIN, PS_ON_AWAKE);
- #endif
-}
-
-void suicide()
-{
- #ifdef SUICIDE_PIN
-    #if (SUICIDE_PIN> -1) 
-      SET_OUTPUT(SUICIDE_PIN);
-      WRITE(SUICIDE_PIN, LOW);
-    #endif
-  #endif
-}
-
-void setup()
-{
-  setup_killpin(); 
-  setup_powerhold();
-  MYSERIAL.begin(BAUDRATE);
-  SERIAL_PROTOCOLLNPGM("start");
-  SERIAL_ECHO_START;
-
-  // Check startup - does nothing if bootloader sets MCUSR to 0
-  byte mcu = MCUSR;
-  if(mcu & 1) SERIAL_ECHOLNPGM(MSG_POWERUP);
-  if(mcu & 2) SERIAL_ECHOLNPGM(MSG_EXTERNAL_RESET);
-  if(mcu & 4) SERIAL_ECHOLNPGM(MSG_BROWNOUT_RESET);
-  if(mcu & 8) SERIAL_ECHOLNPGM(MSG_WATCHDOG_RESET);
-  if(mcu & 32) SERIAL_ECHOLNPGM(MSG_SOFTWARE_RESET);
-  MCUSR=0;
-
-  SERIAL_ECHOPGM(MSG_MARLIN);
-  SERIAL_ECHOLNPGM(VERSION_STRING);
-  #ifdef STRING_VERSION_CONFIG_H
-    #ifdef STRING_CONFIG_H_AUTHOR
-      SERIAL_ECHO_START;
-      SERIAL_ECHOPGM(MSG_CONFIGURATION_VER);
-      SERIAL_ECHOPGM(STRING_VERSION_CONFIG_H);
-      SERIAL_ECHOPGM(MSG_AUTHOR);
-      SERIAL_ECHOLNPGM(STRING_CONFIG_H_AUTHOR);
-      SERIAL_ECHOPGM("Compiled: ");
-      SERIAL_ECHOLNPGM(__DATE__);
-    #endif
-  #endif
-  SERIAL_ECHO_START;
-  SERIAL_ECHOPGM(MSG_FREE_MEMORY);
-  SERIAL_ECHO(freeMemory());
-  SERIAL_ECHOPGM(MSG_PLANNER_BUFFER_BYTES);
-  SERIAL_ECHOLN((int)sizeof(block_t)*BLOCK_BUFFER_SIZE);
-  for(int8_t i = 0; i < BUFSIZE; i++)
-  {
-    fromsd[i] = false;
-  }
-  
-  Config_RetrieveSettings(); // loads data from EEPROM if available
-
-  for(int8_t i=0; i < NUM_AXIS; i++)
-  {
-    axis_steps_per_sqr_second[i] = max_acceleration_units_per_sq_second[i] * axis_steps_per_unit[i];
-  }
-
-
-  tp_init();    // Initialize temperature loop 
-  plan_init();  // Initialize planner;
-  watchdog_init();
-  st_init();    // Initialize stepper, this enables interrupts!
-  setup_photpin();
-  
-  lcd_init();
-}
-
-
-void loop()
-{
-  if(buflen < (BUFSIZE-1))
-    get_command();
-  #ifdef SDSUPPORT
-  card.checkautostart(false);
-  #endif
-  if(buflen)
-  {
-    #ifdef SDSUPPORT
-      if(card.saving)
-      {
-	if(strstr_P(cmdbuffer[bufindr], PSTR("M29")) == NULL)
-	{
-	  card.write_command(cmdbuffer[bufindr]);
-	  SERIAL_PROTOCOLLNPGM(MSG_OK);
-	}
-	else
-	{
-	  card.closefile();
-	  SERIAL_PROTOCOLLNPGM(MSG_FILE_SAVED);
-	}
-      }
-      else
-      {
-	process_commands();
-      }
-    #else
-      process_commands();
-    #endif //SDSUPPORT
-    buflen = (buflen-1);
-    bufindr = (bufindr + 1)%BUFSIZE;
-  }
-  //check heater every n milliseconds
-  manage_heater();
-  manage_inactivity();
-  checkHitEndstops();
-  lcd_update();
-}
-
-void get_command() 
-{ 
-  while( MYSERIAL.available() > 0  && buflen < BUFSIZE) {
-    serial_char = MYSERIAL.read();
-    if(serial_char == '\n' || 
-       serial_char == '\r' || 
-       (serial_char == ':' && comment_mode == false) || 
-       serial_count >= (MAX_CMD_SIZE - 1) ) 
-    {
-      if(!serial_count) { //if empty line
-        comment_mode = false; //for new command
-        return;
-      }
-      cmdbuffer[bufindw][serial_count] = 0; //terminate string
-      if(!comment_mode){
-        comment_mode = false; //for new command
-        fromsd[bufindw] = false;
-        if(strchr(cmdbuffer[bufindw], 'N') != NULL)
-        {
-          strchr_pointer = strchr(cmdbuffer[bufindw], 'N');
-          gcode_N = (strtol(&cmdbuffer[bufindw][strchr_pointer - cmdbuffer[bufindw] + 1], NULL, 10));
-          if(gcode_N != gcode_LastN+1 && (strstr_P(cmdbuffer[bufindw], PSTR("M110")) == NULL) ) {
-            SERIAL_ERROR_START;
-            SERIAL_ERRORPGM(MSG_ERR_LINE_NO);
-            SERIAL_ERRORLN(gcode_LastN);
-            //Serial.println(gcode_N);
-            FlushSerialRequestResend();
-            serial_count = 0;
-            return;
-          }
-
-          if(strchr(cmdbuffer[bufindw], '*') != NULL)
-          {
-            byte checksum = 0;
-            byte count = 0;
-            while(cmdbuffer[bufindw][count] != '*') checksum = checksum^cmdbuffer[bufindw][count++];
-            strchr_pointer = strchr(cmdbuffer[bufindw], '*');
-
-            if( (int)(strtod(&cmdbuffer[bufindw][strchr_pointer - cmdbuffer[bufindw] + 1], NULL)) != checksum) {
-              SERIAL_ERROR_START;
-              SERIAL_ERRORPGM(MSG_ERR_CHECKSUM_MISMATCH);
-              SERIAL_ERRORLN(gcode_LastN);
-              FlushSerialRequestResend();
-              serial_count = 0;
-              return;
-            }
-            //if no errors, continue parsing
-          }
-          else 
-          {
-            SERIAL_ERROR_START;
-            SERIAL_ERRORPGM(MSG_ERR_NO_CHECKSUM);
-            SERIAL_ERRORLN(gcode_LastN);
-            FlushSerialRequestResend();
-            serial_count = 0;
-            return;
-          }
-
-          gcode_LastN = gcode_N;
-          //if no errors, continue parsing
-        }
-        else  // if we don't receive 'N' but still see '*'
-        {
-          if((strchr(cmdbuffer[bufindw], '*') != NULL))
-          {
-            SERIAL_ERROR_START;
-            SERIAL_ERRORPGM(MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM);
-            SERIAL_ERRORLN(gcode_LastN);
-            serial_count = 0;
-            return;
-          }
-        }
-        if((strchr(cmdbuffer[bufindw], 'G') != NULL)){
-          strchr_pointer = strchr(cmdbuffer[bufindw], 'G');
-          switch((int)((strtod(&cmdbuffer[bufindw][strchr_pointer - cmdbuffer[bufindw] + 1], NULL)))){
-          case 0:
-          case 1:
-          case 2:
-          case 3:
-            if(Stopped == false) { // If printer is stopped by an error the G[0-3] codes are ignored.
-	      #ifdef SDSUPPORT
-              if(card.saving)
-                break;
-	      #endif //SDSUPPORT
-              SERIAL_PROTOCOLLNPGM(MSG_OK); 
-            }
-            else {
-              SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
-              LCD_MESSAGEPGM(MSG_STOPPED);
-            }
-            break;
-          default:
-            break;
-          }
-
-        }
-        bufindw = (bufindw + 1)%BUFSIZE;
-        buflen += 1;
-      }
-      serial_count = 0; //clear buffer
-    }
-    else
-    {
-      if(serial_char == ';') comment_mode = true;
-      if(!comment_mode) cmdbuffer[bufindw][serial_count++] = serial_char;
-    }
-  }
-  #ifdef SDSUPPORT
-  if(!card.sdprinting || serial_count!=0){
-    return;
-  }
-  while( !card.eof()  && buflen < BUFSIZE) {
-    int16_t n=card.get();
-    serial_char = (char)n;
-    if(serial_char == '\n' || 
-       serial_char == '\r' || 
-       (serial_char == ':' && comment_mode == false) || 
-       serial_count >= (MAX_CMD_SIZE - 1)||n==-1) 
-    {
-      if(card.eof()){
-        SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);
-        stoptime=millis();
-        char time[30];
-        unsigned long t=(stoptime-starttime)/1000;
-        int hours, minutes;
-        minutes=(t/60)%60;
-        hours=t/60/60;
-        sprintf_P(time, PSTR("%i hours %i minutes"),hours, minutes);
-        SERIAL_ECHO_START;
-        SERIAL_ECHOLN(time);
-        lcd_setstatus(time);
-        card.printingHasFinished();
-        card.checkautostart(true);
-        
-      }
-      if(!serial_count)
-      {
-        comment_mode = false; //for new command
-        return; //if empty line
-      }
-      cmdbuffer[bufindw][serial_count] = 0; //terminate string
-//      if(!comment_mode){
-        fromsd[bufindw] = true;
-        buflen += 1;
-        bufindw = (bufindw + 1)%BUFSIZE;
-//      }     
-      comment_mode = false; //for new command
-      serial_count = 0; //clear buffer
-    }
-    else
-    {
-      if(serial_char == ';') comment_mode = true;
-      if(!comment_mode) cmdbuffer[bufindw][serial_count++] = serial_char;
-    }
-  }
-  
-  #endif //SDSUPPORT
-
-}
-
-
-float code_value() 
-{ 
-  return (strtod(&cmdbuffer[bufindr][strchr_pointer - cmdbuffer[bufindr] + 1], NULL)); 
-}
-
-long code_value_long() 
-{ 
-  return (strtol(&cmdbuffer[bufindr][strchr_pointer - cmdbuffer[bufindr] + 1], NULL, 10)); 
-}
-
-bool code_seen(char code)
-{
-  strchr_pointer = strchr(cmdbuffer[bufindr], code);
-  return (strchr_pointer != NULL);  //Return True if a character was found
-}
-
-#define DEFINE_PGM_READ_ANY(type, reader)		\
-    static inline type pgm_read_any(const type *p)	\
-	{ return pgm_read_##reader##_near(p); }
-
-DEFINE_PGM_READ_ANY(float,       float);
-DEFINE_PGM_READ_ANY(signed char, byte);
-
-#define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG)	\
-static const PROGMEM type array##_P[3] =		\
-    { X_##CONFIG, Y_##CONFIG, Z_##CONFIG };		\
-static inline type array(int axis)			\
-    { return pgm_read_any(&array##_P[axis]); }
-
-XYZ_CONSTS_FROM_CONFIG(float, base_min_pos,    MIN_POS);
-XYZ_CONSTS_FROM_CONFIG(float, base_max_pos,    MAX_POS);
-XYZ_CONSTS_FROM_CONFIG(float, base_home_pos,   HOME_POS);
-XYZ_CONSTS_FROM_CONFIG(float, max_length,      MAX_LENGTH);
-XYZ_CONSTS_FROM_CONFIG(float, home_retract_mm, HOME_RETRACT_MM);
-XYZ_CONSTS_FROM_CONFIG(signed char, home_dir,  HOME_DIR);
-
-static void axis_is_at_home(int axis) {
-  current_position[axis] = base_home_pos(axis) + add_homeing[axis];
-  min_pos[axis] =          base_min_pos(axis) + add_homeing[axis];
-  max_pos[axis] =          base_max_pos(axis) + add_homeing[axis];
-}
-
-static void homeaxis(int axis) {
-#define HOMEAXIS_DO(LETTER) \
-  ((LETTER##_MIN_PIN > -1 && LETTER##_HOME_DIR==-1) || (LETTER##_MAX_PIN > -1 && LETTER##_HOME_DIR==1))
-
-  if (axis==X_AXIS ? HOMEAXIS_DO(X) :
-      axis==Y_AXIS ? HOMEAXIS_DO(Y) :
-      axis==Z_AXIS ? HOMEAXIS_DO(Z) :
-      0) {
-    current_position[axis] = 0;
-    plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
-    destination[axis] = 1.5 * max_length(axis) * home_dir(axis);
-    feedrate = homing_feedrate[axis];
-    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
-    st_synchronize();
-   
-    current_position[axis] = 0;
-    plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
-    destination[axis] = -home_retract_mm(axis) * home_dir(axis);
-    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
-    st_synchronize();
-   
-    destination[axis] = 2*home_retract_mm(axis) * home_dir(axis);
-    feedrate = homing_feedrate[axis]/2 ; 
-    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
-    st_synchronize();
-   
-    axis_is_at_home(axis);					
-    destination[axis] = current_position[axis];
-    feedrate = 0.0;
-    endstops_hit_on_purpose();
-  }
-}
-#define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)
-
-void process_commands()
-{
-  unsigned long codenum; //throw away variable
-  char *starpos = NULL;
-
-  if(code_seen('G'))
-  {
-    switch((int)code_value())
-    {
-    case 0: // G0 -> G1
-    case 1: // G1
-      if(Stopped == false) {
-        get_coordinates(); // For X Y Z E F
-        prepare_move();
-        //ClearToSend();
-        return;
-      }
-      //break;
-    case 2: // G2  - CW ARC
-      if(Stopped == false) {
-        get_arc_coordinates();
-        prepare_arc_move(true);
-        return;
-      }
-    case 3: // G3  - CCW ARC
-      if(Stopped == false) {
-        get_arc_coordinates();
-        prepare_arc_move(false);
-        return;
-      }
-    case 4: // G4 dwell
-      LCD_MESSAGEPGM(MSG_DWELL);
-      codenum = 0;
-      if(code_seen('P')) codenum = code_value(); // milliseconds to wait
-      if(code_seen('S')) codenum = code_value() * 1000; // seconds to wait
-      
-      st_synchronize();
-      codenum += millis();  // keep track of when we started waiting
-      previous_millis_cmd = millis();
-      while(millis()  < codenum ){
-        manage_heater();
-        manage_inactivity();
-        lcd_update();
-      }
-      break;
-      #ifdef FWRETRACT  
-      case 10: // G10 retract
-      if(!retracted) 
-      {
-        destination[X_AXIS]=current_position[X_AXIS];
-        destination[Y_AXIS]=current_position[Y_AXIS];
-        destination[Z_AXIS]=current_position[Z_AXIS]; 
-        current_position[Z_AXIS]+=-retract_zlift;
-        destination[E_AXIS]=current_position[E_AXIS]-retract_length; 
-        feedrate=retract_feedrate;
-        retracted=true;
-        prepare_move();
-      }
-      
-      break;
-      case 11: // G10 retract_recover
-      if(!retracted) 
-      {
-        destination[X_AXIS]=current_position[X_AXIS];
-        destination[Y_AXIS]=current_position[Y_AXIS];
-        destination[Z_AXIS]=current_position[Z_AXIS]; 
-        
-        current_position[Z_AXIS]+=retract_zlift;
-        current_position[E_AXIS]+=-retract_recover_length; 
-        feedrate=retract_recover_feedrate;
-        retracted=false;
-        prepare_move();
-      }
-      break;
-      #endif //FWRETRACT
-    case 28: //G28 Home all Axis one at a time
-      saved_feedrate = feedrate;
-      saved_feedmultiply = feedmultiply;
-      feedmultiply = 100;
-      previous_millis_cmd = millis();
-      
-      enable_endstops(true);
-      
-      for(int8_t i=0; i < NUM_AXIS; i++) {
-        destination[i] = current_position[i];
-      }
-      feedrate = 0.0;
-      home_all_axis = !((code_seen(axis_codes[0])) || (code_seen(axis_codes[1])) || (code_seen(axis_codes[2])));
-      
-      #if Z_HOME_DIR > 0                      // If homing away from BED do Z first
-      if((home_all_axis) || (code_seen(axis_codes[Z_AXIS]))) {
-        HOMEAXIS(Z);
-      }
-      #endif
-      
-      #ifdef QUICK_HOME
-      if((home_all_axis)||( code_seen(axis_codes[X_AXIS]) && code_seen(axis_codes[Y_AXIS])) )  //first diagonal move
-      {
-        current_position[X_AXIS] = 0;current_position[Y_AXIS] = 0;  
-
-        plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]); 
-        destination[X_AXIS] = 1.5 * X_MAX_LENGTH * X_HOME_DIR;destination[Y_AXIS] = 1.5 * Y_MAX_LENGTH * Y_HOME_DIR;  
-        feedrate = homing_feedrate[X_AXIS]; 
-        if(homing_feedrate[Y_AXIS]<feedrate)
-          feedrate =homing_feedrate[Y_AXIS]; 
-        plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
-        st_synchronize();
-    
-        axis_is_at_home(X_AXIS);
-        axis_is_at_home(Y_AXIS);
-        plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
-        destination[X_AXIS] = current_position[X_AXIS];
-        destination[Y_AXIS] = current_position[Y_AXIS];
-        plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
-        feedrate = 0.0;
-        st_synchronize();
-        endstops_hit_on_purpose();
-      }
-      #endif
-      
-      if((home_all_axis) || (code_seen(axis_codes[X_AXIS]))) 
-      {
-        HOMEAXIS(X);
-      }
-
-      if((home_all_axis) || (code_seen(axis_codes[Y_AXIS]))) {
-        HOMEAXIS(Y);
-      }
-      
-      #if Z_HOME_DIR < 0                      // If homing towards BED do Z last
-      if((home_all_axis) || (code_seen(axis_codes[Z_AXIS]))) {
-        HOMEAXIS(Z);
-      }
-      #endif
-      
-      if(code_seen(axis_codes[X_AXIS])) 
-      {
-        if(code_value_long() != 0) {
-          current_position[X_AXIS]=code_value()+add_homeing[0];
-        }
-      }
-
-      if(code_seen(axis_codes[Y_AXIS])) {
-        if(code_value_long() != 0) {
-          current_position[Y_AXIS]=code_value()+add_homeing[1];
-        }
-      }
-
-      if(code_seen(axis_codes[Z_AXIS])) {
-        if(code_value_long() != 0) {
-          current_position[Z_AXIS]=code_value()+add_homeing[2];
-        }
-      }
-      plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
-      
-      #ifdef ENDSTOPS_ONLY_FOR_HOMING
-        enable_endstops(false);
-      #endif
-      
-      feedrate = saved_feedrate;
-      feedmultiply = saved_feedmultiply;
-      previous_millis_cmd = millis();
-      endstops_hit_on_purpose();
-      break;
-    case 90: // G90
-      relative_mode = false;
-      break;
-    case 91: // G91
-      relative_mode = true;
-      break;
-    case 92: // G92
-      if(!code_seen(axis_codes[E_AXIS]))
-        st_synchronize();
-      for(int8_t i=0; i < NUM_AXIS; i++) {
-        if(code_seen(axis_codes[i])) { 
-           if(i == E_AXIS) {
-             current_position[i] = code_value();  
-             plan_set_e_position(current_position[E_AXIS]);
-           }
-           else {
-             current_position[i] = code_value()+add_homeing[i];  
-             plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
-           }
-        }
-      }
-      break;
-    }
-  }
-
-  else if(code_seen('M'))
-  {
-    switch( (int)code_value() ) 
-    {
-#ifdef ULTIPANEL
-    case 0: // M0 - Unconditional stop - Wait for user button press on LCD
-    case 1: // M1 - Conditional stop - Wait for user button press on LCD
-    {
-      LCD_MESSAGEPGM(MSG_USERWAIT);
-      codenum = 0;
-      if(code_seen('P')) codenum = code_value(); // milliseconds to wait
-      if(code_seen('S')) codenum = code_value() * 1000; // seconds to wait
-      
-      st_synchronize();
-      previous_millis_cmd = millis();
-      if (codenum > 0){
-        codenum += millis();  // keep track of when we started waiting
-        while(millis()  < codenum && !LCD_CLICKED){
-          manage_heater();
-          manage_inactivity();
-          lcd_update();
-        }
-      }else{
-        while(!LCD_CLICKED){
-          manage_heater();
-          manage_inactivity();
-          lcd_update();
-        }
-      }
-      LCD_MESSAGEPGM(MSG_RESUMING);
-    }
-    break;
-#endif
-    case 17:
-        LCD_MESSAGEPGM(MSG_NO_MOVE);
-        enable_x(); 
-        enable_y(); 
-        enable_z(); 
-        enable_e0(); 
-        enable_e1(); 
-        enable_e2(); 
-      break;
-
-#ifdef SDSUPPORT
-    case 20: // M20 - list SD card
-      SERIAL_PROTOCOLLNPGM(MSG_BEGIN_FILE_LIST);
-      card.ls();
-      SERIAL_PROTOCOLLNPGM(MSG_END_FILE_LIST);
-      break;
-    case 21: // M21 - init SD card
-      
-      card.initsd();
-      
-      break;
-    case 22: //M22 - release SD card
-      card.release();
-
-      break;
-    case 23: //M23 - Select file
-      starpos = (strchr(strchr_pointer + 4,'*'));
-      if(starpos!=NULL)
-        *(starpos-1)='\0';
-      card.openFile(strchr_pointer + 4,true);
-      break;
-    case 24: //M24 - Start SD print
-      card.startFileprint();
-      starttime=millis();
-      break;
-    case 25: //M25 - Pause SD print
-      card.pauseSDPrint();
-      break;
-    case 26: //M26 - Set SD index
-      if(card.cardOK && code_seen('S')) {
-        card.setIndex(code_value_long());
-      }
-      break;
-    case 27: //M27 - Get SD status
-      card.getStatus();
-      break;
-    case 28: //M28 - Start SD write
-      starpos = (strchr(strchr_pointer + 4,'*'));
-      if(starpos != NULL){
-        char* npos = strchr(cmdbuffer[bufindr], 'N');
-        strchr_pointer = strchr(npos,' ') + 1;
-        *(starpos-1) = '\0';
-      }
-      card.openFile(strchr_pointer+4,false);
-      break;
-    case 29: //M29 - Stop SD write
-      //processed in write to file routine above
-      //card,saving = false;
-      break;
-    case 30: //M30 <filename> Delete File 
-	if (card.cardOK){
-		card.closefile();
-		starpos = (strchr(strchr_pointer + 4,'*'));
-                if(starpos != NULL){
-                char* npos = strchr(cmdbuffer[bufindr], 'N');
-                strchr_pointer = strchr(npos,' ') + 1;
-                *(starpos-1) = '\0';
-         }
-	 card.removeFile(strchr_pointer + 4);
-	}
-	break;
-	
-#endif //SDSUPPORT
-
-    case 31: //M31 take time since the start of the SD print or an M109 command
-      {
-      stoptime=millis();
-      char time[30];
-      unsigned long t=(stoptime-starttime)/1000;
-      int sec,min;
-      min=t/60;
-      sec=t%60;
-      sprintf_P(time, PSTR("%i min, %i sec"), min, sec);
-      SERIAL_ECHO_START;
-      SERIAL_ECHOLN(time);
-      lcd_setstatus(time);
-      autotempShutdown();
-      }
-      break;
-    case 42: //M42 -Change pin status via gcode
-      if (code_seen('S'))
-      {
-        int pin_status = code_value();
-        int pin_number = LED_PIN;
-        if (code_seen('P') && pin_status >= 0 && pin_status <= 255)
-          pin_number = code_value();
-        for(int8_t i = 0; i < (int8_t)sizeof(sensitive_pins); i++)
-        {
-          if (sensitive_pins[i] == pin_number)
-          {
-            pin_number = -1;
-            break;
-          }
-        }
-        if (pin_number > -1)
-        {
-          pinMode(pin_number, OUTPUT);
-          digitalWrite(pin_number, pin_status);
-          analogWrite(pin_number, pin_status);
-        }
-      }
-     break;
-    case 104: // M104
-      if(setTargetedHotend(104)){
-        break;
-      }
-      if (code_seen('S')) setTargetHotend(code_value(), tmp_extruder);
-      setWatch();
-      break;
-    case 140: // M140 set bed temp
-      if (code_seen('S')) setTargetBed(code_value());
-      break;
-    case 105 : // M105
-      if(setTargetedHotend(105)){
-        break;
-      }
-      #if (TEMP_0_PIN > -1)
-        SERIAL_PROTOCOLPGM("ok T:");
-        SERIAL_PROTOCOL_F(degHotend(tmp_extruder),1); 
-        SERIAL_PROTOCOLPGM(" /");
-        SERIAL_PROTOCOL_F(degTargetHotend(tmp_extruder),1); 
-        #if TEMP_BED_PIN > -1
-          SERIAL_PROTOCOLPGM(" B:");  
-          SERIAL_PROTOCOL_F(degBed(),1);
-          SERIAL_PROTOCOLPGM(" /");
-          SERIAL_PROTOCOL_F(degTargetBed(),1);
-        #endif //TEMP_BED_PIN
-      #else
-        SERIAL_ERROR_START;
-        SERIAL_ERRORLNPGM(MSG_ERR_NO_THERMISTORS);
-      #endif
-
-        SERIAL_PROTOCOLPGM(" @:");
-        SERIAL_PROTOCOL(getHeaterPower(tmp_extruder));  
-
-        SERIAL_PROTOCOLPGM(" B@:");
-        SERIAL_PROTOCOL(getHeaterPower(-1));  
-
-        SERIAL_PROTOCOLLN("");
-      return;
-      break;
-    case 109: 
-    {// M109 - Wait for extruder heater to reach target.
-      if(setTargetedHotend(109)){
-        break;
-      }
-      LCD_MESSAGEPGM(MSG_HEATING);   
-      #ifdef AUTOTEMP
-        autotemp_enabled=false;
-      #endif
-      if (code_seen('S')) setTargetHotend(code_value(), tmp_extruder);
-      #ifdef AUTOTEMP
-        if (code_seen('S')) autotemp_min=code_value();
-        if (code_seen('B')) autotemp_max=code_value();
-        if (code_seen('F')) 
-        {
-          autotemp_factor=code_value();
-          autotemp_enabled=true;
-        }
-      #endif
-      
-      setWatch();
-      codenum = millis(); 
-
-      /* See if we are heating up or cooling down */
-      bool target_direction = isHeatingHotend(tmp_extruder); // true if heating, false if cooling
-
-      #ifdef TEMP_RESIDENCY_TIME
-        long residencyStart;
-        residencyStart = -1;
-        /* continue to loop until we have reached the target temp   
-          _and_ until TEMP_RESIDENCY_TIME hasn't passed since we reached it */
-        while((residencyStart == -1) ||
-              (residencyStart >= 0 && (((unsigned int) (millis() - residencyStart)) < (TEMP_RESIDENCY_TIME * 1000UL))) ) {
-      #else
-        while ( target_direction ? (isHeatingHotend(tmp_extruder)) : (isCoolingHotend(tmp_extruder)&&(CooldownNoWait==false)) ) {
-      #endif //TEMP_RESIDENCY_TIME
-          if( (millis() - codenum) > 1000UL )
-          { //Print Temp Reading and remaining time every 1 second while heating up/cooling down
-            SERIAL_PROTOCOLPGM("T:");
-            SERIAL_PROTOCOL_F(degHotend(tmp_extruder),1); 
-            SERIAL_PROTOCOLPGM(" E:");
-            SERIAL_PROTOCOL((int)tmp_extruder); 
-            #ifdef TEMP_RESIDENCY_TIME
-              SERIAL_PROTOCOLPGM(" W:");
-              if(residencyStart > -1)
-              {
-                 codenum = ((TEMP_RESIDENCY_TIME * 1000UL) - (millis() - residencyStart)) / 1000UL;
-                 SERIAL_PROTOCOLLN( codenum );
-              }
-              else 
-              {
-                 SERIAL_PROTOCOLLN( "?" );
-              }
-            #else
-              SERIAL_PROTOCOLLN("");
-            #endif
-            codenum = millis();
-          }
-          manage_heater();
-          manage_inactivity();
-          lcd_update();
-        #ifdef TEMP_RESIDENCY_TIME
-            /* start/restart the TEMP_RESIDENCY_TIME timer whenever we reach target temp for the first time
-              or when current temp falls outside the hysteresis after target temp was reached */
-          if ((residencyStart == -1 &&  target_direction && (degHotend(tmp_extruder) >= (degTargetHotend(tmp_extruder)-TEMP_WINDOW))) ||
-              (residencyStart == -1 && !target_direction && (degHotend(tmp_extruder) <= (degTargetHotend(tmp_extruder)+TEMP_WINDOW))) ||
-              (residencyStart > -1 && labs(degHotend(tmp_extruder) - degTargetHotend(tmp_extruder)) > TEMP_HYSTERESIS) ) 
-          {
-            residencyStart = millis();
-          }
-        #endif //TEMP_RESIDENCY_TIME
-        }
-        LCD_MESSAGEPGM(MSG_HEATING_COMPLETE);
-        starttime=millis();
-        previous_millis_cmd = millis();
-      }
-      break;
-    case 190: // M190 - Wait for bed heater to reach target.
-    #if TEMP_BED_PIN > -1
-        LCD_MESSAGEPGM(MSG_BED_HEATING);
-        if (code_seen('S')) setTargetBed(code_value());
-        codenum = millis(); 
-        while(isHeatingBed()) 
-        {
-          if(( millis() - codenum) > 1000 ) //Print Temp Reading every 1 second while heating up.
-          {
-            float tt=degHotend(active_extruder);
-            SERIAL_PROTOCOLPGM("T:");
-            SERIAL_PROTOCOL(tt);
-            SERIAL_PROTOCOLPGM(" E:");
-            SERIAL_PROTOCOL((int)active_extruder); 
-            SERIAL_PROTOCOLPGM(" B:");
-            SERIAL_PROTOCOL_F(degBed(),1); 
-            SERIAL_PROTOCOLLN(""); 
-            codenum = millis(); 
-          }
-          manage_heater();
-          manage_inactivity();
-          lcd_update();
-        }
-        LCD_MESSAGEPGM(MSG_BED_DONE);
-        previous_millis_cmd = millis();
-    #endif
-        break;
-
-    #if FAN_PIN > -1
-      case 106: //M106 Fan On
-        if (code_seen('S')){
-           fanSpeed=constrain(code_value(),0,255);
-        }
-        else {
-          fanSpeed=255;			
-        }
-        break;
-      case 107: //M107 Fan Off
-        fanSpeed = 0;
-        break;
-    #endif //FAN_PIN
-
-    #if (PS_ON_PIN > -1)
-      case 80: // M80 - ATX Power On
-        SET_OUTPUT(PS_ON_PIN); //GND
-        WRITE(PS_ON_PIN, PS_ON_AWAKE);
-        break;
-      #endif
-      
-      case 81: // M81 - ATX Power Off
-      
-      #if defined SUICIDE_PIN && SUICIDE_PIN > -1
-        st_synchronize();
-        suicide();
-      #elif (PS_ON_PIN > -1)
-        SET_OUTPUT(PS_ON_PIN); 
-        WRITE(PS_ON_PIN, PS_ON_ASLEEP);
-      #endif
-		break;
-        
-    case 82:
-      axis_relative_modes[3] = false;
-      break;
-    case 83:
-      axis_relative_modes[3] = true;
-      break;
-    case 18: //compatibility
-    case 84: // M84
-      if(code_seen('S')){ 
-        stepper_inactive_time = code_value() * 1000; 
-      }
-      else
-      { 
-        bool all_axis = !((code_seen(axis_codes[0])) || (code_seen(axis_codes[1])) || (code_seen(axis_codes[2]))|| (code_seen(axis_codes[3])));
-        if(all_axis)
-        {
-          st_synchronize();
-          disable_e0();
-          disable_e1();
-          disable_e2();
-          finishAndDisableSteppers();
-        }
-        else
-        {
-          st_synchronize();
-          if(code_seen('X')) disable_x();
-          if(code_seen('Y')) disable_y();
-          if(code_seen('Z')) disable_z();
-          #if ((E0_ENABLE_PIN != X_ENABLE_PIN) && (E1_ENABLE_PIN != Y_ENABLE_PIN)) // Only enable on boards that have seperate ENABLE_PINS
-            if(code_seen('E')) {
-              disable_e0();
-              disable_e1();
-              disable_e2();
-            }
-          #endif 
-        }
-      }
-      break;
-    case 85: // M85
-      code_seen('S');
-      max_inactive_time = code_value() * 1000; 
-      break;
-    case 92: // M92
-      for(int8_t i=0; i < NUM_AXIS; i++) 
-      {
-        if(code_seen(axis_codes[i])) 
-        {
-          if(i == 3) { // E
-            float value = code_value();
-            if(value < 20.0) {
-              float factor = axis_steps_per_unit[i] / value; // increase e constants if M92 E14 is given for netfab.
-              max_e_jerk *= factor;
-              max_feedrate[i] *= factor;
-              axis_steps_per_sqr_second[i] *= factor;
-            }
-            axis_steps_per_unit[i] = value;
-          }
-          else {
-            axis_steps_per_unit[i] = code_value();
-          }
-        }
-      }
-      break;
-    case 115: // M115
-      SERIAL_PROTOCOLPGM(MSG_M115_REPORT);
-      break;
-    case 117: // M117 display message
-      starpos = (strchr(strchr_pointer + 5,'*'));
-      if(starpos!=NULL)
-        *(starpos-1)='\0';
-      lcd_setstatus(strchr_pointer + 5);
-      break;
-    case 114: // M114
-      SERIAL_PROTOCOLPGM("X:");
-      SERIAL_PROTOCOL(current_position[X_AXIS]);
-      SERIAL_PROTOCOLPGM("Y:");
-      SERIAL_PROTOCOL(current_position[Y_AXIS]);
-      SERIAL_PROTOCOLPGM("Z:");
-      SERIAL_PROTOCOL(current_position[Z_AXIS]);
-      SERIAL_PROTOCOLPGM("E:");      
-      SERIAL_PROTOCOL(current_position[E_AXIS]);
-      
-      SERIAL_PROTOCOLPGM(MSG_COUNT_X);
-      SERIAL_PROTOCOL(float(st_get_position(X_AXIS))/axis_steps_per_unit[X_AXIS]);
-      SERIAL_PROTOCOLPGM("Y:");
-      SERIAL_PROTOCOL(float(st_get_position(Y_AXIS))/axis_steps_per_unit[Y_AXIS]);
-      SERIAL_PROTOCOLPGM("Z:");
-      SERIAL_PROTOCOL(float(st_get_position(Z_AXIS))/axis_steps_per_unit[Z_AXIS]);
-      
-      SERIAL_PROTOCOLLN("");
-      break;
-    case 120: // M120
-      enable_endstops(false) ;
-      break;
-    case 121: // M121
-      enable_endstops(true) ;
-      break;
-    case 119: // M119
-    SERIAL_PROTOCOLLN(MSG_M119_REPORT);
-      #if (X_MIN_PIN > -1)
-        SERIAL_PROTOCOLPGM(MSG_X_MIN);
-        SERIAL_PROTOCOLLN(((READ(X_MIN_PIN)^X_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
-      #endif
-      #if (X_MAX_PIN > -1)
-        SERIAL_PROTOCOLPGM(MSG_X_MAX);
-        SERIAL_PROTOCOLLN(((READ(X_MAX_PIN)^X_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
-      #endif
-      #if (Y_MIN_PIN > -1)
-        SERIAL_PROTOCOLPGM(MSG_Y_MIN);
-        SERIAL_PROTOCOLLN(((READ(Y_MIN_PIN)^Y_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
-      #endif
-      #if (Y_MAX_PIN > -1)
-        SERIAL_PROTOCOLPGM(MSG_Y_MAX);
-        SERIAL_PROTOCOLLN(((READ(Y_MAX_PIN)^Y_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
-      #endif
-      #if (Z_MIN_PIN > -1)
-        SERIAL_PROTOCOLPGM(MSG_Z_MIN);
-        SERIAL_PROTOCOLLN(((READ(Z_MIN_PIN)^Z_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
-      #endif
-      #if (Z_MAX_PIN > -1)
-        SERIAL_PROTOCOLPGM(MSG_Z_MAX);
-        SERIAL_PROTOCOLLN(((READ(Z_MAX_PIN)^Z_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
-      #endif
-      break;
-      //TODO: update for all axis, use for loop
-    case 201: // M201
-      for(int8_t i=0; i < NUM_AXIS; i++) 
-      {
-        if(code_seen(axis_codes[i]))
-        {
-          max_acceleration_units_per_sq_second[i] = code_value();
-          axis_steps_per_sqr_second[i] = code_value() * axis_steps_per_unit[i];
-        }
-      }
-      break;
-    #if 0 // Not used for Sprinter/grbl gen6
-    case 202: // M202
-      for(int8_t i=0; i < NUM_AXIS; i++) {
-        if(code_seen(axis_codes[i])) axis_travel_steps_per_sqr_second[i] = code_value() * axis_steps_per_unit[i];
-      }
-      break;
-    #endif
-    case 203: // M203 max feedrate mm/sec
-      for(int8_t i=0; i < NUM_AXIS; i++) {
-        if(code_seen(axis_codes[i])) max_feedrate[i] = code_value();
-      }
-      break;
-    case 204: // M204 acclereration S normal moves T filmanent only moves
-      {
-        if(code_seen('S')) acceleration = code_value() ;
-        if(code_seen('T')) retract_acceleration = code_value() ;
-      }
-      break;
-    case 205: //M205 advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk
-    {
-      if(code_seen('S')) minimumfeedrate = code_value();
-      if(code_seen('T')) mintravelfeedrate = code_value();
-      if(code_seen('B')) minsegmenttime = code_value() ;
-      if(code_seen('X')) max_xy_jerk = code_value() ;
-      if(code_seen('Z')) max_z_jerk = code_value() ;
-      if(code_seen('E')) max_e_jerk = code_value() ;
-    }
-    break;
-    case 206: // M206 additional homeing offset
-      for(int8_t i=0; i < 3; i++) 
-      {
-        if(code_seen(axis_codes[i])) add_homeing[i] = code_value();
-      }
-      break;
-    #ifdef FWRETRACT
-    case 207: //M207 - set retract length S[positive mm] F[feedrate mm/sec] Z[additional zlift/hop]
-    {
-      if(code_seen('S')) 
-      {
-        retract_length = code_value() ;
-      }
-      if(code_seen('F')) 
-      {
-        retract_feedrate = code_value() ;
-      }
-      if(code_seen('Z')) 
-      {
-        retract_zlift = code_value() ;
-      }
-    }break;
-    case 208: // M208 - set retract recover length S[positive mm surplus to the M207 S*] F[feedrate mm/sec]
-    {
-      if(code_seen('S')) 
-      {
-        retract_recover_length = code_value() ;
-      }
-      if(code_seen('F')) 
-      {
-        retract_recover_feedrate = code_value() ;
-      }
-    }break;
-    case 209: // M209 - S<1=true/0=false> enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.
-    {
-      if(code_seen('S')) 
-      {
-        int t= code_value() ;
-        switch(t)
-        {
-          case 0: autoretract_enabled=false;retracted=false;break;
-          case 1: autoretract_enabled=true;retracted=false;break;
-          default: 
-            SERIAL_ECHO_START;
-            SERIAL_ECHOPGM(MSG_UNKNOWN_COMMAND);
-            SERIAL_ECHO(cmdbuffer[bufindr]);
-            SERIAL_ECHOLNPGM("\"");
-        }
-      }
-      
-    }break;
+#endif
+uint8_t active_extruder = 0;
+int fanSpeed=0;
+
+#ifdef FWRETRACT
+  bool autoretract_enabled=true;
+  bool retracted=false;
+  float retract_length=3, retract_feedrate=17*60, retract_zlift=0.8;
+  float retract_recover_length=0, retract_recover_feedrate=8*60;
+#endif
+
+//===========================================================================
+//=============================private variables=============================
+//===========================================================================
+const char axis_codes[NUM_AXIS] = {'X', 'Y', 'Z', 'E'};
+static float destination[NUM_AXIS] = {  0.0, 0.0, 0.0, 0.0};
+static float offset[3] = {0.0, 0.0, 0.0};
+static bool home_all_axis = true;
+static float feedrate = 1500.0, next_feedrate, saved_feedrate;
+static long gcode_N, gcode_LastN, Stopped_gcode_LastN = 0;
+
+static bool relative_mode = false;  //Determines Absolute or Relative Coordinates
+
+static char cmdbuffer[BUFSIZE][MAX_CMD_SIZE];
+static bool fromsd[BUFSIZE];
+static int bufindr = 0;
+static int bufindw = 0;
+static int buflen = 0;
+//static int i = 0;
+static char serial_char;
+static int serial_count = 0;
+static boolean comment_mode = false;
+static char *strchr_pointer; // just a pointer to find chars in the cmd string like X, Y, Z, E, etc
+
+const int sensitive_pins[] = SENSITIVE_PINS; // Sensitive pin list for M42
+
+//static float tt = 0;
+//static float bt = 0;
+
+//Inactivity shutdown variables
+static unsigned long previous_millis_cmd = 0;
+static unsigned long max_inactive_time = 0;
+static unsigned long stepper_inactive_time = DEFAULT_STEPPER_DEACTIVE_TIME*1000l;
+
+unsigned long starttime=0;
+unsigned long stoptime=0;
+
+static uint8_t tmp_extruder;
+
+
+bool Stopped=false;
+
+//===========================================================================
+//=============================ROUTINES=============================
+//===========================================================================
+
+void get_arc_coordinates();
+bool setTargetedHotend(int code);
+
+void serial_echopair_P(const char *s_P, float v)
+    { serialprintPGM(s_P); SERIAL_ECHO(v); }
+void serial_echopair_P(const char *s_P, double v)
+    { serialprintPGM(s_P); SERIAL_ECHO(v); }
+void serial_echopair_P(const char *s_P, unsigned long v)
+    { serialprintPGM(s_P); SERIAL_ECHO(v); }
+
+extern "C"{
+  extern unsigned int __bss_end;
+  extern unsigned int __heap_start;
+  extern void *__brkval;
+
+  int freeMemory() {
+    int free_memory;
+
+    if((int)__brkval == 0)
+      free_memory = ((int)&free_memory) - ((int)&__bss_end);
+    else
+      free_memory = ((int)&free_memory) - ((int)__brkval);
+
+    return free_memory;
+  }
+}
+
+//adds an command to the main command buffer
+//thats really done in a non-safe way.
+//needs overworking someday
+void enquecommand(const char *cmd)
+{
+  if(buflen < BUFSIZE)
+  {
+    //this is dangerous if a mixing of serial and this happsens
+    strcpy(&(cmdbuffer[bufindw][0]),cmd);
+    SERIAL_ECHO_START;
+    SERIAL_ECHOPGM("enqueing \"");
+    SERIAL_ECHO(cmdbuffer[bufindw]);
+    SERIAL_ECHOLNPGM("\"");
+    bufindw= (bufindw + 1)%BUFSIZE;
+    buflen += 1;
+  }
+}
+
+void enquecommand_P(const char *cmd)
+{
+  if(buflen < BUFSIZE)
+  {
+    //this is dangerous if a mixing of serial and this happsens
+    strcpy_P(&(cmdbuffer[bufindw][0]),cmd);
+    SERIAL_ECHO_START;
+    SERIAL_ECHOPGM("enqueing \"");
+    SERIAL_ECHO(cmdbuffer[bufindw]);
+    SERIAL_ECHOLNPGM("\"");
+    bufindw= (bufindw + 1)%BUFSIZE;
+    buflen += 1;
+  }
+}
+
+void setup_killpin()
+{
+  #if( KILL_PIN>-1 )
+    pinMode(KILL_PIN,INPUT);
+    WRITE(KILL_PIN,HIGH);
+  #endif
+}
+    
+void setup_photpin()
+{
+  #ifdef PHOTOGRAPH_PIN
+    #if (PHOTOGRAPH_PIN > -1)
+    SET_OUTPUT(PHOTOGRAPH_PIN);
+    WRITE(PHOTOGRAPH_PIN, LOW);
+    #endif
+  #endif 
+}
+
+void setup_powerhold()
+{
+ #ifdef SUICIDE_PIN
+   #if (SUICIDE_PIN> -1)
+      SET_OUTPUT(SUICIDE_PIN);
+      WRITE(SUICIDE_PIN, HIGH);
+   #endif
+ #endif
+ #if (PS_ON_PIN > -1)
+   SET_OUTPUT(PS_ON_PIN);
+   WRITE(PS_ON_PIN, PS_ON_AWAKE);
+ #endif
+}
+
+void suicide()
+{
+ #ifdef SUICIDE_PIN
+    #if (SUICIDE_PIN> -1) 
+      SET_OUTPUT(SUICIDE_PIN);
+      WRITE(SUICIDE_PIN, LOW);
+    #endif
+  #endif
+}
+
+void setup()
+{
+  setup_killpin(); 
+  setup_powerhold();
+  MYSERIAL.begin(BAUDRATE);
+  SERIAL_PROTOCOLLNPGM("start");
+  SERIAL_ECHO_START;
+
+  // Check startup - does nothing if bootloader sets MCUSR to 0
+  byte mcu = MCUSR;
+  if(mcu & 1) SERIAL_ECHOLNPGM(MSG_POWERUP);
+  if(mcu & 2) SERIAL_ECHOLNPGM(MSG_EXTERNAL_RESET);
+  if(mcu & 4) SERIAL_ECHOLNPGM(MSG_BROWNOUT_RESET);
+  if(mcu & 8) SERIAL_ECHOLNPGM(MSG_WATCHDOG_RESET);
+  if(mcu & 32) SERIAL_ECHOLNPGM(MSG_SOFTWARE_RESET);
+  MCUSR=0;
+
+  SERIAL_ECHOPGM(MSG_MARLIN);
+  SERIAL_ECHOLNPGM(VERSION_STRING);
+  #ifdef STRING_VERSION_CONFIG_H
+    #ifdef STRING_CONFIG_H_AUTHOR
+      SERIAL_ECHO_START;
+      SERIAL_ECHOPGM(MSG_CONFIGURATION_VER);
+      SERIAL_ECHOPGM(STRING_VERSION_CONFIG_H);
+      SERIAL_ECHOPGM(MSG_AUTHOR);
+      SERIAL_ECHOLNPGM(STRING_CONFIG_H_AUTHOR);
+      SERIAL_ECHOPGM("Compiled: ");
+      SERIAL_ECHOLNPGM(__DATE__);
+    #endif
+  #endif
+  SERIAL_ECHO_START;
+  SERIAL_ECHOPGM(MSG_FREE_MEMORY);
+  SERIAL_ECHO(freeMemory());
+  SERIAL_ECHOPGM(MSG_PLANNER_BUFFER_BYTES);
+  SERIAL_ECHOLN((int)sizeof(block_t)*BLOCK_BUFFER_SIZE);
+  for(int8_t i = 0; i < BUFSIZE; i++)
+  {
+    fromsd[i] = false;
+  }
+  
+  Config_RetrieveSettings(); // loads data from EEPROM if available
+
+  for(int8_t i=0; i < NUM_AXIS; i++)
+  {
+    axis_steps_per_sqr_second[i] = max_acceleration_units_per_sq_second[i] * axis_steps_per_unit[i];
+  }
+
+
+  tp_init();    // Initialize temperature loop 
+  plan_init();  // Initialize planner;
+  watchdog_init();
+  st_init();    // Initialize stepper, this enables interrupts!
+  setup_photpin();
+  
+  lcd_init();
+  
+  #ifdef CONTROLLERFAN_PIN
+    SET_OUTPUT(CONTROLLERFAN_PIN); //Set pin used for driver cooling fan
+  #endif
+  
+  #ifdef EXTRUDERFAN_PIN
+    SET_OUTPUT(EXTRUDERFAN_PIN); //Set pin used for extruder cooling fan
+  #endif
+}
+
+
+void loop()
+{
+  if(buflen < (BUFSIZE-1))
+    get_command();
+  #ifdef SDSUPPORT
+  card.checkautostart(false);
+  #endif
+  if(buflen)
+  {
+    #ifdef SDSUPPORT
+      if(card.saving)
+      {
+	if(strstr_P(cmdbuffer[bufindr], PSTR("M29")) == NULL)
+	{
+	  card.write_command(cmdbuffer[bufindr]);
+	  SERIAL_PROTOCOLLNPGM(MSG_OK);
+	}
+	else
+	{
+	  card.closefile();
+	  SERIAL_PROTOCOLLNPGM(MSG_FILE_SAVED);
+	}
+      }
+      else
+      {
+	process_commands();
+      }
+    #else
+      process_commands();
+    #endif //SDSUPPORT
+    buflen = (buflen-1);
+    bufindr = (bufindr + 1)%BUFSIZE;
+  }
+  //check heater every n milliseconds
+  manage_heater();
+  manage_inactivity();
+  checkHitEndstops();
+  lcd_update();
+}
+
+void get_command() 
+{ 
+  while( MYSERIAL.available() > 0  && buflen < BUFSIZE) {
+    serial_char = MYSERIAL.read();
+    if(serial_char == '\n' || 
+       serial_char == '\r' || 
+       (serial_char == ':' && comment_mode == false) || 
+       serial_count >= (MAX_CMD_SIZE - 1) ) 
+    {
+      if(!serial_count) { //if empty line
+        comment_mode = false; //for new command
+        return;
+      }
+      cmdbuffer[bufindw][serial_count] = 0; //terminate string
+      if(!comment_mode){
+        comment_mode = false; //for new command
+        fromsd[bufindw] = false;
+        if(strchr(cmdbuffer[bufindw], 'N') != NULL)
+        {
+          strchr_pointer = strchr(cmdbuffer[bufindw], 'N');
+          gcode_N = (strtol(&cmdbuffer[bufindw][strchr_pointer - cmdbuffer[bufindw] + 1], NULL, 10));
+          if(gcode_N != gcode_LastN+1 && (strstr_P(cmdbuffer[bufindw], PSTR("M110")) == NULL) ) {
+            SERIAL_ERROR_START;
+            SERIAL_ERRORPGM(MSG_ERR_LINE_NO);
+            SERIAL_ERRORLN(gcode_LastN);
+            //Serial.println(gcode_N);
+            FlushSerialRequestResend();
+            serial_count = 0;
+            return;
+          }
+
+          if(strchr(cmdbuffer[bufindw], '*') != NULL)
+          {
+            byte checksum = 0;
+            byte count = 0;
+            while(cmdbuffer[bufindw][count] != '*') checksum = checksum^cmdbuffer[bufindw][count++];
+            strchr_pointer = strchr(cmdbuffer[bufindw], '*');
+
+            if( (int)(strtod(&cmdbuffer[bufindw][strchr_pointer - cmdbuffer[bufindw] + 1], NULL)) != checksum) {
+              SERIAL_ERROR_START;
+              SERIAL_ERRORPGM(MSG_ERR_CHECKSUM_MISMATCH);
+              SERIAL_ERRORLN(gcode_LastN);
+              FlushSerialRequestResend();
+              serial_count = 0;
+              return;
+            }
+            //if no errors, continue parsing
+          }
+          else 
+          {
+            SERIAL_ERROR_START;
+            SERIAL_ERRORPGM(MSG_ERR_NO_CHECKSUM);
+            SERIAL_ERRORLN(gcode_LastN);
+            FlushSerialRequestResend();
+            serial_count = 0;
+            return;
+          }
+
+          gcode_LastN = gcode_N;
+          //if no errors, continue parsing
+        }
+        else  // if we don't receive 'N' but still see '*'
+        {
+          if((strchr(cmdbuffer[bufindw], '*') != NULL))
+          {
+            SERIAL_ERROR_START;
+            SERIAL_ERRORPGM(MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM);
+            SERIAL_ERRORLN(gcode_LastN);
+            serial_count = 0;
+            return;
+          }
+        }
+        if((strchr(cmdbuffer[bufindw], 'G') != NULL)){
+          strchr_pointer = strchr(cmdbuffer[bufindw], 'G');
+          switch((int)((strtod(&cmdbuffer[bufindw][strchr_pointer - cmdbuffer[bufindw] + 1], NULL)))){
+          case 0:
+          case 1:
+          case 2:
+          case 3:
+            if(Stopped == false) { // If printer is stopped by an error the G[0-3] codes are ignored.
+	      #ifdef SDSUPPORT
+              if(card.saving)
+                break;
+	      #endif //SDSUPPORT
+              SERIAL_PROTOCOLLNPGM(MSG_OK); 
+            }
+            else {
+              SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
+              LCD_MESSAGEPGM(MSG_STOPPED);
+            }
+            break;
+          default:
+            break;
+          }
+
+        }
+        bufindw = (bufindw + 1)%BUFSIZE;
+        buflen += 1;
+      }
+      serial_count = 0; //clear buffer
+    }
+    else
+    {
+      if(serial_char == ';') comment_mode = true;
+      if(!comment_mode) cmdbuffer[bufindw][serial_count++] = serial_char;
+    }
+  }
+  #ifdef SDSUPPORT
+  if(!card.sdprinting || serial_count!=0){
+    return;
+  }
+  while( !card.eof()  && buflen < BUFSIZE) {
+    int16_t n=card.get();
+    serial_char = (char)n;
+    if(serial_char == '\n' || 
+       serial_char == '\r' || 
+       (serial_char == ':' && comment_mode == false) || 
+       serial_count >= (MAX_CMD_SIZE - 1)||n==-1) 
+    {
+      if(card.eof()){
+        SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);
+        stoptime=millis();
+        char time[30];
+        unsigned long t=(stoptime-starttime)/1000;
+        int hours, minutes;
+        minutes=(t/60)%60;
+        hours=t/60/60;
+        sprintf_P(time, PSTR("%i hours %i minutes"),hours, minutes);
+        SERIAL_ECHO_START;
+        SERIAL_ECHOLN(time);
+        lcd_setstatus(time);
+        card.printingHasFinished();
+        card.checkautostart(true);
+        
+      }
+      if(!serial_count)
+      {
+        comment_mode = false; //for new command
+        return; //if empty line
+      }
+      cmdbuffer[bufindw][serial_count] = 0; //terminate string
+//      if(!comment_mode){
+        fromsd[bufindw] = true;
+        buflen += 1;
+        bufindw = (bufindw + 1)%BUFSIZE;
+//      }     
+      comment_mode = false; //for new command
+      serial_count = 0; //clear buffer
+    }
+    else
+    {
+      if(serial_char == ';') comment_mode = true;
+      if(!comment_mode) cmdbuffer[bufindw][serial_count++] = serial_char;
+    }
+  }
+  
+  #endif //SDSUPPORT
+
+}
+
+
+float code_value() 
+{ 
+  return (strtod(&cmdbuffer[bufindr][strchr_pointer - cmdbuffer[bufindr] + 1], NULL)); 
+}
+
+long code_value_long() 
+{ 
+  return (strtol(&cmdbuffer[bufindr][strchr_pointer - cmdbuffer[bufindr] + 1], NULL, 10)); 
+}
+
+bool code_seen(char code)
+{
+  strchr_pointer = strchr(cmdbuffer[bufindr], code);
+  return (strchr_pointer != NULL);  //Return True if a character was found
+}
+
+#define DEFINE_PGM_READ_ANY(type, reader)		\
+    static inline type pgm_read_any(const type *p)	\
+	{ return pgm_read_##reader##_near(p); }
+
+DEFINE_PGM_READ_ANY(float,       float);
+DEFINE_PGM_READ_ANY(signed char, byte);
+
+#define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG)	\
+static const PROGMEM type array##_P[3] =		\
+    { X_##CONFIG, Y_##CONFIG, Z_##CONFIG };		\
+static inline type array(int axis)			\
+    { return pgm_read_any(&array##_P[axis]); }
+
+XYZ_CONSTS_FROM_CONFIG(float, base_min_pos,    MIN_POS);
+XYZ_CONSTS_FROM_CONFIG(float, base_max_pos,    MAX_POS);
+XYZ_CONSTS_FROM_CONFIG(float, base_home_pos,   HOME_POS);
+XYZ_CONSTS_FROM_CONFIG(float, max_length,      MAX_LENGTH);
+XYZ_CONSTS_FROM_CONFIG(float, home_retract_mm, HOME_RETRACT_MM);
+XYZ_CONSTS_FROM_CONFIG(signed char, home_dir,  HOME_DIR);
+
+static void axis_is_at_home(int axis) {
+  current_position[axis] = base_home_pos(axis) + add_homeing[axis];
+  min_pos[axis] =          base_min_pos(axis) + add_homeing[axis];
+  max_pos[axis] =          base_max_pos(axis) + add_homeing[axis];
+}
+
+static void homeaxis(int axis) {
+#define HOMEAXIS_DO(LETTER) \
+  ((LETTER##_MIN_PIN > -1 && LETTER##_HOME_DIR==-1) || (LETTER##_MAX_PIN > -1 && LETTER##_HOME_DIR==1))
+
+  if (axis==X_AXIS ? HOMEAXIS_DO(X) :
+      axis==Y_AXIS ? HOMEAXIS_DO(Y) :
+      axis==Z_AXIS ? HOMEAXIS_DO(Z) :
+      0) {
+    current_position[axis] = 0;
+    plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+    destination[axis] = 1.5 * max_length(axis) * home_dir(axis);
+    feedrate = homing_feedrate[axis];
+    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
+    st_synchronize();
+   
+    current_position[axis] = 0;
+    plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+    destination[axis] = -home_retract_mm(axis) * home_dir(axis);
+    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
+    st_synchronize();
+   
+    destination[axis] = 2*home_retract_mm(axis) * home_dir(axis);
+    feedrate = homing_feedrate[axis]/2 ; 
+    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
+    st_synchronize();
+   
+    axis_is_at_home(axis);					
+    destination[axis] = current_position[axis];
+    feedrate = 0.0;
+    endstops_hit_on_purpose();
+  }
+}
+#define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)
+
+void process_commands()
+{
+  unsigned long codenum; //throw away variable
+  char *starpos = NULL;
+
+  if(code_seen('G'))
+  {
+    switch((int)code_value())
+    {
+    case 0: // G0 -> G1
+    case 1: // G1
+      if(Stopped == false) {
+        get_coordinates(); // For X Y Z E F
+        prepare_move();
+        //ClearToSend();
+        return;
+      }
+      //break;
+    case 2: // G2  - CW ARC
+      if(Stopped == false) {
+        get_arc_coordinates();
+        prepare_arc_move(true);
+        return;
+      }
+    case 3: // G3  - CCW ARC
+      if(Stopped == false) {
+        get_arc_coordinates();
+        prepare_arc_move(false);
+        return;
+      }
+    case 4: // G4 dwell
+      LCD_MESSAGEPGM(MSG_DWELL);
+      codenum = 0;
+      if(code_seen('P')) codenum = code_value(); // milliseconds to wait
+      if(code_seen('S')) codenum = code_value() * 1000; // seconds to wait
+      
+      st_synchronize();
+      codenum += millis();  // keep track of when we started waiting
+      previous_millis_cmd = millis();
+      while(millis()  < codenum ){
+        manage_heater();
+        manage_inactivity();
+        lcd_update();
+      }
+      break;
+      #ifdef FWRETRACT  
+      case 10: // G10 retract
+      if(!retracted) 
+      {
+        destination[X_AXIS]=current_position[X_AXIS];
+        destination[Y_AXIS]=current_position[Y_AXIS];
+        destination[Z_AXIS]=current_position[Z_AXIS]; 
+        current_position[Z_AXIS]+=-retract_zlift;
+        destination[E_AXIS]=current_position[E_AXIS]-retract_length; 
+        feedrate=retract_feedrate;
+        retracted=true;
+        prepare_move();
+      }
+      
+      break;
+      case 11: // G10 retract_recover
+      if(!retracted) 
+      {
+        destination[X_AXIS]=current_position[X_AXIS];
+        destination[Y_AXIS]=current_position[Y_AXIS];
+        destination[Z_AXIS]=current_position[Z_AXIS]; 
+        
+        current_position[Z_AXIS]+=retract_zlift;
+        current_position[E_AXIS]+=-retract_recover_length; 
+        feedrate=retract_recover_feedrate;
+        retracted=false;
+        prepare_move();
+      }
+      break;
+      #endif //FWRETRACT
+    case 28: //G28 Home all Axis one at a time
+      saved_feedrate = feedrate;
+      saved_feedmultiply = feedmultiply;
+      feedmultiply = 100;
+      previous_millis_cmd = millis();
+      
+      enable_endstops(true);
+      
+      for(int8_t i=0; i < NUM_AXIS; i++) {
+        destination[i] = current_position[i];
+      }
+      feedrate = 0.0;
+      home_all_axis = !((code_seen(axis_codes[0])) || (code_seen(axis_codes[1])) || (code_seen(axis_codes[2])));
+      
+      #if Z_HOME_DIR > 0                      // If homing away from BED do Z first
+      if((home_all_axis) || (code_seen(axis_codes[Z_AXIS]))) {
+        HOMEAXIS(Z);
+      }
+      #endif
+      
+      #ifdef QUICK_HOME
+      if((home_all_axis)||( code_seen(axis_codes[X_AXIS]) && code_seen(axis_codes[Y_AXIS])) )  //first diagonal move
+      {
+        current_position[X_AXIS] = 0;current_position[Y_AXIS] = 0;  
+
+        plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]); 
+        destination[X_AXIS] = 1.5 * X_MAX_LENGTH * X_HOME_DIR;destination[Y_AXIS] = 1.5 * Y_MAX_LENGTH * Y_HOME_DIR;  
+        feedrate = homing_feedrate[X_AXIS]; 
+        if(homing_feedrate[Y_AXIS]<feedrate)
+          feedrate =homing_feedrate[Y_AXIS]; 
+        plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
+        st_synchronize();
+    
+        axis_is_at_home(X_AXIS);
+        axis_is_at_home(Y_AXIS);
+        plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+        destination[X_AXIS] = current_position[X_AXIS];
+        destination[Y_AXIS] = current_position[Y_AXIS];
+        plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
+        feedrate = 0.0;
+        st_synchronize();
+        endstops_hit_on_purpose();
+      }
+      #endif
+      
+      if((home_all_axis) || (code_seen(axis_codes[X_AXIS]))) 
+      {
+        HOMEAXIS(X);
+      }
+
+      if((home_all_axis) || (code_seen(axis_codes[Y_AXIS]))) {
+        HOMEAXIS(Y);
+      }
+      
+      #if Z_HOME_DIR < 0                      // If homing towards BED do Z last
+      if((home_all_axis) || (code_seen(axis_codes[Z_AXIS]))) {
+        HOMEAXIS(Z);
+      }
+      #endif
+      
+      if(code_seen(axis_codes[X_AXIS])) 
+      {
+        if(code_value_long() != 0) {
+          current_position[X_AXIS]=code_value()+add_homeing[0];
+        }
+      }
+
+      if(code_seen(axis_codes[Y_AXIS])) {
+        if(code_value_long() != 0) {
+          current_position[Y_AXIS]=code_value()+add_homeing[1];
+        }
+      }
+
+      if(code_seen(axis_codes[Z_AXIS])) {
+        if(code_value_long() != 0) {
+          current_position[Z_AXIS]=code_value()+add_homeing[2];
+        }
+      }
+      plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+      
+      #ifdef ENDSTOPS_ONLY_FOR_HOMING
+        enable_endstops(false);
+      #endif
+      
+      feedrate = saved_feedrate;
+      feedmultiply = saved_feedmultiply;
+      previous_millis_cmd = millis();
+      endstops_hit_on_purpose();
+      break;
+    case 90: // G90
+      relative_mode = false;
+      break;
+    case 91: // G91
+      relative_mode = true;
+      break;
+    case 92: // G92
+      if(!code_seen(axis_codes[E_AXIS]))
+        st_synchronize();
+      for(int8_t i=0; i < NUM_AXIS; i++) {
+        if(code_seen(axis_codes[i])) { 
+           if(i == E_AXIS) {
+             current_position[i] = code_value();  
+             plan_set_e_position(current_position[E_AXIS]);
+           }
+           else {
+             current_position[i] = code_value()+add_homeing[i];  
+             plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+           }
+        }
+      }
+      break;
+    }
+  }
+
+  else if(code_seen('M'))
+  {
+    switch( (int)code_value() ) 
+    {
+#ifdef ULTIPANEL
+    case 0: // M0 - Unconditional stop - Wait for user button press on LCD
+    case 1: // M1 - Conditional stop - Wait for user button press on LCD
+    {
+      LCD_MESSAGEPGM(MSG_USERWAIT);
+      codenum = 0;
+      if(code_seen('P')) codenum = code_value(); // milliseconds to wait
+      if(code_seen('S')) codenum = code_value() * 1000; // seconds to wait
+      
+      st_synchronize();
+      previous_millis_cmd = millis();
+      if (codenum > 0){
+        codenum += millis();  // keep track of when we started waiting
+        while(millis()  < codenum && !LCD_CLICKED){
+          manage_heater();
+          manage_inactivity();
+          lcd_update();
+        }
+      }else{
+        while(!LCD_CLICKED){
+          manage_heater();
+          manage_inactivity();
+          lcd_update();
+        }
+      }
+      LCD_MESSAGEPGM(MSG_RESUMING);
+    }
+    break;
+#endif
+    case 17:
+        LCD_MESSAGEPGM(MSG_NO_MOVE);
+        enable_x(); 
+        enable_y(); 
+        enable_z(); 
+        enable_e0(); 
+        enable_e1(); 
+        enable_e2(); 
+      break;
+
+#ifdef SDSUPPORT
+    case 20: // M20 - list SD card
+      SERIAL_PROTOCOLLNPGM(MSG_BEGIN_FILE_LIST);
+      card.ls();
+      SERIAL_PROTOCOLLNPGM(MSG_END_FILE_LIST);
+      break;
+    case 21: // M21 - init SD card
+      
+      card.initsd();
+      
+      break;
+    case 22: //M22 - release SD card
+      card.release();
+
+      break;
+    case 23: //M23 - Select file
+      starpos = (strchr(strchr_pointer + 4,'*'));
+      if(starpos!=NULL)
+        *(starpos-1)='\0';
+      card.openFile(strchr_pointer + 4,true);
+      break;
+    case 24: //M24 - Start SD print
+      card.startFileprint();
+      starttime=millis();
+      break;
+    case 25: //M25 - Pause SD print
+      card.pauseSDPrint();
+      break;
+    case 26: //M26 - Set SD index
+      if(card.cardOK && code_seen('S')) {
+        card.setIndex(code_value_long());
+      }
+      break;
+    case 27: //M27 - Get SD status
+      card.getStatus();
+      break;
+    case 28: //M28 - Start SD write
+      starpos = (strchr(strchr_pointer + 4,'*'));
+      if(starpos != NULL){
+        char* npos = strchr(cmdbuffer[bufindr], 'N');
+        strchr_pointer = strchr(npos,' ') + 1;
+        *(starpos-1) = '\0';
+      }
+      card.openFile(strchr_pointer+4,false);
+      break;
+    case 29: //M29 - Stop SD write
+      //processed in write to file routine above
+      //card,saving = false;
+      break;
+    case 30: //M30 <filename> Delete File 
+	if (card.cardOK){
+		card.closefile();
+		starpos = (strchr(strchr_pointer + 4,'*'));
+                if(starpos != NULL){
+                char* npos = strchr(cmdbuffer[bufindr], 'N');
+                strchr_pointer = strchr(npos,' ') + 1;
+                *(starpos-1) = '\0';
+         }
+	 card.removeFile(strchr_pointer + 4);
+	}
+	break;
+	
+#endif //SDSUPPORT
+
+    case 31: //M31 take time since the start of the SD print or an M109 command
+      {
+      stoptime=millis();
+      char time[30];
+      unsigned long t=(stoptime-starttime)/1000;
+      int sec,min;
+      min=t/60;
+      sec=t%60;
+      sprintf_P(time, PSTR("%i min, %i sec"), min, sec);
+      SERIAL_ECHO_START;
+      SERIAL_ECHOLN(time);
+      lcd_setstatus(time);
+      autotempShutdown();
+      }
+      break;
+    case 42: //M42 -Change pin status via gcode
+      if (code_seen('S'))
+      {
+        int pin_status = code_value();
+        int pin_number = LED_PIN;
+        if (code_seen('P') && pin_status >= 0 && pin_status <= 255)
+          pin_number = code_value();
+        for(int8_t i = 0; i < (int8_t)sizeof(sensitive_pins); i++)
+        {
+          if (sensitive_pins[i] == pin_number)
+          {
+            pin_number = -1;
+            break;
+          }
+        }
+        if (pin_number > -1)
+        {
+          pinMode(pin_number, OUTPUT);
+          digitalWrite(pin_number, pin_status);
+          analogWrite(pin_number, pin_status);
+        }
+      }
+     break;
+    case 104: // M104
+      if(setTargetedHotend(104)){
+        break;
+      }
+      if (code_seen('S')) setTargetHotend(code_value(), tmp_extruder);
+      setWatch();
+      break;
+    case 140: // M140 set bed temp
+      if (code_seen('S')) setTargetBed(code_value());
+      break;
+    case 105 : // M105
+      if(setTargetedHotend(105)){
+        break;
+      }
+      #if (TEMP_0_PIN > -1)
+        SERIAL_PROTOCOLPGM("ok T:");
+        SERIAL_PROTOCOL_F(degHotend(tmp_extruder),1); 
+        SERIAL_PROTOCOLPGM(" /");
+        SERIAL_PROTOCOL_F(degTargetHotend(tmp_extruder),1); 
+        #if TEMP_BED_PIN > -1
+          SERIAL_PROTOCOLPGM(" B:");  
+          SERIAL_PROTOCOL_F(degBed(),1);
+          SERIAL_PROTOCOLPGM(" /");
+          SERIAL_PROTOCOL_F(degTargetBed(),1);
+        #endif //TEMP_BED_PIN
+      #else
+        SERIAL_ERROR_START;
+        SERIAL_ERRORLNPGM(MSG_ERR_NO_THERMISTORS);
+      #endif
+
+        SERIAL_PROTOCOLPGM(" @:");
+        SERIAL_PROTOCOL(getHeaterPower(tmp_extruder));  
+
+        SERIAL_PROTOCOLPGM(" B@:");
+        SERIAL_PROTOCOL(getHeaterPower(-1));  
+
+        SERIAL_PROTOCOLLN("");
+      return;
+      break;
+    case 109: 
+    {// M109 - Wait for extruder heater to reach target.
+      if(setTargetedHotend(109)){
+        break;
+      }
+      LCD_MESSAGEPGM(MSG_HEATING);   
+      #ifdef AUTOTEMP
+        autotemp_enabled=false;
+      #endif
+      if (code_seen('S')) setTargetHotend(code_value(), tmp_extruder);
+      #ifdef AUTOTEMP
+        if (code_seen('S')) autotemp_min=code_value();
+        if (code_seen('B')) autotemp_max=code_value();
+        if (code_seen('F')) 
+        {
+          autotemp_factor=code_value();
+          autotemp_enabled=true;
+        }
+      #endif
+      
+      setWatch();
+      codenum = millis(); 
+
+      /* See if we are heating up or cooling down */
+      bool target_direction = isHeatingHotend(tmp_extruder); // true if heating, false if cooling
+
+      #ifdef TEMP_RESIDENCY_TIME
+        long residencyStart;
+        residencyStart = -1;
+        /* continue to loop until we have reached the target temp   
+          _and_ until TEMP_RESIDENCY_TIME hasn't passed since we reached it */
+        while((residencyStart == -1) ||
+              (residencyStart >= 0 && (((unsigned int) (millis() - residencyStart)) < (TEMP_RESIDENCY_TIME * 1000UL))) ) {
+      #else
+        while ( target_direction ? (isHeatingHotend(tmp_extruder)) : (isCoolingHotend(tmp_extruder)&&(CooldownNoWait==false)) ) {
+      #endif //TEMP_RESIDENCY_TIME
+          if( (millis() - codenum) > 1000UL )
+          { //Print Temp Reading and remaining time every 1 second while heating up/cooling down
+            SERIAL_PROTOCOLPGM("T:");
+            SERIAL_PROTOCOL_F(degHotend(tmp_extruder),1); 
+            SERIAL_PROTOCOLPGM(" E:");
+            SERIAL_PROTOCOL((int)tmp_extruder); 
+            #ifdef TEMP_RESIDENCY_TIME
+              SERIAL_PROTOCOLPGM(" W:");
+              if(residencyStart > -1)
+              {
+                 codenum = ((TEMP_RESIDENCY_TIME * 1000UL) - (millis() - residencyStart)) / 1000UL;
+                 SERIAL_PROTOCOLLN( codenum );
+              }
+              else 
+              {
+                 SERIAL_PROTOCOLLN( "?" );
+              }
+            #else
+              SERIAL_PROTOCOLLN("");
+            #endif
+            codenum = millis();
+          }
+          manage_heater();
+          manage_inactivity();
+          lcd_update();
+        #ifdef TEMP_RESIDENCY_TIME
+            /* start/restart the TEMP_RESIDENCY_TIME timer whenever we reach target temp for the first time
+              or when current temp falls outside the hysteresis after target temp was reached */
+          if ((residencyStart == -1 &&  target_direction && (degHotend(tmp_extruder) >= (degTargetHotend(tmp_extruder)-TEMP_WINDOW))) ||
+              (residencyStart == -1 && !target_direction && (degHotend(tmp_extruder) <= (degTargetHotend(tmp_extruder)+TEMP_WINDOW))) ||
+              (residencyStart > -1 && labs(degHotend(tmp_extruder) - degTargetHotend(tmp_extruder)) > TEMP_HYSTERESIS) ) 
+          {
+            residencyStart = millis();
+          }
+        #endif //TEMP_RESIDENCY_TIME
+        }
+        LCD_MESSAGEPGM(MSG_HEATING_COMPLETE);
+        starttime=millis();
+        previous_millis_cmd = millis();
+      }
+      break;
+    case 190: // M190 - Wait for bed heater to reach target.
+    #if TEMP_BED_PIN > -1
+        LCD_MESSAGEPGM(MSG_BED_HEATING);
+        if (code_seen('S')) setTargetBed(code_value());
+        codenum = millis(); 
+        while(isHeatingBed()) 
+        {
+          if(( millis() - codenum) > 1000 ) //Print Temp Reading every 1 second while heating up.
+          {
+            float tt=degHotend(active_extruder);
+            SERIAL_PROTOCOLPGM("T:");
+            SERIAL_PROTOCOL(tt);
+            SERIAL_PROTOCOLPGM(" E:");
+            SERIAL_PROTOCOL((int)active_extruder); 
+            SERIAL_PROTOCOLPGM(" B:");
+            SERIAL_PROTOCOL_F(degBed(),1); 
+            SERIAL_PROTOCOLLN(""); 
+            codenum = millis(); 
+          }
+          manage_heater();
+          manage_inactivity();
+          lcd_update();
+        }
+        LCD_MESSAGEPGM(MSG_BED_DONE);
+        previous_millis_cmd = millis();
+    #endif
+        break;
+
+    #if FAN_PIN > -1
+      case 106: //M106 Fan On
+        if (code_seen('S')){
+           fanSpeed=constrain(code_value(),0,255);
+        }
+        else {
+          fanSpeed=255;			
+        }
+        break;
+      case 107: //M107 Fan Off
+        fanSpeed = 0;
+        break;
+    #endif //FAN_PIN
+
+    #if (PS_ON_PIN > -1)
+      case 80: // M80 - ATX Power On
+        SET_OUTPUT(PS_ON_PIN); //GND
+        WRITE(PS_ON_PIN, PS_ON_AWAKE);
+        break;
+      #endif
+      
+      case 81: // M81 - ATX Power Off
+      
+      #if defined SUICIDE_PIN && SUICIDE_PIN > -1
+        st_synchronize();
+        suicide();
+      #elif (PS_ON_PIN > -1)
+        SET_OUTPUT(PS_ON_PIN); 
+        WRITE(PS_ON_PIN, PS_ON_ASLEEP);
+      #endif
+		break;
+        
+    case 82:
+      axis_relative_modes[3] = false;
+      break;
+    case 83:
+      axis_relative_modes[3] = true;
+      break;
+    case 18: //compatibility
+    case 84: // M84
+      if(code_seen('S')){ 
+        stepper_inactive_time = code_value() * 1000; 
+      }
+      else
+      { 
+        bool all_axis = !((code_seen(axis_codes[0])) || (code_seen(axis_codes[1])) || (code_seen(axis_codes[2]))|| (code_seen(axis_codes[3])));
+        if(all_axis)
+        {
+          st_synchronize();
+          disable_e0();
+          disable_e1();
+          disable_e2();
+          finishAndDisableSteppers();
+        }
+        else
+        {
+          st_synchronize();
+          if(code_seen('X')) disable_x();
+          if(code_seen('Y')) disable_y();
+          if(code_seen('Z')) disable_z();
+          #if ((E0_ENABLE_PIN != X_ENABLE_PIN) && (E1_ENABLE_PIN != Y_ENABLE_PIN)) // Only enable on boards that have seperate ENABLE_PINS
+            if(code_seen('E')) {
+              disable_e0();
+              disable_e1();
+              disable_e2();
+            }
+          #endif 
+        }
+      }
+      break;
+    case 85: // M85
+      code_seen('S');
+      max_inactive_time = code_value() * 1000; 
+      break;
+    case 92: // M92
+      for(int8_t i=0; i < NUM_AXIS; i++) 
+      {
+        if(code_seen(axis_codes[i])) 
+        {
+          if(i == 3) { // E
+            float value = code_value();
+            if(value < 20.0) {
+              float factor = axis_steps_per_unit[i] / value; // increase e constants if M92 E14 is given for netfab.
+              max_e_jerk *= factor;
+              max_feedrate[i] *= factor;
+              axis_steps_per_sqr_second[i] *= factor;
+            }
+            axis_steps_per_unit[i] = value;
+          }
+          else {
+            axis_steps_per_unit[i] = code_value();
+          }
+        }
+      }
+      break;
+    case 115: // M115
+      SERIAL_PROTOCOLPGM(MSG_M115_REPORT);
+      break;
+    case 117: // M117 display message
+      starpos = (strchr(strchr_pointer + 5,'*'));
+      if(starpos!=NULL)
+        *(starpos-1)='\0';
+      lcd_setstatus(strchr_pointer + 5);
+      break;
+    case 114: // M114
+      SERIAL_PROTOCOLPGM("X:");
+      SERIAL_PROTOCOL(current_position[X_AXIS]);
+      SERIAL_PROTOCOLPGM("Y:");
+      SERIAL_PROTOCOL(current_position[Y_AXIS]);
+      SERIAL_PROTOCOLPGM("Z:");
+      SERIAL_PROTOCOL(current_position[Z_AXIS]);
+      SERIAL_PROTOCOLPGM("E:");      
+      SERIAL_PROTOCOL(current_position[E_AXIS]);
+      
+      SERIAL_PROTOCOLPGM(MSG_COUNT_X);
+      SERIAL_PROTOCOL(float(st_get_position(X_AXIS))/axis_steps_per_unit[X_AXIS]);
+      SERIAL_PROTOCOLPGM("Y:");
+      SERIAL_PROTOCOL(float(st_get_position(Y_AXIS))/axis_steps_per_unit[Y_AXIS]);
+      SERIAL_PROTOCOLPGM("Z:");
+      SERIAL_PROTOCOL(float(st_get_position(Z_AXIS))/axis_steps_per_unit[Z_AXIS]);
+      
+      SERIAL_PROTOCOLLN("");
+      break;
+    case 120: // M120
+      enable_endstops(false) ;
+      break;
+    case 121: // M121
+      enable_endstops(true) ;
+      break;
+    case 119: // M119
+    SERIAL_PROTOCOLLN(MSG_M119_REPORT);
+      #if (X_MIN_PIN > -1)
+        SERIAL_PROTOCOLPGM(MSG_X_MIN);
+        SERIAL_PROTOCOLLN(((READ(X_MIN_PIN)^X_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
+      #endif
+      #if (X_MAX_PIN > -1)
+        SERIAL_PROTOCOLPGM(MSG_X_MAX);
+        SERIAL_PROTOCOLLN(((READ(X_MAX_PIN)^X_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
+      #endif
+      #if (Y_MIN_PIN > -1)
+        SERIAL_PROTOCOLPGM(MSG_Y_MIN);
+        SERIAL_PROTOCOLLN(((READ(Y_MIN_PIN)^Y_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
+      #endif
+      #if (Y_MAX_PIN > -1)
+        SERIAL_PROTOCOLPGM(MSG_Y_MAX);
+        SERIAL_PROTOCOLLN(((READ(Y_MAX_PIN)^Y_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
+      #endif
+      #if (Z_MIN_PIN > -1)
+        SERIAL_PROTOCOLPGM(MSG_Z_MIN);
+        SERIAL_PROTOCOLLN(((READ(Z_MIN_PIN)^Z_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
+      #endif
+      #if (Z_MAX_PIN > -1)
+        SERIAL_PROTOCOLPGM(MSG_Z_MAX);
+        SERIAL_PROTOCOLLN(((READ(Z_MAX_PIN)^Z_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
+      #endif
+      break;
+      //TODO: update for all axis, use for loop
+    case 201: // M201
+      for(int8_t i=0; i < NUM_AXIS; i++) 
+      {
+        if(code_seen(axis_codes[i]))
+        {
+          max_acceleration_units_per_sq_second[i] = code_value();
+          axis_steps_per_sqr_second[i] = code_value() * axis_steps_per_unit[i];
+        }
+      }
+      break;
+    #if 0 // Not used for Sprinter/grbl gen6
+    case 202: // M202
+      for(int8_t i=0; i < NUM_AXIS; i++) {
+        if(code_seen(axis_codes[i])) axis_travel_steps_per_sqr_second[i] = code_value() * axis_steps_per_unit[i];
+      }
+      break;
+    #endif
+    case 203: // M203 max feedrate mm/sec
+      for(int8_t i=0; i < NUM_AXIS; i++) {
+        if(code_seen(axis_codes[i])) max_feedrate[i] = code_value();
+      }
+      break;
+    case 204: // M204 acclereration S normal moves T filmanent only moves
+      {
+        if(code_seen('S')) acceleration = code_value() ;
+        if(code_seen('T')) retract_acceleration = code_value() ;
+      }
+      break;
+    case 205: //M205 advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk
+    {
+      if(code_seen('S')) minimumfeedrate = code_value();
+      if(code_seen('T')) mintravelfeedrate = code_value();
+      if(code_seen('B')) minsegmenttime = code_value() ;
+      if(code_seen('X')) max_xy_jerk = code_value() ;
+      if(code_seen('Z')) max_z_jerk = code_value() ;
+      if(code_seen('E')) max_e_jerk = code_value() ;
+    }
+    break;
+    case 206: // M206 additional homeing offset
+      for(int8_t i=0; i < 3; i++) 
+      {
+        if(code_seen(axis_codes[i])) add_homeing[i] = code_value();
+      }
+      break;
+    #ifdef FWRETRACT
+    case 207: //M207 - set retract length S[positive mm] F[feedrate mm/sec] Z[additional zlift/hop]
+    {
+      if(code_seen('S')) 
+      {
+        retract_length = code_value() ;
+      }
+      if(code_seen('F')) 
+      {
+        retract_feedrate = code_value() ;
+      }
+      if(code_seen('Z')) 
+      {
+        retract_zlift = code_value() ;
+      }
+    }break;
+    case 208: // M208 - set retract recover length S[positive mm surplus to the M207 S*] F[feedrate mm/sec]
+    {
+      if(code_seen('S')) 
+      {
+        retract_recover_length = code_value() ;
+      }
+      if(code_seen('F')) 
+      {
+        retract_recover_feedrate = code_value() ;
+      }
+    }break;
+    case 209: // M209 - S<1=true/0=false> enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.
+    {
+      if(code_seen('S')) 
+      {
+        int t= code_value() ;
+        switch(t)
+        {
+          case 0: autoretract_enabled=false;retracted=false;break;
+          case 1: autoretract_enabled=true;retracted=false;break;
+          default: 
+            SERIAL_ECHO_START;
+            SERIAL_ECHOPGM(MSG_UNKNOWN_COMMAND);
+            SERIAL_ECHO(cmdbuffer[bufindr]);
+            SERIAL_ECHOLNPGM("\"");
+        }
+      }
+      
+    }break;
     #endif // FWRETRACT
-    #if EXTRUDERS > 1
-    case 218: // M218 - set hotend offset (in mm), T<extruder_number> X<offset_on_X> Y<offset_on_Y>
-    {
-      if(setTargetedHotend(218)){
-        break;
-      }
-      if(code_seen('X')) 
-      {
-        extruder_offset[X_AXIS][tmp_extruder] = code_value();
-      }
-      if(code_seen('Y'))
-      {
-        extruder_offset[Y_AXIS][tmp_extruder] = code_value();
-      }
-      SERIAL_ECHO_START;
-      SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
-      for(tmp_extruder = 0; tmp_extruder < EXTRUDERS; tmp_extruder++) 
-      {
-         SERIAL_ECHO(" ");
-         SERIAL_ECHO(extruder_offset[X_AXIS][tmp_extruder]);
-         SERIAL_ECHO(",");
-         SERIAL_ECHO(extruder_offset[Y_AXIS][tmp_extruder]);
-      }
-      SERIAL_ECHOLN("");
+    #if EXTRUDERS > 1
+    case 218: // M218 - set hotend offset (in mm), T<extruder_number> X<offset_on_X> Y<offset_on_Y>
+    {
+      if(setTargetedHotend(218)){
+        break;
+      }
+      if(code_seen('X')) 
+      {
+        extruder_offset[X_AXIS][tmp_extruder] = code_value();
+      }
+      if(code_seen('Y'))
+      {
+        extruder_offset[Y_AXIS][tmp_extruder] = code_value();
+      }
+      SERIAL_ECHO_START;
+      SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
+      for(tmp_extruder = 0; tmp_extruder < EXTRUDERS; tmp_extruder++) 
+      {
+         SERIAL_ECHO(" ");
+         SERIAL_ECHO(extruder_offset[X_AXIS][tmp_extruder]);
+         SERIAL_ECHO(",");
+         SERIAL_ECHO(extruder_offset[Y_AXIS][tmp_extruder]);
+      }
+      SERIAL_ECHOLN("");
     }break;
-    #endif
-    case 220: // M220 S<factor in percent>- set speed factor override percentage
-    {
-      if(code_seen('S')) 
-      {
-        feedmultiply = code_value() ;
-      }
-    }
-    break;
-    case 221: // M221 S<factor in percent>- set extrude factor override percentage
-    {
-      if(code_seen('S')) 
-      {
-        extrudemultiply = code_value() ;
-      }
-    }
-    break;
-
-    #ifdef PIDTEMP
-    case 301: // M301
-      {
-        if(code_seen('P')) Kp = code_value();
-        if(code_seen('I')) Ki = code_value()*PID_dT;
-        if(code_seen('D')) Kd = code_value()/PID_dT;
-        #ifdef PID_ADD_EXTRUSION_RATE
-        if(code_seen('C')) Kc = code_value();
-        #endif
-        updatePID();
-        SERIAL_PROTOCOL(MSG_OK);
-		SERIAL_PROTOCOL(" p:");
-        SERIAL_PROTOCOL(Kp);
-        SERIAL_PROTOCOL(" i:");
-        SERIAL_PROTOCOL(Ki/PID_dT);
-        SERIAL_PROTOCOL(" d:");
-        SERIAL_PROTOCOL(Kd*PID_dT);
-        #ifdef PID_ADD_EXTRUSION_RATE
-        SERIAL_PROTOCOL(" c:");
-        SERIAL_PROTOCOL(Kc*PID_dT);
-        #endif
-        SERIAL_PROTOCOLLN("");
-      }
-      break;
-    #endif //PIDTEMP
-    #ifdef PIDTEMPBED
-    case 304: // M304
-      {
-        if(code_seen('P')) bedKp = code_value();
-        if(code_seen('I')) bedKi = code_value()*PID_dT;
-        if(code_seen('D')) bedKd = code_value()/PID_dT;
-        updatePID();
-        SERIAL_PROTOCOL(MSG_OK);
-		SERIAL_PROTOCOL(" p:");
-        SERIAL_PROTOCOL(bedKp);
-        SERIAL_PROTOCOL(" i:");
-        SERIAL_PROTOCOL(bedKi/PID_dT);
-        SERIAL_PROTOCOL(" d:");
-        SERIAL_PROTOCOL(bedKd*PID_dT);
-        SERIAL_PROTOCOLLN("");
-      }
-      break;
-    #endif //PIDTEMP
-    case 240: // M240  Triggers a camera by emulating a Canon RC-1 : http://www.doc-diy.net/photo/rc-1_hacked/
-     {
-      #ifdef PHOTOGRAPH_PIN
-        #if (PHOTOGRAPH_PIN > -1)
-        const uint8_t NUM_PULSES=16;
-        const float PULSE_LENGTH=0.01524;
-        for(int i=0; i < NUM_PULSES; i++) {
-          WRITE(PHOTOGRAPH_PIN, HIGH);
-          _delay_ms(PULSE_LENGTH);
-          WRITE(PHOTOGRAPH_PIN, LOW);
-          _delay_ms(PULSE_LENGTH);
-        }
-        delay(7.33);
-        for(int i=0; i < NUM_PULSES; i++) {
-          WRITE(PHOTOGRAPH_PIN, HIGH);
-          _delay_ms(PULSE_LENGTH);
-          WRITE(PHOTOGRAPH_PIN, LOW);
-          _delay_ms(PULSE_LENGTH);
-        }
-        #endif
-      #endif
-     }
-    break;
-      
-    case 302: // allow cold extrudes
-    {
-      allow_cold_extrudes(true);
-    }
-    break;
-    case 303: // M303 PID autotune
-    {
-      float temp = 150.0;
-      int e=0;
-      int c=5;
-      if (code_seen('E')) e=code_value();
-			if (e<0)
-				temp=70;
-      if (code_seen('S')) temp=code_value();
-      if (code_seen('C')) c=code_value();
-      PID_autotune(temp, e, c);
-    }
-    break;
-    case 400: // M400 finish all moves
-    {
-      st_synchronize();
-    }
-    break;
-    case 500: // M500 Store settings in EEPROM
-    {
-        Config_StoreSettings();
-    }
-    break;
-    case 501: // M501 Read settings from EEPROM
-    {
-        Config_RetrieveSettings();
-    }
-    break;
-    case 502: // M502 Revert to default settings
-    {
-        Config_ResetDefault();
-    }
-    break;
-    case 503: // M503 print settings currently in memory
-    {
-        Config_PrintSettings();
-    }
-    break;
-    #ifdef ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
-    case 540:
-    {
-        if(code_seen('S')) abort_on_endstop_hit = code_value() > 0;
-    }
-    break;
-    #endif
-    #ifdef FILAMENTCHANGEENABLE
-    case 600: //Pause for filament change X[pos] Y[pos] Z[relative lift] E[initial retract] L[later retract distance for removal]
-    {
-        float target[4];
-        float lastpos[4];
-        target[X_AXIS]=current_position[X_AXIS];
-        target[Y_AXIS]=current_position[Y_AXIS];
-        target[Z_AXIS]=current_position[Z_AXIS];
-        target[E_AXIS]=current_position[E_AXIS];
-        lastpos[X_AXIS]=current_position[X_AXIS];
-        lastpos[Y_AXIS]=current_position[Y_AXIS];
-        lastpos[Z_AXIS]=current_position[Z_AXIS];
-        lastpos[E_AXIS]=current_position[E_AXIS];
-        //retract by E
-        if(code_seen('E')) 
-        {
-          target[E_AXIS]+= code_value();
-        }
-        else
-        {
-          #ifdef FILAMENTCHANGE_FIRSTRETRACT
-            target[E_AXIS]+= FILAMENTCHANGE_FIRSTRETRACT ;
-          #endif
-        }
-        plan_buffer_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], target[E_AXIS], feedrate/60, active_extruder);
-        
-        //lift Z
-        if(code_seen('Z')) 
-        {
-          target[Z_AXIS]+= code_value();
-        }
-        else
-        {
-          #ifdef FILAMENTCHANGE_ZADD
-            target[Z_AXIS]+= FILAMENTCHANGE_ZADD ;
-          #endif
-        }
-        plan_buffer_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], target[E_AXIS], feedrate/60, active_extruder);
-        
-        //move xy
-        if(code_seen('X')) 
-        {
-          target[X_AXIS]+= code_value();
-        }
-        else
-        {
-          #ifdef FILAMENTCHANGE_XPOS
-            target[X_AXIS]= FILAMENTCHANGE_XPOS ;
-          #endif
-        }
-        if(code_seen('Y')) 
-        {
-          target[Y_AXIS]= code_value();
-        }
-        else
-        {
-          #ifdef FILAMENTCHANGE_YPOS
-            target[Y_AXIS]= FILAMENTCHANGE_YPOS ;
-          #endif
-        }
-        
-        plan_buffer_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], target[E_AXIS], feedrate/60, active_extruder);
-        
-        if(code_seen('L'))
-        {
-          target[E_AXIS]+= code_value();
-        }
-        else
-        {
-          #ifdef FILAMENTCHANGE_FINALRETRACT
-            target[E_AXIS]+= FILAMENTCHANGE_FINALRETRACT ;
-          #endif
-        }
-        
-        plan_buffer_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], target[E_AXIS], feedrate/60, active_extruder);
-        
-        //finish moves
-        st_synchronize();
-        //disable extruder steppers so filament can be removed
-        disable_e0();
-        disable_e1();
-        disable_e2();
-        delay(100);
-        LCD_ALERTMESSAGEPGM(MSG_FILAMENTCHANGE);
-        uint8_t cnt=0;
-        while(!LCD_CLICKED){
-          cnt++;
-          manage_heater();
-          manage_inactivity();
-          lcd_update();
-          
-          #if BEEPER > -1
-          if(cnt==0)
-          {
-            SET_OUTPUT(BEEPER);
-            
-            WRITE(BEEPER,HIGH);
-            delay(3);
-            WRITE(BEEPER,LOW);
-            delay(3);
-          }
-          #endif
-        }
-        
-        //return to normal
-        if(code_seen('L')) 
-        {
-          target[E_AXIS]+= -code_value();
-        }
-        else
-        {
-          #ifdef FILAMENTCHANGE_FINALRETRACT
-            target[E_AXIS]+=(-1)*FILAMENTCHANGE_FINALRETRACT ;
-          #endif
-        }
-        current_position[E_AXIS]=target[E_AXIS]; //the long retract of L is compensated by manual filament feeding
-        plan_set_e_position(current_position[E_AXIS]);
-        plan_buffer_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], target[E_AXIS], feedrate/60, active_extruder); //should do nothing
-        plan_buffer_line(lastpos[X_AXIS], lastpos[Y_AXIS], target[Z_AXIS], target[E_AXIS], feedrate/60, active_extruder); //move xy back
-        plan_buffer_line(lastpos[X_AXIS], lastpos[Y_AXIS], lastpos[Z_AXIS], target[E_AXIS], feedrate/60, active_extruder); //move z back
-        plan_buffer_line(lastpos[X_AXIS], lastpos[Y_AXIS], lastpos[Z_AXIS], lastpos[E_AXIS], feedrate/60, active_extruder); //final untretract
-    }
-    break;
-    #endif //FILAMENTCHANGEENABLE    
-    case 907: // M907 Set digital trimpot motor current using axis codes.
-    {
-      #if DIGIPOTSS_PIN > -1
-        for(int i=0;i<=NUM_AXIS;i++) if(code_seen(axis_codes[i])) digipot_current(i,code_value());
-        if(code_seen('B')) digipot_current(4,code_value());
-        if(code_seen('S')) for(int i=0;i<=4;i++) digipot_current(i,code_value());
-      #endif
-    }
-    case 908: // M908 Control digital trimpot directly.
-    {
-      #if DIGIPOTSS_PIN > -1
-        uint8_t channel,current;
-        if(code_seen('P')) channel=code_value();
-        if(code_seen('S')) current=code_value();
-        digitalPotWrite(channel, current);
-      #endif
-    }
-    break;
-    case 350: // M350 Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
-    {
-      #if X_MS1_PIN > -1
-        if(code_seen('S')) for(int i=0;i<=4;i++) microstep_mode(i,code_value()); 
-        for(int i=0;i<=NUM_AXIS;i++) if(code_seen(axis_codes[i])) microstep_mode(i,(uint8_t)code_value());
-        if(code_seen('B')) microstep_mode(4,code_value());
-        microstep_readings();
-      #endif
-    }
-    break;
-    case 351: // M351 Toggle MS1 MS2 pins directly, S# determines MS1 or MS2, X# sets the pin high/low.
-    {
-      #if X_MS1_PIN > -1
-      if(code_seen('S')) switch((int)code_value())
-      {
-        case 1:
-          for(int i=0;i<=NUM_AXIS;i++) if(code_seen(axis_codes[i])) microstep_ms(i,code_value(),-1);
-          if(code_seen('B')) microstep_ms(4,code_value(),-1);
-          break;
-        case 2:
-          for(int i=0;i<=NUM_AXIS;i++) if(code_seen(axis_codes[i])) microstep_ms(i,-1,code_value());
-          if(code_seen('B')) microstep_ms(4,-1,code_value());
-          break;
-      }
-      microstep_readings();
-      #endif
-    }
-    break;
-    case 999: // M999: Restart after being stopped
-      Stopped = false;
-      lcd_reset_alert_level();
-      gcode_LastN = Stopped_gcode_LastN;
-      FlushSerialRequestResend();
-    break;
-    }
-  }
-
-  else if(code_seen('T')) 
-  {
-    tmp_extruder = code_value();
-    if(tmp_extruder >= EXTRUDERS) {
-      SERIAL_ECHO_START;
-      SERIAL_ECHO("T");
-      SERIAL_ECHO(tmp_extruder);
-      SERIAL_ECHOLN(MSG_INVALID_EXTRUDER);
-    }
-    else {
-      boolean make_move = false;
-      if(code_seen('F')) {
-        make_move = true;
-        next_feedrate = code_value();
-        if(next_feedrate > 0.0) {
-          feedrate = next_feedrate;
-        }
-      }
-      #if EXTRUDERS > 1
-      if(tmp_extruder != active_extruder) {
-        // Save current position to return to after applying extruder offset
-        memcpy(destination, current_position, sizeof(destination));
-        // Offset extruder (only by XY)
-        int i;
-        for(i = 0; i < 2; i++) {
-           current_position[i] = current_position[i] - 
-                                 extruder_offset[i][active_extruder] +
-                                 extruder_offset[i][tmp_extruder];
-        }
-        // Set the new active extruder and position
-        active_extruder = tmp_extruder;
-        plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
-        // Move to the old position if 'F' was in the parameters
-        if(make_move && Stopped == false) {
-           prepare_move();
-        }
+    #endif
+    case 220: // M220 S<factor in percent>- set speed factor override percentage
+    {
+      if(code_seen('S')) 
+      {
+        feedmultiply = code_value() ;
       }
-      #endif
-      SERIAL_ECHO_START;
-      SERIAL_ECHO(MSG_ACTIVE_EXTRUDER);
-      SERIAL_PROTOCOLLN((int)active_extruder);
-    }
-  }
-
-  else
-  {
-    SERIAL_ECHO_START;
-    SERIAL_ECHOPGM(MSG_UNKNOWN_COMMAND);
-    SERIAL_ECHO(cmdbuffer[bufindr]);
-    SERIAL_ECHOLNPGM("\"");
-  }
-
-  ClearToSend();
-}
-
-void FlushSerialRequestResend()
-{
-  //char cmdbuffer[bufindr][100]="Resend:";
-  MYSERIAL.flush();
-  SERIAL_PROTOCOLPGM(MSG_RESEND);
-  SERIAL_PROTOCOLLN(gcode_LastN + 1);
-  ClearToSend();
-}
-
-void ClearToSend()
-{
-  previous_millis_cmd = millis();
-  #ifdef SDSUPPORT
-  if(fromsd[bufindr])
-    return;
-  #endif //SDSUPPORT
-  SERIAL_PROTOCOLLNPGM(MSG_OK); 
-}
-
-void get_coordinates()
-{
-  bool seen[4]={false,false,false,false};
-  for(int8_t i=0; i < NUM_AXIS; i++) {
-    if(code_seen(axis_codes[i])) 
-    {
-      destination[i] = (float)code_value() + (axis_relative_modes[i] || relative_mode)*current_position[i];
-      seen[i]=true;
-    }
-    else destination[i] = current_position[i]; //Are these else lines really needed?
-  }
-  if(code_seen('F')) {
-    next_feedrate = code_value();
-    if(next_feedrate > 0.0) feedrate = next_feedrate;
-  }
-  #ifdef FWRETRACT
-  if(autoretract_enabled)
-  if( !(seen[X_AXIS] || seen[Y_AXIS] || seen[Z_AXIS]) && seen[E_AXIS])
-  {
-    float echange=destination[E_AXIS]-current_position[E_AXIS];
-    if(echange<-MIN_RETRACT) //retract
-    {
-      if(!retracted) 
-      {
-      
-      destination[Z_AXIS]+=retract_zlift; //not sure why chaninging current_position negatively does not work.
-      //if slicer retracted by echange=-1mm and you want to retract 3mm, corrrectede=-2mm additionally
-      float correctede=-echange-retract_length;
-      //to generate the additional steps, not the destination is changed, but inversely the current position
-      current_position[E_AXIS]+=-correctede; 
-      feedrate=retract_feedrate;
-      retracted=true;
-      }
-      
-    }
-    else 
-      if(echange>MIN_RETRACT) //retract_recover
-    {
-      if(retracted) 
-      {
-      //current_position[Z_AXIS]+=-retract_zlift;
-      //if slicer retracted_recovered by echange=+1mm and you want to retract_recover 3mm, corrrectede=2mm additionally
-      float correctede=-echange+1*retract_length+retract_recover_length; //total unretract=retract_length+retract_recover_length[surplus]
-      current_position[E_AXIS]+=correctede; //to generate the additional steps, not the destination is changed, but inversely the current position
-      feedrate=retract_recover_feedrate;
-      retracted=false;
-      }
-    }
-    
-  }
-  #endif //FWRETRACT
-}
-
-void get_arc_coordinates()
-{
-#ifdef SF_ARC_FIX
-   bool relative_mode_backup = relative_mode;
-   relative_mode = true;
-#endif
-   get_coordinates();
-#ifdef SF_ARC_FIX
-   relative_mode=relative_mode_backup;
-#endif
-
-   if(code_seen('I')) {
-     offset[0] = code_value();
-   } 
-   else {
-     offset[0] = 0.0;
-   }
-   if(code_seen('J')) {
-     offset[1] = code_value();
-   }
-   else {
-     offset[1] = 0.0;
-   }
-}
-
-void clamp_to_software_endstops(float target[3])
-{
-  if (min_software_endstops) {
-    if (target[X_AXIS] < min_pos[X_AXIS]) target[X_AXIS] = min_pos[X_AXIS];
-    if (target[Y_AXIS] < min_pos[Y_AXIS]) target[Y_AXIS] = min_pos[Y_AXIS];
-    if (target[Z_AXIS] < min_pos[Z_AXIS]) target[Z_AXIS] = min_pos[Z_AXIS];
-  }
-
-  if (max_software_endstops) {
-    if (target[X_AXIS] > max_pos[X_AXIS]) target[X_AXIS] = max_pos[X_AXIS];
-    if (target[Y_AXIS] > max_pos[Y_AXIS]) target[Y_AXIS] = max_pos[Y_AXIS];
-    if (target[Z_AXIS] > max_pos[Z_AXIS]) target[Z_AXIS] = max_pos[Z_AXIS];
-  }
-}
-
-void prepare_move()
-{
-  clamp_to_software_endstops(destination);
-
-  previous_millis_cmd = millis(); 
-  // Do not use feedmultiply for E or Z only moves
-  if( (current_position[X_AXIS] == destination [X_AXIS]) && (current_position[Y_AXIS] == destination [Y_AXIS])) {
-      plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
-  }
-  else {
-    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate*feedmultiply/60/100.0, active_extruder);
-  }
-  for(int8_t i=0; i < NUM_AXIS; i++) {
-    current_position[i] = destination[i];
-  }
-}
-
-void prepare_arc_move(char isclockwise) {
-  float r = hypot(offset[X_AXIS], offset[Y_AXIS]); // Compute arc radius for mc_arc
-
-  // Trace the arc
-  mc_arc(current_position, destination, offset, X_AXIS, Y_AXIS, Z_AXIS, feedrate*feedmultiply/60/100.0, r, isclockwise, active_extruder);
-  
-  // As far as the parser is concerned, the position is now == target. In reality the
-  // motion control system might still be processing the action and the real tool position
-  // in any intermediate location.
-  for(int8_t i=0; i < NUM_AXIS; i++) {
-    current_position[i] = destination[i];
-  }
-  previous_millis_cmd = millis();
-}
-
-#ifdef CONTROLLERFAN_PIN
-unsigned long lastMotor = 0; //Save the time for when a motor was turned on last
-unsigned long lastMotorCheck = 0;
-
-void controllerFan()
-{
-  if ((millis() - lastMotorCheck) >= 2500) //Not a time critical function, so we only check every 2500ms
-  {
-    lastMotorCheck = millis();
-    
-    if(!READ(X_ENABLE_PIN) || !READ(Y_ENABLE_PIN) || !READ(Z_ENABLE_PIN)
-    #if EXTRUDERS > 2
-       || !READ(E2_ENABLE_PIN)
-    #endif
-    #if EXTRUDER > 1
-       || !READ(E2_ENABLE_PIN)
-    #endif
-       || !READ(E0_ENABLE_PIN)) //If any of the drivers are enabled...    
-    {
-      lastMotor = millis(); //... set time to NOW so the fan will turn on
-    }
-    
-    if ((millis() - lastMotor) >= (CONTROLLERFAN_SEC*1000UL) || lastMotor == 0) //If the last time any driver was enabled, is longer since than CONTROLLERSEC...   
-    {
-      WRITE(CONTROLLERFAN_PIN, LOW); //... turn the fan off
-    }
-    else
-    {
-      WRITE(CONTROLLERFAN_PIN, HIGH); //... turn the fan on
-    }
-  }
-}
-#endif
-
-void manage_inactivity() 
-{ 
-  if( (millis() - previous_millis_cmd) >  max_inactive_time ) 
-    if(max_inactive_time) 
-      kill(); 
-  if(stepper_inactive_time)  {
-    if( (millis() - previous_millis_cmd) >  stepper_inactive_time ) 
-    {
-      if(blocks_queued() == false) {
-        disable_x();
-        disable_y();
-        disable_z();
-        disable_e0();
-        disable_e1();
-        disable_e2();
-      }
-    }
-  }
-  #if( KILL_PIN>-1 )
-    if( 0 == READ(KILL_PIN) )
-      kill();
-  #endif
-  #ifdef CONTROLLERFAN_PIN
-    controllerFan(); //Check if fan should be turned on to cool stepper drivers down
-  #endif
-  #ifdef EXTRUDER_RUNOUT_PREVENT
-    if( (millis() - previous_millis_cmd) >  EXTRUDER_RUNOUT_SECONDS*1000 ) 
-    if(degHotend(active_extruder)>EXTRUDER_RUNOUT_MINTEMP)
-    {
-     bool oldstatus=READ(E0_ENABLE_PIN);
-     enable_e0();
-     float oldepos=current_position[E_AXIS];
-     float oldedes=destination[E_AXIS];
-     plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], 
-                      current_position[E_AXIS]+EXTRUDER_RUNOUT_EXTRUDE*EXTRUDER_RUNOUT_ESTEPS/axis_steps_per_unit[E_AXIS], 
-                      EXTRUDER_RUNOUT_SPEED/60.*EXTRUDER_RUNOUT_ESTEPS/axis_steps_per_unit[E_AXIS], active_extruder);
-     current_position[E_AXIS]=oldepos;
-     destination[E_AXIS]=oldedes;
-     plan_set_e_position(oldepos);
-     previous_millis_cmd=millis();
-     st_synchronize();
-     WRITE(E0_ENABLE_PIN,oldstatus);
-    }
-  #endif
-  check_axes_activity();
-}
-
-void kill()
-{
-  cli(); // Stop interrupts
-  disable_heater();
-
-  disable_x();
-  disable_y();
-  disable_z();
-  disable_e0();
-  disable_e1();
-  disable_e2();
-  
-  if(PS_ON_PIN > -1) pinMode(PS_ON_PIN,INPUT);
-  SERIAL_ERROR_START;
-  SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
-  LCD_ALERTMESSAGEPGM(MSG_KILLED);
-  suicide();
-  while(1) { /* Intentionally left empty */ } // Wait for reset
-}
-
-void Stop()
-{
-  disable_heater();
-  if(Stopped == false) {
-    Stopped = true;
-    Stopped_gcode_LastN = gcode_LastN; // Save last g_code for restart
-    SERIAL_ERROR_START;
-    SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
-    LCD_MESSAGEPGM(MSG_STOPPED);
-  }
-}
-
-bool IsStopped() { return Stopped; };
-
-#ifdef FAST_PWM_FAN
-void setPwmFrequency(uint8_t pin, int val)
-{
-  val &= 0x07;
-  switch(digitalPinToTimer(pin))
-  {
- 
-    #if defined(TCCR0A)
-    case TIMER0A:
-    case TIMER0B:
-//         TCCR0B &= ~(_BV(CS00) | _BV(CS01) | _BV(CS02));
-//         TCCR0B |= val;
-         break;
-    #endif
-
-    #if defined(TCCR1A)
-    case TIMER1A:
-    case TIMER1B:
-//         TCCR1B &= ~(_BV(CS10) | _BV(CS11) | _BV(CS12));
-//         TCCR1B |= val;
-         break;
-    #endif
-
-    #if defined(TCCR2)
-    case TIMER2:
-    case TIMER2:
-         TCCR2 &= ~(_BV(CS10) | _BV(CS11) | _BV(CS12));
-         TCCR2 |= val;
-         break;
-    #endif
-
-    #if defined(TCCR2A)
-    case TIMER2A:
-    case TIMER2B:
-         TCCR2B &= ~(_BV(CS20) | _BV(CS21) | _BV(CS22));
-         TCCR2B |= val;
-         break;
-    #endif
-
-    #if defined(TCCR3A)
-    case TIMER3A:
-    case TIMER3B:
-    case TIMER3C:
-         TCCR3B &= ~(_BV(CS30) | _BV(CS31) | _BV(CS32));
-         TCCR3B |= val;
-         break;
-    #endif
-
-    #if defined(TCCR4A) 
-    case TIMER4A:
-    case TIMER4B:
-    case TIMER4C:
-         TCCR4B &= ~(_BV(CS40) | _BV(CS41) | _BV(CS42));
-         TCCR4B |= val;
-         break;
-   #endif
-
-    #if defined(TCCR5A) 
-    case TIMER5A:
-    case TIMER5B:
-    case TIMER5C:
-         TCCR5B &= ~(_BV(CS50) | _BV(CS51) | _BV(CS52));
-         TCCR5B |= val;
-         break;
-   #endif
-
-  }
-}
-#endif //FAST_PWM_FAN
-
-bool setTargetedHotend(int code){
-  tmp_extruder = active_extruder;
-  if(code_seen('T')) {
-    tmp_extruder = code_value();
-    if(tmp_extruder >= EXTRUDERS) {
-      SERIAL_ECHO_START;
-      switch(code){
-        case 104:
-          SERIAL_ECHO(MSG_M104_INVALID_EXTRUDER);
-          break;
-        case 105:
-          SERIAL_ECHO(MSG_M105_INVALID_EXTRUDER);
-          break;
-        case 109:
-          SERIAL_ECHO(MSG_M109_INVALID_EXTRUDER);
-          break;
-        case 218:
-          SERIAL_ECHO(MSG_M218_INVALID_EXTRUDER);
-          break;
-      }
-      SERIAL_ECHOLN(tmp_extruder);
-      return true;
-    }
-  }
-  return false;
+    }
+    break;
+    case 221: // M221 S<factor in percent>- set extrude factor override percentage
+    {
+      if(code_seen('S')) 
+      {
+        extrudemultiply = code_value() ;
+      }
+    }
+    break;
+
+    #ifdef PIDTEMP
+    case 301: // M301
+      {
+        if(code_seen('P')) Kp = code_value();
+        if(code_seen('I')) Ki = code_value()*PID_dT;
+        if(code_seen('D')) Kd = code_value()/PID_dT;
+        #ifdef PID_ADD_EXTRUSION_RATE
+        if(code_seen('C')) Kc = code_value();
+        #endif
+        updatePID();
+        SERIAL_PROTOCOL(MSG_OK);
+		SERIAL_PROTOCOL(" p:");
+        SERIAL_PROTOCOL(Kp);
+        SERIAL_PROTOCOL(" i:");
+        SERIAL_PROTOCOL(Ki/PID_dT);
+        SERIAL_PROTOCOL(" d:");
+        SERIAL_PROTOCOL(Kd*PID_dT);
+        #ifdef PID_ADD_EXTRUSION_RATE
+        SERIAL_PROTOCOL(" c:");
+        SERIAL_PROTOCOL(Kc*PID_dT);
+        #endif
+        SERIAL_PROTOCOLLN("");
+      }
+      break;
+    #endif //PIDTEMP
+    #ifdef PIDTEMPBED
+    case 304: // M304
+      {
+        if(code_seen('P')) bedKp = code_value();
+        if(code_seen('I')) bedKi = code_value()*PID_dT;
+        if(code_seen('D')) bedKd = code_value()/PID_dT;
+        updatePID();
+        SERIAL_PROTOCOL(MSG_OK);
+		SERIAL_PROTOCOL(" p:");
+        SERIAL_PROTOCOL(bedKp);
+        SERIAL_PROTOCOL(" i:");
+        SERIAL_PROTOCOL(bedKi/PID_dT);
+        SERIAL_PROTOCOL(" d:");
+        SERIAL_PROTOCOL(bedKd*PID_dT);
+        SERIAL_PROTOCOLLN("");
+      }
+      break;
+    #endif //PIDTEMP
+    case 240: // M240  Triggers a camera by emulating a Canon RC-1 : http://www.doc-diy.net/photo/rc-1_hacked/
+     {
+      #ifdef PHOTOGRAPH_PIN
+        #if (PHOTOGRAPH_PIN > -1)
+        const uint8_t NUM_PULSES=16;
+        const float PULSE_LENGTH=0.01524;
+        for(int i=0; i < NUM_PULSES; i++) {
+          WRITE(PHOTOGRAPH_PIN, HIGH);
+          _delay_ms(PULSE_LENGTH);
+          WRITE(PHOTOGRAPH_PIN, LOW);
+          _delay_ms(PULSE_LENGTH);
+        }
+        delay(7.33);
+        for(int i=0; i < NUM_PULSES; i++) {
+          WRITE(PHOTOGRAPH_PIN, HIGH);
+          _delay_ms(PULSE_LENGTH);
+          WRITE(PHOTOGRAPH_PIN, LOW);
+          _delay_ms(PULSE_LENGTH);
+        }
+        #endif
+      #endif
+     }
+    break;
+      
+    case 302: // allow cold extrudes
+    {
+      allow_cold_extrudes(true);
+    }
+    break;
+    case 303: // M303 PID autotune
+    {
+      float temp = 150.0;
+      int e=0;
+      int c=5;
+      if (code_seen('E')) e=code_value();
+			if (e<0)
+				temp=70;
+      if (code_seen('S')) temp=code_value();
+      if (code_seen('C')) c=code_value();
+      PID_autotune(temp, e, c);
+    }
+    break;
+    case 400: // M400 finish all moves
+    {
+      st_synchronize();
+    }
+    break;
+    case 500: // M500 Store settings in EEPROM
+    {
+        Config_StoreSettings();
+    }
+    break;
+    case 501: // M501 Read settings from EEPROM
+    {
+        Config_RetrieveSettings();
+    }
+    break;
+    case 502: // M502 Revert to default settings
+    {
+        Config_ResetDefault();
+    }
+    break;
+    case 503: // M503 print settings currently in memory
+    {
+        Config_PrintSettings();
+    }
+    break;
+    #ifdef ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
+    case 540:
+    {
+        if(code_seen('S')) abort_on_endstop_hit = code_value() > 0;
+    }
+    break;
+    #endif
+    #ifdef FILAMENTCHANGEENABLE
+    case 600: //Pause for filament change X[pos] Y[pos] Z[relative lift] E[initial retract] L[later retract distance for removal]
+    {
+        float target[4];
+        float lastpos[4];
+        target[X_AXIS]=current_position[X_AXIS];
+        target[Y_AXIS]=current_position[Y_AXIS];
+        target[Z_AXIS]=current_position[Z_AXIS];
+        target[E_AXIS]=current_position[E_AXIS];
+        lastpos[X_AXIS]=current_position[X_AXIS];
+        lastpos[Y_AXIS]=current_position[Y_AXIS];
+        lastpos[Z_AXIS]=current_position[Z_AXIS];
+        lastpos[E_AXIS]=current_position[E_AXIS];
+        //retract by E
+        if(code_seen('E')) 
+        {
+          target[E_AXIS]+= code_value();
+        }
+        else
+        {
+          #ifdef FILAMENTCHANGE_FIRSTRETRACT
+            target[E_AXIS]+= FILAMENTCHANGE_FIRSTRETRACT ;
+          #endif
+        }
+        plan_buffer_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], target[E_AXIS], feedrate/60, active_extruder);
+        
+        //lift Z
+        if(code_seen('Z')) 
+        {
+          target[Z_AXIS]+= code_value();
+        }
+        else
+        {
+          #ifdef FILAMENTCHANGE_ZADD
+            target[Z_AXIS]+= FILAMENTCHANGE_ZADD ;
+          #endif
+        }
+        plan_buffer_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], target[E_AXIS], feedrate/60, active_extruder);
+        
+        //move xy
+        if(code_seen('X')) 
+        {
+          target[X_AXIS]+= code_value();
+        }
+        else
+        {
+          #ifdef FILAMENTCHANGE_XPOS
+            target[X_AXIS]= FILAMENTCHANGE_XPOS ;
+          #endif
+        }
+        if(code_seen('Y')) 
+        {
+          target[Y_AXIS]= code_value();
+        }
+        else
+        {
+          #ifdef FILAMENTCHANGE_YPOS
+            target[Y_AXIS]= FILAMENTCHANGE_YPOS ;
+          #endif
+        }
+        
+        plan_buffer_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], target[E_AXIS], feedrate/60, active_extruder);
+        
+        if(code_seen('L'))
+        {
+          target[E_AXIS]+= code_value();
+        }
+        else
+        {
+          #ifdef FILAMENTCHANGE_FINALRETRACT
+            target[E_AXIS]+= FILAMENTCHANGE_FINALRETRACT ;
+          #endif
+        }
+        
+        plan_buffer_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], target[E_AXIS], feedrate/60, active_extruder);
+        
+        //finish moves
+        st_synchronize();
+        //disable extruder steppers so filament can be removed
+        disable_e0();
+        disable_e1();
+        disable_e2();
+        delay(100);
+        LCD_ALERTMESSAGEPGM(MSG_FILAMENTCHANGE);
+        uint8_t cnt=0;
+        while(!LCD_CLICKED){
+          cnt++;
+          manage_heater();
+          manage_inactivity();
+          lcd_update();
+          
+          #if BEEPER > -1
+          if(cnt==0)
+          {
+            SET_OUTPUT(BEEPER);
+            
+            WRITE(BEEPER,HIGH);
+            delay(3);
+            WRITE(BEEPER,LOW);
+            delay(3);
+          }
+          #endif
+        }
+        
+        //return to normal
+        if(code_seen('L')) 
+        {
+          target[E_AXIS]+= -code_value();
+        }
+        else
+        {
+          #ifdef FILAMENTCHANGE_FINALRETRACT
+            target[E_AXIS]+=(-1)*FILAMENTCHANGE_FINALRETRACT ;
+          #endif
+        }
+        current_position[E_AXIS]=target[E_AXIS]; //the long retract of L is compensated by manual filament feeding
+        plan_set_e_position(current_position[E_AXIS]);
+        plan_buffer_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], target[E_AXIS], feedrate/60, active_extruder); //should do nothing
+        plan_buffer_line(lastpos[X_AXIS], lastpos[Y_AXIS], target[Z_AXIS], target[E_AXIS], feedrate/60, active_extruder); //move xy back
+        plan_buffer_line(lastpos[X_AXIS], lastpos[Y_AXIS], lastpos[Z_AXIS], target[E_AXIS], feedrate/60, active_extruder); //move z back
+        plan_buffer_line(lastpos[X_AXIS], lastpos[Y_AXIS], lastpos[Z_AXIS], lastpos[E_AXIS], feedrate/60, active_extruder); //final untretract
+    }
+    break;
+    #endif //FILAMENTCHANGEENABLE    
+    case 907: // M907 Set digital trimpot motor current using axis codes.
+    {
+      #if DIGIPOTSS_PIN > -1
+        for(int i=0;i<=NUM_AXIS;i++) if(code_seen(axis_codes[i])) digipot_current(i,code_value());
+        if(code_seen('B')) digipot_current(4,code_value());
+        if(code_seen('S')) for(int i=0;i<=4;i++) digipot_current(i,code_value());
+      #endif
+    }
+    case 908: // M908 Control digital trimpot directly.
+    {
+      #if DIGIPOTSS_PIN > -1
+        uint8_t channel,current;
+        if(code_seen('P')) channel=code_value();
+        if(code_seen('S')) current=code_value();
+        digitalPotWrite(channel, current);
+      #endif
+    }
+    break;
+    case 350: // M350 Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
+    {
+      #if X_MS1_PIN > -1
+        if(code_seen('S')) for(int i=0;i<=4;i++) microstep_mode(i,code_value()); 
+        for(int i=0;i<=NUM_AXIS;i++) if(code_seen(axis_codes[i])) microstep_mode(i,(uint8_t)code_value());
+        if(code_seen('B')) microstep_mode(4,code_value());
+        microstep_readings();
+      #endif
+    }
+    break;
+    case 351: // M351 Toggle MS1 MS2 pins directly, S# determines MS1 or MS2, X# sets the pin high/low.
+    {
+      #if X_MS1_PIN > -1
+      if(code_seen('S')) switch((int)code_value())
+      {
+        case 1:
+          for(int i=0;i<=NUM_AXIS;i++) if(code_seen(axis_codes[i])) microstep_ms(i,code_value(),-1);
+          if(code_seen('B')) microstep_ms(4,code_value(),-1);
+          break;
+        case 2:
+          for(int i=0;i<=NUM_AXIS;i++) if(code_seen(axis_codes[i])) microstep_ms(i,-1,code_value());
+          if(code_seen('B')) microstep_ms(4,-1,code_value());
+          break;
+      }
+      microstep_readings();
+      #endif
+    }
+    break;
+    case 999: // M999: Restart after being stopped
+      Stopped = false;
+      lcd_reset_alert_level();
+      gcode_LastN = Stopped_gcode_LastN;
+      FlushSerialRequestResend();
+    break;
+    }
+  }
+
+  else if(code_seen('T')) 
+  {
+    tmp_extruder = code_value();
+    if(tmp_extruder >= EXTRUDERS) {
+      SERIAL_ECHO_START;
+      SERIAL_ECHO("T");
+      SERIAL_ECHO(tmp_extruder);
+      SERIAL_ECHOLN(MSG_INVALID_EXTRUDER);
+    }
+    else {
+      boolean make_move = false;
+      if(code_seen('F')) {
+        make_move = true;
+        next_feedrate = code_value();
+        if(next_feedrate > 0.0) {
+          feedrate = next_feedrate;
+        }
+      }
+      #if EXTRUDERS > 1
+      if(tmp_extruder != active_extruder) {
+        // Save current position to return to after applying extruder offset
+        memcpy(destination, current_position, sizeof(destination));
+        // Offset extruder (only by XY)
+        int i;
+        for(i = 0; i < 2; i++) {
+           current_position[i] = current_position[i] - 
+                                 extruder_offset[i][active_extruder] +
+                                 extruder_offset[i][tmp_extruder];
+        }
+        // Set the new active extruder and position
+        active_extruder = tmp_extruder;
+        plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+        // Move to the old position if 'F' was in the parameters
+        if(make_move && Stopped == false) {
+           prepare_move();
+        }
+      }
+      #endif
+      SERIAL_ECHO_START;
+      SERIAL_ECHO(MSG_ACTIVE_EXTRUDER);
+      SERIAL_PROTOCOLLN((int)active_extruder);
+    }
+  }
+
+  else
+  {
+    SERIAL_ECHO_START;
+    SERIAL_ECHOPGM(MSG_UNKNOWN_COMMAND);
+    SERIAL_ECHO(cmdbuffer[bufindr]);
+    SERIAL_ECHOLNPGM("\"");
+  }
+
+  ClearToSend();
+}
+
+void FlushSerialRequestResend()
+{
+  //char cmdbuffer[bufindr][100]="Resend:";
+  MYSERIAL.flush();
+  SERIAL_PROTOCOLPGM(MSG_RESEND);
+  SERIAL_PROTOCOLLN(gcode_LastN + 1);
+  ClearToSend();
+}
+
+void ClearToSend()
+{
+  previous_millis_cmd = millis();
+  #ifdef SDSUPPORT
+  if(fromsd[bufindr])
+    return;
+  #endif //SDSUPPORT
+  SERIAL_PROTOCOLLNPGM(MSG_OK); 
+}
+
+void get_coordinates()
+{
+  bool seen[4]={false,false,false,false};
+  for(int8_t i=0; i < NUM_AXIS; i++) {
+    if(code_seen(axis_codes[i])) 
+    {
+      destination[i] = (float)code_value() + (axis_relative_modes[i] || relative_mode)*current_position[i];
+      seen[i]=true;
+    }
+    else destination[i] = current_position[i]; //Are these else lines really needed?
+  }
+  if(code_seen('F')) {
+    next_feedrate = code_value();
+    if(next_feedrate > 0.0) feedrate = next_feedrate;
+  }
+  #ifdef FWRETRACT
+  if(autoretract_enabled)
+  if( !(seen[X_AXIS] || seen[Y_AXIS] || seen[Z_AXIS]) && seen[E_AXIS])
+  {
+    float echange=destination[E_AXIS]-current_position[E_AXIS];
+    if(echange<-MIN_RETRACT) //retract
+    {
+      if(!retracted) 
+      {
+      
+      destination[Z_AXIS]+=retract_zlift; //not sure why chaninging current_position negatively does not work.
+      //if slicer retracted by echange=-1mm and you want to retract 3mm, corrrectede=-2mm additionally
+      float correctede=-echange-retract_length;
+      //to generate the additional steps, not the destination is changed, but inversely the current position
+      current_position[E_AXIS]+=-correctede; 
+      feedrate=retract_feedrate;
+      retracted=true;
+      }
+      
+    }
+    else 
+      if(echange>MIN_RETRACT) //retract_recover
+    {
+      if(retracted) 
+      {
+      //current_position[Z_AXIS]+=-retract_zlift;
+      //if slicer retracted_recovered by echange=+1mm and you want to retract_recover 3mm, corrrectede=2mm additionally
+      float correctede=-echange+1*retract_length+retract_recover_length; //total unretract=retract_length+retract_recover_length[surplus]
+      current_position[E_AXIS]+=correctede; //to generate the additional steps, not the destination is changed, but inversely the current position
+      feedrate=retract_recover_feedrate;
+      retracted=false;
+      }
+    }
+    
+  }
+  #endif //FWRETRACT
+}
+
+void get_arc_coordinates()
+{
+#ifdef SF_ARC_FIX
+   bool relative_mode_backup = relative_mode;
+   relative_mode = true;
+#endif
+   get_coordinates();
+#ifdef SF_ARC_FIX
+   relative_mode=relative_mode_backup;
+#endif
+
+   if(code_seen('I')) {
+     offset[0] = code_value();
+   } 
+   else {
+     offset[0] = 0.0;
+   }
+   if(code_seen('J')) {
+     offset[1] = code_value();
+   }
+   else {
+     offset[1] = 0.0;
+   }
+}
+
+void clamp_to_software_endstops(float target[3])
+{
+  if (min_software_endstops) {
+    if (target[X_AXIS] < min_pos[X_AXIS]) target[X_AXIS] = min_pos[X_AXIS];
+    if (target[Y_AXIS] < min_pos[Y_AXIS]) target[Y_AXIS] = min_pos[Y_AXIS];
+    if (target[Z_AXIS] < min_pos[Z_AXIS]) target[Z_AXIS] = min_pos[Z_AXIS];
+  }
+
+  if (max_software_endstops) {
+    if (target[X_AXIS] > max_pos[X_AXIS]) target[X_AXIS] = max_pos[X_AXIS];
+    if (target[Y_AXIS] > max_pos[Y_AXIS]) target[Y_AXIS] = max_pos[Y_AXIS];
+    if (target[Z_AXIS] > max_pos[Z_AXIS]) target[Z_AXIS] = max_pos[Z_AXIS];
+  }
+}
+
+void prepare_move()
+{
+  clamp_to_software_endstops(destination);
+
+  previous_millis_cmd = millis(); 
+  // Do not use feedmultiply for E or Z only moves
+  if( (current_position[X_AXIS] == destination [X_AXIS]) && (current_position[Y_AXIS] == destination [Y_AXIS])) {
+      plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
+  }
+  else {
+    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate*feedmultiply/60/100.0, active_extruder);
+  }
+  for(int8_t i=0; i < NUM_AXIS; i++) {
+    current_position[i] = destination[i];
+  }
+}
+
+void prepare_arc_move(char isclockwise) {
+  float r = hypot(offset[X_AXIS], offset[Y_AXIS]); // Compute arc radius for mc_arc
+
+  // Trace the arc
+  mc_arc(current_position, destination, offset, X_AXIS, Y_AXIS, Z_AXIS, feedrate*feedmultiply/60/100.0, r, isclockwise, active_extruder);
+  
+  // As far as the parser is concerned, the position is now == target. In reality the
+  // motion control system might still be processing the action and the real tool position
+  // in any intermediate location.
+  for(int8_t i=0; i < NUM_AXIS; i++) {
+    current_position[i] = destination[i];
+  }
+  previous_millis_cmd = millis();
+}
+
+#ifdef CONTROLLERFAN_PIN
+unsigned long lastMotor = 0; //Save the time for when a motor was turned on last
+unsigned long lastMotorCheck = 0;
+
+void controllerFan()
+{
+  if ((millis() - lastMotorCheck) >= 2500) //Not a time critical function, so we only check every 2500ms
+  {
+    lastMotorCheck = millis();
+    
+    if(!READ(X_ENABLE_PIN) || !READ(Y_ENABLE_PIN) || !READ(Z_ENABLE_PIN)
+    #if EXTRUDERS > 2
+       || !READ(E2_ENABLE_PIN)
+    #endif
+    #if EXTRUDER > 1
+       || !READ(E2_ENABLE_PIN)
+    #endif
+       || !READ(E0_ENABLE_PIN)) //If any of the drivers are enabled...    
+    {
+      lastMotor = millis(); //... set time to NOW so the fan will turn on
+    }
+    
+    if ((millis() - lastMotor) >= (CONTROLLERFAN_SEC*1000UL) || lastMotor == 0) //If the last time any driver was enabled, is longer since than CONTROLLERSEC...   
+    {
+      WRITE(CONTROLLERFAN_PIN, LOW); //... turn the fan off
+    }
+    else
+    {
+      WRITE(CONTROLLERFAN_PIN, HIGH); //... turn the fan on
+    }
+  }
+}
+#endif
+
+#ifdef EXTRUDERFAN_PIN
+unsigned long lastExtruderCheck = 0;
+
+void extruderFan()
+{
+  if ((millis() - lastExtruderCheck) >= 2500) //Not a time critical function, so we only check every 2500ms
+  {
+    lastExtruderCheck = millis();
+           
+    if (degHotend(active_extruder) < EXTRUDERFAN_DEC)
+    {
+      WRITE(EXTRUDERFAN_PIN, LOW); //... turn the fan off
+    }
+    else
+    {
+      WRITE(EXTRUDERFAN_PIN, HIGH); //... turn the fan on
+    }
+  }
+}
+#endif
+
+void manage_inactivity() 
+{ 
+  if( (millis() - previous_millis_cmd) >  max_inactive_time ) 
+    if(max_inactive_time) 
+      kill(); 
+  if(stepper_inactive_time)  {
+    if( (millis() - previous_millis_cmd) >  stepper_inactive_time ) 
+    {
+      if(blocks_queued() == false) {
+        disable_x();
+        disable_y();
+        disable_z();
+        disable_e0();
+        disable_e1();
+        disable_e2();
+      }
+    }
+  }
+  #if( KILL_PIN>-1 )
+    if( 0 == READ(KILL_PIN) )
+      kill();
+  #endif
+  #ifdef CONTROLLERFAN_PIN
+    controllerFan(); //Check if fan should be turned on to cool stepper drivers down
+  #endif
+  #ifdef EXTRUDER_RUNOUT_PREVENT
+    if( (millis() - previous_millis_cmd) >  EXTRUDER_RUNOUT_SECONDS*1000 ) 
+    if(degHotend(active_extruder)>EXTRUDER_RUNOUT_MINTEMP)
+    {
+     bool oldstatus=READ(E0_ENABLE_PIN);
+     enable_e0();
+     float oldepos=current_position[E_AXIS];
+     float oldedes=destination[E_AXIS];
+     plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], 
+                      current_position[E_AXIS]+EXTRUDER_RUNOUT_EXTRUDE*EXTRUDER_RUNOUT_ESTEPS/axis_steps_per_unit[E_AXIS], 
+                      EXTRUDER_RUNOUT_SPEED/60.*EXTRUDER_RUNOUT_ESTEPS/axis_steps_per_unit[E_AXIS], active_extruder);
+     current_position[E_AXIS]=oldepos;
+     destination[E_AXIS]=oldedes;
+     plan_set_e_position(oldepos);
+     previous_millis_cmd=millis();
+     st_synchronize();
+     WRITE(E0_ENABLE_PIN,oldstatus);
+    }
+  #endif
+  check_axes_activity();
+}
+
+void kill()
+{
+  cli(); // Stop interrupts
+  disable_heater();
+
+  disable_x();
+  disable_y();
+  disable_z();
+  disable_e0();
+  disable_e1();
+  disable_e2();
+  
+  if(PS_ON_PIN > -1) pinMode(PS_ON_PIN,INPUT);
+  SERIAL_ERROR_START;
+  SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
+  LCD_ALERTMESSAGEPGM(MSG_KILLED);
+  suicide();
+  while(1) { /* Intentionally left empty */ } // Wait for reset
+}
+
+void Stop()
+{
+  disable_heater();
+  if(Stopped == false) {
+    Stopped = true;
+    Stopped_gcode_LastN = gcode_LastN; // Save last g_code for restart
+    SERIAL_ERROR_START;
+    SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
+    LCD_MESSAGEPGM(MSG_STOPPED);
+  }
+}
+
+bool IsStopped() { return Stopped; };
+
+#ifdef FAST_PWM_FAN
+void setPwmFrequency(uint8_t pin, int val)
+{
+  val &= 0x07;
+  switch(digitalPinToTimer(pin))
+  {
+ 
+    #if defined(TCCR0A)
+    case TIMER0A:
+    case TIMER0B:
+//         TCCR0B &= ~(_BV(CS00) | _BV(CS01) | _BV(CS02));
+//         TCCR0B |= val;
+         break;
+    #endif
+
+    #if defined(TCCR1A)
+    case TIMER1A:
+    case TIMER1B:
+//         TCCR1B &= ~(_BV(CS10) | _BV(CS11) | _BV(CS12));
+//         TCCR1B |= val;
+         break;
+    #endif
+
+    #if defined(TCCR2)
+    case TIMER2:
+    case TIMER2:
+         TCCR2 &= ~(_BV(CS10) | _BV(CS11) | _BV(CS12));
+         TCCR2 |= val;
+         break;
+    #endif
+
+    #if defined(TCCR2A)
+    case TIMER2A:
+    case TIMER2B:
+         TCCR2B &= ~(_BV(CS20) | _BV(CS21) | _BV(CS22));
+         TCCR2B |= val;
+         break;
+    #endif
+
+    #if defined(TCCR3A)
+    case TIMER3A:
+    case TIMER3B:
+    case TIMER3C:
+         TCCR3B &= ~(_BV(CS30) | _BV(CS31) | _BV(CS32));
+         TCCR3B |= val;
+         break;
+    #endif
+
+    #if defined(TCCR4A) 
+    case TIMER4A:
+    case TIMER4B:
+    case TIMER4C:
+         TCCR4B &= ~(_BV(CS40) | _BV(CS41) | _BV(CS42));
+         TCCR4B |= val;
+         break;
+   #endif
+
+    #if defined(TCCR5A) 
+    case TIMER5A:
+    case TIMER5B:
+    case TIMER5C:
+         TCCR5B &= ~(_BV(CS50) | _BV(CS51) | _BV(CS52));
+         TCCR5B |= val;
+         break;
+   #endif
+
+  }
+}
+#endif //FAST_PWM_FAN
+
+bool setTargetedHotend(int code){
+  tmp_extruder = active_extruder;
+  if(code_seen('T')) {
+    tmp_extruder = code_value();
+    if(tmp_extruder >= EXTRUDERS) {
+      SERIAL_ECHO_START;
+      switch(code){
+        case 104:
+          SERIAL_ECHO(MSG_M104_INVALID_EXTRUDER);
+          break;
+        case 105:
+          SERIAL_ECHO(MSG_M105_INVALID_EXTRUDER);
+          break;
+        case 109:
+          SERIAL_ECHO(MSG_M109_INVALID_EXTRUDER);
+          break;
+        case 218:
+          SERIAL_ECHO(MSG_M218_INVALID_EXTRUDER);
+          break;
+      }
+      SERIAL_ECHOLN(tmp_extruder);
+      return true;
+    }
+  }
+  return false;
 }
diff --git a/Marlin/language.h b/Marlin/language.h
index 15ebb98..51d40a2 100644
--- a/Marlin/language.h
+++ b/Marlin/language.h
@@ -1,1464 +1,1467 @@
-#ifndef LANGUAGE_H
-#define LANGUAGE_H
-
-// NOTE: IF YOU CHANGE THIS FILE / MERGE THIS FILE WITH CHANGES
-//
-//   ==> ALWAYS TRY TO COMPILE MARLIN WITH/WITHOUT "ULTIPANEL" / "ULTRALCD" / "SDSUPPORT" #define IN "Configuration.h" 
-//   ==> ALSO TRY ALL AVAILABLE "LANGUAGE_CHOICE" OPTIONS
-
-// Languages
-// 1  English
-// 2  Polish
-// 3  French	(awaiting translation!)
-// 4  German
-// 5  Spanish
-// 6  Russian
-// 7  Italian
-// 8  Portuguese
-// 9  Finnish
-
-#ifndef LANGUAGE_CHOICE
-#define LANGUAGE_CHOICE 1  // Pick your language from the list above
-#endif
-
-#define PROTOCOL_VERSION "1.0"
-
-#if MOTHERBOARD == 7 || MOTHERBOARD == 71
-	#define MACHINE_NAME "Ultimaker"
-	#define FIRMWARE_URL "http://firmware.ultimaker.com"
-#else
-	#define MACHINE_NAME "Mendel"
-	#define FIRMWARE_URL "http://www.mendel-parts.com"
-#endif
-
-#define STRINGIFY_(n) #n
-#define STRINGIFY(n) STRINGIFY_(n)
-
-#if LANGUAGE_CHOICE == 1
-
-// LCD Menu Messages
-	#define WELCOME_MSG MACHINE_NAME " Ready."
-	#define MSG_SD_INSERTED "Card inserted"
-	#define MSG_SD_REMOVED "Card removed"
-	#define MSG_MAIN "Main"
-	#define MSG_AUTOSTART "Autostart"
-	#define MSG_DISABLE_STEPPERS "Disable Steppers"
-	#define MSG_AUTO_HOME "Auto Home"
-	#define MSG_SET_ORIGIN "Set Origin"
-	#define MSG_PREHEAT_PLA "Preheat PLA"
-	#define MSG_PREHEAT_PLA_SETTINGS "Preheat PLA Conf"
-	#define MSG_PREHEAT_ABS "Preheat ABS"
-	#define MSG_PREHEAT_ABS_SETTINGS "Preheat ABS Conf"
-	#define MSG_COOLDOWN "Cooldown"
-	#define MSG_EXTRUDE "Extrude"
-	#define MSG_RETRACT "Retract"
-	#define MSG_MOVE_AXIS "Move Axis"
-	#define MSG_SPEED "Speed"
-	#define MSG_NOZZLE "Nozzle"
-	#define MSG_NOZZLE1 "Nozzle2"
-	#define MSG_NOZZLE2 "Nozzle3"
-	#define MSG_BED "Bed"
-	#define MSG_FAN_SPEED "Fan speed"
-	#define MSG_FLOW "Flow"
-	#define MSG_CONTROL "Control"
-	#define MSG_MIN " \002 Min"
-	#define MSG_MAX " \002 Max"
-	#define MSG_FACTOR " \002 Fact"
-	#define MSG_AUTOTEMP "Autotemp"
-	#define MSG_ON "On "
-	#define MSG_OFF "Off"
-	#define MSG_PID_P "PID-P"
-	#define MSG_PID_I "PID-I"
-	#define MSG_PID_D "PID-D"
-	#define MSG_PID_C "PID-C"
-	#define MSG_ACC  "Accel"
-	#define MSG_VXY_JERK "Vxy-jerk"
-	#define MSG_VMAX "Vmax "
-	#define MSG_X "x"
-	#define MSG_Y "y"
-	#define MSG_Z "z"
-	#define MSG_E "e"
-	#define MSG_VMIN "Vmin"
-	#define MSG_VTRAV_MIN "VTrav min"
-	#define MSG_AMAX "Amax "
-	#define MSG_A_RETRACT "A-retract"
-	#define MSG_XSTEPS "Xsteps/mm"
-	#define MSG_YSTEPS "Ysteps/mm"
-	#define MSG_ZSTEPS "Zsteps/mm"
-	#define MSG_ESTEPS "Esteps/mm"
-	#define MSG_RECTRACT "Rectract"
-	#define MSG_TEMPERATURE "Temperature"
-	#define MSG_MOTION "Motion"
-	#define MSG_STORE_EPROM "Store memory"
-	#define MSG_LOAD_EPROM "Load memory"
-	#define MSG_RESTORE_FAILSAFE "Restore Failsafe"
-	#define MSG_REFRESH "Refresh"
-	#define MSG_WATCH "Watch"
-	#define MSG_PREPARE "Prepare"
-	#define MSG_TUNE "Tune"
-	#define MSG_PAUSE_PRINT "Pause Print"
-	#define MSG_RESUME_PRINT "Resume Print"
-	#define MSG_STOP_PRINT "Stop Print"
-	#define MSG_CARD_MENU "Card Menu"
-	#define MSG_NO_CARD "No Card"
-	#define MSG_DWELL "Sleep..."
-	#define MSG_USERWAIT "Wait for user..."
-	#define MSG_RESUMING "Resuming print"
-	#define MSG_NO_MOVE "No move."
-	#define MSG_KILLED "KILLED. "
-	#define MSG_STOPPED "STOPPED. "
-	#define MSG_CONTROL_RETRACT  "Retract mm"
-	#define MSG_CONTROL_RETRACTF "Retract  F"
-	#define MSG_CONTROL_RETRACT_ZLIFT "Hop mm"
-	#define MSG_CONTROL_RETRACT_RECOVER "UnRet +mm"
-	#define MSG_CONTROL_RETRACT_RECOVERF "UnRet  F"
-	#define MSG_AUTORETRACT "AutoRetr."
-	#define MSG_FILAMENTCHANGE "Change filament"
-	#define MSG_INIT_SDCARD "Init. SD-Card"	
-	#define MSG_CNG_SDCARD "Change SD-Card"
-
-// Serial Console Messages
-
-	#define MSG_Enqueing "enqueing \""
-	#define MSG_POWERUP "PowerUp"
-	#define MSG_EXTERNAL_RESET " External Reset"
-	#define MSG_BROWNOUT_RESET " Brown out Reset"
-	#define MSG_WATCHDOG_RESET " Watchdog Reset"
-	#define MSG_SOFTWARE_RESET " Software Reset"
-	#define MSG_MARLIN "Marlin "
-	#define MSG_AUTHOR " | Author: "
-	#define MSG_CONFIGURATION_VER " Last Updated: "
-	#define MSG_FREE_MEMORY " Free Memory: "
-	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
-	#define MSG_OK "ok"
-	#define MSG_FILE_SAVED "Done saving file."
-	#define MSG_ERR_LINE_NO "Line Number is not Last Line Number+1, Last Line: "
-	#define MSG_ERR_CHECKSUM_MISMATCH "checksum mismatch, Last Line: "
-	#define MSG_ERR_NO_CHECKSUM "No Checksum with line number, Last Line: "
-	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "No Line Number with checksum, Last Line: "
-	#define MSG_FILE_PRINTED "Done printing file"
-	#define MSG_BEGIN_FILE_LIST "Begin file list"
-	#define MSG_END_FILE_LIST "End file list"
-	#define MSG_M104_INVALID_EXTRUDER "M104 Invalid extruder "
-	#define MSG_M105_INVALID_EXTRUDER "M105 Invalid extruder "
-	#define MSG_M218_INVALID_EXTRUDER "M218 Invalid extruder "
-	#define MSG_ERR_NO_THERMISTORS "No thermistors - no temperature"
-	#define MSG_M109_INVALID_EXTRUDER "M109 Invalid extruder "
-	#define MSG_HEATING "Heating..."
-	#define MSG_HEATING_COMPLETE "Heating done."
-	#define MSG_BED_HEATING "Bed Heating."
-	#define MSG_BED_DONE "Bed done."
-	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
-	#define MSG_COUNT_X " Count X: "
-	#define MSG_ERR_KILLED "Printer halted. kill() called!"
-	#define MSG_ERR_STOPPED "Printer stopped due to errors. Fix the error and use M999 to restart. (Temperature is reset. Set it after restarting)"
-	#define MSG_RESEND "Resend: "
-	#define MSG_UNKNOWN_COMMAND "Unknown command: \""
-	#define MSG_ACTIVE_EXTRUDER "Active Extruder: "
-	#define MSG_INVALID_EXTRUDER "Invalid extruder"
-	#define MSG_X_MIN "x_min: "
-	#define MSG_X_MAX "x_max: "
-	#define MSG_Y_MIN "y_min: "
-	#define MSG_Y_MAX "y_max: "
-	#define MSG_Z_MIN "z_min: "
-	#define MSG_Z_MAX "z_max: "
-	#define MSG_M119_REPORT "Reporting endstop status"
-	#define MSG_ENDSTOP_HIT "TRIGGERED"
-	#define MSG_ENDSTOP_OPEN "open"
-	#define MSG_HOTEND_OFFSET "Hotend offsets:"
-
-	#define MSG_SD_CANT_OPEN_SUBDIR "Cannot open subdir"
-	#define MSG_SD_INIT_FAIL "SD init fail"
-	#define MSG_SD_VOL_INIT_FAIL "volume.init failed"
-	#define MSG_SD_OPENROOT_FAIL "openRoot failed"
-	#define MSG_SD_CARD_OK "SD card ok"
-	#define MSG_SD_WORKDIR_FAIL "workDir open failed"
-	#define MSG_SD_OPEN_FILE_FAIL "open failed, File: "
-	#define MSG_SD_FILE_OPENED "File opened: "
-	#define MSG_SD_SIZE " Size: "
-	#define MSG_SD_FILE_SELECTED "File selected"
-	#define MSG_SD_WRITE_TO_FILE "Writing to file: "
-	#define MSG_SD_PRINTING_BYTE "SD printing byte "
-	#define MSG_SD_NOT_PRINTING "Not SD printing"
-	#define MSG_SD_ERR_WRITE_TO_FILE "error writing to file"
-	#define MSG_SD_CANT_ENTER_SUBDIR "Cannot enter subdir: "
-
-	#define MSG_STEPPER_TO_HIGH "Steprate to high: "
-	#define MSG_ENDSTOPS_HIT "endstops hit: "
-	#define MSG_ERR_COLD_EXTRUDE_STOP " cold extrusion prevented"
-	#define MSG_ERR_LONG_EXTRUDE_STOP " too long extrusion prevented"
-
-#endif
-
-
-#if LANGUAGE_CHOICE == 2
-
-// LCD Menu Messages
-	#define WELCOME_MSG MACHINE_NAME " Gotowe."
-	#define MSG_SD_INSERTED "Karta wlozona"
-	#define MSG_SD_REMOVED "Karta usunieta"
-	#define MSG_MAIN "Main"
-	#define MSG_AUTOSTART "Autostart"
-	#define MSG_DISABLE_STEPPERS "Wylacz silniki"
-	#define MSG_AUTO_HOME "Auto. poz. zerowa"
-	#define MSG_SET_ORIGIN "Ustaw punkt zerowy"
-	#define MSG_PREHEAT_PLA "Rozgrzej PLA"
-	#define MSG_PREHEAT_PLA_SETTINGS "Ustawienia roz. PLA"
-	#define MSG_PREHEAT_ABS "Rozgrzej ABS"
-	#define MSG_PREHEAT_ABS_SETTINGS "Ustawienia roz. ABS"
-	#define MSG_COOLDOWN "Chlodzenie"
-	#define MSG_EXTRUDE "Ekstruzja"
-	#define MSG_RETRACT "Cofanie"
-	#define MSG_MOVE_AXIS "Ruch osi"
-	#define MSG_SPEED "Predkosc"
-	#define MSG_NOZZLE "Dysza"
-	#define MSG_NOZZLE1 "Dysza2"
-	#define MSG_NOZZLE2 "Dysza3"
-	#define MSG_BED "Loze"
-	#define MSG_FAN_SPEED "Obroty wiatraka"
-	#define MSG_FLOW "Przeplyw"
-	#define MSG_CONTROL "Kontrola"
-	#define MSG_MIN " \002 Min"
-	#define MSG_MAX " \002 Max"
-	#define MSG_FACTOR " \002 Mnoznik"
-	#define MSG_AUTOTEMP "Auto. temp."
-	#define MSG_ON "Wl. "
-	#define MSG_OFF "Wyl."
-	#define MSG_PID_P "PID-P"
-	#define MSG_PID_I "PID-I"
-	#define MSG_PID_D "PID-D"
-	#define MSG_PID_C "PID-C"
-	#define MSG_ACC  "Acc"
-	#define MSG_VXY_JERK "Zryw Vxy"
-	#define MSG_VMAX "Vmax"
-	#define MSG_X "x"
-	#define MSG_Y "y"
-	#define MSG_Z "z"
-	#define MSG_E "e"
-	#define MSG_VMIN "Vmin"
-	#define MSG_VTRAV_MIN "Vskok min"
-	#define MSG_AMAX "Amax"
-	#define MSG_A_RETRACT "A-wycofanie"
-	#define MSG_XSTEPS "krokiX/mm"
-	#define MSG_YSTEPS "krokiY/mm"
-	#define MSG_ZSTEPS "krokiZ/mm"
-	#define MSG_ESTEPS "krokiE/mm"
-	#define MSG_RECTRACT "Wycofanie"
-	#define MSG_TEMPERATURE "Temperatura"
-	#define MSG_MOTION "Ruch"
-	#define MSG_STORE_EPROM "Zapisz w pamieci"
-	#define MSG_LOAD_EPROM "Wczytaj z pamieci"
-	#define MSG_RESTORE_FAILSAFE " Ustawienia fabryczne"
-	#define MSG_REFRESH "\004Odswiez"
-	#define MSG_WATCH "Obserwuj"
-	#define MSG_PREPARE "Przygotuj"
-	#define MSG_CONTROL "Kontroluj"
-	#define MSG_TUNE "Strojenie"
-	#define MSG_PAUSE_PRINT "Pauza"
-	#define MSG_RESUME_PRINT "Wznowienie"
-	#define MSG_STOP_PRINT "Stop"
-	#define MSG_CARD_MENU "Menu SDCard"
-	#define MSG_NO_CARD "Brak karty"
-	#define MSG_DWELL "Uspij..."
-	#define MSG_USERWAIT "Czekaj na uzytkownika..."
-	#define MSG_RESUMING "Wznawiam drukowanie"
-	#define MSG_NO_MOVE "Brak ruchu."
-	#define MSG_PART_RELEASE "Czesciowe zwolnienie"
-	#define MSG_KILLED "Ubity. "
-	#define MSG_STOPPED "Zatrzymany. "
-	#define MSG_STEPPER_RELEASED "Zwolniony."
-	#define MSG_CONTROL_RETRACT  "Wycofaj mm"
-	#define MSG_CONTROL_RETRACTF "Wycofaj  F"
-	#define MSG_CONTROL_RETRACT_ZLIFT "Skok Z mm:"
-	#define MSG_CONTROL_RETRACT_RECOVER "Cof. wycof. +mm"
-	#define MSG_CONTROL_RETRACT_RECOVERF "Cof. wycof.  F"
-	#define MSG_AUTORETRACT "Auto. wycofanie"
-	#define MSG_FILAMENTCHANGE "Change filament"
-
-// Serial Console Messages
-
-	#define MSG_Enqueing "Kolejkowanie \""
-	#define MSG_POWERUP "Zasilanie wlaczone"
-	#define MSG_EXTERNAL_RESET " Reset (zewnetrzny)"
-	#define MSG_BROWNOUT_RESET " Reset (spadek napiecia)"
-	#define MSG_WATCHDOG_RESET " Reset (watchdog)"
-	#define MSG_SOFTWARE_RESET " Reset (programowy)"
-	#define MSG_MARLIN "Marlin "
-	#define MSG_AUTHOR " | Autor: "
-	#define MSG_CONFIGURATION_VER " Ostatnia aktualizacja: "
-	#define MSG_FREE_MEMORY " Wolna pamiec: "
-	#define MSG_PLANNER_BUFFER_BYTES "  Bufor planisty krokow (w bajtach): "
-	#define MSG_OK "ok"
-	#define MSG_FILE_SAVED "Plik zapisany."
-	#define MSG_ERR_LINE_NO "Numer linijki nie jest ostatnim numerem linijki+1; ostatnia linijka:"
-	#define MSG_ERR_CHECKSUM_MISMATCH "Niezgodna suma kontrolna; ostatnia linijka: "
-	#define MSG_ERR_NO_CHECKSUM "Brak sumy kontrolnej w linijce; ostatnia linijka:"
-	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Brak numery linijki przy sumie kontrolnej; ostatnia linijka:"
-	#define MSG_FILE_PRINTED "Ukonczono wydruk z pliku"
-	#define MSG_BEGIN_FILE_LIST "Start listy plikow"
-	#define MSG_END_FILE_LIST "Koniec listy plikow"
-	#define MSG_M104_INVALID_EXTRUDER "M104 Niepoprawny ekstruder "
-	#define MSG_M105_INVALID_EXTRUDER "M105 Niepoprawny ekstruder "
-	#define MSG_M218_INVALID_EXTRUDER "M218 Niepoprawny ekstruder "
-	#define MSG_ERR_NO_THERMISTORS "Brak termistorow - brak temperatury :("
-	#define MSG_M109_INVALID_EXTRUDER "M109 Niepoprawny ekstruder "
-	#define MSG_HEATING "Nagrzewanie ekstrudera..."
-	#define MSG_HEATING_COMPLETE "Nagrzewanie ekstrudera zakonczone."
-	#define MSG_BED_HEATING "Nagrzewanie loza..."
-	#define MSG_BED_DONE "Nagrzewanie loza zakonczone."
-	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
-	#define MSG_COUNT_X " Liczenie X: "
-	#define MSG_ERR_KILLED "Drukarka zatrzymana. Wywolano kill()"
-	#define MSG_ERR_STOPPED "Drukarka zatrzymana z powodu bledu. Usun problem i zrestartuj drukartke komenda M999. (temperatura zostala zresetowana; ustaw temperature po restarcie)"
-	#define MSG_RESEND "Wyslij ponownie: "
-	#define MSG_UNKNOWN_COMMAND "Nieznane polecenie: \""
-	#define MSG_ACTIVE_EXTRUDER "Aktywny ekstruder: "
-	#define MSG_INVALID_EXTRUDER "Niepoprawny ekstruder"
-	#define MSG_X_MIN "x_min: "
-	#define MSG_X_MAX "x_max: "
-	#define MSG_Y_MIN "y_min: "
-	#define MSG_Y_MAX "y_max: "
-	#define MSG_Z_MIN "z_min: "
-	#define MSG_Z_MAX "z_max: "
-	#define MSG_M119_REPORT "Zgloszenie statusu wylacznikow krancowych"
-	#define MSG_ENDSTOP_HIT "WYZWOLONY"
-	#define MSG_ENDSTOP_OPEN "otwarty"
-	#define MSG_HOTEND_OFFSET "Hotend offsets:"
-
-	#define MSG_SD_CANT_OPEN_SUBDIR "Nie mozna otworzyc podkatalogu"
-	#define MSG_SD_INIT_FAIL "Blad inicjalizacji karty SD"
-	#define MSG_SD_VOL_INIT_FAIL "Blad inizjalizacji wolumenu"
-	#define MSG_SD_OPENROOT_FAIL "Blad odczytywania katalogu glownego"
-	#define MSG_SD_CARD_OK "Karta SD zainicjalizowana"
-	#define MSG_SD_WORKDIR_FAIL "Blad odczytywania katalogu roboczego"
-	#define MSG_SD_OPEN_FILE_FAIL "Nie mozna otworzyc pliku: "
-	#define MSG_SD_FILE_OPENED "Otwarto plik:"
-	#define MSG_SD_SIZE " Rozmiar:"
-	#define MSG_SD_FILE_SELECTED "Wybrano plik"
-	#define MSG_SD_WRITE_TO_FILE "Zapisywanie do pliku: "
-	#define MSG_SD_PRINTING_BYTE "Drukowanie z karty SD, bajt "
-	#define MSG_SD_NOT_PRINTING "Nie trwa drukowanie z karty SD"
-	#define MSG_SD_ERR_WRITE_TO_FILE "blad podczas zapisu do pliku"
-	#define MSG_SD_CANT_ENTER_SUBDIR "Nie mozna odczytac podkatalogu: "
-
-	#define MSG_STEPPER_TO_HIGH "Za duza czestotliwosc krokow: "
-	#define MSG_ENDSTOPS_HIT "Wylacznik krancowy zostal wyzwolony na pozycji: "
-	#define MSG_ERR_COLD_EXTRUDE_STOP " uniemozliwiono zimna ekstruzje"
-	#define MSG_ERR_LONG_EXTRUDE_STOP " uniemozliwiono zbyt dluga ekstruzje"
-
-#endif
-
-
-#if LANGUAGE_CHOICE == 3
-
-#define WELCOME_MSG MACHINE_NAME " Pret."
-#define MSG_SD_INSERTED "Carte inseree"
-#define MSG_SD_REMOVED "Carte retiree"
-#define MSG_MAIN " Principal \003"
-#define MSG_AUTOSTART " Demarrage auto."
-#define MSG_DISABLE_STEPPERS " Desactiver moteurs"
-#define MSG_AUTO_HOME " Home auto."
-#define MSG_SET_ORIGIN " Regler origine"
-#define MSG_PREHEAT_PLA " Prechauffage PLA"
-#define MSG_PREHEAT_PLA_SETTINGS " Regl. prechauffe PLA"
-#define MSG_PREHEAT_ABS " Prechauffage ABS"
-#define MSG_PREHEAT_ABS_SETTINGS " Regl. prechauffe ABS"
-#define MSG_COOLDOWN " Refroidissement"
-#define MSG_EXTRUDE " Extrusion"
-#define MSG_RETRACT " Retractation"
-#define MSG_PREHEAT_PLA " Prechauffage PLA"
-#define MSG_PREHEAT_ABS " Prechauffage ABS"
-#define MSG_MOVE_AXIS " Deplacer axe \x7E"
-#define MSG_SPEED " Vitesse:"
-#define MSG_NOZZLE " \002Buse:"
-#define MSG_NOZZLE1 " \002Buse2:"
-#define MSG_NOZZLE2 " \002Buse3:"
-#define MSG_BED " \002Lit:"
-#define MSG_FAN_SPEED " Vitesse ventilateur:"
-#define MSG_FLOW " Flux:"
-#define MSG_CONTROL " Controle \003"
-#define MSG_MIN " \002 Min:"
-#define MSG_MAX " \002 Max:"
-#define MSG_FACTOR " \002 Facteur:"
-#define MSG_AUTOTEMP " Temp. Auto.:"
-#define MSG_ON "Marche "
-#define MSG_OFF "Arret"
-#define MSG_PID_P " PID-P: "
-#define MSG_PID_I " PID-I: "
-#define MSG_PID_D " PID-D: "
-#define MSG_PID_C " PID-C: "
-#define MSG_ACC " Acc:"
-#define MSG_VXY_JERK " Vxy-jerk: "
-#define MSG_VMAX " Vmax "
-#define MSG_X "x:"
-#define MSG_Y "y:"
-#define MSG_Z "z:"
-#define MSG_E "e:"
-#define MSG_VMIN " Vmin:"
-#define MSG_VTRAV_MIN " Vdepl min:"
-#define MSG_AMAX " Amax "
-#define MSG_A_RETRACT " A-retract:"
-#define MSG_XSTEPS " Xpas/mm:"
-#define MSG_YSTEPS " Ypas/mm:"
-#define MSG_ZSTEPS " Zpas/mm:"
-#define MSG_ESTEPS " Epas/mm:"
-#define MSG_MAIN_WIDE " Principal \003"
-#define MSG_RECTRACT_WIDE " Rectractater \x7E"
-#define MSG_TEMPERATURE_WIDE " Temperature \x7E"
-#define MSG_TEMPERATURE_RTN " Temperature \003"
-#define MSG_MOTION_WIDE " Mouvement \x7E"
-#define MSG_STORE_EPROM " Sauvegarder memoire"
-#define MSG_LOAD_EPROM " Lire memoire"
-#define MSG_RESTORE_FAILSAFE " Restaurer memoire"
-#define MSG_REFRESH "\004Actualiser"
-#define MSG_WATCH " Surveiller \003"
-#define MSG_PREPARE " Preparer \x7E"
-#define MSG_PREPARE_ALT " Prepare \003"
-#define MSG_CONTROL_ARROW " Controle \x7E"
-#define MSG_RETRACT_ARROW " Retracter \x7E"
-#define MSG_TUNE " Regler \x7E"
-#define MSG_PAUSE_PRINT " Pause impression \x7E"
-#define MSG_RESUME_PRINT " Reprendre impression \x7E"
-#define MSG_STOP_PRINT " Arreter impression \x7E"
-#define MSG_CARD_MENU " Menu carte \x7E"
-#define MSG_NO_CARD " Pas de carte"
-#define MSG_DWELL "Repos..."
-#define MSG_USERWAIT "Attente de l'utilisateur..."
-#define MSG_NO_MOVE "Aucun mouvement."
-#define MSG_PART_RELEASE "Relache partielle"
-#define MSG_KILLED "TUE."
-#define MSG_STOPPED "STOPPE."
-#define MSG_STEPPER_RELEASED "RELACHE."
-#define MSG_CONTROL_RETRACT " Retractation mm:"
-#define MSG_CONTROL_RETRACTF " Retractation F:"
-#define MSG_CONTROL_RETRACT_ZLIFT " Hop mm:"
-#define MSG_CONTROL_RETRACT_RECOVER " UnRet +mm:"
-#define MSG_CONTROL_RETRACT_RECOVERF " UnRet F:"
-#define MSG_AUTORETRACT " Retract. Auto.:"
-#define MSG_FILAMENTCHANGE "Change filament"
-
-// Serial Console Messages
-
-#define MSG_Enqueing "Mise en tampon \""
-#define MSG_POWERUP "Allumage"
-#define MSG_EXTERNAL_RESET " RAZ Externe"
-#define MSG_BROWNOUT_RESET " RAZ defaut alim."
-#define MSG_WATCHDOG_RESET " RAZ Watchdog"
-#define MSG_SOFTWARE_RESET " RAZ logicielle"
-#define MSG_MARLIN "Marlin "
-#define MSG_AUTHOR " | Auteur: "
-#define MSG_CONFIGURATION_VER " Derniere MaJ: "
-#define MSG_FREE_MEMORY " Memoire libre: "
-#define MSG_PLANNER_BUFFER_BYTES " PlannerBufferBytes: "
-#define MSG_OK "ok"
-#define MSG_FILE_SAVED "Fichier enregistre."
-#define MSG_ERR_LINE_NO "Le numero de ligne n'est pas la derniere ligne + 1, derniere ligne: "
-#define MSG_ERR_CHECKSUM_MISMATCH "Erreur somme de controle, derniere ligne: "
-#define MSG_ERR_NO_CHECKSUM "Pas de somme de controle avec le numero de ligne, derniere ligne: "
-#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Pas de numero de ligne avec somme de controle, derniere ligne: "
-#define MSG_FILE_PRINTED "Impression terminee"
-#define MSG_BEGIN_FILE_LIST "Debut de la liste de fichiers"
-#define MSG_END_FILE_LIST "Fin de la liste de fichiers"
-#define MSG_M104_INVALID_EXTRUDER "M104 Extruder invalide"
-#define MSG_M105_INVALID_EXTRUDER "M105 Extruder invalide"
-#define MSG_M218_INVALID_EXTRUDER "M218 Extruder invalide"
-#define MSG_ERR_NO_THERMISTORS "Pas de thermistor, pas de temperature"
-#define MSG_M109_INVALID_EXTRUDER "M109 Extruder invalide "
-#define MSG_HEATING "En chauffe..."
-#define MSG_HEATING_COMPLETE "Chauffe terminee."
-#define MSG_BED_HEATING "Chauffe du lit."
-#define MSG_BED_DONE "Chauffe du lit terminee."
-#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
-#define MSG_COUNT_X " Compteur X: "
-#define MSG_ERR_KILLED "Impression arretee. kill() appelee!"
-#define MSG_ERR_STOPPED "Impression arretee a cause d'erreurs. Corriger les erreurs et utiliser M999 pour la reprendre. (Temperature remise a zero. Reactivez la apres redemarrage)"
-#define MSG_RESEND "Renvoie: "
-#define MSG_UNKNOWN_COMMAND "Commande inconnue: \""
-#define MSG_ACTIVE_EXTRUDER "Extrudeur actif: "
-#define MSG_INVALID_EXTRUDER "Extrudeur invalide"
-#define MSG_X_MIN "x_min: "
-#define MSG_X_MAX "x_max: "
-#define MSG_Y_MIN "y_min: "
-#define MSG_Y_MAX "y_max: "
-#define MSG_Z_MIN "z_min: "
-#define MSG_Z_MAX "z_max: "
-#define MSG_M119_REPORT "Affichage du status des fin de course"
-#define MSG_ENDSTOP_HIT "DECLENCHE"
-#define MSG_ENDSTOP_OPEN "OUVERT"
-#define MSG_HOTEND_OFFSET "Hotend offsets:"
-
-#define MSG_SD_CANT_OPEN_SUBDIR "Impossible d'ouvrir le sous-repertoire"
-#define MSG_SD_INIT_FAIL "Echec de l'initialisation de la SD"
-#define MSG_SD_VOL_INIT_FAIL "Echec de volume.init"
-#define MSG_SD_OPENROOT_FAIL "Echec openRoot"
-#define MSG_SD_CARD_OK "Carte SD Ok"
-#define MSG_SD_WORKDIR_FAIL "Echec d'ouverture workDir"
-#define MSG_SD_OPEN_FILE_FAIL "Echec d'ouverture, Fichier: "
-#define MSG_SD_FILE_OPENED "Fichier ouvert: "
-#define MSG_SD_SIZE " Taille: "
-#define MSG_SD_FILE_SELECTED "Fichier selectionne"
-#define MSG_SD_WRITE_TO_FILE "Ecriture dans le fichier: "
-#define MSG_SD_PRINTING_BYTE "Octet impression SD "
-#define MSG_SD_NOT_PRINTING "Pas d'impression SD"
-#define MSG_SD_ERR_WRITE_TO_FILE "Erreur d'ecriture dans le fichier"
-#define MSG_SD_CANT_ENTER_SUBDIR "Impossible d'entrer dans le sous-repertoire: "
-
-#define MSG_STEPPER_TO_HIGH "Steprate trop eleve: "
-#define MSG_ENDSTOPS_HIT "Fin de course atteint: "
-#define MSG_ERR_COLD_EXTRUDE_STOP " Extrusion a froid evitee"
-#define MSG_ERR_LONG_EXTRUDE_STOP " Extrusion longue evitee"
-	
-#endif
-
-
-#if LANGUAGE_CHOICE == 4
-
-// LCD Menu Messages
-
-	#define WELCOME_MSG MACHINE_NAME " Bereit."
-
-	#define MSG_SD_INSERTED      "SDKarte erkannt"
-	#define MSG_SD_REMOVED       "SDKarte entfernt"
-	#define MSG_MAIN             "Hauptmne"
-	#define MSG_AUTOSTART        "Autostart"
-	#define MSG_DISABLE_STEPPERS "Stepper abschalten"
-	#define MSG_AUTO_HOME        "Auto Nullpunkt"
-	#define MSG_SET_ORIGIN       "Setze Nullpunkt"
-	#define MSG_PREHEAT_PLA      "Vorwrmen PLA"
-	#define MSG_PREHEAT_PLA_SETTINGS "Vorwrmen PLA Einstellungen"
-	#define MSG_PREHEAT_ABS      "Vorwrmen ABS"
-	#define MSG_PREHEAT_ABS_SETTINGS "Vorwrmen ABS Einstellungen"
-	#define MSG_COOLDOWN         "Abkhlen"
-	#define MSG_EXTRUDE          "Extrude"
-	#define MSG_RETRACT          "Retract"
-	#define MSG_MOVE_AXIS        "Achsen bewegen"
-	#define MSG_SPEED            "Geschw"
-	#define MSG_NOZZLE           "Dse"
-	#define MSG_NOZZLE1          "Dse2"
-	#define MSG_NOZZLE2          "Dse3"
-	#define MSG_BED              "Bett"
-	#define MSG_FAN_SPEED        "Lftergeschw."
-	#define MSG_FLOW             "Flu"
-	#define MSG_CONTROL          "Einstellungen"
-	#define MSG_MIN              "\002 Min"
-	#define MSG_MAX              "\002 Max"
-	#define MSG_FACTOR           "\002 Faktor"
-	#define MSG_AUTOTEMP         "AutoTemp"
-	#define MSG_ON               "Ein"
-	#define MSG_OFF              "Aus"
-	#define MSG_PID_P            "PID-P"
-	#define MSG_PID_I            "PID-I"
-	#define MSG_PID_D            "PID-D"
-	#define MSG_PID_C            "PID-C"
-	#define MSG_ACC              "Acc"
-	#define MSG_VXY_JERK         "Vxy-jerk"
-	#define MSG_VMAX             "Vmax "
-	#define MSG_X                "x"
-	#define MSG_Y                "y"
-	#define MSG_Z                "z"
-	#define MSG_E                "e"
-	#define MSG_VMIN             "Vmin"
-	#define MSG_VTRAV_MIN        "VTrav min"
-	#define MSG_AMAX             "Amax "
-	#define MSG_A_RETRACT        "A-Retract"
-	#define MSG_XSTEPS           "Xsteps/mm"
-	#define MSG_YSTEPS           "Ysteps/mm"
-	#define MSG_ZSTEPS           "Zsteps/mm"
-	#define MSG_ESTEPS           "Esteps/mm"
-	#define MSG_RECTRACT_WIDE    "Rectract"
-	#define MSG_WATCH            "Beobachten"
-	#define MSG_TEMPERATURE      "Temperatur"
-	#define MSG_MOTION           "Bewegung"
-	#define MSG_STORE_EPROM      "EPROM speichern"
-	#define MSG_LOAD_EPROM       "EPROM laden"
-	#define MSG_RESTORE_FAILSAFE "Standardkonfig."
-	#define MSG_REFRESH          "Aktualisieren"
-	#define MSG_PREPARE          "Vorbereitung"
-	#define MSG_CONTROL          "Einstellungen"
-	#define MSG_TUNE             "Justierung"
-	#define MSG_PAUSE_PRINT      "Druck anhalten"
-	#define MSG_RESUME_PRINT     "Druck fortsetz"
-	#define MSG_STOP_PRINT       "Druck stoppen"
-	#define MSG_CARD_MENU        "SDKarten Men"
-	#define MSG_NO_CARD          "Keine SDKarte"
-	#define MSG_DWELL            "Warten..."		
-	#define MSG_USERWAIT         "Warte auf Nutzer..."
-    #define MSG_RESUMING         "Druck fortsetzung"
-	#define MSG_NO_MOVE          "Kein Zug."
-	#define MSG_PART_RELEASE     "Stepper tlw frei"
-	#define MSG_KILLED           "KILLED"
-	#define MSG_STOPPED          "GESTOPPT"
-	#define MSG_STEPPER_RELEASED "Stepper frei"
-    #define MSG_CONTROL_RETRACT  "Retract mm"
-    #define MSG_CONTROL_RETRACTF "Retract  F"
-    #define MSG_CONTROL_RETRACT_ZLIFT "Hop mm"
-    #define MSG_CONTROL_RETRACT_RECOVER "UnRet +mm"
-    #define MSG_CONTROL_RETRACT_RECOVERF "UnRet  F"
-    #define MSG_AUTORETRACT      "AutoRetr."
-    #define MSG_FILAMENTCHANGE "Filament wechseln"
-	
-// Serial Console Messages
-
-	#define MSG_Enqueing "enqueing \""
-	#define MSG_POWERUP "PowerUp"
-	#define MSG_EXTERNAL_RESET " External Reset"
-	#define MSG_BROWNOUT_RESET " Brown out Reset"
-	#define MSG_WATCHDOG_RESET " Watchdog Reset"
-	#define MSG_SOFTWARE_RESET " Software Reset"
-	#define MSG_MARLIN "Marlin: "
-	#define MSG_AUTHOR " | Author: "
-	#define MSG_CONFIGURATION_VER " Last Updated: "
-	#define MSG_FREE_MEMORY " Free Memory: "
-	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
-	#define MSG_OK "ok"
-	#define MSG_FILE_SAVED "Done saving file."
-	#define MSG_ERR_LINE_NO "Line Number is not Last Line Number+1, Last Line:"
-	#define MSG_ERR_CHECKSUM_MISMATCH "checksum mismatch, Last Line:"
-	#define MSG_ERR_NO_CHECKSUM "No Checksum with line number, Last Line:"
-	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "No Line Number with checksum, Last Line:"
-	#define MSG_FILE_PRINTED "Done printing file"
-	#define MSG_BEGIN_FILE_LIST "Begin file list"
-	#define MSG_END_FILE_LIST "End file list"
-	#define MSG_M104_INVALID_EXTRUDER "M104 Invalid extruder "
-	#define MSG_M105_INVALID_EXTRUDER "M105 Invalid extruder "
-	#define MSG_M218_INVALID_EXTRUDER "M218 Invalid extruder "
-	#define MSG_ERR_NO_THERMISTORS "No thermistors - no temp"
-	#define MSG_M109_INVALID_EXTRUDER "M109 Invalid extruder "
-	#define MSG_HEATING "Heating..."
-	#define MSG_HEATING_COMPLETE "Heating done."
-	#define MSG_BED_HEATING "Bed Heating."
-	#define MSG_BED_DONE "Bed done."
-	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
-	#define MSG_COUNT_X " Count X:"
-	#define MSG_ERR_KILLED "Printer halted. kill() called !!"
-	#define MSG_ERR_STOPPED "Printer stopped due to errors. Fix the error and use M999 to restart!"
-	#define MSG_RESEND "Resend:"
-	#define MSG_UNKNOWN_COMMAND "Unknown command:\""
-	#define MSG_ACTIVE_EXTRUDER "Active Extruder: "
-	#define MSG_INVALID_EXTRUDER "Invalid extruder"
-	#define MSG_X_MIN "x_min: "
-	#define MSG_X_MAX "x_max: "
-	#define MSG_Y_MIN "y_min: "
-	#define MSG_Y_MAX "y_max: "
-	#define MSG_Z_MIN "z_min: "
-	#define MSG_Z_MAX "z_max: "
-	#define MSG_M119_REPORT "Reporting endstop status"
-	#define MSG_ENDSTOP_HIT "TRIGGERED"
-	#define MSG_ENDSTOP_OPEN "open"
-	#define MSG_HOTEND_OFFSET "Hotend offsets:"
-
-	#define MSG_SD_CANT_OPEN_SUBDIR "Cannot open subdir"
-	#define MSG_SD_INIT_FAIL "SD init fail"
-	#define MSG_SD_VOL_INIT_FAIL "volume.init failed"
-	#define MSG_SD_OPENROOT_FAIL "openRoot failed"
-	#define MSG_SD_CARD_OK "SD card ok"
-	#define MSG_SD_WORKDIR_FAIL "workDir open failed"
-	#define MSG_SD_OPEN_FILE_FAIL "open failed, File: "
-	#define MSG_SD_FILE_OPENED "File opened:"
-	#define MSG_SD_SIZE " Size:"
-	#define MSG_SD_FILE_SELECTED "File selected"
-	#define MSG_SD_WRITE_TO_FILE "Writing to file: "
-	#define MSG_SD_PRINTING_BYTE "SD printing byte "
-	#define MSG_SD_NOT_PRINTING "Not SD printing"
-	#define MSG_SD_ERR_WRITE_TO_FILE "error writing to file"
-	#define MSG_SD_CANT_ENTER_SUBDIR "Cannot enter subdir:"
-
-	#define MSG_STEPPER_TO_HIGH "Steprate to high : "
-	#define MSG_ENDSTOPS_HIT "endstops hit: "
-	#define MSG_ERR_COLD_EXTRUDE_STOP " cold extrusion prevented"
-	#define MSG_ERR_LONG_EXTRUDE_STOP " too long extrusion prevented"
-
-#endif
-
-
-#if LANGUAGE_CHOICE == 5
-
-// LCD Menu Messages
-#define WELCOME_MSG MACHINE_NAME " Lista."
-#define MSG_SD_INSERTED "Tarjeta SD Colocada"
-#define MSG_SD_REMOVED "Tarjeta SD Retirada"
-#define MSG_MAIN " Menu Principal \003"
-#define MSG_AUTOSTART " Autostart"
-#define MSG_DISABLE_STEPPERS " Apagar Motores"
-#define MSG_AUTO_HOME " Llevar Ejes al Cero"
-#define MSG_SET_ORIGIN " Establecer Cero"
-#define MSG_COOLDOWN " Enfriar"
-#define MSG_EXTRUDE " Extruir"
-#define MSG_RETRACT " Retraer"
-#define MSG_PREHEAT_PLA " Precalentar PLA"
-#define MSG_PREHEAT_PLA_SETTINGS " Ajustar temp. PLA"
-#define MSG_PREHEAT_ABS " Precalentar ABS"
-#define MSG_PREHEAT_ABS_SETTINGS " Ajustar temp. ABS"
-#define MSG_MOVE_AXIS " Mover Ejes      \x7E"
-#define MSG_SPEED " Velocidad:"
-#define MSG_NOZZLE " \002Nozzle:"
-#define MSG_NOZZLE1 " \002Nozzle2:"
-#define MSG_NOZZLE2 " \002Nozzle3:"
-#define MSG_BED " \002Base:"
-#define MSG_FAN_SPEED " Ventilador:"
-#define MSG_FLOW " Flujo:"
-#define MSG_CONTROL " Control \003"
-#define MSG_MIN " \002 Min:"
-#define MSG_MAX " \002 Max:"
-#define MSG_FACTOR " \002 Fact:"
-#define MSG_AUTOTEMP " Autotemp:"
-#define MSG_ON "On "
-#define MSG_OFF "Off"
-#define MSG_PID_P " PID-P: "
-#define MSG_PID_I " PID-I: "
-#define MSG_PID_D " PID-D: "
-#define MSG_PID_C " PID-C: "
-#define MSG_ACC  " Acc:"
-#define MSG_VXY_JERK " Vxy-jerk: "
-#define MSG_VMAX " Vmax "
-#define MSG_X "x:"
-#define MSG_Y "y:"
-#define MSG_Z "z:"
-#define MSG_E "e:"
-#define MSG_VMIN " Vmin:"
-#define MSG_VTRAV_MIN " VTrav min:"
-#define MSG_AMAX " Amax "
-#define MSG_A_RETRACT " A-retrac.:"
-#define MSG_XSTEPS " Xpasos/mm:"
-#define MSG_YSTEPS " Ypasos/mm:"
-#define MSG_ZSTEPS " Zpasos/mm:"
-#define MSG_ESTEPS " Epasos/mm:"
-#define MSG_MAIN_WIDE " Menu Principal  \003"
-#define MSG_RECTRACT_WIDE " Retraer         \x7E"
-#define MSG_TEMPERATURE_WIDE " Temperatura     \x7E"
-#define MSG_TEMPERATURE_RTN  " Temperatura     \003"
-#define MSG_MOTION_WIDE " Movimiento      \x7E"
-#define MSG_STORE_EPROM " Guardar Memoria"
-#define MSG_LOAD_EPROM " Cargar Memoria"
-#define MSG_RESTORE_FAILSAFE " Rest. de emergencia"
-#define MSG_REFRESH "\004Volver a cargar"
-#define MSG_WATCH " Monitorizar \003"
-#define MSG_PREPARE " Preparar \x7E"
-#define MSG_PREPARE_ALT " Preparar \003"
-#define MSG_CONTROL_ARROW " Control  \x7E"
-#define MSG_RETRACT_ARROW " Retraer  \x7E"
-#define MSG_TUNE " Ajustar \x7E"
-#define MSG_PAUSE_PRINT " Pausar Impresion \x7E"
-#define MSG_RESUME_PRINT " Reanudar Impresion \x7E"
-#define MSG_STOP_PRINT " Detener Impresion \x7E"
-#define MSG_CARD_MENU " Menu de SD    \x7E"
-#define MSG_NO_CARD " No hay Tarjeta SD"
-#define MSG_DWELL "Reposo..."
-#define MSG_USERWAIT "Esperando Ordenes..."
-#define MSG_NO_MOVE "Sin movimiento"
-#define MSG_PART_RELEASE "Desacople Parcial"
-#define MSG_KILLED "PARADA DE EMERGENCIA. "
-#define MSG_STOPPED "PARADA. "
-#define MSG_STEPPER_RELEASED "Desacoplada."
-#define MSG_CONTROL_RETRACT  " Retraer mm:"
-#define MSG_CONTROL_RETRACTF " Retraer  F:"
-#define MSG_CONTROL_RETRACT_ZLIFT " Levantar mm:"
-#define MSG_CONTROL_RETRACT_RECOVER " DesRet +mm:"
-#define MSG_CONTROL_RETRACT_RECOVERF " DesRet F:"
-#define MSG_AUTORETRACT " AutoRetr.:"
-#define MSG_FILAMENTCHANGE "Change filament"
-// Serial Console Messages
-
-#define MSG_Enqueing "En cola \""
-#define MSG_POWERUP "PowerUp"
-#define MSG_EXTERNAL_RESET " Reset Externo"
-#define MSG_BROWNOUT_RESET " Reset por Voltaje Incorrecto"
-#define MSG_WATCHDOG_RESET " Reset por Bloqueo"
-#define MSG_SOFTWARE_RESET " Reset por Software"
-#define MSG_MARLIN "Marlin "
-#define MSG_AUTHOR " | Autor: "
-#define MSG_CONFIGURATION_VER " Ultima actualizacion: "
-#define MSG_FREE_MEMORY " Memoria libre: "
-#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
-#define MSG_OK "ok"
-#define MSG_FILE_SAVED "Guardado."
-#define MSG_ERR_LINE_NO "El Numero de Linea no es igual al Ultimo Numero de Linea+1, Ultima Linea:"
-#define MSG_ERR_CHECKSUM_MISMATCH "el checksum no coincide, Ultima Linea:"
-#define MSG_ERR_NO_CHECKSUM "No se pudo hallar el Checksum con el numero de linea, Ultima Linea:"
-#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "No se hallo el Numero de Linea con el Checksum, Ultima Linea:"
-#define MSG_FILE_PRINTED "Impresion terminada"
-#define MSG_BEGIN_FILE_LIST "Comienzo de la lista de archivos"
-#define MSG_END_FILE_LIST "Fin de la lista de archivos"
-#define MSG_M104_INVALID_EXTRUDER "M104 Extrusor Invalido "
-#define MSG_M105_INVALID_EXTRUDER "M105 Extrusor Invalido "
-#define MSG_M218_INVALID_EXTRUDER "M218 Extrusor Invalido "
-#define MSG_ERR_NO_THERMISTORS "No hay termistores - no temp"
-#define MSG_M109_INVALID_EXTRUDER "M109 Extrusor Invalido "
-#define MSG_HEATING "Calentando..."
-#define MSG_HEATING_COMPLETE "Calentamiento Hecho."
-#define MSG_BED_HEATING "Calentando la base."
-#define MSG_BED_DONE "Base Caliente."
-#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
-#define MSG_COUNT_X " Cuenta X:"
-#define MSG_ERR_KILLED "Impresora Parada con kill()!!"
-#define MSG_ERR_STOPPED "Impresora parada por errores. Arregle el error y use M999 Para reiniciar!. (La temperatura se reestablece. Ajustela antes de continuar)"
-#define MSG_RESEND "Reenviar:"
-#define MSG_UNKNOWN_COMMAND "Comando Desconocido:\""
-#define MSG_ACTIVE_EXTRUDER "Extrusor Activo: "
-#define MSG_INVALID_EXTRUDER "Extrusor Invalido"
-#define MSG_X_MIN "x_min: "
-#define MSG_X_MAX "x_max: "
-#define MSG_Y_MIN "y_min: "
-#define MSG_Y_MAX "y_max: "
-#define MSG_Z_MIN "z_min: "
-#define MSG_M119_REPORT "Comprobando fines de carrera."
-#define MSG_ENDSTOP_HIT "PULSADO"
-#define MSG_ENDSTOP_OPEN "abierto"
-#define MSG_HOTEND_OFFSET "Hotend offsets:"
-        
-#define MSG_SD_CANT_OPEN_SUBDIR "No se pudo abrir la subcarpeta."
-#define MSG_SD_INIT_FAIL "Fallo al iniciar la SD"
-#define MSG_SD_VOL_INIT_FAIL "Fallo al montar el volumen"
-#define MSG_SD_OPENROOT_FAIL "Fallo al abrir la carpeta raiz"
-#define MSG_SD_CARD_OK "Tarjeta SD OK"
-#define MSG_SD_WORKDIR_FAIL "Fallo al abrir la carpeta de trabajo"
-#define MSG_SD_OPEN_FILE_FAIL "Error al abrir, Archivo: "
-#define MSG_SD_FILE_OPENED "Archivo abierto:"
-#define MSG_SD_SIZE " Tamao:"
-#define MSG_SD_FILE_SELECTED "Archivo Seleccionado"
-#define MSG_SD_WRITE_TO_FILE "Escribiendo en el archivo: "
-#define MSG_SD_PRINTING_BYTE "SD imprimiendo el byte "
-#define MSG_SD_NOT_PRINTING "No se esta imprimiendo con SD"
-#define MSG_SD_ERR_WRITE_TO_FILE "Error al escribir en el archivo"
-#define MSG_SD_CANT_ENTER_SUBDIR "No se puede abrir la carpeta:"
-
-#define MSG_STEPPER_TO_HIGH "Steprate demasiado alto : "
-#define MSG_ENDSTOPS_HIT "Se ha tocado el fin de carril: "
-#define MSG_ERR_COLD_EXTRUDE_STOP " extrusion fria evitada"
-#define MSG_ERR_LONG_EXTRUDE_STOP " extrusion demasiado larga evitada"
-
-#endif
-
-#if LANGUAGE_CHOICE == 6
-
-// LCD Menu Messages
-#define WELCOME_MSG MACHINE_NAME			" "
-#define MSG_SD_INSERTED						" "
-#define MSG_SD_REMOVED						" "
-#define MSG_MAIN							"               \003"
-#define MSG_AUTOSTART						"           "
-#define MSG_DISABLE_STEPPERS				"  "
-#define MSG_AUTO_HOME						"            "
-#define MSG_SET_ORIGIN						"       "
-#define MSG_PREHEAT_PLA						"  PLA     "
-#define MSG_PREHEAT_PLA_SETTINGS			" . .PLA"
-#define MSG_PREHEAT_ABS						"  ABS     "
-#define MSG_PREHEAT_ABS_SETTINGS			" . .ABS"
-#define MSG_COOLDOWN						"          "
-#define MSG_EXTRUDE							"           "
-#define MSG_RETRACT							" "
-#define MSG_MOVE_AXIS						"     \x7E"
-#define MSG_SPEED							" :"
-#define MSG_NOZZLE							" \002 :"
-#define MSG_NOZZLE1							" \002 2:"
-#define MSG_NOZZLE2							" \002 3:"
-#define MSG_BED								" \002 :"
-#define MSG_FAN_SPEED						" :"
-#define MSG_FLOW							" :"
-#define MSG_CONTROL							"  \003"
-#define MSG_MIN								" \002 :"
-#define MSG_MAX								" \002 :"
-#define MSG_FACTOR							" \002 :"
-#define MSG_AUTOTEMP						" Autotemp:"
-#define MSG_ON								". "
-#define MSG_OFF								". "
-#define MSG_PID_P							" PID-P: "
-#define MSG_PID_I							" PID-I: "
-#define MSG_PID_D							" PID-D: "
-#define MSG_PID_C							" PID-C: "
-#define MSG_ACC								" Acc:"
-#define MSG_VXY_JERK						" Vxy-jerk: "
-#define MSG_VMAX							" Vmax "
-#define MSG_X								"x:"
-#define MSG_Y								"y:"
-#define MSG_Z								"z:"
-#define MSG_E								"e:"
-#define MSG_VMIN							" Vmin:"
-#define MSG_VTRAV_MIN						" VTrav min:"
-#define MSG_AMAX							" Amax "
-#define MSG_A_RETRACT						" A-retract:"
-#define MSG_XSTEPS							" X /mm:"
-#define MSG_YSTEPS							" Y /mm:"
-#define MSG_ZSTEPS							" Z /mm:"
-#define MSG_ESTEPS							" E /mm:"
-#define MSG_RECTRACT    					"        \x7E"
-#define MSG_TEMPERATURE  				"        \x7E"
-#define MSG_MOTION						"           \x7E"
-#define MSG_STORE_EPROM						"  "
-#define MSG_LOAD_EPROM						"  "
-#define MSG_RESTORE_FAILSAFE				"       "
-#define MSG_REFRESH							"\004           "
-#define MSG_WATCH							"              \003"
-#define MSG_PREPARE							"           \x7E"
-#define MSG_TUNE					"          \x7E"
-#define MSG_PAUSE_PRINT						"        \x7E"
-#define MSG_RESUME_PRINT					"   \x7E"
-#define MSG_STOP_PRINT						"   \x7E"
-#define MSG_CARD_MENU						"          \x7E"
-#define MSG_NO_CARD							"  "
-#define MSG_DWELL							"..."
-#define MSG_USERWAIT						"  ."
-#define MSG_NO_MOVE							" .       "
-#define MSG_PART_RELEASE					"    "
-#define MSG_KILLED							". "
-#define MSG_STOPPED							". "
-#define MSG_CONTROL_RETRACT					"  mm:"
-#define MSG_CONTROL_RETRACTF				"   F:"
-#define MSG_CONTROL_RETRACT_ZLIFT			"  mm:"
-#define MSG_CONTROL_RETRACT_RECOVER			"  +mm:"
-#define MSG_CONTROL_RETRACT_RECOVERF		"   F:"
-#define MSG_AUTORETRACT						" :"
-#define MSG_FILAMENTCHANGE "Change filament"
-
-// Serial Console Messages
-
-#define MSG_Enqueing						" \""
-#define MSG_POWERUP							" "
-#define MSG_EXTERNAL_RESET					"  "
-#define MSG_BROWNOUT_RESET					" Brown out "
-#define MSG_WATCHDOG_RESET					" Watchdog "
-#define MSG_SOFTWARE_RESET					"  "
-#define MSG_MARLIN							"Marlin "
-#define MSG_AUTHOR							" | : "
-#define MSG_CONFIGURATION_VER				"  : "
-#define MSG_FREE_MEMORY						"  : "
-#define MSG_PLANNER_BUFFER_BYTES			"     Bytes: "
-#define MSG_OK								"ok"
-#define MSG_FILE_SAVED						" ."
-#define MSG_ERR_LINE_NO						"     +1,  :"
-#define MSG_ERR_CHECKSUM_MISMATCH			"   ,  :"
-#define MSG_ERR_NO_CHECKSUM					"    ,  :"
-#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM	"    ,  :"
-#define MSG_FILE_PRINTED					"  "
-#define MSG_BEGIN_FILE_LIST					" "
-#define MSG_END_FILE_LIST					"  "
-#define MSG_M104_INVALID_EXTRUDER			"M104   "
-#define MSG_M105_INVALID_EXTRUDER			"M105   "
-#define MSG_M218_INVALID_EXTRUDER			"M218   "
-#define MSG_ERR_NO_THERMISTORS				"  -  "
-#define MSG_M109_INVALID_EXTRUDER			"M109   "
-#define MSG_HEATING							"...  "
-#define MSG_HEATING_COMPLETE				".    "
-#define MSG_BED_HEATING						" ...     "
-#define MSG_BED_DONE						" .        "
-#define MSG_M115_REPORT						"FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
-#define MSG_COUNT_X							" Count X:"
-#define MSG_ERR_KILLED						" .  kill() !!"
-#define MSG_ERR_STOPPED						" , .     M999  !. ( .  )"
-#define MSG_RESEND							":"
-#define MSG_UNKNOWN_COMMAND					" :\""
-#define MSG_ACTIVE_EXTRUDER					" : "
-#define MSG_INVALID_EXTRUDER				" "
-#define MSG_X_MIN							"x_min:"
-#define MSG_X_MAX							"x_max:"
-#define MSG_Y_MIN							"y_min:"
-#define MSG_Y_MAX							"y_max:"
-#define MSG_Z_MIN							"z_min:"
-#define MSG_Z_MAX							"z_max:"
-#define MSG_M119_REPORT						" "
-#define MSG_ENDSTOP_HIT						" "
-#define MSG_ENDSTOP_OPEN					" "
-#define MSG_HOTEND_OFFSET					"Hotend offsets:"
-#define MSG_SD_CANT_OPEN_SUBDIR				"  "
-#define MSG_SD_INIT_FAIL					"  SD"
-#define MSG_SD_VOL_INIT_FAIL				"  "
-#define MSG_SD_OPENROOT_FAIL				"   "
-#define MSG_SD_CARD_OK						"SD   "
-#define MSG_SD_WORKDIR_FAIL					"   "
-#define MSG_SD_OPEN_FILE_FAIL				" , : "
-#define MSG_SD_FILE_OPENED					" :"
-#define MSG_SD_SIZE							" :"
-#define MSG_SD_FILE_SELECTED				" "
-#define MSG_SD_WRITE_TO_FILE				"  : "
-#define MSG_SD_PRINTING_BYTE				"SD  byte "
-#define MSG_SD_NOT_PRINTING					" SD "
-#define MSG_SD_ERR_WRITE_TO_FILE			"   "
-#define MSG_SD_CANT_ENTER_SUBDIR			"   :"
-#define MSG_STEPPER_TO_HIGH					"    : "
-#define MSG_ENDSTOPS_HIT					" : "
-#define MSG_ERR_COLD_EXTRUDE_STOP			"   "
-#define MSG_ERR_LONG_EXTRUDE_STOP			"    "
-
-#endif
-
-
-#if LANGUAGE_CHOICE == 7
-
-	// LCD Menu Messages
-	#define WELCOME_MSG MACHINE_NAME " Pronto."
-	#define MSG_SD_INSERTED          "SD Card inserita"
-	#define MSG_SD_REMOVED           "SD Card rimossa"
-	#define MSG_MAIN                 "Menu principale"
-	#define MSG_AUTOSTART            "Autostart"
-	#define MSG_DISABLE_STEPPERS     "Disabilita Motori"
-	#define MSG_AUTO_HOME            "Auto Home"
-	#define MSG_SET_ORIGIN           "Imposta Origine"
-	#define MSG_PREHEAT_PLA          "Preriscalda PLA"
-	#define MSG_PREHEAT_PLA_SETTINGS "Preris. PLA Conf"
-	#define MSG_PREHEAT_ABS          "Preriscalda ABS"
-	#define MSG_PREHEAT_ABS_SETTINGS "Preris. ABS Conf"
-	#define MSG_COOLDOWN             "Rafredda"
-	#define MSG_EXTRUDE              "Estrudi"
-	#define MSG_RETRACT              "Ritrai"
-	#define MSG_MOVE_AXIS            "Muovi Asse"
-	#define MSG_SPEED                "Velcit"
-	#define MSG_NOZZLE               "Ugello"
-	#define MSG_NOZZLE1              "Ugello2"
-	#define MSG_NOZZLE2              "Ugello3"
-	#define MSG_BED                  "Piatto"
-	#define MSG_FAN_SPEED            "Ventola"
-	#define MSG_FLOW                 "Flusso"
-	#define MSG_CONTROL              "Controllo"
-	#define MSG_MIN                  " \002 Min:"
-	#define MSG_MAX                  " \002 Max:"
-	#define MSG_FACTOR               " \002 Fact:"
-	#define MSG_AUTOTEMP             "Autotemp"
-	#define MSG_ON                   "On "
-	#define MSG_OFF                  "Off"
-	#define MSG_PID_P                "PID-P"
-	#define MSG_PID_I                "PID-I"
-	#define MSG_PID_D                "PID-D"
-	#define MSG_PID_C                "PID-C"
-	#define MSG_ACC                  "Accel"
-	#define MSG_VXY_JERK             "Vxy-jerk"
-	#define MSG_VMAX                 "Vmax"
-	#define MSG_X                    "x"
-	#define MSG_Y                    "y"
-	#define MSG_Z                    "z"
-	#define MSG_E                    "e"
-	#define MSG_VMIN                 "Vmin"
-	#define MSG_VTRAV_MIN            "VTrav min"
-	#define MSG_AMAX                 "Amax"
-	#define MSG_A_RETRACT            "A-retract"
-	#define MSG_XSTEPS               "Xpassi/mm"
-	#define MSG_YSTEPS               "Ypassi/mm"
-	#define MSG_ZSTEPS               "Zpassi/mm"
-	#define MSG_ESTEPS               "Epassi/mm"
-	#define MSG_RECTRACT             "Ritrai"
-	#define MSG_TEMPERATURE          "Temperatura"
-	#define MSG_MOTION               "Movimento"
-	#define MSG_STORE_EPROM          "Salva in EEPROM"
-	#define MSG_LOAD_EPROM           "Carica da EEPROM"
-	#define MSG_RESTORE_FAILSAFE     "Impostaz. default"
-	#define MSG_REFRESH              "Aggiorna"
-	#define MSG_WATCH                "Guarda"
-	#define MSG_PREPARE              "Prepara"
-	#define MSG_TUNE                 "Adatta"
-	#define MSG_PAUSE_PRINT          "Pausa"
-	#define MSG_RESUME_PRINT         "Riprendi Stampa"
-	#define MSG_STOP_PRINT           "Arresta Stampa"
-	#define MSG_CARD_MENU            "SD Card Menu"
-	#define MSG_NO_CARD              "No SD Card"
-	#define MSG_DWELL                "Sospensione..."
-	#define MSG_USERWAIT             "Attendi Utente..."
-	#define MSG_RESUMING             "Riprendi Stampa"
-	#define MSG_NO_MOVE              "Nessun Movimento."
-	#define MSG_KILLED               "UCCISO. "
-	#define MSG_STOPPED              "ARRESTATO. "
-	#define MSG_CONTROL_RETRACT      "Ritrai mm"
-	#define MSG_CONTROL_RETRACTF     "Ritrai  F"
-	#define MSG_CONTROL_RETRACT_ZLIFT "Salta mm"
-	#define MSG_CONTROL_RETRACT_RECOVER "UnRet +mm"
-	#define MSG_CONTROL_RETRACT_RECOVERF "UnRet  F"
-	#define MSG_AUTORETRACT          "AutoArretramento"
-	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Qualcosa non va in MenuStructure."
-	#define MSG_FILAMENTCHANGE       "Cambia filamento"
-	#define MSG_INIT_SDCARD          "Iniz. SD-Card"
-	#define MSG_CNG_SDCARD           "Cambia SD-Card"
-
-	// Serial Console Messages
-
-	#define MSG_Enqueing             "accodamento \""
-	#define MSG_POWERUP              "Accensione"
-	#define MSG_EXTERNAL_RESET       " Reset Esterno"
-	#define MSG_BROWNOUT_RESET       " Brown out Reset"
-	#define MSG_WATCHDOG_RESET       " Watchdog Reset"
-	#define MSG_SOFTWARE_RESET       " Software Reset"
-	#define MSG_MARLIN               "Marlin "
-	#define MSG_AUTHOR               " | Autore: "
-	#define MSG_CONFIGURATION_VER    " Ultimo Aggiornamento: "
-	#define MSG_FREE_MEMORY          " Memoria Libera: "
-	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
-	#define MSG_OK                   "ok"
-	#define MSG_FILE_SAVED           "File Salvato."
-	#define MSG_ERR_LINE_NO          "Il Numero della Linea non corrisponde al Numero dell'Ultima Linea+1, Ultima Linea: "
-	#define MSG_ERR_CHECKSUM_MISMATCH "checksum non corrispondente, Ultima Linea: "
-	#define MSG_ERR_NO_CHECKSUM      "Nessun Checksum con Numero di Linea, Ultima Linea: "
-	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Nessun Numero di Linea con Checksum, Ultima Linea: "
-	#define MSG_FILE_PRINTED         "File stampato"
-	#define MSG_BEGIN_FILE_LIST      "Inizio Lista File"
-	#define MSG_END_FILE_LIST        "Fine Lista File"
-	#define MSG_M104_INVALID_EXTRUDER "M104 Estrusore non valido "
-	#define MSG_M105_INVALID_EXTRUDER "M105 Estrusore non valido "
-	#define MSG_M218_INVALID_EXTRUDER "M218 Estrusore non valido "
-	#define MSG_ERR_NO_THERMISTORS   "Nessun Termistore - nessuna temperatura"
-	#define MSG_M109_INVALID_EXTRUDER "M109 Estrusore non valido "
-	#define MSG_HEATING              "Riscaldamento..."
-	#define MSG_HEATING_COMPLETE     "Stampante Calda."
-	#define MSG_BED_HEATING          "Riscaldamento Piatto."
-	#define MSG_BED_DONE             "Piatto Pronto."
-	#define MSG_M115_REPORT          "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
-	#define MSG_COUNT_X              " Calcola X: "
-	#define MSG_ERR_KILLED           "Stampante Calda. kill() chiamata !!"
-	#define MSG_ERR_STOPPED          "Stampante fermata a causa di errori. Risolvi l'errore e usa M999 per ripartire!. (Reset temperatura. Impostala prima di ripartire)"
-	#define MSG_RESEND               "Reinviato:"
-	#define MSG_UNKNOWN_COMMAND      "Comando sconosciuto: \""
-	#define MSG_ACTIVE_EXTRUDER      "Attiva Estrusore: "
-	#define MSG_INVALID_EXTRUDER     "Estrusore non valido"
-	#define MSG_X_MIN                "x_min: "
-	#define MSG_X_MAX                "x_max: "
-	#define MSG_Y_MIN                "y_min: "
-	#define MSG_Y_MAX                "y_max: "
-	#define MSG_Z_MIN                "z_min: "
-	#define MSG_Z_MAX                "z_max: "
-	#define MSG_M119_REPORT          "Segnalazione stato degli endstop"
-	#define MSG_ENDSTOP_HIT          "INNESCATO"
-	#define MSG_ENDSTOP_OPEN         "aperto"
-	#define MSG_HOTEND_OFFSET        "Hotend offsets:"
-
-	#define MSG_SD_CANT_OPEN_SUBDIR  "Impossibile aprire sottocartella"
-	#define MSG_SD_INIT_FAIL         "Fallita Inizializzazione SD"
-	#define MSG_SD_VOL_INIT_FAIL     "Fallito il montaggio del Volume"
-	#define MSG_SD_OPENROOT_FAIL     "Fallita l'apertura Cartella Principale"
-	#define MSG_SD_CARD_OK           "SD card ok"
-	#define MSG_SD_WORKDIR_FAIL      "Fallita l'apertura Cartella di Lavoro"
-	#define MSG_SD_OPEN_FILE_FAIL    "Fallita l'apertura del File: "
-	#define MSG_SD_FILE_OPENED       "File aperto: "
-	#define MSG_SD_SIZE              " Dimensione: "
-	#define MSG_SD_FILE_SELECTED     "File selezionato"
-	#define MSG_SD_WRITE_TO_FILE     "Scrittura su file: "
-	#define MSG_SD_PRINTING_BYTE     "Si sta scrivendo il byte su SD "
-	#define MSG_SD_NOT_PRINTING      "Non si sta scrivendo su SD"
-	#define MSG_SD_ERR_WRITE_TO_FILE "Errore nella scrittura su file"
-	#define MSG_SD_CANT_ENTER_SUBDIR "Impossibile entrare nella sottocartella: "
-
-	#define MSG_STEPPER_TO_HIGH      "Steprate troppo alto: "
-	#define MSG_ENDSTOPS_HIT         "Raggiunto il fondo carrello: "
-	#define MSG_ERR_COLD_EXTRUDE_STOP " prevenuta estrusione fredda"
-	#define MSG_ERR_LONG_EXTRUDE_STOP " prevenuta estrusione troppo lunga"
-
-#endif
-
-
-#if LANGUAGE_CHOICE == 8
-
-// LCD Menu Messages
-	#define WELCOME_MSG MACHINE_NAME " Pronta."
-	#define MSG_SD_INSERTED "Cartao SD inserido"
-	#define MSG_SD_REMOVED "Cartao SD removido"
-	#define MSG_MAIN " Menu Principal \003"
-	#define MSG_AUTOSTART " Autostart"
-	#define MSG_DISABLE_STEPPERS " Apagar Motores"
-	#define MSG_AUTO_HOME " Ir para Origen"
-	#define MSG_SET_ORIGIN " Estabelecer Origen"
-	#define MSG_PREHEAT_PLA " pre-aquecer PLA"
-	#define MSG_PREHEAT_PLA_SETTINGS " pre-aquecer PLA Setting"
-	#define MSG_PREHEAT_ABS " pre-aquecer ABS"
-	#define MSG_PREHEAT_ABS_SETTINGS " pre-aquecer ABS Setting"
-	#define MSG_COOLDOWN " Esfriar"
-	#define MSG_EXTRUDE " Extrudar"
-	#define MSG_RETRACT " Retrair"
-	#define MSG_PREHEAT_PLA " pre-aquecer PLA"
-	#define MSG_PREHEAT_ABS " pre-aquecer ABS"
-	#define MSG_MOVE_AXIS " Mover eixo      \x7E"
-	#define MSG_SPEED " Velocidade:"
-	#define MSG_NOZZLE " \002Nozzle:"
-	#define MSG_NOZZLE1 " \002Nozzle2:"
-	#define MSG_NOZZLE2 " \002Nozzle3:"
-	#define MSG_BED " \002Base:"
-	#define MSG_FAN_SPEED " Velocidade Ventoinha:"
-	#define MSG_FLOW " Fluxo:"
-	#define MSG_CONTROL " Controle \003"
-	#define MSG_MIN " \002 Min:"
-	#define MSG_MAX " \002 Max:"
-	#define MSG_FACTOR " \002 Fact:"
-	#define MSG_AUTOTEMP " Autotemp:"
-	#define MSG_ON "On "
-	#define MSG_OFF "Off"
-	#define MSG_PID_P " PID-P: "
-	#define MSG_PID_I " PID-I: "
-	#define MSG_PID_D " PID-D: "
-	#define MSG_PID_C " PID-C: "
-	#define MSG_ACC  " Acc:"
-	#define MSG_VXY_JERK " Vxy-jerk: "
-	#define MSG_VMAX " Vmax "
-	#define MSG_X "x:"
-	#define MSG_Y "y:"
-	#define MSG_Z "z:"
-	#define MSG_E "e:"
-	#define MSG_VMIN " Vmin:"
-	#define MSG_VTRAV_MIN " VTrav min:"
-	#define MSG_AMAX " Amax "
-	#define MSG_A_RETRACT " A-retract:"
-	#define MSG_XSTEPS " Xpasso/mm:"
-	#define MSG_YSTEPS " Ypasso/mm:"
-	#define MSG_ZSTEPS " Zpasso/mm:"
-	#define MSG_ESTEPS " Epasso/mm:"
-	#define MSG_MAIN_WIDE " Menu Principal  \003"
-	#define MSG_RECTRACT_WIDE " Retrair    \x7E"
-	#define MSG_TEMPERATURE_WIDE " Temperatura \x7E"
-	#define MSG_TEMPERATURE_RTN " Temperatura  \003"
-	#define MSG_MOTION_WIDE " Movimento     \x7E"
-	#define MSG_STORE_EPROM " Guardar memoria"
-	#define MSG_LOAD_EPROM " Carregar memoria"
-	#define MSG_RESTORE_FAILSAFE " Rest. de emergencia"
-	#define MSG_REFRESH "\004Recarregar"
-	#define MSG_WATCH " Monitorar   \003"
-	#define MSG_PREPARE " Preparar \x7E"
-	#define MSG_PREPARE_ALT " Preparar \003"
-	#define MSG_CONTROL_ARROW " Controle \x7E"
-	#define MSG_RETRACT_ARROW " Retrair \x7E"
-	#define MSG_TUNE " Tune    \x7E"
-	#define MSG_PAUSE_PRINT " Pausar Impressao \x7E"
-	#define MSG_RESUME_PRINT " Resumir Impressao \x7E"
-	#define MSG_STOP_PRINT " Parar Impressao   \x7E"
-	#define MSG_CARD_MENU " Menu cartao SD    \x7E"
-	#define MSG_NO_CARD " Sem cartao SD"
-	#define MSG_DWELL "Repouso..."
-	#define MSG_USERWAIT "Esperando Ordem..."
-	#define MSG_NO_MOVE "Sem movimento."
-	#define MSG_PART_RELEASE "Lancamento Parcial"
-	#define MSG_KILLED "PARADA DE EMERGENCIA. "
-	#define MSG_STOPPED "PARADA. "
-	#define MSG_STEPPER_RELEASED "Lancado."
-	#define MSG_CONTROL_RETRACT  " Retrair mm:"
-	#define MSG_CONTROL_RETRACTF " Retrair  F:"
-	#define MSG_CONTROL_RETRACT_ZLIFT " Levantar mm:"
-	#define MSG_CONTROL_RETRACT_RECOVER " DesRet +mm:"
-	#define MSG_CONTROL_RETRACT_RECOVERF " DesRet  F:"
-	#define MSG_AUTORETRACT " AutoRetr.:"
-        #define MSG_SERIAL_ERROR_MENU_STRUCTURE "Algo esta errado na estrutura do Menu."
-        #define MSG_FILAMENTCHANGE "Change filament"
-
-// Serial Console Messages
-
-	#define MSG_Enqueing "enqueing \""
-	#define MSG_POWERUP "PowerUp"
-	#define MSG_EXTERNAL_RESET " Reset Externo"
-	#define MSG_BROWNOUT_RESET " Reset por voltagem incorreta"
-	#define MSG_WATCHDOG_RESET " Reset por Bloqueio"
-	#define MSG_SOFTWARE_RESET " Reset por Software"
-	#define MSG_MARLIN "Marlin "
-	#define MSG_AUTHOR " | Author: "
-	#define MSG_CONFIGURATION_VER " Ultima atualizacao: "
-	#define MSG_FREE_MEMORY " memoria Livre: "
-	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
-	#define MSG_OK "ok"
-	#define MSG_FILE_SAVED "Guardado."
-	#define MSG_ERR_LINE_NO "O Numero da linha Nao e igual ao ultimo Numero da linha+1, Ultima linha:"
-	#define MSG_ERR_CHECKSUM_MISMATCH "O checksum Nao coincide, Ultima linha:"
-	#define MSG_ERR_NO_CHECKSUM "Nao foi possivel encontrar o checksum com o numero da linha, Ultima linha :"
-	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Nao ha o numero da linha com o checksum, Ultima linha:"
-	#define MSG_FILE_PRINTED "Impressao terminada"
-	#define MSG_BEGIN_FILE_LIST "Comeo da lista de arquivos"
-	#define MSG_END_FILE_LIST "Fim da lista de arquivos"
-	#define MSG_M104_INVALID_EXTRUDER "M104 Extrusor invlido "
-	#define MSG_M105_INVALID_EXTRUDER "M105 Extrusor invlido "
-	#define MSG_M218_INVALID_EXTRUDER "M218 Extrusor invlido "
-	#define MSG_ERR_NO_THERMISTORS "Nao ha termistor - no temp"
-	#define MSG_M109_INVALID_EXTRUDER "M109 Extrusor invlido "
-	#define MSG_HEATING "Aquecendo..."
-	#define MSG_HEATING_COMPLETE "Aquecido."
-	#define MSG_BED_HEATING "Aquecendo a Base."
-	#define MSG_BED_DONE "Base quente."
-	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
-	#define MSG_COUNT_X " Conta X:"
-	#define MSG_ERR_KILLED "Impressora parada com kill() !!"
-	#define MSG_ERR_STOPPED "Impressora parada por erros. Coserte o erro e use M999 para recomear!. (Temperatura reiniciada. Ajuste antes de recomear)"
-	#define MSG_RESEND "Reenviar:"
-	#define MSG_UNKNOWN_COMMAND "Comando desconhecido:\""
-	#define MSG_ACTIVE_EXTRUDER "Extrusor ativo: "
-	#define MSG_INVALID_EXTRUDER "Extrusor invalido"
-	#define MSG_X_MIN "x_min: "
-	#define MSG_X_MAX "x_max: "
-	#define MSG_Y_MIN "y_min: "
-	#define MSG_Y_MAX "y_max: "
-	#define MSG_Z_MIN "z_min: "
-	#define MSG_Z_MAX "z_max: "
-	#define MSG_M119_REPORT "Relatando estado do ponto final"
-	#define MSG_ENDSTOP_HIT "PULSADO"
-	#define MSG_ENDSTOP_OPEN "Aberto"
-	#define MSG_HOTEND_OFFSET "Hotend offsets:"
-
-	#define MSG_SD_CANT_OPEN_SUBDIR "Nao pode abrir sub diretorio"
-	#define MSG_SD_INIT_FAIL "Falha ao iniciar SD"
-	#define MSG_SD_VOL_INIT_FAIL "Falha ao montar volume"
-	#define MSG_SD_OPENROOT_FAIL "Falha ao abrir diretorio raiz"
-	#define MSG_SD_CARD_OK "cartao SD ok"
-	#define MSG_SD_WORKDIR_FAIL "Falha ao abrir diretorio de trabalho"
-	#define MSG_SD_OPEN_FILE_FAIL "Erro ao abrir, Arquivo: "
-	#define MSG_SD_FILE_OPENED "Arquivo aberto:"
-	#define MSG_SD_SIZE " Size:"
-	#define MSG_SD_FILE_SELECTED "Arquivo selecionado"
-	#define MSG_SD_WRITE_TO_FILE "Escrevendo no arquivo: "
-	#define MSG_SD_PRINTING_BYTE "SD imprimindo o byte "
-	#define MSG_SD_NOT_PRINTING "Nao esta se imprimindo com o SD"
-	#define MSG_SD_ERR_WRITE_TO_FILE "Erro ao escrever no arquivo"
-	#define MSG_SD_CANT_ENTER_SUBDIR "Nao pode abrir o sub diretorio:"
-
-	#define MSG_STEPPER_TO_HIGH "Steprate muito alto : "
-	#define MSG_ENDSTOPS_HIT "O ponto final foi tocado: "
-	#define MSG_ERR_COLD_EXTRUDE_STOP " Extrusao a frio evitada"
-	#define MSG_ERR_LONG_EXTRUDE_STOP " Extrusao muito larga evitada"
-
-
-#endif
-
-
-
-#if LANGUAGE_CHOICE == 9
-
-// Finnish
-
-// LCD Menu Messages
-	#define WELCOME_MSG MACHINE_NAME " valmis"
-	#define MSG_SD_INSERTED "Kortti asetettu"
-	#define MSG_SD_REMOVED "Kortti poistettu"
-	#define MSG_MAIN "Palaa"
-	#define MSG_AUTOSTART "Automaatti"
-	#define MSG_DISABLE_STEPPERS "Vapauta moottorit"
-	#define MSG_AUTO_HOME "Aja referenssiin"
-	#define MSG_SET_ORIGIN "Aseta origo"
-	#define MSG_PREHEAT_PLA "Esilammita PLA"
-	#define MSG_PREHEAT_PLA_SETTINGS "Esilammita PLA konf"
-	#define MSG_PREHEAT_ABS "Esilammita ABS"
-	#define MSG_PREHEAT_ABS_SETTINGS "Esilammita ABS konf"
-	#define MSG_COOLDOWN "Jaahdyta"
-	#define MSG_EXTRUDE "Pursota"
-	#define MSG_RETRACT "Veda takaisin"
-	#define MSG_MOVE_AXIS "Liikuta akseleita"
-	#define MSG_SPEED "Nopeus"
-	#define MSG_NOZZLE "Suutin"
-	#define MSG_NOZZLE1 "Suutin2"
-	#define MSG_NOZZLE2 "Suutin3"
-	#define MSG_BED "Alusta"
-	#define MSG_FAN_SPEED "Tuul. nopeus"
-	#define MSG_FLOW "Virtaus"
-	#define MSG_CONTROL "Kontrolli"
-	#define MSG_MIN " \002 Min"
-	#define MSG_MAX " \002 Max"
-	#define MSG_FACTOR " \002 Kerr"
-	#define MSG_AUTOTEMP "Autotemp"
-	#define MSG_ON "On "
-	#define MSG_OFF "Off"
-	#define MSG_PID_P "PID-P"
-	#define MSG_PID_I "PID-I"
-	#define MSG_PID_D "PID-D"
-	#define MSG_PID_C "PID-C"
-	#define MSG_ACC  "Kiihtyv"
-	#define MSG_VXY_JERK "Vxy-jerk"
-	#define MSG_VMAX "Vmax "
-	#define MSG_X "x"
-	#define MSG_Y "y"
-	#define MSG_Z "z"
-	#define MSG_E "e"
-	#define MSG_VMIN "Vmin"
-	#define MSG_VTRAV_MIN "VLiike min"
-	#define MSG_AMAX "Amax "
-	#define MSG_A_RETRACT "A-peruuta"
-	#define MSG_XSTEPS "Xsteps/mm"
-	#define MSG_YSTEPS "Ysteps/mm"
-	#define MSG_ZSTEPS "Zsteps/mm"
-	#define MSG_ESTEPS "Esteps/mm"
-	#define MSG_RECTRACT "Veda takaisin"
-	#define MSG_TEMPERATURE "Lampotila"
-	#define MSG_MOTION "Liike"
-	#define MSG_STORE_EPROM "Tallenna muistiin"
-	#define MSG_LOAD_EPROM "Lataa muistista"
-	#define MSG_RESTORE_FAILSAFE "Palauta oletus"
-	#define MSG_REFRESH "Paivita"
-	#define MSG_WATCH "Seuraa"
-	#define MSG_PREPARE "Valmistele"
-	#define MSG_TUNE "Saada"
-	#define MSG_PAUSE_PRINT "Keskeyta tulostus"
-	#define MSG_RESUME_PRINT "Jatka tulostusta"
-	#define MSG_STOP_PRINT "Pysayta tulostus"
-	#define MSG_CARD_MENU "Korttivalikko"
-	#define MSG_NO_CARD "Ei korttia"
-	#define MSG_DWELL "Nukkumassa..."
-	#define MSG_USERWAIT "Odotetaan valintaa..."
-	#define MSG_RESUMING "Jatketaan tulostusta"
-	#define MSG_NO_MOVE "Ei liiketta."
-	#define MSG_KILLED "KILLED. "
-	#define MSG_STOPPED "STOPPED. "
-	#define MSG_CONTROL_RETRACT  "Veda mm"
-	#define MSG_CONTROL_RETRACTF "Veda F"
-	#define MSG_CONTROL_RETRACT_ZLIFT "Z mm"
-	#define MSG_CONTROL_RETRACT_RECOVER "UnRet +mm"
-	#define MSG_CONTROL_RETRACT_RECOVERF "UnRet  F"
-	#define MSG_AUTORETRACT "AutoVeto."
-	#define MSG_FILAMENTCHANGE "Change filament"
-
-// Serial Console Messages
-
-	#define MSG_Enqueing "jonoon \""
-	#define MSG_POWERUP "Kaynnistys"
-	#define MSG_EXTERNAL_RESET " Ulkoinen Reset"
-	#define MSG_BROWNOUT_RESET " Alajannite Reset"
-	#define MSG_WATCHDOG_RESET " Vahtikoira Reset"
-	#define MSG_SOFTWARE_RESET " Ohjelmisto Reset"
-	#define MSG_MARLIN "Marlin "
-	#define MSG_AUTHOR " | Author: "
-	#define MSG_CONFIGURATION_VER " Paivitetty viimeksi: "
-	#define MSG_FREE_MEMORY " Vapaata muistia: "
-	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
-	#define MSG_OK "ok"
-	#define MSG_FILE_SAVED "Tiedosto tallennettu."
-	#define MSG_ERR_LINE_NO "Rivinumero ei ole Viimeisin rivi+1, Viimeisin rivi: "
-	#define MSG_ERR_CHECKSUM_MISMATCH "Tarkistesummassa virhe, Viimeisin rivi: "
-	#define MSG_ERR_NO_CHECKSUM "Rivilla ei tarkistesummaa, Viimeisin rivi: "
-	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Ei rivinumeroa tarkistesumman kanssa, Viimeisin rivi: "
-	#define MSG_FILE_PRINTED "Tiedoston tulostus valmis"
-	#define MSG_BEGIN_FILE_LIST "Tiedostolistauksen alku"
-	#define MSG_END_FILE_LIST "Tiedostolistauksen loppu"
-	#define MSG_M104_INVALID_EXTRUDER "M104 Virheellinen suutin "
-	#define MSG_M105_INVALID_EXTRUDER "M105 Virheellinen suutin "
-	#define MSG_M218_INVALID_EXTRUDER "M218 Virheellinen suutin "
-	#define MSG_ERR_NO_THERMISTORS "Ei termistoreja - ei lampotiloja"
-	#define MSG_M109_INVALID_EXTRUDER "M109 Virheellinen suutin "
-	#define MSG_HEATING "Lammitan..."
-	#define MSG_HEATING_COMPLETE "Lammitys valmis."
-	#define MSG_BED_HEATING "Alusta lampiaa."
-	#define MSG_BED_DONE "Alusta valmis."
-	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
-	#define MSG_COUNT_X " Laskuri X: "
-	#define MSG_ERR_KILLED "Tulostin pysaytetty. kill():ia kutsuttu!"
-	#define MSG_ERR_STOPPED "Tulostin pysaytetty virheiden vuoksi. Korjaa virheet ja kayta M999 kaynnistaaksesi uudelleen. (Lampotila nollattiin. Aseta lampotila sen jalkeen kun jatkat.)"
-	#define MSG_RESEND "Uudelleenlahetys: "
-	#define MSG_UNKNOWN_COMMAND "Tuntematon komento: \""
-	#define MSG_ACTIVE_EXTRUDER "Aktiivinen suutin: "
-	#define MSG_INVALID_EXTRUDER "Virheellinen suutin"
-	#define MSG_X_MIN "x_min: "
-	#define MSG_X_MAX "x_max: "
-	#define MSG_Y_MIN "y_min: "
-	#define MSG_Y_MAX "y_max: "
-	#define MSG_Z_MIN "z_min: "
-	#define MSG_Z_MAX "z_max: "
-	#define MSG_M119_REPORT "Rajakytkimien tilaraportti"
-	#define MSG_ENDSTOP_HIT "AKTIIVISENA"
-	#define MSG_ENDSTOP_OPEN "avoinna"
-	#define MSG_HOTEND_OFFSET "Hotend offsets:"
-
-	#define MSG_SD_CANT_OPEN_SUBDIR "Alihakemistoa ei voitu avata"
-	#define MSG_SD_INIT_FAIL "SD alustus epaonnistui"
-	#define MSG_SD_VOL_INIT_FAIL "volume.init epaonnistui"
-	#define MSG_SD_OPENROOT_FAIL "openRoot epaonnistui"
-	#define MSG_SD_CARD_OK "SD kortti ok"
-	#define MSG_SD_WORKDIR_FAIL "workDir open epaonnistui"
-	#define MSG_SD_OPEN_FILE_FAIL "avaus epaonnistui, Tiedosto: "
-	#define MSG_SD_FILE_OPENED "Tiedosto avattu: "
-	#define MSG_SD_SIZE " Koko: "
-	#define MSG_SD_FILE_SELECTED "Tiedosto valittu"
-	#define MSG_SD_WRITE_TO_FILE "Kirjoitetaan tiedostoon: "
-	#define MSG_SD_PRINTING_BYTE "SD tulostus byte "
-	#define MSG_SD_NOT_PRINTING "Ei SD tulostus"
-	#define MSG_SD_ERR_WRITE_TO_FILE "virhe kirjoitettaessa tiedostoon"
-	#define MSG_SD_CANT_ENTER_SUBDIR "Alihakemistoon ei voitu siirtya: "
-
-	#define MSG_STEPPER_TO_HIGH "Askellustaajuus liian suuri: "
-	#define MSG_ENDSTOPS_HIT "paatyrajat aktivoitu: "
-	#define MSG_ERR_COLD_EXTRUDE_STOP " kylmana pursotus estetty"
-	#define MSG_ERR_LONG_EXTRUDE_STOP " liian pitka pursotus estetty"
-
-#endif
+#ifndef LANGUAGE_H
+#define LANGUAGE_H
+
+// NOTE: IF YOU CHANGE THIS FILE / MERGE THIS FILE WITH CHANGES
+//
+//   ==&gt; ALWAYS TRY TO COMPILE MARLIN WITH/WITHOUT "ULTIPANEL" / "ULTRALCD" / "SDSUPPORT" #define IN "Configuration.h" 
+//   ==&gt; ALSO TRY ALL AVAILABLE "LANGUAGE_CHOICE" OPTIONS
+
+// Languages
+// 1  English
+// 2  Polish
+// 3  French	(awaiting translation!)
+// 4  German
+// 5  Spanish
+// 6  Russian
+// 7  Italian
+// 8  Portuguese
+// 9  Finnish
+
+#ifndef LANGUAGE_CHOICE
+#define LANGUAGE_CHOICE 1  // Pick your language from the list above
+#endif
+
+#define PROTOCOL_VERSION "1.0"
+
+#if MOTHERBOARD == 7 || MOTHERBOARD == 71
+	#define MACHINE_NAME "Ultimaker"
+	#define FIRMWARE_URL "http://firmware.ultimaker.com"
+#elif MOTHERBOARD == 80
+	#define MACHINE_NAME "Rumba"
+	#define FIRMWARE_URL "https://github.com/ErikZalm/Marlin/"
+#else
+	#define MACHINE_NAME "Mendel"
+	#define FIRMWARE_URL "http://www.mendel-parts.com"
+#endif
+
+#define STRINGIFY_(n) #n
+#define STRINGIFY(n) STRINGIFY_(n)
+
+#if LANGUAGE_CHOICE == 1
+
+// LCD Menu Messages
+	#define WELCOME_MSG MACHINE_NAME " Ready."
+	#define MSG_SD_INSERTED "Card inserted"
+	#define MSG_SD_REMOVED "Card removed"
+	#define MSG_MAIN "Main"
+	#define MSG_AUTOSTART "Autostart"
+	#define MSG_DISABLE_STEPPERS "Disable Steppers"
+	#define MSG_AUTO_HOME "Auto Home"
+	#define MSG_SET_ORIGIN "Set Origin"
+	#define MSG_PREHEAT_PLA "Preheat PLA"
+	#define MSG_PREHEAT_PLA_SETTINGS "Preheat PLA Conf"
+	#define MSG_PREHEAT_ABS "Preheat ABS"
+	#define MSG_PREHEAT_ABS_SETTINGS "Preheat ABS Conf"
+	#define MSG_COOLDOWN "Cooldown"
+	#define MSG_EXTRUDE "Extrude"
+	#define MSG_RETRACT "Retract"
+	#define MSG_MOVE_AXIS "Move Axis"
+	#define MSG_SPEED "Speed"
+	#define MSG_NOZZLE "Nozzle"
+	#define MSG_NOZZLE1 "Nozzle2"
+	#define MSG_NOZZLE2 "Nozzle3"
+	#define MSG_BED "Bed"
+	#define MSG_FAN_SPEED "Fan speed"
+	#define MSG_FLOW "Flow"
+	#define MSG_CONTROL "Control"
+	#define MSG_MIN " \002 Min"
+	#define MSG_MAX " \002 Max"
+	#define MSG_FACTOR " \002 Fact"
+	#define MSG_AUTOTEMP "Autotemp"
+	#define MSG_ON "On "
+	#define MSG_OFF "Off"
+	#define MSG_PID_P "PID-P"
+	#define MSG_PID_I "PID-I"
+	#define MSG_PID_D "PID-D"
+	#define MSG_PID_C "PID-C"
+	#define MSG_ACC  "Accel"
+	#define MSG_VXY_JERK "Vxy-jerk"
+	#define MSG_VMAX "Vmax "
+	#define MSG_X "x"
+	#define MSG_Y "y"
+	#define MSG_Z "z"
+	#define MSG_E "e"
+	#define MSG_VMIN "Vmin"
+	#define MSG_VTRAV_MIN "VTrav min"
+	#define MSG_AMAX "Amax "
+	#define MSG_A_RETRACT "A-retract"
+	#define MSG_XSTEPS "Xsteps/mm"
+	#define MSG_YSTEPS "Ysteps/mm"
+	#define MSG_ZSTEPS "Zsteps/mm"
+	#define MSG_ESTEPS "Esteps/mm"
+	#define MSG_RECTRACT "Rectract"
+	#define MSG_TEMPERATURE "Temperature"
+	#define MSG_MOTION "Motion"
+	#define MSG_STORE_EPROM "Store memory"
+	#define MSG_LOAD_EPROM "Load memory"
+	#define MSG_RESTORE_FAILSAFE "Restore Failsafe"
+	#define MSG_REFRESH "Refresh"
+	#define MSG_WATCH "Watch"
+	#define MSG_PREPARE "Prepare"
+	#define MSG_TUNE "Tune"
+	#define MSG_PAUSE_PRINT "Pause Print"
+	#define MSG_RESUME_PRINT "Resume Print"
+	#define MSG_STOP_PRINT "Stop Print"
+	#define MSG_CARD_MENU "Card Menu"
+	#define MSG_NO_CARD "No Card"
+	#define MSG_DWELL "Sleep..."
+	#define MSG_USERWAIT "Wait for user..."
+	#define MSG_RESUMING "Resuming print"
+	#define MSG_NO_MOVE "No move."
+	#define MSG_KILLED "KILLED. "
+	#define MSG_STOPPED "STOPPED. "
+	#define MSG_CONTROL_RETRACT  "Retract mm"
+	#define MSG_CONTROL_RETRACTF "Retract  F"
+	#define MSG_CONTROL_RETRACT_ZLIFT "Hop mm"
+	#define MSG_CONTROL_RETRACT_RECOVER "UnRet +mm"
+	#define MSG_CONTROL_RETRACT_RECOVERF "UnRet  F"
+	#define MSG_AUTORETRACT "AutoRetr."
+	#define MSG_FILAMENTCHANGE "Change filament"
+	#define MSG_INIT_SDCARD "Init. SD-Card"	
+	#define MSG_CNG_SDCARD "Change SD-Card"
+
+// Serial Console Messages
+
+	#define MSG_Enqueing "enqueing \""
+	#define MSG_POWERUP "PowerUp"
+	#define MSG_EXTERNAL_RESET " External Reset"
+	#define MSG_BROWNOUT_RESET " Brown out Reset"
+	#define MSG_WATCHDOG_RESET " Watchdog Reset"
+	#define MSG_SOFTWARE_RESET " Software Reset"
+	#define MSG_MARLIN "Marlin "
+	#define MSG_AUTHOR " | Author: "
+	#define MSG_CONFIGURATION_VER " Last Updated: "
+	#define MSG_FREE_MEMORY " Free Memory: "
+	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
+	#define MSG_OK "ok"
+	#define MSG_FILE_SAVED "Done saving file."
+	#define MSG_ERR_LINE_NO "Line Number is not Last Line Number+1, Last Line: "
+	#define MSG_ERR_CHECKSUM_MISMATCH "checksum mismatch, Last Line: "
+	#define MSG_ERR_NO_CHECKSUM "No Checksum with line number, Last Line: "
+	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "No Line Number with checksum, Last Line: "
+	#define MSG_FILE_PRINTED "Done printing file"
+	#define MSG_BEGIN_FILE_LIST "Begin file list"
+	#define MSG_END_FILE_LIST "End file list"
+	#define MSG_M104_INVALID_EXTRUDER "M104 Invalid extruder "
+	#define MSG_M105_INVALID_EXTRUDER "M105 Invalid extruder "
+	#define MSG_M218_INVALID_EXTRUDER "M218 Invalid extruder "
+	#define MSG_ERR_NO_THERMISTORS "No thermistors - no temperature"
+	#define MSG_M109_INVALID_EXTRUDER "M109 Invalid extruder "
+	#define MSG_HEATING "Heating..."
+	#define MSG_HEATING_COMPLETE "Heating done."
+	#define MSG_BED_HEATING "Bed Heating."
+	#define MSG_BED_DONE "Bed done."
+	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
+	#define MSG_COUNT_X " Count X: "
+	#define MSG_ERR_KILLED "Printer halted. kill() called!"
+	#define MSG_ERR_STOPPED "Printer stopped due to errors. Fix the error and use M999 to restart. (Temperature is reset. Set it after restarting)"
+	#define MSG_RESEND "Resend: "
+	#define MSG_UNKNOWN_COMMAND "Unknown command: \""
+	#define MSG_ACTIVE_EXTRUDER "Active Extruder: "
+	#define MSG_INVALID_EXTRUDER "Invalid extruder"
+	#define MSG_X_MIN "x_min: "
+	#define MSG_X_MAX "x_max: "
+	#define MSG_Y_MIN "y_min: "
+	#define MSG_Y_MAX "y_max: "
+	#define MSG_Z_MIN "z_min: "
+	#define MSG_Z_MAX "z_max: "
+	#define MSG_M119_REPORT "Reporting endstop status"
+	#define MSG_ENDSTOP_HIT "TRIGGERED"
+	#define MSG_ENDSTOP_OPEN "open"
+	#define MSG_HOTEND_OFFSET "Hotend offsets:"
+
+	#define MSG_SD_CANT_OPEN_SUBDIR "Cannot open subdir"
+	#define MSG_SD_INIT_FAIL "SD init fail"
+	#define MSG_SD_VOL_INIT_FAIL "volume.init failed"
+	#define MSG_SD_OPENROOT_FAIL "openRoot failed"
+	#define MSG_SD_CARD_OK "SD card ok"
+	#define MSG_SD_WORKDIR_FAIL "workDir open failed"
+	#define MSG_SD_OPEN_FILE_FAIL "open failed, File: "
+	#define MSG_SD_FILE_OPENED "File opened: "
+	#define MSG_SD_SIZE " Size: "
+	#define MSG_SD_FILE_SELECTED "File selected"
+	#define MSG_SD_WRITE_TO_FILE "Writing to file: "
+	#define MSG_SD_PRINTING_BYTE "SD printing byte "
+	#define MSG_SD_NOT_PRINTING "Not SD printing"
+	#define MSG_SD_ERR_WRITE_TO_FILE "error writing to file"
+	#define MSG_SD_CANT_ENTER_SUBDIR "Cannot enter subdir: "
+
+	#define MSG_STEPPER_TO_HIGH "Steprate to high: "
+	#define MSG_ENDSTOPS_HIT "endstops hit: "
+	#define MSG_ERR_COLD_EXTRUDE_STOP " cold extrusion prevented"
+	#define MSG_ERR_LONG_EXTRUDE_STOP " too long extrusion prevented"
+
+#endif
+
+
+#if LANGUAGE_CHOICE == 2
+
+// LCD Menu Messages
+	#define WELCOME_MSG MACHINE_NAME " Gotowe."
+	#define MSG_SD_INSERTED "Karta wlozona"
+	#define MSG_SD_REMOVED "Karta usunieta"
+	#define MSG_MAIN "Main"
+	#define MSG_AUTOSTART "Autostart"
+	#define MSG_DISABLE_STEPPERS "Wylacz silniki"
+	#define MSG_AUTO_HOME "Auto. poz. zerowa"
+	#define MSG_SET_ORIGIN "Ustaw punkt zerowy"
+	#define MSG_PREHEAT_PLA "Rozgrzej PLA"
+	#define MSG_PREHEAT_PLA_SETTINGS "Ustawienia roz. PLA"
+	#define MSG_PREHEAT_ABS "Rozgrzej ABS"
+	#define MSG_PREHEAT_ABS_SETTINGS "Ustawienia roz. ABS"
+	#define MSG_COOLDOWN "Chlodzenie"
+	#define MSG_EXTRUDE "Ekstruzja"
+	#define MSG_RETRACT "Cofanie"
+	#define MSG_MOVE_AXIS "Ruch osi"
+	#define MSG_SPEED "Predkosc"
+	#define MSG_NOZZLE "Dysza"
+	#define MSG_NOZZLE1 "Dysza2"
+	#define MSG_NOZZLE2 "Dysza3"
+	#define MSG_BED "Loze"
+	#define MSG_FAN_SPEED "Obroty wiatraka"
+	#define MSG_FLOW "Przeplyw"
+	#define MSG_CONTROL "Kontrola"
+	#define MSG_MIN " \002 Min"
+	#define MSG_MAX " \002 Max"
+	#define MSG_FACTOR " \002 Mnoznik"
+	#define MSG_AUTOTEMP "Auto. temp."
+	#define MSG_ON "Wl. "
+	#define MSG_OFF "Wyl."
+	#define MSG_PID_P "PID-P"
+	#define MSG_PID_I "PID-I"
+	#define MSG_PID_D "PID-D"
+	#define MSG_PID_C "PID-C"
+	#define MSG_ACC  "Acc"
+	#define MSG_VXY_JERK "Zryw Vxy"
+	#define MSG_VMAX "Vmax"
+	#define MSG_X "x"
+	#define MSG_Y "y"
+	#define MSG_Z "z"
+	#define MSG_E "e"
+	#define MSG_VMIN "Vmin"
+	#define MSG_VTRAV_MIN "Vskok min"
+	#define MSG_AMAX "Amax"
+	#define MSG_A_RETRACT "A-wycofanie"
+	#define MSG_XSTEPS "krokiX/mm"
+	#define MSG_YSTEPS "krokiY/mm"
+	#define MSG_ZSTEPS "krokiZ/mm"
+	#define MSG_ESTEPS "krokiE/mm"
+	#define MSG_RECTRACT "Wycofanie"
+	#define MSG_TEMPERATURE "Temperatura"
+	#define MSG_MOTION "Ruch"
+	#define MSG_STORE_EPROM "Zapisz w pamieci"
+	#define MSG_LOAD_EPROM "Wczytaj z pamieci"
+	#define MSG_RESTORE_FAILSAFE " Ustawienia fabryczne"
+	#define MSG_REFRESH "\004Odswiez"
+	#define MSG_WATCH "Obserwuj"
+	#define MSG_PREPARE "Przygotuj"
+	#define MSG_CONTROL "Kontroluj"
+	#define MSG_TUNE "Strojenie"
+	#define MSG_PAUSE_PRINT "Pauza"
+	#define MSG_RESUME_PRINT "Wznowienie"
+	#define MSG_STOP_PRINT "Stop"
+	#define MSG_CARD_MENU "Menu SDCard"
+	#define MSG_NO_CARD "Brak karty"
+	#define MSG_DWELL "Uspij..."
+	#define MSG_USERWAIT "Czekaj na uzytkownika..."
+	#define MSG_RESUMING "Wznawiam drukowanie"
+	#define MSG_NO_MOVE "Brak ruchu."
+	#define MSG_PART_RELEASE "Czesciowe zwolnienie"
+	#define MSG_KILLED "Ubity. "
+	#define MSG_STOPPED "Zatrzymany. "
+	#define MSG_STEPPER_RELEASED "Zwolniony."
+	#define MSG_CONTROL_RETRACT  "Wycofaj mm"
+	#define MSG_CONTROL_RETRACTF "Wycofaj  F"
+	#define MSG_CONTROL_RETRACT_ZLIFT "Skok Z mm:"
+	#define MSG_CONTROL_RETRACT_RECOVER "Cof. wycof. +mm"
+	#define MSG_CONTROL_RETRACT_RECOVERF "Cof. wycof.  F"
+	#define MSG_AUTORETRACT "Auto. wycofanie"
+	#define MSG_FILAMENTCHANGE "Change filament"
+
+// Serial Console Messages
+
+	#define MSG_Enqueing "Kolejkowanie \""
+	#define MSG_POWERUP "Zasilanie wlaczone"
+	#define MSG_EXTERNAL_RESET " Reset (zewnetrzny)"
+	#define MSG_BROWNOUT_RESET " Reset (spadek napiecia)"
+	#define MSG_WATCHDOG_RESET " Reset (watchdog)"
+	#define MSG_SOFTWARE_RESET " Reset (programowy)"
+	#define MSG_MARLIN "Marlin "
+	#define MSG_AUTHOR " | Autor: "
+	#define MSG_CONFIGURATION_VER " Ostatnia aktualizacja: "
+	#define MSG_FREE_MEMORY " Wolna pamiec: "
+	#define MSG_PLANNER_BUFFER_BYTES "  Bufor planisty krokow (w bajtach): "
+	#define MSG_OK "ok"
+	#define MSG_FILE_SAVED "Plik zapisany."
+	#define MSG_ERR_LINE_NO "Numer linijki nie jest ostatnim numerem linijki+1; ostatnia linijka:"
+	#define MSG_ERR_CHECKSUM_MISMATCH "Niezgodna suma kontrolna; ostatnia linijka: "
+	#define MSG_ERR_NO_CHECKSUM "Brak sumy kontrolnej w linijce; ostatnia linijka:"
+	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Brak numery linijki przy sumie kontrolnej; ostatnia linijka:"
+	#define MSG_FILE_PRINTED "Ukonczono wydruk z pliku"
+	#define MSG_BEGIN_FILE_LIST "Start listy plikow"
+	#define MSG_END_FILE_LIST "Koniec listy plikow"
+	#define MSG_M104_INVALID_EXTRUDER "M104 Niepoprawny ekstruder "
+	#define MSG_M105_INVALID_EXTRUDER "M105 Niepoprawny ekstruder "
+	#define MSG_M218_INVALID_EXTRUDER "M218 Niepoprawny ekstruder "
+	#define MSG_ERR_NO_THERMISTORS "Brak termistorow - brak temperatury :("
+	#define MSG_M109_INVALID_EXTRUDER "M109 Niepoprawny ekstruder "
+	#define MSG_HEATING "Nagrzewanie ekstrudera..."
+	#define MSG_HEATING_COMPLETE "Nagrzewanie ekstrudera zakonczone."
+	#define MSG_BED_HEATING "Nagrzewanie loza..."
+	#define MSG_BED_DONE "Nagrzewanie loza zakonczone."
+	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
+	#define MSG_COUNT_X " Liczenie X: "
+	#define MSG_ERR_KILLED "Drukarka zatrzymana. Wywolano kill()"
+	#define MSG_ERR_STOPPED "Drukarka zatrzymana z powodu bledu. Usun problem i zrestartuj drukartke komenda M999. (temperatura zostala zresetowana; ustaw temperature po restarcie)"
+	#define MSG_RESEND "Wyslij ponownie: "
+	#define MSG_UNKNOWN_COMMAND "Nieznane polecenie: \""
+	#define MSG_ACTIVE_EXTRUDER "Aktywny ekstruder: "
+	#define MSG_INVALID_EXTRUDER "Niepoprawny ekstruder"
+	#define MSG_X_MIN "x_min: "
+	#define MSG_X_MAX "x_max: "
+	#define MSG_Y_MIN "y_min: "
+	#define MSG_Y_MAX "y_max: "
+	#define MSG_Z_MIN "z_min: "
+	#define MSG_Z_MAX "z_max: "
+	#define MSG_M119_REPORT "Zgloszenie statusu wylacznikow krancowych"
+	#define MSG_ENDSTOP_HIT "WYZWOLONY"
+	#define MSG_ENDSTOP_OPEN "otwarty"
+	#define MSG_HOTEND_OFFSET "Hotend offsets:"
+
+	#define MSG_SD_CANT_OPEN_SUBDIR "Nie mozna otworzyc podkatalogu"
+	#define MSG_SD_INIT_FAIL "Blad inicjalizacji karty SD"
+	#define MSG_SD_VOL_INIT_FAIL "Blad inizjalizacji wolumenu"
+	#define MSG_SD_OPENROOT_FAIL "Blad odczytywania katalogu glownego"
+	#define MSG_SD_CARD_OK "Karta SD zainicjalizowana"
+	#define MSG_SD_WORKDIR_FAIL "Blad odczytywania katalogu roboczego"
+	#define MSG_SD_OPEN_FILE_FAIL "Nie mozna otworzyc pliku: "
+	#define MSG_SD_FILE_OPENED "Otwarto plik:"
+	#define MSG_SD_SIZE " Rozmiar:"
+	#define MSG_SD_FILE_SELECTED "Wybrano plik"
+	#define MSG_SD_WRITE_TO_FILE "Zapisywanie do pliku: "
+	#define MSG_SD_PRINTING_BYTE "Drukowanie z karty SD, bajt "
+	#define MSG_SD_NOT_PRINTING "Nie trwa drukowanie z karty SD"
+	#define MSG_SD_ERR_WRITE_TO_FILE "blad podczas zapisu do pliku"
+	#define MSG_SD_CANT_ENTER_SUBDIR "Nie mozna odczytac podkatalogu: "
+
+	#define MSG_STEPPER_TO_HIGH "Za duza czestotliwosc krokow: "
+	#define MSG_ENDSTOPS_HIT "Wylacznik krancowy zostal wyzwolony na pozycji: "
+	#define MSG_ERR_COLD_EXTRUDE_STOP " uniemozliwiono zimna ekstruzje"
+	#define MSG_ERR_LONG_EXTRUDE_STOP " uniemozliwiono zbyt dluga ekstruzje"
+
+#endif
+
+
+#if LANGUAGE_CHOICE == 3
+
+#define WELCOME_MSG MACHINE_NAME " Pret."
+#define MSG_SD_INSERTED "Carte inseree"
+#define MSG_SD_REMOVED "Carte retiree"
+#define MSG_MAIN " Principal \003"
+#define MSG_AUTOSTART " Demarrage auto."
+#define MSG_DISABLE_STEPPERS " Desactiver moteurs"
+#define MSG_AUTO_HOME " Home auto."
+#define MSG_SET_ORIGIN " Regler origine"
+#define MSG_PREHEAT_PLA " Prechauffage PLA"
+#define MSG_PREHEAT_PLA_SETTINGS " Regl. prechauffe PLA"
+#define MSG_PREHEAT_ABS " Prechauffage ABS"
+#define MSG_PREHEAT_ABS_SETTINGS " Regl. prechauffe ABS"
+#define MSG_COOLDOWN " Refroidissement"
+#define MSG_EXTRUDE " Extrusion"
+#define MSG_RETRACT " Retractation"
+#define MSG_PREHEAT_PLA " Prechauffage PLA"
+#define MSG_PREHEAT_ABS " Prechauffage ABS"
+#define MSG_MOVE_AXIS " Deplacer axe \x7E"
+#define MSG_SPEED " Vitesse:"
+#define MSG_NOZZLE " \002Buse:"
+#define MSG_NOZZLE1 " \002Buse2:"
+#define MSG_NOZZLE2 " \002Buse3:"
+#define MSG_BED " \002Lit:"
+#define MSG_FAN_SPEED " Vitesse ventilateur:"
+#define MSG_FLOW " Flux:"
+#define MSG_CONTROL " Controle \003"
+#define MSG_MIN " \002 Min:"
+#define MSG_MAX " \002 Max:"
+#define MSG_FACTOR " \002 Facteur:"
+#define MSG_AUTOTEMP " Temp. Auto.:"
+#define MSG_ON "Marche "
+#define MSG_OFF "Arret"
+#define MSG_PID_P " PID-P: "
+#define MSG_PID_I " PID-I: "
+#define MSG_PID_D " PID-D: "
+#define MSG_PID_C " PID-C: "
+#define MSG_ACC " Acc:"
+#define MSG_VXY_JERK " Vxy-jerk: "
+#define MSG_VMAX " Vmax "
+#define MSG_X "x:"
+#define MSG_Y "y:"
+#define MSG_Z "z:"
+#define MSG_E "e:"
+#define MSG_VMIN " Vmin:"
+#define MSG_VTRAV_MIN " Vdepl min:"
+#define MSG_AMAX " Amax "
+#define MSG_A_RETRACT " A-retract:"
+#define MSG_XSTEPS " Xpas/mm:"
+#define MSG_YSTEPS " Ypas/mm:"
+#define MSG_ZSTEPS " Zpas/mm:"
+#define MSG_ESTEPS " Epas/mm:"
+#define MSG_MAIN_WIDE " Principal \003"
+#define MSG_RECTRACT_WIDE " Rectractater \x7E"
+#define MSG_TEMPERATURE_WIDE " Temperature \x7E"
+#define MSG_TEMPERATURE_RTN " Temperature \003"
+#define MSG_MOTION_WIDE " Mouvement \x7E"
+#define MSG_STORE_EPROM " Sauvegarder memoire"
+#define MSG_LOAD_EPROM " Lire memoire"
+#define MSG_RESTORE_FAILSAFE " Restaurer memoire"
+#define MSG_REFRESH "\004Actualiser"
+#define MSG_WATCH " Surveiller \003"
+#define MSG_PREPARE " Preparer \x7E"
+#define MSG_PREPARE_ALT " Prepare \003"
+#define MSG_CONTROL_ARROW " Controle \x7E"
+#define MSG_RETRACT_ARROW " Retracter \x7E"
+#define MSG_TUNE " Regler \x7E"
+#define MSG_PAUSE_PRINT " Pause impression \x7E"
+#define MSG_RESUME_PRINT " Reprendre impression \x7E"
+#define MSG_STOP_PRINT " Arreter impression \x7E"
+#define MSG_CARD_MENU " Menu carte \x7E"
+#define MSG_NO_CARD " Pas de carte"
+#define MSG_DWELL "Repos..."
+#define MSG_USERWAIT "Attente de l'utilisateur..."
+#define MSG_NO_MOVE "Aucun mouvement."
+#define MSG_PART_RELEASE "Relache partielle"
+#define MSG_KILLED "TUE."
+#define MSG_STOPPED "STOPPE."
+#define MSG_STEPPER_RELEASED "RELACHE."
+#define MSG_CONTROL_RETRACT " Retractation mm:"
+#define MSG_CONTROL_RETRACTF " Retractation F:"
+#define MSG_CONTROL_RETRACT_ZLIFT " Hop mm:"
+#define MSG_CONTROL_RETRACT_RECOVER " UnRet +mm:"
+#define MSG_CONTROL_RETRACT_RECOVERF " UnRet F:"
+#define MSG_AUTORETRACT " Retract. Auto.:"
+#define MSG_FILAMENTCHANGE "Change filament"
+
+// Serial Console Messages
+
+#define MSG_Enqueing "Mise en tampon \""
+#define MSG_POWERUP "Allumage"
+#define MSG_EXTERNAL_RESET " RAZ Externe"
+#define MSG_BROWNOUT_RESET " RAZ defaut alim."
+#define MSG_WATCHDOG_RESET " RAZ Watchdog"
+#define MSG_SOFTWARE_RESET " RAZ logicielle"
+#define MSG_MARLIN "Marlin "
+#define MSG_AUTHOR " | Auteur: "
+#define MSG_CONFIGURATION_VER " Derniere MaJ: "
+#define MSG_FREE_MEMORY " Memoire libre: "
+#define MSG_PLANNER_BUFFER_BYTES " PlannerBufferBytes: "
+#define MSG_OK "ok"
+#define MSG_FILE_SAVED "Fichier enregistre."
+#define MSG_ERR_LINE_NO "Le numero de ligne n'est pas la derniere ligne + 1, derniere ligne: "
+#define MSG_ERR_CHECKSUM_MISMATCH "Erreur somme de controle, derniere ligne: "
+#define MSG_ERR_NO_CHECKSUM "Pas de somme de controle avec le numero de ligne, derniere ligne: "
+#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Pas de numero de ligne avec somme de controle, derniere ligne: "
+#define MSG_FILE_PRINTED "Impression terminee"
+#define MSG_BEGIN_FILE_LIST "Debut de la liste de fichiers"
+#define MSG_END_FILE_LIST "Fin de la liste de fichiers"
+#define MSG_M104_INVALID_EXTRUDER "M104 Extruder invalide"
+#define MSG_M105_INVALID_EXTRUDER "M105 Extruder invalide"
+#define MSG_M218_INVALID_EXTRUDER "M218 Extruder invalide"
+#define MSG_ERR_NO_THERMISTORS "Pas de thermistor, pas de temperature"
+#define MSG_M109_INVALID_EXTRUDER "M109 Extruder invalide "
+#define MSG_HEATING "En chauffe..."
+#define MSG_HEATING_COMPLETE "Chauffe terminee."
+#define MSG_BED_HEATING "Chauffe du lit."
+#define MSG_BED_DONE "Chauffe du lit terminee."
+#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
+#define MSG_COUNT_X " Compteur X: "
+#define MSG_ERR_KILLED "Impression arretee. kill() appelee!"
+#define MSG_ERR_STOPPED "Impression arretee a cause d'erreurs. Corriger les erreurs et utiliser M999 pour la reprendre. (Temperature remise a zero. Reactivez la apres redemarrage)"
+#define MSG_RESEND "Renvoie: "
+#define MSG_UNKNOWN_COMMAND "Commande inconnue: \""
+#define MSG_ACTIVE_EXTRUDER "Extrudeur actif: "
+#define MSG_INVALID_EXTRUDER "Extrudeur invalide"
+#define MSG_X_MIN "x_min: "
+#define MSG_X_MAX "x_max: "
+#define MSG_Y_MIN "y_min: "
+#define MSG_Y_MAX "y_max: "
+#define MSG_Z_MIN "z_min: "
+#define MSG_Z_MAX "z_max: "
+#define MSG_M119_REPORT "Affichage du status des fin de course"
+#define MSG_ENDSTOP_HIT "DECLENCHE"
+#define MSG_ENDSTOP_OPEN "OUVERT"
+#define MSG_HOTEND_OFFSET "Hotend offsets:"
+
+#define MSG_SD_CANT_OPEN_SUBDIR "Impossible d'ouvrir le sous-repertoire"
+#define MSG_SD_INIT_FAIL "Echec de l'initialisation de la SD"
+#define MSG_SD_VOL_INIT_FAIL "Echec de volume.init"
+#define MSG_SD_OPENROOT_FAIL "Echec openRoot"
+#define MSG_SD_CARD_OK "Carte SD Ok"
+#define MSG_SD_WORKDIR_FAIL "Echec d'ouverture workDir"
+#define MSG_SD_OPEN_FILE_FAIL "Echec d'ouverture, Fichier: "
+#define MSG_SD_FILE_OPENED "Fichier ouvert: "
+#define MSG_SD_SIZE " Taille: "
+#define MSG_SD_FILE_SELECTED "Fichier selectionne"
+#define MSG_SD_WRITE_TO_FILE "Ecriture dans le fichier: "
+#define MSG_SD_PRINTING_BYTE "Octet impression SD "
+#define MSG_SD_NOT_PRINTING "Pas d'impression SD"
+#define MSG_SD_ERR_WRITE_TO_FILE "Erreur d'ecriture dans le fichier"
+#define MSG_SD_CANT_ENTER_SUBDIR "Impossible d'entrer dans le sous-repertoire: "
+
+#define MSG_STEPPER_TO_HIGH "Steprate trop eleve: "
+#define MSG_ENDSTOPS_HIT "Fin de course atteint: "
+#define MSG_ERR_COLD_EXTRUDE_STOP " Extrusion a froid evitee"
+#define MSG_ERR_LONG_EXTRUDE_STOP " Extrusion longue evitee"
+	
+#endif
+
+
+#if LANGUAGE_CHOICE == 4
+
+// LCD Menu Messages
+
+	#define WELCOME_MSG MACHINE_NAME " Bereit."
+
+	#define MSG_SD_INSERTED      "SDKarte erkannt"
+	#define MSG_SD_REMOVED       "SDKarte entfernt"
+	#define MSG_MAIN             "Hauptmne"
+	#define MSG_AUTOSTART        "Autostart"
+	#define MSG_DISABLE_STEPPERS "Stepper abschalten"
+	#define MSG_AUTO_HOME        "Auto Nullpunkt"
+	#define MSG_SET_ORIGIN       "Setze Nullpunkt"
+	#define MSG_PREHEAT_PLA      "Vorwrmen PLA"
+	#define MSG_PREHEAT_PLA_SETTINGS "Vorwrmen PLA Einstellungen"
+	#define MSG_PREHEAT_ABS      "Vorwrmen ABS"
+	#define MSG_PREHEAT_ABS_SETTINGS "Vorwrmen ABS Einstellungen"
+	#define MSG_COOLDOWN         "Abkhlen"
+	#define MSG_EXTRUDE          "Extrude"
+	#define MSG_RETRACT          "Retract"
+	#define MSG_MOVE_AXIS        "Achsen bewegen"
+	#define MSG_SPEED            "Geschw"
+	#define MSG_NOZZLE           "Dse"
+	#define MSG_NOZZLE1          "Dse2"
+	#define MSG_NOZZLE2          "Dse3"
+	#define MSG_BED              "Bett"
+	#define MSG_FAN_SPEED        "Lftergeschw."
+	#define MSG_FLOW             "Flu"
+	#define MSG_CONTROL          "Einstellungen"
+	#define MSG_MIN              "\002 Min"
+	#define MSG_MAX              "\002 Max"
+	#define MSG_FACTOR           "\002 Faktor"
+	#define MSG_AUTOTEMP         "AutoTemp"
+	#define MSG_ON               "Ein"
+	#define MSG_OFF              "Aus"
+	#define MSG_PID_P            "PID-P"
+	#define MSG_PID_I            "PID-I"
+	#define MSG_PID_D            "PID-D"
+	#define MSG_PID_C            "PID-C"
+	#define MSG_ACC              "Acc"
+	#define MSG_VXY_JERK         "Vxy-jerk"
+	#define MSG_VMAX             "Vmax "
+	#define MSG_X                "x"
+	#define MSG_Y                "y"
+	#define MSG_Z                "z"
+	#define MSG_E                "e"
+	#define MSG_VMIN             "Vmin"
+	#define MSG_VTRAV_MIN        "VTrav min"
+	#define MSG_AMAX             "Amax "
+	#define MSG_A_RETRACT        "A-Retract"
+	#define MSG_XSTEPS           "Xsteps/mm"
+	#define MSG_YSTEPS           "Ysteps/mm"
+	#define MSG_ZSTEPS           "Zsteps/mm"
+	#define MSG_ESTEPS           "Esteps/mm"
+	#define MSG_RECTRACT_WIDE    "Rectract"
+	#define MSG_WATCH            "Beobachten"
+	#define MSG_TEMPERATURE      "Temperatur"
+	#define MSG_MOTION           "Bewegung"
+	#define MSG_STORE_EPROM      "EPROM speichern"
+	#define MSG_LOAD_EPROM       "EPROM laden"
+	#define MSG_RESTORE_FAILSAFE "Standardkonfig."
+	#define MSG_REFRESH          "Aktualisieren"
+	#define MSG_PREPARE          "Vorbereitung"
+	#define MSG_CONTROL          "Einstellungen"
+	#define MSG_TUNE             "Justierung"
+	#define MSG_PAUSE_PRINT      "Druck anhalten"
+	#define MSG_RESUME_PRINT     "Druck fortsetz"
+	#define MSG_STOP_PRINT       "Druck stoppen"
+	#define MSG_CARD_MENU        "SDKarten Men"
+	#define MSG_NO_CARD          "Keine SDKarte"
+	#define MSG_DWELL            "Warten..."		
+	#define MSG_USERWAIT         "Warte auf Nutzer..."
+    #define MSG_RESUMING         "Druck fortsetzung"
+	#define MSG_NO_MOVE          "Kein Zug."
+	#define MSG_PART_RELEASE     "Stepper tlw frei"
+	#define MSG_KILLED           "KILLED"
+	#define MSG_STOPPED          "GESTOPPT"
+	#define MSG_STEPPER_RELEASED "Stepper frei"
+    #define MSG_CONTROL_RETRACT  "Retract mm"
+    #define MSG_CONTROL_RETRACTF "Retract  F"
+    #define MSG_CONTROL_RETRACT_ZLIFT "Hop mm"
+    #define MSG_CONTROL_RETRACT_RECOVER "UnRet +mm"
+    #define MSG_CONTROL_RETRACT_RECOVERF "UnRet  F"
+    #define MSG_AUTORETRACT      "AutoRetr."
+    #define MSG_FILAMENTCHANGE "Filament wechseln"
+	
+// Serial Console Messages
+
+	#define MSG_Enqueing "enqueing \""
+	#define MSG_POWERUP "PowerUp"
+	#define MSG_EXTERNAL_RESET " External Reset"
+	#define MSG_BROWNOUT_RESET " Brown out Reset"
+	#define MSG_WATCHDOG_RESET " Watchdog Reset"
+	#define MSG_SOFTWARE_RESET " Software Reset"
+	#define MSG_MARLIN "Marlin: "
+	#define MSG_AUTHOR " | Author: "
+	#define MSG_CONFIGURATION_VER " Last Updated: "
+	#define MSG_FREE_MEMORY " Free Memory: "
+	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
+	#define MSG_OK "ok"
+	#define MSG_FILE_SAVED "Done saving file."
+	#define MSG_ERR_LINE_NO "Line Number is not Last Line Number+1, Last Line:"
+	#define MSG_ERR_CHECKSUM_MISMATCH "checksum mismatch, Last Line:"
+	#define MSG_ERR_NO_CHECKSUM "No Checksum with line number, Last Line:"
+	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "No Line Number with checksum, Last Line:"
+	#define MSG_FILE_PRINTED "Done printing file"
+	#define MSG_BEGIN_FILE_LIST "Begin file list"
+	#define MSG_END_FILE_LIST "End file list"
+	#define MSG_M104_INVALID_EXTRUDER "M104 Invalid extruder "
+	#define MSG_M105_INVALID_EXTRUDER "M105 Invalid extruder "
+	#define MSG_M218_INVALID_EXTRUDER "M218 Invalid extruder "
+	#define MSG_ERR_NO_THERMISTORS "No thermistors - no temp"
+	#define MSG_M109_INVALID_EXTRUDER "M109 Invalid extruder "
+	#define MSG_HEATING "Heating..."
+	#define MSG_HEATING_COMPLETE "Heating done."
+	#define MSG_BED_HEATING "Bed Heating."
+	#define MSG_BED_DONE "Bed done."
+	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
+	#define MSG_COUNT_X " Count X:"
+	#define MSG_ERR_KILLED "Printer halted. kill() called !!"
+	#define MSG_ERR_STOPPED "Printer stopped due to errors. Fix the error and use M999 to restart!"
+	#define MSG_RESEND "Resend:"
+	#define MSG_UNKNOWN_COMMAND "Unknown command:\""
+	#define MSG_ACTIVE_EXTRUDER "Active Extruder: "
+	#define MSG_INVALID_EXTRUDER "Invalid extruder"
+	#define MSG_X_MIN "x_min: "
+	#define MSG_X_MAX "x_max: "
+	#define MSG_Y_MIN "y_min: "
+	#define MSG_Y_MAX "y_max: "
+	#define MSG_Z_MIN "z_min: "
+	#define MSG_Z_MAX "z_max: "
+	#define MSG_M119_REPORT "Reporting endstop status"
+	#define MSG_ENDSTOP_HIT "TRIGGERED"
+	#define MSG_ENDSTOP_OPEN "open"
+	#define MSG_HOTEND_OFFSET "Hotend offsets:"
+
+	#define MSG_SD_CANT_OPEN_SUBDIR "Cannot open subdir"
+	#define MSG_SD_INIT_FAIL "SD init fail"
+	#define MSG_SD_VOL_INIT_FAIL "volume.init failed"
+	#define MSG_SD_OPENROOT_FAIL "openRoot failed"
+	#define MSG_SD_CARD_OK "SD card ok"
+	#define MSG_SD_WORKDIR_FAIL "workDir open failed"
+	#define MSG_SD_OPEN_FILE_FAIL "open failed, File: "
+	#define MSG_SD_FILE_OPENED "File opened:"
+	#define MSG_SD_SIZE " Size:"
+	#define MSG_SD_FILE_SELECTED "File selected"
+	#define MSG_SD_WRITE_TO_FILE "Writing to file: "
+	#define MSG_SD_PRINTING_BYTE "SD printing byte "
+	#define MSG_SD_NOT_PRINTING "Not SD printing"
+	#define MSG_SD_ERR_WRITE_TO_FILE "error writing to file"
+	#define MSG_SD_CANT_ENTER_SUBDIR "Cannot enter subdir:"
+
+	#define MSG_STEPPER_TO_HIGH "Steprate to high : "
+	#define MSG_ENDSTOPS_HIT "endstops hit: "
+	#define MSG_ERR_COLD_EXTRUDE_STOP " cold extrusion prevented"
+	#define MSG_ERR_LONG_EXTRUDE_STOP " too long extrusion prevented"
+
+#endif
+
+
+#if LANGUAGE_CHOICE == 5
+
+// LCD Menu Messages
+#define WELCOME_MSG MACHINE_NAME " Lista."
+#define MSG_SD_INSERTED "Tarjeta SD Colocada"
+#define MSG_SD_REMOVED "Tarjeta SD Retirada"
+#define MSG_MAIN " Menu Principal \003"
+#define MSG_AUTOSTART " Autostart"
+#define MSG_DISABLE_STEPPERS " Apagar Motores"
+#define MSG_AUTO_HOME " Llevar Ejes al Cero"
+#define MSG_SET_ORIGIN " Establecer Cero"
+#define MSG_COOLDOWN " Enfriar"
+#define MSG_EXTRUDE " Extruir"
+#define MSG_RETRACT " Retraer"
+#define MSG_PREHEAT_PLA " Precalentar PLA"
+#define MSG_PREHEAT_PLA_SETTINGS " Ajustar temp. PLA"
+#define MSG_PREHEAT_ABS " Precalentar ABS"
+#define MSG_PREHEAT_ABS_SETTINGS " Ajustar temp. ABS"
+#define MSG_MOVE_AXIS " Mover Ejes      \x7E"
+#define MSG_SPEED " Velocidad:"
+#define MSG_NOZZLE " \002Nozzle:"
+#define MSG_NOZZLE1 " \002Nozzle2:"
+#define MSG_NOZZLE2 " \002Nozzle3:"
+#define MSG_BED " \002Base:"
+#define MSG_FAN_SPEED " Ventilador:"
+#define MSG_FLOW " Flujo:"
+#define MSG_CONTROL " Control \003"
+#define MSG_MIN " \002 Min:"
+#define MSG_MAX " \002 Max:"
+#define MSG_FACTOR " \002 Fact:"
+#define MSG_AUTOTEMP " Autotemp:"
+#define MSG_ON "On "
+#define MSG_OFF "Off"
+#define MSG_PID_P " PID-P: "
+#define MSG_PID_I " PID-I: "
+#define MSG_PID_D " PID-D: "
+#define MSG_PID_C " PID-C: "
+#define MSG_ACC  " Acc:"
+#define MSG_VXY_JERK " Vxy-jerk: "
+#define MSG_VMAX " Vmax "
+#define MSG_X "x:"
+#define MSG_Y "y:"
+#define MSG_Z "z:"
+#define MSG_E "e:"
+#define MSG_VMIN " Vmin:"
+#define MSG_VTRAV_MIN " VTrav min:"
+#define MSG_AMAX " Amax "
+#define MSG_A_RETRACT " A-retrac.:"
+#define MSG_XSTEPS " Xpasos/mm:"
+#define MSG_YSTEPS " Ypasos/mm:"
+#define MSG_ZSTEPS " Zpasos/mm:"
+#define MSG_ESTEPS " Epasos/mm:"
+#define MSG_MAIN_WIDE " Menu Principal  \003"
+#define MSG_RECTRACT_WIDE " Retraer         \x7E"
+#define MSG_TEMPERATURE_WIDE " Temperatura     \x7E"
+#define MSG_TEMPERATURE_RTN  " Temperatura     \003"
+#define MSG_MOTION_WIDE " Movimiento      \x7E"
+#define MSG_STORE_EPROM " Guardar Memoria"
+#define MSG_LOAD_EPROM " Cargar Memoria"
+#define MSG_RESTORE_FAILSAFE " Rest. de emergencia"
+#define MSG_REFRESH "\004Volver a cargar"
+#define MSG_WATCH " Monitorizar \003"
+#define MSG_PREPARE " Preparar \x7E"
+#define MSG_PREPARE_ALT " Preparar \003"
+#define MSG_CONTROL_ARROW " Control  \x7E"
+#define MSG_RETRACT_ARROW " Retraer  \x7E"
+#define MSG_TUNE " Ajustar \x7E"
+#define MSG_PAUSE_PRINT " Pausar Impresion \x7E"
+#define MSG_RESUME_PRINT " Reanudar Impresion \x7E"
+#define MSG_STOP_PRINT " Detener Impresion \x7E"
+#define MSG_CARD_MENU " Menu de SD    \x7E"
+#define MSG_NO_CARD " No hay Tarjeta SD"
+#define MSG_DWELL "Reposo..."
+#define MSG_USERWAIT "Esperando Ordenes..."
+#define MSG_NO_MOVE "Sin movimiento"
+#define MSG_PART_RELEASE "Desacople Parcial"
+#define MSG_KILLED "PARADA DE EMERGENCIA. "
+#define MSG_STOPPED "PARADA. "
+#define MSG_STEPPER_RELEASED "Desacoplada."
+#define MSG_CONTROL_RETRACT  " Retraer mm:"
+#define MSG_CONTROL_RETRACTF " Retraer  F:"
+#define MSG_CONTROL_RETRACT_ZLIFT " Levantar mm:"
+#define MSG_CONTROL_RETRACT_RECOVER " DesRet +mm:"
+#define MSG_CONTROL_RETRACT_RECOVERF " DesRet F:"
+#define MSG_AUTORETRACT " AutoRetr.:"
+#define MSG_FILAMENTCHANGE "Change filament"
+// Serial Console Messages
+
+#define MSG_Enqueing "En cola \""
+#define MSG_POWERUP "PowerUp"
+#define MSG_EXTERNAL_RESET " Reset Externo"
+#define MSG_BROWNOUT_RESET " Reset por Voltaje Incorrecto"
+#define MSG_WATCHDOG_RESET " Reset por Bloqueo"
+#define MSG_SOFTWARE_RESET " Reset por Software"
+#define MSG_MARLIN "Marlin "
+#define MSG_AUTHOR " | Autor: "
+#define MSG_CONFIGURATION_VER " Ultima actualizacion: "
+#define MSG_FREE_MEMORY " Memoria libre: "
+#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
+#define MSG_OK "ok"
+#define MSG_FILE_SAVED "Guardado."
+#define MSG_ERR_LINE_NO "El Numero de Linea no es igual al Ultimo Numero de Linea+1, Ultima Linea:"
+#define MSG_ERR_CHECKSUM_MISMATCH "el checksum no coincide, Ultima Linea:"
+#define MSG_ERR_NO_CHECKSUM "No se pudo hallar el Checksum con el numero de linea, Ultima Linea:"
+#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "No se hallo el Numero de Linea con el Checksum, Ultima Linea:"
+#define MSG_FILE_PRINTED "Impresion terminada"
+#define MSG_BEGIN_FILE_LIST "Comienzo de la lista de archivos"
+#define MSG_END_FILE_LIST "Fin de la lista de archivos"
+#define MSG_M104_INVALID_EXTRUDER "M104 Extrusor Invalido "
+#define MSG_M105_INVALID_EXTRUDER "M105 Extrusor Invalido "
+#define MSG_M218_INVALID_EXTRUDER "M218 Extrusor Invalido "
+#define MSG_ERR_NO_THERMISTORS "No hay termistores - no temp"
+#define MSG_M109_INVALID_EXTRUDER "M109 Extrusor Invalido "
+#define MSG_HEATING "Calentando..."
+#define MSG_HEATING_COMPLETE "Calentamiento Hecho."
+#define MSG_BED_HEATING "Calentando la base."
+#define MSG_BED_DONE "Base Caliente."
+#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
+#define MSG_COUNT_X " Cuenta X:"
+#define MSG_ERR_KILLED "Impresora Parada con kill()!!"
+#define MSG_ERR_STOPPED "Impresora parada por errores. Arregle el error y use M999 Para reiniciar!. (La temperatura se reestablece. Ajustela antes de continuar)"
+#define MSG_RESEND "Reenviar:"
+#define MSG_UNKNOWN_COMMAND "Comando Desconocido:\""
+#define MSG_ACTIVE_EXTRUDER "Extrusor Activo: "
+#define MSG_INVALID_EXTRUDER "Extrusor Invalido"
+#define MSG_X_MIN "x_min: "
+#define MSG_X_MAX "x_max: "
+#define MSG_Y_MIN "y_min: "
+#define MSG_Y_MAX "y_max: "
+#define MSG_Z_MIN "z_min: "
+#define MSG_M119_REPORT "Comprobando fines de carrera."
+#define MSG_ENDSTOP_HIT "PULSADO"
+#define MSG_ENDSTOP_OPEN "abierto"
+#define MSG_HOTEND_OFFSET "Hotend offsets:"
+        
+#define MSG_SD_CANT_OPEN_SUBDIR "No se pudo abrir la subcarpeta."
+#define MSG_SD_INIT_FAIL "Fallo al iniciar la SD"
+#define MSG_SD_VOL_INIT_FAIL "Fallo al montar el volumen"
+#define MSG_SD_OPENROOT_FAIL "Fallo al abrir la carpeta raiz"
+#define MSG_SD_CARD_OK "Tarjeta SD OK"
+#define MSG_SD_WORKDIR_FAIL "Fallo al abrir la carpeta de trabajo"
+#define MSG_SD_OPEN_FILE_FAIL "Error al abrir, Archivo: "
+#define MSG_SD_FILE_OPENED "Archivo abierto:"
+#define MSG_SD_SIZE " Tamao:"
+#define MSG_SD_FILE_SELECTED "Archivo Seleccionado"
+#define MSG_SD_WRITE_TO_FILE "Escribiendo en el archivo: "
+#define MSG_SD_PRINTING_BYTE "SD imprimiendo el byte "
+#define MSG_SD_NOT_PRINTING "No se esta imprimiendo con SD"
+#define MSG_SD_ERR_WRITE_TO_FILE "Error al escribir en el archivo"
+#define MSG_SD_CANT_ENTER_SUBDIR "No se puede abrir la carpeta:"
+
+#define MSG_STEPPER_TO_HIGH "Steprate demasiado alto : "
+#define MSG_ENDSTOPS_HIT "Se ha tocado el fin de carril: "
+#define MSG_ERR_COLD_EXTRUDE_STOP " extrusion fria evitada"
+#define MSG_ERR_LONG_EXTRUDE_STOP " extrusion demasiado larga evitada"
+
+#endif
+
+#if LANGUAGE_CHOICE == 6
+
+// LCD Menu Messages
+#define WELCOME_MSG MACHINE_NAME			" "
+#define MSG_SD_INSERTED						" "
+#define MSG_SD_REMOVED						" "
+#define MSG_MAIN							"               \003"
+#define MSG_AUTOSTART						"           "
+#define MSG_DISABLE_STEPPERS				"  "
+#define MSG_AUTO_HOME						"            "
+#define MSG_SET_ORIGIN						"       "
+#define MSG_PREHEAT_PLA						"  PLA     "
+#define MSG_PREHEAT_PLA_SETTINGS			" . .PLA"
+#define MSG_PREHEAT_ABS						"  ABS     "
+#define MSG_PREHEAT_ABS_SETTINGS			" . .ABS"
+#define MSG_COOLDOWN						"          "
+#define MSG_EXTRUDE							"           "
+#define MSG_RETRACT							" "
+#define MSG_MOVE_AXIS						"     \x7E"
+#define MSG_SPEED							" :"
+#define MSG_NOZZLE							" \002 :"
+#define MSG_NOZZLE1							" \002 2:"
+#define MSG_NOZZLE2							" \002 3:"
+#define MSG_BED								" \002 :"
+#define MSG_FAN_SPEED						" :"
+#define MSG_FLOW							" :"
+#define MSG_CONTROL							"  \003"
+#define MSG_MIN								" \002 :"
+#define MSG_MAX								" \002 :"
+#define MSG_FACTOR							" \002 :"
+#define MSG_AUTOTEMP						" Autotemp:"
+#define MSG_ON								". "
+#define MSG_OFF								". "
+#define MSG_PID_P							" PID-P: "
+#define MSG_PID_I							" PID-I: "
+#define MSG_PID_D							" PID-D: "
+#define MSG_PID_C							" PID-C: "
+#define MSG_ACC								" Acc:"
+#define MSG_VXY_JERK						" Vxy-jerk: "
+#define MSG_VMAX							" Vmax "
+#define MSG_X								"x:"
+#define MSG_Y								"y:"
+#define MSG_Z								"z:"
+#define MSG_E								"e:"
+#define MSG_VMIN							" Vmin:"
+#define MSG_VTRAV_MIN						" VTrav min:"
+#define MSG_AMAX							" Amax "
+#define MSG_A_RETRACT						" A-retract:"
+#define MSG_XSTEPS							" X /mm:"
+#define MSG_YSTEPS							" Y /mm:"
+#define MSG_ZSTEPS							" Z /mm:"
+#define MSG_ESTEPS							" E /mm:"
+#define MSG_RECTRACT    					"        \x7E"
+#define MSG_TEMPERATURE  				"        \x7E"
+#define MSG_MOTION						"           \x7E"
+#define MSG_STORE_EPROM						"  "
+#define MSG_LOAD_EPROM						"  "
+#define MSG_RESTORE_FAILSAFE				"       "
+#define MSG_REFRESH							"\004           "
+#define MSG_WATCH							"              \003"
+#define MSG_PREPARE							"           \x7E"
+#define MSG_TUNE					"          \x7E"
+#define MSG_PAUSE_PRINT						"        \x7E"
+#define MSG_RESUME_PRINT					"   \x7E"
+#define MSG_STOP_PRINT						"   \x7E"
+#define MSG_CARD_MENU						"          \x7E"
+#define MSG_NO_CARD							"  "
+#define MSG_DWELL							"..."
+#define MSG_USERWAIT						"  ."
+#define MSG_NO_MOVE							" .       "
+#define MSG_PART_RELEASE					"    "
+#define MSG_KILLED							". "
+#define MSG_STOPPED							". "
+#define MSG_CONTROL_RETRACT					"  mm:"
+#define MSG_CONTROL_RETRACTF				"   F:"
+#define MSG_CONTROL_RETRACT_ZLIFT			"  mm:"
+#define MSG_CONTROL_RETRACT_RECOVER			"  +mm:"
+#define MSG_CONTROL_RETRACT_RECOVERF		"   F:"
+#define MSG_AUTORETRACT						" :"
+#define MSG_FILAMENTCHANGE "Change filament"
+
+// Serial Console Messages
+
+#define MSG_Enqueing						" \""
+#define MSG_POWERUP							" "
+#define MSG_EXTERNAL_RESET					"  "
+#define MSG_BROWNOUT_RESET					" Brown out "
+#define MSG_WATCHDOG_RESET					" Watchdog "
+#define MSG_SOFTWARE_RESET					"  "
+#define MSG_MARLIN							"Marlin "
+#define MSG_AUTHOR							" | : "
+#define MSG_CONFIGURATION_VER				"  : "
+#define MSG_FREE_MEMORY						"  : "
+#define MSG_PLANNER_BUFFER_BYTES			"     Bytes: "
+#define MSG_OK								"ok"
+#define MSG_FILE_SAVED						" ."
+#define MSG_ERR_LINE_NO						"     +1,  :"
+#define MSG_ERR_CHECKSUM_MISMATCH			"   ,  :"
+#define MSG_ERR_NO_CHECKSUM					"    ,  :"
+#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM	"    ,  :"
+#define MSG_FILE_PRINTED					"  "
+#define MSG_BEGIN_FILE_LIST					" "
+#define MSG_END_FILE_LIST					"  "
+#define MSG_M104_INVALID_EXTRUDER			"M104   "
+#define MSG_M105_INVALID_EXTRUDER			"M105   "
+#define MSG_M218_INVALID_EXTRUDER			"M218   "
+#define MSG_ERR_NO_THERMISTORS				"  -  "
+#define MSG_M109_INVALID_EXTRUDER			"M109   "
+#define MSG_HEATING							"...  "
+#define MSG_HEATING_COMPLETE				".    "
+#define MSG_BED_HEATING						" ...     "
+#define MSG_BED_DONE						" .        "
+#define MSG_M115_REPORT						"FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
+#define MSG_COUNT_X							" Count X:"
+#define MSG_ERR_KILLED						" .  kill() !!"
+#define MSG_ERR_STOPPED						" , .     M999  !. ( .  )"
+#define MSG_RESEND							":"
+#define MSG_UNKNOWN_COMMAND					" :\""
+#define MSG_ACTIVE_EXTRUDER					" : "
+#define MSG_INVALID_EXTRUDER				" "
+#define MSG_X_MIN							"x_min:"
+#define MSG_X_MAX							"x_max:"
+#define MSG_Y_MIN							"y_min:"
+#define MSG_Y_MAX							"y_max:"
+#define MSG_Z_MIN							"z_min:"
+#define MSG_Z_MAX							"z_max:"
+#define MSG_M119_REPORT						" "
+#define MSG_ENDSTOP_HIT						" "
+#define MSG_ENDSTOP_OPEN					" "
+#define MSG_HOTEND_OFFSET					"Hotend offsets:"
+#define MSG_SD_CANT_OPEN_SUBDIR				"  "
+#define MSG_SD_INIT_FAIL					"  SD"
+#define MSG_SD_VOL_INIT_FAIL				"  "
+#define MSG_SD_OPENROOT_FAIL				"   "
+#define MSG_SD_CARD_OK						"SD   "
+#define MSG_SD_WORKDIR_FAIL					"   "
+#define MSG_SD_OPEN_FILE_FAIL				" , : "
+#define MSG_SD_FILE_OPENED					" :"
+#define MSG_SD_SIZE							" :"
+#define MSG_SD_FILE_SELECTED				" "
+#define MSG_SD_WRITE_TO_FILE				"  : "
+#define MSG_SD_PRINTING_BYTE				"SD  byte "
+#define MSG_SD_NOT_PRINTING					" SD "
+#define MSG_SD_ERR_WRITE_TO_FILE			"   "
+#define MSG_SD_CANT_ENTER_SUBDIR			"   :"
+#define MSG_STEPPER_TO_HIGH					"    : "
+#define MSG_ENDSTOPS_HIT					" : "
+#define MSG_ERR_COLD_EXTRUDE_STOP			"   "
+#define MSG_ERR_LONG_EXTRUDE_STOP			"    "
+
+#endif
+
+
+#if LANGUAGE_CHOICE == 7
+
+	// LCD Menu Messages
+	#define WELCOME_MSG MACHINE_NAME " Pronto."
+	#define MSG_SD_INSERTED          "SD Card inserita"
+	#define MSG_SD_REMOVED           "SD Card rimossa"
+	#define MSG_MAIN                 "Menu principale"
+	#define MSG_AUTOSTART            "Autostart"
+	#define MSG_DISABLE_STEPPERS     "Disabilita Motori"
+	#define MSG_AUTO_HOME            "Auto Home"
+	#define MSG_SET_ORIGIN           "Imposta Origine"
+	#define MSG_PREHEAT_PLA          "Preriscalda PLA"
+	#define MSG_PREHEAT_PLA_SETTINGS "Preris. PLA Conf"
+	#define MSG_PREHEAT_ABS          "Preriscalda ABS"
+	#define MSG_PREHEAT_ABS_SETTINGS "Preris. ABS Conf"
+	#define MSG_COOLDOWN             "Rafredda"
+	#define MSG_EXTRUDE              "Estrudi"
+	#define MSG_RETRACT              "Ritrai"
+	#define MSG_MOVE_AXIS            "Muovi Asse"
+	#define MSG_SPEED                "Velcit"
+	#define MSG_NOZZLE               "Ugello"
+	#define MSG_NOZZLE1              "Ugello2"
+	#define MSG_NOZZLE2              "Ugello3"
+	#define MSG_BED                  "Piatto"
+	#define MSG_FAN_SPEED            "Ventola"
+	#define MSG_FLOW                 "Flusso"
+	#define MSG_CONTROL              "Controllo"
+	#define MSG_MIN                  " \002 Min:"
+	#define MSG_MAX                  " \002 Max:"
+	#define MSG_FACTOR               " \002 Fact:"
+	#define MSG_AUTOTEMP             "Autotemp"
+	#define MSG_ON                   "On "
+	#define MSG_OFF                  "Off"
+	#define MSG_PID_P                "PID-P"
+	#define MSG_PID_I                "PID-I"
+	#define MSG_PID_D                "PID-D"
+	#define MSG_PID_C                "PID-C"
+	#define MSG_ACC                  "Accel"
+	#define MSG_VXY_JERK             "Vxy-jerk"
+	#define MSG_VMAX                 "Vmax"
+	#define MSG_X                    "x"
+	#define MSG_Y                    "y"
+	#define MSG_Z                    "z"
+	#define MSG_E                    "e"
+	#define MSG_VMIN                 "Vmin"
+	#define MSG_VTRAV_MIN            "VTrav min"
+	#define MSG_AMAX                 "Amax"
+	#define MSG_A_RETRACT            "A-retract"
+	#define MSG_XSTEPS               "Xpassi/mm"
+	#define MSG_YSTEPS               "Ypassi/mm"
+	#define MSG_ZSTEPS               "Zpassi/mm"
+	#define MSG_ESTEPS               "Epassi/mm"
+	#define MSG_RECTRACT             "Ritrai"
+	#define MSG_TEMPERATURE          "Temperatura"
+	#define MSG_MOTION               "Movimento"
+	#define MSG_STORE_EPROM          "Salva in EEPROM"
+	#define MSG_LOAD_EPROM           "Carica da EEPROM"
+	#define MSG_RESTORE_FAILSAFE     "Impostaz. default"
+	#define MSG_REFRESH              "Aggiorna"
+	#define MSG_WATCH                "Guarda"
+	#define MSG_PREPARE              "Prepara"
+	#define MSG_TUNE                 "Adatta"
+	#define MSG_PAUSE_PRINT          "Pausa"
+	#define MSG_RESUME_PRINT         "Riprendi Stampa"
+	#define MSG_STOP_PRINT           "Arresta Stampa"
+	#define MSG_CARD_MENU            "SD Card Menu"
+	#define MSG_NO_CARD              "No SD Card"
+	#define MSG_DWELL                "Sospensione..."
+	#define MSG_USERWAIT             "Attendi Utente..."
+	#define MSG_RESUMING             "Riprendi Stampa"
+	#define MSG_NO_MOVE              "Nessun Movimento."
+	#define MSG_KILLED               "UCCISO. "
+	#define MSG_STOPPED              "ARRESTATO. "
+	#define MSG_CONTROL_RETRACT      "Ritrai mm"
+	#define MSG_CONTROL_RETRACTF     "Ritrai  F"
+	#define MSG_CONTROL_RETRACT_ZLIFT "Salta mm"
+	#define MSG_CONTROL_RETRACT_RECOVER "UnRet +mm"
+	#define MSG_CONTROL_RETRACT_RECOVERF "UnRet  F"
+	#define MSG_AUTORETRACT          "AutoArretramento"
+	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Qualcosa non va in MenuStructure."
+	#define MSG_FILAMENTCHANGE       "Cambia filamento"
+	#define MSG_INIT_SDCARD          "Iniz. SD-Card"
+	#define MSG_CNG_SDCARD           "Cambia SD-Card"
+
+	// Serial Console Messages
+
+	#define MSG_Enqueing             "accodamento \""
+	#define MSG_POWERUP              "Accensione"
+	#define MSG_EXTERNAL_RESET       " Reset Esterno"
+	#define MSG_BROWNOUT_RESET       " Brown out Reset"
+	#define MSG_WATCHDOG_RESET       " Watchdog Reset"
+	#define MSG_SOFTWARE_RESET       " Software Reset"
+	#define MSG_MARLIN               "Marlin "
+	#define MSG_AUTHOR               " | Autore: "
+	#define MSG_CONFIGURATION_VER    " Ultimo Aggiornamento: "
+	#define MSG_FREE_MEMORY          " Memoria Libera: "
+	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
+	#define MSG_OK                   "ok"
+	#define MSG_FILE_SAVED           "File Salvato."
+	#define MSG_ERR_LINE_NO          "Il Numero della Linea non corrisponde al Numero dell'Ultima Linea+1, Ultima Linea: "
+	#define MSG_ERR_CHECKSUM_MISMATCH "checksum non corrispondente, Ultima Linea: "
+	#define MSG_ERR_NO_CHECKSUM      "Nessun Checksum con Numero di Linea, Ultima Linea: "
+	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Nessun Numero di Linea con Checksum, Ultima Linea: "
+	#define MSG_FILE_PRINTED         "File stampato"
+	#define MSG_BEGIN_FILE_LIST      "Inizio Lista File"
+	#define MSG_END_FILE_LIST        "Fine Lista File"
+	#define MSG_M104_INVALID_EXTRUDER "M104 Estrusore non valido "
+	#define MSG_M105_INVALID_EXTRUDER "M105 Estrusore non valido "
+	#define MSG_M218_INVALID_EXTRUDER "M218 Estrusore non valido "
+	#define MSG_ERR_NO_THERMISTORS   "Nessun Termistore - nessuna temperatura"
+	#define MSG_M109_INVALID_EXTRUDER "M109 Estrusore non valido "
+	#define MSG_HEATING              "Riscaldamento..."
+	#define MSG_HEATING_COMPLETE     "Stampante Calda."
+	#define MSG_BED_HEATING          "Riscaldamento Piatto."
+	#define MSG_BED_DONE             "Piatto Pronto."
+	#define MSG_M115_REPORT          "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
+	#define MSG_COUNT_X              " Calcola X: "
+	#define MSG_ERR_KILLED           "Stampante Calda. kill() chiamata !!"
+	#define MSG_ERR_STOPPED          "Stampante fermata a causa di errori. Risolvi l'errore e usa M999 per ripartire!. (Reset temperatura. Impostala prima di ripartire)"
+	#define MSG_RESEND               "Reinviato:"
+	#define MSG_UNKNOWN_COMMAND      "Comando sconosciuto: \""
+	#define MSG_ACTIVE_EXTRUDER      "Attiva Estrusore: "
+	#define MSG_INVALID_EXTRUDER     "Estrusore non valido"
+	#define MSG_X_MIN                "x_min: "
+	#define MSG_X_MAX                "x_max: "
+	#define MSG_Y_MIN                "y_min: "
+	#define MSG_Y_MAX                "y_max: "
+	#define MSG_Z_MIN                "z_min: "
+	#define MSG_Z_MAX                "z_max: "
+	#define MSG_M119_REPORT          "Segnalazione stato degli endstop"
+	#define MSG_ENDSTOP_HIT          "INNESCATO"
+	#define MSG_ENDSTOP_OPEN         "aperto"
+	#define MSG_HOTEND_OFFSET        "Hotend offsets:"
+
+	#define MSG_SD_CANT_OPEN_SUBDIR  "Impossibile aprire sottocartella"
+	#define MSG_SD_INIT_FAIL         "Fallita Inizializzazione SD"
+	#define MSG_SD_VOL_INIT_FAIL     "Fallito il montaggio del Volume"
+	#define MSG_SD_OPENROOT_FAIL     "Fallita l'apertura Cartella Principale"
+	#define MSG_SD_CARD_OK           "SD card ok"
+	#define MSG_SD_WORKDIR_FAIL      "Fallita l'apertura Cartella di Lavoro"
+	#define MSG_SD_OPEN_FILE_FAIL    "Fallita l'apertura del File: "
+	#define MSG_SD_FILE_OPENED       "File aperto: "
+	#define MSG_SD_SIZE              " Dimensione: "
+	#define MSG_SD_FILE_SELECTED     "File selezionato"
+	#define MSG_SD_WRITE_TO_FILE     "Scrittura su file: "
+	#define MSG_SD_PRINTING_BYTE     "Si sta scrivendo il byte su SD "
+	#define MSG_SD_NOT_PRINTING      "Non si sta scrivendo su SD"
+	#define MSG_SD_ERR_WRITE_TO_FILE "Errore nella scrittura su file"
+	#define MSG_SD_CANT_ENTER_SUBDIR "Impossibile entrare nella sottocartella: "
+
+	#define MSG_STEPPER_TO_HIGH      "Steprate troppo alto: "
+	#define MSG_ENDSTOPS_HIT         "Raggiunto il fondo carrello: "
+	#define MSG_ERR_COLD_EXTRUDE_STOP " prevenuta estrusione fredda"
+	#define MSG_ERR_LONG_EXTRUDE_STOP " prevenuta estrusione troppo lunga"
+
+#endif
+
+
+#if LANGUAGE_CHOICE == 8
+
+// LCD Menu Messages
+	#define WELCOME_MSG MACHINE_NAME " Pronta."
+	#define MSG_SD_INSERTED "Cartao SD inserido"
+	#define MSG_SD_REMOVED "Cartao SD removido"
+	#define MSG_MAIN " Menu Principal \003"
+	#define MSG_AUTOSTART " Autostart"
+	#define MSG_DISABLE_STEPPERS " Apagar Motores"
+	#define MSG_AUTO_HOME " Ir para Origen"
+	#define MSG_SET_ORIGIN " Estabelecer Origen"
+	#define MSG_PREHEAT_PLA " pre-aquecer PLA"
+	#define MSG_PREHEAT_PLA_SETTINGS " pre-aquecer PLA Setting"
+	#define MSG_PREHEAT_ABS " pre-aquecer ABS"
+	#define MSG_PREHEAT_ABS_SETTINGS " pre-aquecer ABS Setting"
+	#define MSG_COOLDOWN " Esfriar"
+	#define MSG_EXTRUDE " Extrudar"
+	#define MSG_RETRACT " Retrair"
+	#define MSG_PREHEAT_PLA " pre-aquecer PLA"
+	#define MSG_PREHEAT_ABS " pre-aquecer ABS"
+	#define MSG_MOVE_AXIS " Mover eixo      \x7E"
+	#define MSG_SPEED " Velocidade:"
+	#define MSG_NOZZLE " \002Nozzle:"
+	#define MSG_NOZZLE1 " \002Nozzle2:"
+	#define MSG_NOZZLE2 " \002Nozzle3:"
+	#define MSG_BED " \002Base:"
+	#define MSG_FAN_SPEED " Velocidade Ventoinha:"
+	#define MSG_FLOW " Fluxo:"
+	#define MSG_CONTROL " Controle \003"
+	#define MSG_MIN " \002 Min:"
+	#define MSG_MAX " \002 Max:"
+	#define MSG_FACTOR " \002 Fact:"
+	#define MSG_AUTOTEMP " Autotemp:"
+	#define MSG_ON "On "
+	#define MSG_OFF "Off"
+	#define MSG_PID_P " PID-P: "
+	#define MSG_PID_I " PID-I: "
+	#define MSG_PID_D " PID-D: "
+	#define MSG_PID_C " PID-C: "
+	#define MSG_ACC  " Acc:"
+	#define MSG_VXY_JERK " Vxy-jerk: "
+	#define MSG_VMAX " Vmax "
+	#define MSG_X "x:"
+	#define MSG_Y "y:"
+	#define MSG_Z "z:"
+	#define MSG_E "e:"
+	#define MSG_VMIN " Vmin:"
+	#define MSG_VTRAV_MIN " VTrav min:"
+	#define MSG_AMAX " Amax "
+	#define MSG_A_RETRACT " A-retract:"
+	#define MSG_XSTEPS " Xpasso/mm:"
+	#define MSG_YSTEPS " Ypasso/mm:"
+	#define MSG_ZSTEPS " Zpasso/mm:"
+	#define MSG_ESTEPS " Epasso/mm:"
+	#define MSG_MAIN_WIDE " Menu Principal  \003"
+	#define MSG_RECTRACT_WIDE " Retrair    \x7E"
+	#define MSG_TEMPERATURE_WIDE " Temperatura \x7E"
+	#define MSG_TEMPERATURE_RTN " Temperatura  \003"
+	#define MSG_MOTION_WIDE " Movimento     \x7E"
+	#define MSG_STORE_EPROM " Guardar memoria"
+	#define MSG_LOAD_EPROM " Carregar memoria"
+	#define MSG_RESTORE_FAILSAFE " Rest. de emergencia"
+	#define MSG_REFRESH "\004Recarregar"
+	#define MSG_WATCH " Monitorar   \003"
+	#define MSG_PREPARE " Preparar \x7E"
+	#define MSG_PREPARE_ALT " Preparar \003"
+	#define MSG_CONTROL_ARROW " Controle \x7E"
+	#define MSG_RETRACT_ARROW " Retrair \x7E"
+	#define MSG_TUNE " Tune    \x7E"
+	#define MSG_PAUSE_PRINT " Pausar Impressao \x7E"
+	#define MSG_RESUME_PRINT " Resumir Impressao \x7E"
+	#define MSG_STOP_PRINT " Parar Impressao   \x7E"
+	#define MSG_CARD_MENU " Menu cartao SD    \x7E"
+	#define MSG_NO_CARD " Sem cartao SD"
+	#define MSG_DWELL "Repouso..."
+	#define MSG_USERWAIT "Esperando Ordem..."
+	#define MSG_NO_MOVE "Sem movimento."
+	#define MSG_PART_RELEASE "Lancamento Parcial"
+	#define MSG_KILLED "PARADA DE EMERGENCIA. "
+	#define MSG_STOPPED "PARADA. "
+	#define MSG_STEPPER_RELEASED "Lancado."
+	#define MSG_CONTROL_RETRACT  " Retrair mm:"
+	#define MSG_CONTROL_RETRACTF " Retrair  F:"
+	#define MSG_CONTROL_RETRACT_ZLIFT " Levantar mm:"
+	#define MSG_CONTROL_RETRACT_RECOVER " DesRet +mm:"
+	#define MSG_CONTROL_RETRACT_RECOVERF " DesRet  F:"
+	#define MSG_AUTORETRACT " AutoRetr.:"
+        #define MSG_SERIAL_ERROR_MENU_STRUCTURE "Algo esta errado na estrutura do Menu."
+        #define MSG_FILAMENTCHANGE "Change filament"
+
+// Serial Console Messages
+
+	#define MSG_Enqueing "enqueing \""
+	#define MSG_POWERUP "PowerUp"
+	#define MSG_EXTERNAL_RESET " Reset Externo"
+	#define MSG_BROWNOUT_RESET " Reset por voltagem incorreta"
+	#define MSG_WATCHDOG_RESET " Reset por Bloqueio"
+	#define MSG_SOFTWARE_RESET " Reset por Software"
+	#define MSG_MARLIN "Marlin "
+	#define MSG_AUTHOR " | Author: "
+	#define MSG_CONFIGURATION_VER " Ultima atualizacao: "
+	#define MSG_FREE_MEMORY " memoria Livre: "
+	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
+	#define MSG_OK "ok"
+	#define MSG_FILE_SAVED "Guardado."
+	#define MSG_ERR_LINE_NO "O Numero da linha Nao e igual ao ultimo Numero da linha+1, Ultima linha:"
+	#define MSG_ERR_CHECKSUM_MISMATCH "O checksum Nao coincide, Ultima linha:"
+	#define MSG_ERR_NO_CHECKSUM "Nao foi possivel encontrar o checksum com o numero da linha, Ultima linha :"
+	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Nao ha o numero da linha com o checksum, Ultima linha:"
+	#define MSG_FILE_PRINTED "Impressao terminada"
+	#define MSG_BEGIN_FILE_LIST "Comeo da lista de arquivos"
+	#define MSG_END_FILE_LIST "Fim da lista de arquivos"
+	#define MSG_M104_INVALID_EXTRUDER "M104 Extrusor invlido "
+	#define MSG_M105_INVALID_EXTRUDER "M105 Extrusor invlido "
+	#define MSG_M218_INVALID_EXTRUDER "M218 Extrusor invlido "
+	#define MSG_ERR_NO_THERMISTORS "Nao ha termistor - no temp"
+	#define MSG_M109_INVALID_EXTRUDER "M109 Extrusor invlido "
+	#define MSG_HEATING "Aquecendo..."
+	#define MSG_HEATING_COMPLETE "Aquecido."
+	#define MSG_BED_HEATING "Aquecendo a Base."
+	#define MSG_BED_DONE "Base quente."
+	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
+	#define MSG_COUNT_X " Conta X:"
+	#define MSG_ERR_KILLED "Impressora parada com kill() !!"
+	#define MSG_ERR_STOPPED "Impressora parada por erros. Coserte o erro e use M999 para recomear!. (Temperatura reiniciada. Ajuste antes de recomear)"
+	#define MSG_RESEND "Reenviar:"
+	#define MSG_UNKNOWN_COMMAND "Comando desconhecido:\""
+	#define MSG_ACTIVE_EXTRUDER "Extrusor ativo: "
+	#define MSG_INVALID_EXTRUDER "Extrusor invalido"
+	#define MSG_X_MIN "x_min: "
+	#define MSG_X_MAX "x_max: "
+	#define MSG_Y_MIN "y_min: "
+	#define MSG_Y_MAX "y_max: "
+	#define MSG_Z_MIN "z_min: "
+	#define MSG_Z_MAX "z_max: "
+	#define MSG_M119_REPORT "Relatando estado do ponto final"
+	#define MSG_ENDSTOP_HIT "PULSADO"
+	#define MSG_ENDSTOP_OPEN "Aberto"
+	#define MSG_HOTEND_OFFSET "Hotend offsets:"
+
+	#define MSG_SD_CANT_OPEN_SUBDIR "Nao pode abrir sub diretorio"
+	#define MSG_SD_INIT_FAIL "Falha ao iniciar SD"
+	#define MSG_SD_VOL_INIT_FAIL "Falha ao montar volume"
+	#define MSG_SD_OPENROOT_FAIL "Falha ao abrir diretorio raiz"
+	#define MSG_SD_CARD_OK "cartao SD ok"
+	#define MSG_SD_WORKDIR_FAIL "Falha ao abrir diretorio de trabalho"
+	#define MSG_SD_OPEN_FILE_FAIL "Erro ao abrir, Arquivo: "
+	#define MSG_SD_FILE_OPENED "Arquivo aberto:"
+	#define MSG_SD_SIZE " Size:"
+	#define MSG_SD_FILE_SELECTED "Arquivo selecionado"
+	#define MSG_SD_WRITE_TO_FILE "Escrevendo no arquivo: "
+	#define MSG_SD_PRINTING_BYTE "SD imprimindo o byte "
+	#define MSG_SD_NOT_PRINTING "Nao esta se imprimindo com o SD"
+	#define MSG_SD_ERR_WRITE_TO_FILE "Erro ao escrever no arquivo"
+	#define MSG_SD_CANT_ENTER_SUBDIR "Nao pode abrir o sub diretorio:"
+
+	#define MSG_STEPPER_TO_HIGH "Steprate muito alto : "
+	#define MSG_ENDSTOPS_HIT "O ponto final foi tocado: "
+	#define MSG_ERR_COLD_EXTRUDE_STOP " Extrusao a frio evitada"
+	#define MSG_ERR_LONG_EXTRUDE_STOP " Extrusao muito larga evitada"
+
+
+#endif
+
+
+
+#if LANGUAGE_CHOICE == 9
+
+// Finnish
+
+// LCD Menu Messages
+	#define WELCOME_MSG MACHINE_NAME " valmis"
+	#define MSG_SD_INSERTED "Kortti asetettu"
+	#define MSG_SD_REMOVED "Kortti poistettu"
+	#define MSG_MAIN "Palaa"
+	#define MSG_AUTOSTART "Automaatti"
+	#define MSG_DISABLE_STEPPERS "Vapauta moottorit"
+	#define MSG_AUTO_HOME "Aja referenssiin"
+	#define MSG_SET_ORIGIN "Aseta origo"
+	#define MSG_PREHEAT_PLA "Esilammita PLA"
+	#define MSG_PREHEAT_PLA_SETTINGS "Esilammita PLA konf"
+	#define MSG_PREHEAT_ABS "Esilammita ABS"
+	#define MSG_PREHEAT_ABS_SETTINGS "Esilammita ABS konf"
+	#define MSG_COOLDOWN "Jaahdyta"
+	#define MSG_EXTRUDE "Pursota"
+	#define MSG_RETRACT "Veda takaisin"
+	#define MSG_MOVE_AXIS "Liikuta akseleita"
+	#define MSG_SPEED "Nopeus"
+	#define MSG_NOZZLE "Suutin"
+	#define MSG_NOZZLE1 "Suutin2"
+	#define MSG_NOZZLE2 "Suutin3"
+	#define MSG_BED "Alusta"
+	#define MSG_FAN_SPEED "Tuul. nopeus"
+	#define MSG_FLOW "Virtaus"
+	#define MSG_CONTROL "Kontrolli"
+	#define MSG_MIN " \002 Min"
+	#define MSG_MAX " \002 Max"
+	#define MSG_FACTOR " \002 Kerr"
+	#define MSG_AUTOTEMP "Autotemp"
+	#define MSG_ON "On "
+	#define MSG_OFF "Off"
+	#define MSG_PID_P "PID-P"
+	#define MSG_PID_I "PID-I"
+	#define MSG_PID_D "PID-D"
+	#define MSG_PID_C "PID-C"
+	#define MSG_ACC  "Kiihtyv"
+	#define MSG_VXY_JERK "Vxy-jerk"
+	#define MSG_VMAX "Vmax "
+	#define MSG_X "x"
+	#define MSG_Y "y"
+	#define MSG_Z "z"
+	#define MSG_E "e"
+	#define MSG_VMIN "Vmin"
+	#define MSG_VTRAV_MIN "VLiike min"
+	#define MSG_AMAX "Amax "
+	#define MSG_A_RETRACT "A-peruuta"
+	#define MSG_XSTEPS "Xsteps/mm"
+	#define MSG_YSTEPS "Ysteps/mm"
+	#define MSG_ZSTEPS "Zsteps/mm"
+	#define MSG_ESTEPS "Esteps/mm"
+	#define MSG_RECTRACT "Veda takaisin"
+	#define MSG_TEMPERATURE "Lampotila"
+	#define MSG_MOTION "Liike"
+	#define MSG_STORE_EPROM "Tallenna muistiin"
+	#define MSG_LOAD_EPROM "Lataa muistista"
+	#define MSG_RESTORE_FAILSAFE "Palauta oletus"
+	#define MSG_REFRESH "Paivita"
+	#define MSG_WATCH "Seuraa"
+	#define MSG_PREPARE "Valmistele"
+	#define MSG_TUNE "Saada"
+	#define MSG_PAUSE_PRINT "Keskeyta tulostus"
+	#define MSG_RESUME_PRINT "Jatka tulostusta"
+	#define MSG_STOP_PRINT "Pysayta tulostus"
+	#define MSG_CARD_MENU "Korttivalikko"
+	#define MSG_NO_CARD "Ei korttia"
+	#define MSG_DWELL "Nukkumassa..."
+	#define MSG_USERWAIT "Odotetaan valintaa..."
+	#define MSG_RESUMING "Jatketaan tulostusta"
+	#define MSG_NO_MOVE "Ei liiketta."
+	#define MSG_KILLED "KILLED. "
+	#define MSG_STOPPED "STOPPED. "
+	#define MSG_CONTROL_RETRACT  "Veda mm"
+	#define MSG_CONTROL_RETRACTF "Veda F"
+	#define MSG_CONTROL_RETRACT_ZLIFT "Z mm"
+	#define MSG_CONTROL_RETRACT_RECOVER "UnRet +mm"
+	#define MSG_CONTROL_RETRACT_RECOVERF "UnRet  F"
+	#define MSG_AUTORETRACT "AutoVeto."
+	#define MSG_FILAMENTCHANGE "Change filament"
+
+// Serial Console Messages
+
+	#define MSG_Enqueing "jonoon \""
+	#define MSG_POWERUP "Kaynnistys"
+	#define MSG_EXTERNAL_RESET " Ulkoinen Reset"
+	#define MSG_BROWNOUT_RESET " Alajannite Reset"
+	#define MSG_WATCHDOG_RESET " Vahtikoira Reset"
+	#define MSG_SOFTWARE_RESET " Ohjelmisto Reset"
+	#define MSG_MARLIN "Marlin "
+	#define MSG_AUTHOR " | Author: "
+	#define MSG_CONFIGURATION_VER " Paivitetty viimeksi: "
+	#define MSG_FREE_MEMORY " Vapaata muistia: "
+	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
+	#define MSG_OK "ok"
+	#define MSG_FILE_SAVED "Tiedosto tallennettu."
+	#define MSG_ERR_LINE_NO "Rivinumero ei ole Viimeisin rivi+1, Viimeisin rivi: "
+	#define MSG_ERR_CHECKSUM_MISMATCH "Tarkistesummassa virhe, Viimeisin rivi: "
+	#define MSG_ERR_NO_CHECKSUM "Rivilla ei tarkistesummaa, Viimeisin rivi: "
+	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Ei rivinumeroa tarkistesumman kanssa, Viimeisin rivi: "
+	#define MSG_FILE_PRINTED "Tiedoston tulostus valmis"
+	#define MSG_BEGIN_FILE_LIST "Tiedostolistauksen alku"
+	#define MSG_END_FILE_LIST "Tiedostolistauksen loppu"
+	#define MSG_M104_INVALID_EXTRUDER "M104 Virheellinen suutin "
+	#define MSG_M105_INVALID_EXTRUDER "M105 Virheellinen suutin "
+	#define MSG_M218_INVALID_EXTRUDER "M218 Virheellinen suutin "
+	#define MSG_ERR_NO_THERMISTORS "Ei termistoreja - ei lampotiloja"
+	#define MSG_M109_INVALID_EXTRUDER "M109 Virheellinen suutin "
+	#define MSG_HEATING "Lammitan..."
+	#define MSG_HEATING_COMPLETE "Lammitys valmis."
+	#define MSG_BED_HEATING "Alusta lampiaa."
+	#define MSG_BED_DONE "Alusta valmis."
+	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
+	#define MSG_COUNT_X " Laskuri X: "
+	#define MSG_ERR_KILLED "Tulostin pysaytetty. kill():ia kutsuttu!"
+	#define MSG_ERR_STOPPED "Tulostin pysaytetty virheiden vuoksi. Korjaa virheet ja kayta M999 kaynnistaaksesi uudelleen. (Lampotila nollattiin. Aseta lampotila sen jalkeen kun jatkat.)"
+	#define MSG_RESEND "Uudelleenlahetys: "
+	#define MSG_UNKNOWN_COMMAND "Tuntematon komento: \""
+	#define MSG_ACTIVE_EXTRUDER "Aktiivinen suutin: "
+	#define MSG_INVALID_EXTRUDER "Virheellinen suutin"
+	#define MSG_X_MIN "x_min: "
+	#define MSG_X_MAX "x_max: "
+	#define MSG_Y_MIN "y_min: "
+	#define MSG_Y_MAX "y_max: "
+	#define MSG_Z_MIN "z_min: "
+	#define MSG_Z_MAX "z_max: "
+	#define MSG_M119_REPORT "Rajakytkimien tilaraportti"
+	#define MSG_ENDSTOP_HIT "AKTIIVISENA"
+	#define MSG_ENDSTOP_OPEN "avoinna"
+	#define MSG_HOTEND_OFFSET "Hotend offsets:"
+
+	#define MSG_SD_CANT_OPEN_SUBDIR "Alihakemistoa ei voitu avata"
+	#define MSG_SD_INIT_FAIL "SD alustus epaonnistui"
+	#define MSG_SD_VOL_INIT_FAIL "volume.init epaonnistui"
+	#define MSG_SD_OPENROOT_FAIL "openRoot epaonnistui"
+	#define MSG_SD_CARD_OK "SD kortti ok"
+	#define MSG_SD_WORKDIR_FAIL "workDir open epaonnistui"
+	#define MSG_SD_OPEN_FILE_FAIL "avaus epaonnistui, Tiedosto: "
+	#define MSG_SD_FILE_OPENED "Tiedosto avattu: "
+	#define MSG_SD_SIZE " Koko: "
+	#define MSG_SD_FILE_SELECTED "Tiedosto valittu"
+	#define MSG_SD_WRITE_TO_FILE "Kirjoitetaan tiedostoon: "
+	#define MSG_SD_PRINTING_BYTE "SD tulostus byte "
+	#define MSG_SD_NOT_PRINTING "Ei SD tulostus"
+	#define MSG_SD_ERR_WRITE_TO_FILE "virhe kirjoitettaessa tiedostoon"
+	#define MSG_SD_CANT_ENTER_SUBDIR "Alihakemistoon ei voitu siirtya: "
+
+	#define MSG_STEPPER_TO_HIGH "Askellustaajuus liian suuri: "
+	#define MSG_ENDSTOPS_HIT "paatyrajat aktivoitu: "
+	#define MSG_ERR_COLD_EXTRUDE_STOP " kylmana pursotus estetty"
+	#define MSG_ERR_LONG_EXTRUDE_STOP " liian pitka pursotus estetty"
+
+#endif
 #endif // ifndef LANGUAGE_H
diff --git a/Marlin/pins.h b/Marlin/pins.h
index 41aae2e..6191ed2 100644
--- a/Marlin/pins.h
+++ b/Marlin/pins.h
@@ -644,10 +644,13 @@
 * Sanguinololu pin assignment
 *
 ****************************************************************************************/
+#if MOTHERBOARD == 64
+#define STB
+#endif
 #if MOTHERBOARD == 63
 #define MELZI
 #endif
-#if MOTHERBOARD == 62 || MOTHERBOARD == 63
+#if MOTHERBOARD == 62 || MOTHERBOARD == 63 || MOTHERBOARD == 64
 #undef MOTHERBOARD
 #define MOTHERBOARD 6
 #define SANGUINOLOLU_V_1_2 
@@ -687,6 +690,10 @@
 #define FAN_PIN            4
 #endif
 
+#ifdef STB
+#define FAN_PIN            4
+#endif
+
 #define PS_ON_PIN          -1
 #define KILL_PIN           -1
 
@@ -727,13 +734,25 @@
      //we have no buzzer installed
      #define BEEPER -1
      //LCD Pins
-     #define LCD_PINS_RS        4
-     #define LCD_PINS_ENABLE    17
-     #define LCD_PINS_D4        30
-     #define LCD_PINS_D5        29
-     #define LCD_PINS_D6        28
-     #define LCD_PINS_D7        27
-     
+	 	 #ifdef DOGLCD
+			 // Pins for DOGM SPI LCD Support
+			 #define DOGLCD_A0	30
+			 #define DOGLCD_CS	29
+			 // GLCD features
+			 #define LCD_CONTRAST 1
+			 // Uncomment screen orientation
+		     // #define LCD_SCREEN_ROT_0
+		     // #define LCD_SCREEN_ROT_90
+			 #define LCD_SCREEN_ROT_180
+		     // #define LCD_SCREEN_ROT_270
+			 #else // standard Hitachi LCD controller
+			 #define LCD_PINS_RS        4
+			 #define LCD_PINS_ENABLE    17
+			 #define LCD_PINS_D4        30
+			 #define LCD_PINS_D5        29
+			 #define LCD_PINS_D6        28
+			 #define LCD_PINS_D7        27
+         #endif
      //The encoder and click button
      #define BTN_EN1 11  //must be a hardware interrupt pin
      #define BTN_EN2 10 //must be hardware interrupt pin
@@ -960,6 +979,93 @@
 
 #endif
 
+
+/****************************************************************************************
+* RUMBA pin assignment
+*
+****************************************************************************************/
+#if MOTHERBOARD == 80
+#define KNOWN_BOARD 1
+
+#ifndef __AVR_ATmega2560__
+ #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -> Boards' menu.
+#endif
+
+#define X_STEP_PIN         17
+#define X_DIR_PIN          16
+#define X_ENABLE_PIN       48
+#define X_MIN_PIN          37
+#define X_MAX_PIN          36 
+
+#define Y_STEP_PIN         54
+#define Y_DIR_PIN          47 
+#define Y_ENABLE_PIN       55
+#define Y_MIN_PIN          35
+#define Y_MAX_PIN          34 
+
+#define Z_STEP_PIN         57 
+#define Z_DIR_PIN          56
+#define Z_ENABLE_PIN       62 
+#define Z_MIN_PIN          33
+#define Z_MAX_PIN          32
+
+#define E0_STEP_PIN        23
+#define E0_DIR_PIN         22
+#define E0_ENABLE_PIN      24
+
+#define E1_STEP_PIN        26
+#define E1_DIR_PIN         25
+#define E1_ENABLE_PIN      27
+
+#define E2_STEP_PIN        29
+#define E2_DIR_PIN         28
+#define E2_ENABLE_PIN      39
+
+#define LED_PIN            13
+
+#define FAN_PIN            7 
+//additional FAN1 PIN (e.g. useful for electronics fan or light on/off) on PIN 8
+
+#define PS_ON_PIN          45
+#define KILL_PIN           46
+
+#define HEATER_0_PIN       2    // EXTRUDER 1
+#define HEATER_1_PIN       3    // EXTRUDER 2
+#define HEATER_2_PIN       6    // EXTRUDER 3
+//optional FAN1 can be used as 4th heater output: #define HEATER_3_PIN       8    // EXTRUDER 4
+#define HEATER_BED_PIN     9    // BED
+
+#define TEMP_0_PIN         15   // ANALOG NUMBERING
+#define TEMP_1_PIN         14   // ANALOG NUMBERING
+#define TEMP_2_PIN         13   // ANALOG NUMBERING
+//optional for extruder 4 or chamber: #define TEMP_2_PIN         12   // ANALOG NUMBERING
+#define TEMP_BED_PIN       11   // ANALOG NUMBERING
+
+#define SDPOWER            -1
+#define SDSS               53
+#define SDCARDDETECT       49
+#define BEEPER             44
+#define LCD_PINS_RS        19 
+#define LCD_PINS_ENABLE    42
+#define LCD_PINS_D4        18
+#define LCD_PINS_D5        38 
+#define LCD_PINS_D6        41
+#define LCD_PINS_D7        40
+#define BTN_EN1            11
+#define BTN_EN2            12
+#define BTN_ENC            43
+//encoder rotation values
+#define BLEN_C 2
+#define BLEN_B 1
+#define BLEN_A 0
+#define encrot0 0
+#define encrot1 2
+#define encrot2 3
+#define encrot3 1
+
+#endif //MOTHERBOARD==80
+
+
 /****************************************************************************************
 * Teensylu 0.7 / Printrboard pin assignments (AT90USB1286)
 * Requires the Teensyduino software with Teensy++ 2.0 selected in Arduino IDE!
diff --git a/Marlin/stepper.cpp b/Marlin/stepper.cpp
index 4ed8bef..3bc5e9c 100644
--- a/Marlin/stepper.cpp
+++ b/Marlin/stepper.cpp
@@ -62,6 +62,7 @@ static long acceleration_time, deceleration_time;
 static unsigned short acc_step_rate; // needed for deccelaration start point
 static char step_loops;
 static unsigned short OCR1A_nominal;
+static unsigned short step_loops_nominal;
 
 volatile long endstops_trigsteps[3]={0,0,0};
 volatile long endstops_stepsTotal,endstops_stepsDone;
@@ -288,6 +289,8 @@ FORCE_INLINE void trapezoid_generator_reset() {
   deceleration_time = 0;
   // step_rate to timer interval
   OCR1A_nominal = calc_timer(current_block->nominal_rate);
+  // make a note of the number of step loops required at nominal speed
+  step_loops_nominal = step_loops;
   acc_step_rate = current_block->initial_rate;
   acceleration_time = calc_timer(acc_step_rate);
   OCR1A = acceleration_time;
@@ -665,6 +668,8 @@ ISR(TIMER1_COMPA_vect)
     }
     else {
       OCR1A = OCR1A_nominal;
+      // ensure we're running at the correct step rate, even if we just came off an acceleration
+      step_loops = step_loops_nominal;
     }
 
     // If current block is finished, reset pointer 
diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index 6093c99..58c7b60 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -325,10 +325,10 @@ void manage_heater()
     #ifndef PID_OPENLOOP
         pid_error[e] = target_temperature[e] - pid_input;
         if(pid_error[e] > PID_FUNCTIONAL_RANGE) {
-          pid_output = PID_MAX;
+          pid_output = BANG_MAX;
           pid_reset[e] = true;
         }
-        else if(pid_error[e] < -PID_FUNCTIONAL_RANGE) {
+        else if(pid_error[e] < -PID_FUNCTIONAL_RANGE || target_temperature[e] == 0) {
           pid_output = 0;
           pid_reset[e] = true;
         }
diff --git a/Marlin/thermistortables.h b/Marlin/thermistortables.h
index e3d28ba..0918220 100644
--- a/Marlin/thermistortables.h
+++ b/Marlin/thermistortables.h
@@ -556,6 +556,84 @@ const short temptable_55[][2] PROGMEM = {
 };
 #endif
 
+#if (THERMISTORHEATER_0 == 60) || (THERMISTORHEATER_1 == 60) || (THERMISTORHEATER_2 == 60) || (THERMISTORBED == 60) // Maker's Tool Works Kapton Bed Thermister
+const short temptable_60[][2] PROGMEM = {
+   {51*OVERSAMPLENR, 272},
+   {61*OVERSAMPLENR, 258},
+   {71*OVERSAMPLENR, 247},
+   {81*OVERSAMPLENR, 237},
+   {91*OVERSAMPLENR, 229},
+   {101*OVERSAMPLENR, 221},
+   {131*OVERSAMPLENR, 204},
+   {161*OVERSAMPLENR, 190},
+   {191*OVERSAMPLENR, 179},
+   {231*OVERSAMPLENR, 167},
+   {271*OVERSAMPLENR, 157},
+   {311*OVERSAMPLENR, 148},
+   {351*OVERSAMPLENR, 140},
+   {381*OVERSAMPLENR, 135},
+   {411*OVERSAMPLENR, 130},
+   {441*OVERSAMPLENR, 125},
+   {451*OVERSAMPLENR, 123},
+   {461*OVERSAMPLENR, 122},
+   {471*OVERSAMPLENR, 120},
+   {481*OVERSAMPLENR, 119},
+   {491*OVERSAMPLENR, 117},
+   {501*OVERSAMPLENR, 116},
+   {511*OVERSAMPLENR, 114},
+   {521*OVERSAMPLENR, 113},
+   {531*OVERSAMPLENR, 111},
+   {541*OVERSAMPLENR, 110},
+   {551*OVERSAMPLENR, 108},
+   {561*OVERSAMPLENR, 107},
+   {571*OVERSAMPLENR, 105},
+   {581*OVERSAMPLENR, 104},
+   {591*OVERSAMPLENR, 102},
+   {601*OVERSAMPLENR, 101},
+   {611*OVERSAMPLENR, 100},
+   {621*OVERSAMPLENR, 98},
+   {631*OVERSAMPLENR, 97},
+   {641*OVERSAMPLENR, 95},
+   {651*OVERSAMPLENR, 94},
+   {661*OVERSAMPLENR, 92},
+   {671*OVERSAMPLENR, 91},
+   {681*OVERSAMPLENR, 90},
+   {691*OVERSAMPLENR, 88},
+   {701*OVERSAMPLENR, 87},
+   {711*OVERSAMPLENR, 85},
+   {721*OVERSAMPLENR, 84},
+   {731*OVERSAMPLENR, 82},
+   {741*OVERSAMPLENR, 81},
+   {751*OVERSAMPLENR, 79},
+   {761*OVERSAMPLENR, 77},
+   {771*OVERSAMPLENR, 76},
+   {781*OVERSAMPLENR, 74},
+   {791*OVERSAMPLENR, 72},
+   {801*OVERSAMPLENR, 71},
+   {811*OVERSAMPLENR, 69},
+   {821*OVERSAMPLENR, 67},
+   {831*OVERSAMPLENR, 65},
+   {841*OVERSAMPLENR, 63},
+   {851*OVERSAMPLENR, 62},
+   {861*OVERSAMPLENR, 60},
+   {871*OVERSAMPLENR, 57},
+   {881*OVERSAMPLENR, 55},
+   {891*OVERSAMPLENR, 53},
+   {901*OVERSAMPLENR, 51},
+   {911*OVERSAMPLENR, 48},
+   {921*OVERSAMPLENR, 45},
+   {931*OVERSAMPLENR, 42},
+   {941*OVERSAMPLENR, 39},
+   {951*OVERSAMPLENR, 36},
+   {961*OVERSAMPLENR, 32},
+   {981*OVERSAMPLENR, 23},
+   {991*OVERSAMPLENR, 17},
+   {1001*OVERSAMPLENR, 9},
+   {1008*OVERSAMPLENR, 0},
+};
+#endif
+
+
 #define _TT_NAME(_N) temptable_ ## _N
 #define TT_NAME(_N) _TT_NAME(_N)
 

