commit 7c27f3499625a57b7a666aaa242776060e5ddb85 (from b7b7c904774474e665b84628373b0b14b6e089c2)
Merge: b7b7c90 060dc6d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jul 24 18:45:54 2016 -0700

    Merge pull request #4397 from thinkyhead/rc_tweak_eeprom
    
    Neaten up EEPROM read/write functions

diff --git a/Marlin/Marlin.h b/Marlin/Marlin.h
index 3d09723..42269b7 100644
--- a/Marlin/Marlin.h
+++ b/Marlin/Marlin.h
@@ -114,6 +114,7 @@ void serial_echopair_P(const char* s_P, long v);
 void serial_echopair_P(const char* s_P, float v);
 void serial_echopair_P(const char* s_P, double v);
 void serial_echopair_P(const char* s_P, unsigned long v);
+FORCE_INLINE void serial_echopair_P(const char* s_P, uint16_t v) { serial_echopair_P(s_P, (int)v); }
 FORCE_INLINE void serial_echopair_P(const char* s_P, bool v) { serial_echopair_P(s_P, (int)v); }
 FORCE_INLINE void serial_echopair_P(const char* s_P, void *v) { serial_echopair_P(s_P, (unsigned long)v); }
 
diff --git a/Marlin/configuration_store.cpp b/Marlin/configuration_store.cpp
index 233a28c..a8bc7b8 100644
--- a/Marlin/configuration_store.cpp
+++ b/Marlin/configuration_store.cpp
@@ -191,8 +191,10 @@ void Config_Postprocess() {
 #if ENABLED(EEPROM_SETTINGS)
 
   #define DUMMY_PID_VALUE 3000.0f
-  #define EEPROM_WRITE_VAR(pos, value) _EEPROM_writeData(pos, (uint8_t*)&value, sizeof(value))
-  #define EEPROM_READ_VAR(pos, value) _EEPROM_readData(pos, (uint8_t*)&value, sizeof(value))
+  #define EEPROM_START() int eeprom_index = EEPROM_OFFSET
+  #define EEPROM_SKIP(VAR) eeprom_index += sizeof(VAR)
+  #define EEPROM_WRITE(VAR) _EEPROM_writeData(eeprom_index, (uint8_t*)&VAR, sizeof(VAR))
+  #define EEPROM_READ(VAR) _EEPROM_readData(eeprom_index, (uint8_t*)&VAR, sizeof(VAR))
 
 /**
  * M500 - Store Configuration
@@ -200,26 +202,27 @@ void Config_Postprocess() {
 void Config_StoreSettings()  {
   float dummy = 0.0f;
   char ver[4] = "000";
-  int i = EEPROM_OFFSET;
 
-  EEPROM_WRITE_VAR(i, ver);     // invalidate data first
-  i += sizeof(eeprom_checksum); // Skip the checksum slot
+  EEPROM_START();
+
+  EEPROM_WRITE(ver);     // invalidate data first
+  EEPROM_SKIP(eeprom_checksum); // Skip the checksum slot
 
   eeprom_checksum = 0; // clear before first "real data"
 
-  EEPROM_WRITE_VAR(i, planner.axis_steps_per_mm);
-  EEPROM_WRITE_VAR(i, planner.max_feedrate_mm_s);
-  EEPROM_WRITE_VAR(i, planner.max_acceleration_mm_per_s2);
-  EEPROM_WRITE_VAR(i, planner.acceleration);
-  EEPROM_WRITE_VAR(i, planner.retract_acceleration);
-  EEPROM_WRITE_VAR(i, planner.travel_acceleration);
-  EEPROM_WRITE_VAR(i, planner.min_feedrate_mm_s);
-  EEPROM_WRITE_VAR(i, planner.min_travel_feedrate_mm_s);
-  EEPROM_WRITE_VAR(i, planner.min_segment_time);
-  EEPROM_WRITE_VAR(i, planner.max_xy_jerk);
-  EEPROM_WRITE_VAR(i, planner.max_z_jerk);
-  EEPROM_WRITE_VAR(i, planner.max_e_jerk);
-  EEPROM_WRITE_VAR(i, home_offset);
+  EEPROM_WRITE(planner.axis_steps_per_mm);
+  EEPROM_WRITE(planner.max_feedrate_mm_s);
+  EEPROM_WRITE(planner.max_acceleration_mm_per_s2);
+  EEPROM_WRITE(planner.acceleration);
+  EEPROM_WRITE(planner.retract_acceleration);
+  EEPROM_WRITE(planner.travel_acceleration);
+  EEPROM_WRITE(planner.min_feedrate_mm_s);
+  EEPROM_WRITE(planner.min_travel_feedrate_mm_s);
+  EEPROM_WRITE(planner.min_segment_time);
+  EEPROM_WRITE(planner.max_xy_jerk);
+  EEPROM_WRITE(planner.max_z_jerk);
+  EEPROM_WRITE(planner.max_e_jerk);
+  EEPROM_WRITE(home_offset);
 
   #if ENABLED(MESH_BED_LEVELING)
     // Compile time test that sizeof(mbl.z_values) is as expected
@@ -227,45 +230,45 @@ void Config_StoreSettings()  {
     uint8_t mesh_num_x = MESH_NUM_X_POINTS,
             mesh_num_y = MESH_NUM_Y_POINTS,
             dummy_uint8 = mbl.status & _BV(MBL_STATUS_HAS_MESH_BIT);
-    EEPROM_WRITE_VAR(i, dummy_uint8);
-    EEPROM_WRITE_VAR(i, mbl.z_offset);
-    EEPROM_WRITE_VAR(i, mesh_num_x);
-    EEPROM_WRITE_VAR(i, mesh_num_y);
-    EEPROM_WRITE_VAR(i, mbl.z_values);
+    EEPROM_WRITE(dummy_uint8);
+    EEPROM_WRITE(mbl.z_offset);
+    EEPROM_WRITE(mesh_num_x);
+    EEPROM_WRITE(mesh_num_y);
+    EEPROM_WRITE(mbl.z_values);
   #else
     // For disabled MBL write a default mesh
     uint8_t mesh_num_x = 3,
             mesh_num_y = 3,
             dummy_uint8 = 0;
     dummy = 0.0f;
-    EEPROM_WRITE_VAR(i, dummy_uint8);
-    EEPROM_WRITE_VAR(i, dummy);
-    EEPROM_WRITE_VAR(i, mesh_num_x);
-    EEPROM_WRITE_VAR(i, mesh_num_y);
-    for (uint8_t q = 0; q < mesh_num_x * mesh_num_y; q++) EEPROM_WRITE_VAR(i, dummy);
+    EEPROM_WRITE(dummy_uint8);
+    EEPROM_WRITE(dummy);
+    EEPROM_WRITE(mesh_num_x);
+    EEPROM_WRITE(mesh_num_y);
+    for (uint8_t q = 0; q < mesh_num_x * mesh_num_y; q++) EEPROM_WRITE(dummy);
   #endif // MESH_BED_LEVELING
 
   #if !HAS_BED_PROBE
     float zprobe_zoffset = 0;
   #endif
-  EEPROM_WRITE_VAR(i, zprobe_zoffset);
+  EEPROM_WRITE(zprobe_zoffset);
 
   // 9 floats for DELTA / Z_DUAL_ENDSTOPS
   #if ENABLED(DELTA)
-    EEPROM_WRITE_VAR(i, endstop_adj);               // 3 floats
-    EEPROM_WRITE_VAR(i, delta_radius);              // 1 float
-    EEPROM_WRITE_VAR(i, delta_diagonal_rod);        // 1 float
-    EEPROM_WRITE_VAR(i, delta_segments_per_second); // 1 float
-    EEPROM_WRITE_VAR(i, delta_diagonal_rod_trim_tower_1);  // 1 float
-    EEPROM_WRITE_VAR(i, delta_diagonal_rod_trim_tower_2);  // 1 float
-    EEPROM_WRITE_VAR(i, delta_diagonal_rod_trim_tower_3);  // 1 float
+    EEPROM_WRITE(endstop_adj);               // 3 floats
+    EEPROM_WRITE(delta_radius);              // 1 float
+    EEPROM_WRITE(delta_diagonal_rod);        // 1 float
+    EEPROM_WRITE(delta_segments_per_second); // 1 float
+    EEPROM_WRITE(delta_diagonal_rod_trim_tower_1);  // 1 float
+    EEPROM_WRITE(delta_diagonal_rod_trim_tower_2);  // 1 float
+    EEPROM_WRITE(delta_diagonal_rod_trim_tower_3);  // 1 float
   #elif ENABLED(Z_DUAL_ENDSTOPS)
-    EEPROM_WRITE_VAR(i, z_endstop_adj);            // 1 float
+    EEPROM_WRITE(z_endstop_adj);            // 1 float
     dummy = 0.0f;
-    for (uint8_t q = 8; q--;) EEPROM_WRITE_VAR(i, dummy);
+    for (uint8_t q = 8; q--;) EEPROM_WRITE(dummy);
   #else
     dummy = 0.0f;
-    for (uint8_t q = 9; q--;) EEPROM_WRITE_VAR(i, dummy);
+    for (uint8_t q = 9; q--;) EEPROM_WRITE(dummy);
   #endif
 
   #if DISABLED(ULTIPANEL)
@@ -273,34 +276,34 @@ void Config_StoreSettings()  {
         preheatHotendTemp2 = PREHEAT_2_TEMP_HOTEND, preheatBedTemp2 = PREHEAT_2_TEMP_BED, preheatFanSpeed2 = PREHEAT_2_FAN_SPEED;
   #endif // !ULTIPANEL
 
-  EEPROM_WRITE_VAR(i, preheatHotendTemp1);
-  EEPROM_WRITE_VAR(i, preheatBedTemp1);
-  EEPROM_WRITE_VAR(i, preheatFanSpeed1);
-  EEPROM_WRITE_VAR(i, preheatHotendTemp2);
-  EEPROM_WRITE_VAR(i, preheatBedTemp2);
-  EEPROM_WRITE_VAR(i, preheatFanSpeed2);
+  EEPROM_WRITE(preheatHotendTemp1);
+  EEPROM_WRITE(preheatBedTemp1);
+  EEPROM_WRITE(preheatFanSpeed1);
+  EEPROM_WRITE(preheatHotendTemp2);
+  EEPROM_WRITE(preheatBedTemp2);
+  EEPROM_WRITE(preheatFanSpeed2);
 
   for (uint8_t e = 0; e < MAX_EXTRUDERS; e++) {
 
     #if ENABLED(PIDTEMP)
       if (e < HOTENDS) {
-        EEPROM_WRITE_VAR(i, PID_PARAM(Kp, e));
-        EEPROM_WRITE_VAR(i, PID_PARAM(Ki, e));
-        EEPROM_WRITE_VAR(i, PID_PARAM(Kd, e));
+        EEPROM_WRITE(PID_PARAM(Kp, e));
+        EEPROM_WRITE(PID_PARAM(Ki, e));
+        EEPROM_WRITE(PID_PARAM(Kd, e));
         #if ENABLED(PID_ADD_EXTRUSION_RATE)
-          EEPROM_WRITE_VAR(i, PID_PARAM(Kc, e));
+          EEPROM_WRITE(PID_PARAM(Kc, e));
         #else
           dummy = 1.0f; // 1.0 = default kc
-          EEPROM_WRITE_VAR(i, dummy);
+          EEPROM_WRITE(dummy);
         #endif
       }
       else
     #endif // !PIDTEMP
       {
         dummy = DUMMY_PID_VALUE; // When read, will not change the existing value
-        EEPROM_WRITE_VAR(i, dummy); // Kp
+        EEPROM_WRITE(dummy); // Kp
         dummy = 0.0f;
-        for (uint8_t q = 3; q--;) EEPROM_WRITE_VAR(i, dummy); // Ki, Kd, Kc
+        for (uint8_t q = 3; q--;) EEPROM_WRITE(dummy); // Ki, Kd, Kc
       }
 
   } // Hotends Loop
@@ -308,67 +311,68 @@ void Config_StoreSettings()  {
   #if DISABLED(PID_ADD_EXTRUSION_RATE)
     int lpq_len = 20;
   #endif
-  EEPROM_WRITE_VAR(i, lpq_len);
+  EEPROM_WRITE(lpq_len);
 
   #if DISABLED(PIDTEMPBED)
     dummy = DUMMY_PID_VALUE;
-    for (uint8_t q = 3; q--;) EEPROM_WRITE_VAR(i, dummy);
+    for (uint8_t q = 3; q--;) EEPROM_WRITE(dummy);
   #else
-    EEPROM_WRITE_VAR(i, thermalManager.bedKp);
-    EEPROM_WRITE_VAR(i, thermalManager.bedKi);
-    EEPROM_WRITE_VAR(i, thermalManager.bedKd);
+    EEPROM_WRITE(thermalManager.bedKp);
+    EEPROM_WRITE(thermalManager.bedKi);
+    EEPROM_WRITE(thermalManager.bedKd);
   #endif
 
   #if !HAS_LCD_CONTRAST
     const int lcd_contrast = 32;
   #endif
-  EEPROM_WRITE_VAR(i, lcd_contrast);
+  EEPROM_WRITE(lcd_contrast);
 
   #if ENABLED(SCARA)
-    EEPROM_WRITE_VAR(i, axis_scaling); // 3 floats
+    EEPROM_WRITE(axis_scaling); // 3 floats
   #else
     dummy = 1.0f;
-    EEPROM_WRITE_VAR(i, dummy);
+    EEPROM_WRITE(dummy);
   #endif
 
   #if ENABLED(FWRETRACT)
-    EEPROM_WRITE_VAR(i, autoretract_enabled);
-    EEPROM_WRITE_VAR(i, retract_length);
+    EEPROM_WRITE(autoretract_enabled);
+    EEPROM_WRITE(retract_length);
     #if EXTRUDERS > 1
-      EEPROM_WRITE_VAR(i, retract_length_swap);
+      EEPROM_WRITE(retract_length_swap);
     #else
       dummy = 0.0f;
-      EEPROM_WRITE_VAR(i, dummy);
+      EEPROM_WRITE(dummy);
     #endif
-    EEPROM_WRITE_VAR(i, retract_feedrate_mm_s);
-    EEPROM_WRITE_VAR(i, retract_zlift);
-    EEPROM_WRITE_VAR(i, retract_recover_length);
+    EEPROM_WRITE(retract_feedrate_mm_s);
+    EEPROM_WRITE(retract_zlift);
+    EEPROM_WRITE(retract_recover_length);
     #if EXTRUDERS > 1
-      EEPROM_WRITE_VAR(i, retract_recover_length_swap);
+      EEPROM_WRITE(retract_recover_length_swap);
     #else
       dummy = 0.0f;
-      EEPROM_WRITE_VAR(i, dummy);
+      EEPROM_WRITE(dummy);
     #endif
-    EEPROM_WRITE_VAR(i, retract_recover_feedrate_mm_s);
+    EEPROM_WRITE(retract_recover_feedrate_mm_s);
   #endif // FWRETRACT
 
-  EEPROM_WRITE_VAR(i, volumetric_enabled);
+  EEPROM_WRITE(volumetric_enabled);
 
   // Save filament sizes
   for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
     if (q < COUNT(filament_size)) dummy = filament_size[q];
-    EEPROM_WRITE_VAR(i, dummy);
+    EEPROM_WRITE(dummy);
   }
 
-  uint16_t final_checksum = eeprom_checksum;
+  uint16_t final_checksum = eeprom_checksum,
+           eeprom_size = eeprom_index;
 
-  int j = EEPROM_OFFSET;
-  EEPROM_WRITE_VAR(j, version);
-  EEPROM_WRITE_VAR(j, final_checksum);
+  eeprom_index = EEPROM_OFFSET;
+  EEPROM_WRITE(version);
+  EEPROM_WRITE(final_checksum);
 
   // Report storage size
   SERIAL_ECHO_START;
-  SERIAL_ECHOPAIR("Settings Stored (", i);
+  SERIAL_ECHOPAIR("Settings Stored (", eeprom_size);
   SERIAL_ECHOLNPGM(" bytes)");
 }
 
@@ -376,11 +380,15 @@ void Config_StoreSettings()  {
  * M501 - Retrieve Configuration
  */
 void Config_RetrieveSettings() {
-  int i = EEPROM_OFFSET;
+
+  EEPROM_START();
+
   char stored_ver[4];
+  EEPROM_READ(stored_ver);
+
   uint16_t stored_checksum;
-  EEPROM_READ_VAR(i, stored_ver);
-  EEPROM_READ_VAR(i, stored_checksum);
+  EEPROM_READ(stored_checksum);
+
   //  SERIAL_ECHOPAIR("Version: [", ver);
   //  SERIAL_ECHOPAIR("] Stored version: [", stored_ver);
   //  SERIAL_ECHOLNPGM("]");
@@ -394,63 +402,63 @@ void Config_RetrieveSettings() {
     eeprom_checksum = 0; // clear before reading first "real data"
 
     // version number match
-    EEPROM_READ_VAR(i, planner.axis_steps_per_mm);
-    EEPROM_READ_VAR(i, planner.max_feedrate_mm_s);
-    EEPROM_READ_VAR(i, planner.max_acceleration_mm_per_s2);
-
-    EEPROM_READ_VAR(i, planner.acceleration);
-    EEPROM_READ_VAR(i, planner.retract_acceleration);
-    EEPROM_READ_VAR(i, planner.travel_acceleration);
-    EEPROM_READ_VAR(i, planner.min_feedrate_mm_s);
-    EEPROM_READ_VAR(i, planner.min_travel_feedrate_mm_s);
-    EEPROM_READ_VAR(i, planner.min_segment_time);
-    EEPROM_READ_VAR(i, planner.max_xy_jerk);
-    EEPROM_READ_VAR(i, planner.max_z_jerk);
-    EEPROM_READ_VAR(i, planner.max_e_jerk);
-    EEPROM_READ_VAR(i, home_offset);
+    EEPROM_READ(planner.axis_steps_per_mm);
+    EEPROM_READ(planner.max_feedrate_mm_s);
+    EEPROM_READ(planner.max_acceleration_mm_per_s2);
+
+    EEPROM_READ(planner.acceleration);
+    EEPROM_READ(planner.retract_acceleration);
+    EEPROM_READ(planner.travel_acceleration);
+    EEPROM_READ(planner.min_feedrate_mm_s);
+    EEPROM_READ(planner.min_travel_feedrate_mm_s);
+    EEPROM_READ(planner.min_segment_time);
+    EEPROM_READ(planner.max_xy_jerk);
+    EEPROM_READ(planner.max_z_jerk);
+    EEPROM_READ(planner.max_e_jerk);
+    EEPROM_READ(home_offset);
 
     uint8_t dummy_uint8 = 0, mesh_num_x = 0, mesh_num_y = 0;
-    EEPROM_READ_VAR(i, dummy_uint8);
-    EEPROM_READ_VAR(i, dummy);
-    EEPROM_READ_VAR(i, mesh_num_x);
-    EEPROM_READ_VAR(i, mesh_num_y);
+    EEPROM_READ(dummy_uint8);
+    EEPROM_READ(dummy);
+    EEPROM_READ(mesh_num_x);
+    EEPROM_READ(mesh_num_y);
     #if ENABLED(MESH_BED_LEVELING)
       mbl.status = dummy_uint8;
       mbl.z_offset = dummy;
       if (mesh_num_x == MESH_NUM_X_POINTS && mesh_num_y == MESH_NUM_Y_POINTS) {
         // EEPROM data fits the current mesh
-        EEPROM_READ_VAR(i, mbl.z_values);
+        EEPROM_READ(mbl.z_values);
       }
       else {
         // EEPROM data is stale
         mbl.reset();
-        for (uint8_t q = 0; q < mesh_num_x * mesh_num_y; q++) EEPROM_READ_VAR(i, dummy);
+        for (uint8_t q = 0; q < mesh_num_x * mesh_num_y; q++) EEPROM_READ(dummy);
       }
     #else
       // MBL is disabled - skip the stored data
-      for (uint8_t q = 0; q < mesh_num_x * mesh_num_y; q++) EEPROM_READ_VAR(i, dummy);
+      for (uint8_t q = 0; q < mesh_num_x * mesh_num_y; q++) EEPROM_READ(dummy);
     #endif // MESH_BED_LEVELING
 
     #if !HAS_BED_PROBE
       float zprobe_zoffset = 0;
     #endif
-    EEPROM_READ_VAR(i, zprobe_zoffset);
+    EEPROM_READ(zprobe_zoffset);
 
     #if ENABLED(DELTA)
-      EEPROM_READ_VAR(i, endstop_adj);                // 3 floats
-      EEPROM_READ_VAR(i, delta_radius);               // 1 float
-      EEPROM_READ_VAR(i, delta_diagonal_rod);         // 1 float
-      EEPROM_READ_VAR(i, delta_segments_per_second);  // 1 float
-      EEPROM_READ_VAR(i, delta_diagonal_rod_trim_tower_1);  // 1 float
-      EEPROM_READ_VAR(i, delta_diagonal_rod_trim_tower_2);  // 1 float
-      EEPROM_READ_VAR(i, delta_diagonal_rod_trim_tower_3);  // 1 float
+      EEPROM_READ(endstop_adj);                // 3 floats
+      EEPROM_READ(delta_radius);               // 1 float
+      EEPROM_READ(delta_diagonal_rod);         // 1 float
+      EEPROM_READ(delta_segments_per_second);  // 1 float
+      EEPROM_READ(delta_diagonal_rod_trim_tower_1);  // 1 float
+      EEPROM_READ(delta_diagonal_rod_trim_tower_2);  // 1 float
+      EEPROM_READ(delta_diagonal_rod_trim_tower_3);  // 1 float
     #elif ENABLED(Z_DUAL_ENDSTOPS)
-      EEPROM_READ_VAR(i, z_endstop_adj);
+      EEPROM_READ(z_endstop_adj);
       dummy = 0.0f;
-      for (uint8_t q=8; q--;) EEPROM_READ_VAR(i, dummy);
+      for (uint8_t q=8; q--;) EEPROM_READ(dummy);
     #else
       dummy = 0.0f;
-      for (uint8_t q=9; q--;) EEPROM_READ_VAR(i, dummy);
+      for (uint8_t q=9; q--;) EEPROM_READ(dummy);
     #endif
 
     #if DISABLED(ULTIPANEL)
@@ -458,86 +466,86 @@ void Config_RetrieveSettings() {
           preheatHotendTemp2, preheatBedTemp2, preheatFanSpeed2;
     #endif
 
-    EEPROM_READ_VAR(i, preheatHotendTemp1);
-    EEPROM_READ_VAR(i, preheatBedTemp1);
-    EEPROM_READ_VAR(i, preheatFanSpeed1);
-    EEPROM_READ_VAR(i, preheatHotendTemp2);
-    EEPROM_READ_VAR(i, preheatBedTemp2);
-    EEPROM_READ_VAR(i, preheatFanSpeed2);
+    EEPROM_READ(preheatHotendTemp1);
+    EEPROM_READ(preheatBedTemp1);
+    EEPROM_READ(preheatFanSpeed1);
+    EEPROM_READ(preheatHotendTemp2);
+    EEPROM_READ(preheatBedTemp2);
+    EEPROM_READ(preheatFanSpeed2);
 
     #if ENABLED(PIDTEMP)
       for (uint8_t e = 0; e < MAX_EXTRUDERS; e++) {
-        EEPROM_READ_VAR(i, dummy); // Kp
+        EEPROM_READ(dummy); // Kp
         if (e < HOTENDS && dummy != DUMMY_PID_VALUE) {
           // do not need to scale PID values as the values in EEPROM are already scaled
           PID_PARAM(Kp, e) = dummy;
-          EEPROM_READ_VAR(i, PID_PARAM(Ki, e));
-          EEPROM_READ_VAR(i, PID_PARAM(Kd, e));
+          EEPROM_READ(PID_PARAM(Ki, e));
+          EEPROM_READ(PID_PARAM(Kd, e));
           #if ENABLED(PID_ADD_EXTRUSION_RATE)
-            EEPROM_READ_VAR(i, PID_PARAM(Kc, e));
+            EEPROM_READ(PID_PARAM(Kc, e));
           #else
-            EEPROM_READ_VAR(i, dummy);
+            EEPROM_READ(dummy);
           #endif
         }
         else {
-          for (uint8_t q=3; q--;) EEPROM_READ_VAR(i, dummy); // Ki, Kd, Kc
+          for (uint8_t q=3; q--;) EEPROM_READ(dummy); // Ki, Kd, Kc
         }
       }
     #else // !PIDTEMP
       // 4 x 4 = 16 slots for PID parameters
-      for (uint8_t q = MAX_EXTRUDERS * 4; q--;) EEPROM_READ_VAR(i, dummy);  // Kp, Ki, Kd, Kc
+      for (uint8_t q = MAX_EXTRUDERS * 4; q--;) EEPROM_READ(dummy);  // Kp, Ki, Kd, Kc
     #endif // !PIDTEMP
 
     #if DISABLED(PID_ADD_EXTRUSION_RATE)
       int lpq_len;
     #endif
-    EEPROM_READ_VAR(i, lpq_len);
+    EEPROM_READ(lpq_len);
 
     #if ENABLED(PIDTEMPBED)
-      EEPROM_READ_VAR(i, dummy); // bedKp
+      EEPROM_READ(dummy); // bedKp
       if (dummy != DUMMY_PID_VALUE) {
         thermalManager.bedKp = dummy;
-        EEPROM_READ_VAR(i, thermalManager.bedKi);
-        EEPROM_READ_VAR(i, thermalManager.bedKd);
+        EEPROM_READ(thermalManager.bedKi);
+        EEPROM_READ(thermalManager.bedKd);
       }
     #else
-      for (uint8_t q=3; q--;) EEPROM_READ_VAR(i, dummy); // bedKp, bedKi, bedKd
+      for (uint8_t q=3; q--;) EEPROM_READ(dummy); // bedKp, bedKi, bedKd
     #endif
 
     #if !HAS_LCD_CONTRAST
       int lcd_contrast;
     #endif
-    EEPROM_READ_VAR(i, lcd_contrast);
+    EEPROM_READ(lcd_contrast);
 
     #if ENABLED(SCARA)
-      EEPROM_READ_VAR(i, axis_scaling);  // 3 floats
+      EEPROM_READ(axis_scaling);  // 3 floats
     #else
-      EEPROM_READ_VAR(i, dummy);
+      EEPROM_READ(dummy);
     #endif
 
     #if ENABLED(FWRETRACT)
-      EEPROM_READ_VAR(i, autoretract_enabled);
-      EEPROM_READ_VAR(i, retract_length);
+      EEPROM_READ(autoretract_enabled);
+      EEPROM_READ(retract_length);
       #if EXTRUDERS > 1
-        EEPROM_READ_VAR(i, retract_length_swap);
+        EEPROM_READ(retract_length_swap);
       #else
-        EEPROM_READ_VAR(i, dummy);
+        EEPROM_READ(dummy);
       #endif
-      EEPROM_READ_VAR(i, retract_feedrate_mm_s);
-      EEPROM_READ_VAR(i, retract_zlift);
-      EEPROM_READ_VAR(i, retract_recover_length);
+      EEPROM_READ(retract_feedrate_mm_s);
+      EEPROM_READ(retract_zlift);
+      EEPROM_READ(retract_recover_length);
       #if EXTRUDERS > 1
-        EEPROM_READ_VAR(i, retract_recover_length_swap);
+        EEPROM_READ(retract_recover_length_swap);
       #else
-        EEPROM_READ_VAR(i, dummy);
+        EEPROM_READ(dummy);
       #endif
-      EEPROM_READ_VAR(i, retract_recover_feedrate_mm_s);
+      EEPROM_READ(retract_recover_feedrate_mm_s);
     #endif // FWRETRACT
 
-    EEPROM_READ_VAR(i, volumetric_enabled);
+    EEPROM_READ(volumetric_enabled);
 
     for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
-      EEPROM_READ_VAR(i, dummy);
+      EEPROM_READ(dummy);
       if (q < COUNT(filament_size)) filament_size[q] = dummy;
     }
 
@@ -545,7 +553,7 @@ void Config_RetrieveSettings() {
       Config_Postprocess();
       SERIAL_ECHO_START;
       SERIAL_ECHO(version);
-      SERIAL_ECHOPAIR(" stored settings retrieved (", i);
+      SERIAL_ECHOPAIR(" stored settings retrieved (", eeprom_index);
       SERIAL_ECHOLNPGM(" bytes)");
     }
     else {

commit 7c27f3499625a57b7a666aaa242776060e5ddb85 (from 060dc6d95ad983e164a9b969e837a8dc9355ba41)
Merge: b7b7c90 060dc6d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jul 24 18:45:54 2016 -0700

    Merge pull request #4397 from thinkyhead/rc_tweak_eeprom
    
    Neaten up EEPROM read/write functions

diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index ef4bd32..7b8fcb0 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -610,6 +610,20 @@ static void report_current_position();
     print_xyz(PSTR(STRINGIFY(VAR) "="), PSTR(" : " SUFFIX "\n"), VAR); } while(0)
 #endif
 
+/**
+ * sync_plan_position
+ * Set planner / stepper positions to the cartesian current_position.
+ * The stepper code translates these coordinates into step units.
+ * Allows translation between steps and millimeters for cartesian & core robots
+ */
+inline void sync_plan_position() {
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position", current_position);
+  #endif
+  planner.set_position_mm(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+}
+inline void sync_plan_position_e() { planner.set_e_position_mm(current_position[E_AXIS]); }
+
 #if ENABLED(DELTA) || ENABLED(SCARA)
   inline void sync_plan_position_delta() {
     #if ENABLED(DEBUG_LEVELING_FEATURE)
@@ -897,16 +911,15 @@ void setup() {
   // Send "ok" after commands by default
   for (int8_t i = 0; i < BUFSIZE; i++) send_ok[i] = true;
 
-  // loads data from EEPROM if available else uses defaults (and resets step acceleration rate)
+  // Load data from EEPROM if available (or use defaults)
+  // This also updates variables in the planner, elsewhere
   Config_RetrieveSettings();
 
   // Initialize current position based on home_offset
   memcpy(current_position, home_offset, sizeof(home_offset));
 
-  #if ENABLED(DELTA) || ENABLED(SCARA)
-    // Vital to init kinematic equivalent for X0 Y0 Z0
-    SYNC_PLAN_POSITION_KINEMATIC();
-  #endif
+  // Vital to init stepper/planner equivalent for current_position
+  SYNC_PLAN_POSITION_KINEMATIC();
 
   thermalManager.init();    // Initialize temperature loop
 
@@ -1319,7 +1332,7 @@ inline bool code_value_bool() { return code_value_byte() > 0; }
       case TEMPUNIT_C:
         return code_value_float();
       case TEMPUNIT_F:
-        return (code_value_float() - 32) / 1.8;
+        return (code_value_float() - 32) * 0.5555555556;
       case TEMPUNIT_K:
         return code_value_float() - 272.15;
       default:
@@ -1333,7 +1346,7 @@ inline bool code_value_bool() { return code_value_byte() > 0; }
       case TEMPUNIT_K:
         return code_value_float();
       case TEMPUNIT_F:
-        return code_value_float() / 1.8;
+        return code_value_float() * 0.5555555556;
       default:
         return code_value_float();
     }
@@ -1627,19 +1640,6 @@ inline void line_to_destination(float fr_mm_m) {
 }
 inline void line_to_destination() { line_to_destination(feedrate_mm_m); }
 
-/**
- * sync_plan_position
- * Set planner / stepper positions to the cartesian current_position.
- * The stepper code translates these coordinates into step units.
- * Allows translation between steps and millimeters for cartesian & core robots
- */
-inline void sync_plan_position() {
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position", current_position);
-  #endif
-  planner.set_position_mm(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
-}
-inline void sync_plan_position_e() { planner.set_e_position_mm(current_position[E_AXIS]); }
 inline void set_current_to_destination() { memcpy(current_position, destination, sizeof(current_position)); }
 inline void set_destination_to_current() { memcpy(destination, current_position, sizeof(destination)); }
 
@@ -5147,6 +5147,7 @@ inline void gcode_M92() {
       }
     }
   }
+  planner.refresh_positioning();
 }
 
 /**
@@ -6140,7 +6141,7 @@ inline void gcode_M428() {
   bool err = false;
   LOOP_XYZ(i) {
     if (axis_homed[i]) {
-      float base = (current_position[i] > (sw_endstop_min[i] + sw_endstop_max[i]) / 2) ? base_home_pos(i) : 0,
+      float base = (current_position[i] > (sw_endstop_min[i] + sw_endstop_max[i]) * 0.5) ? base_home_pos(i) : 0,
             diff = current_position[i] - LOGICAL_POSITION(base, i);
       if (diff > -20 && diff < 20) {
         set_home_offset((AxisEnum)i, home_offset[i] - diff);
diff --git a/Marlin/SanityCheck.h b/Marlin/SanityCheck.h
index 9ed8caa..129a435 100644
--- a/Marlin/SanityCheck.h
+++ b/Marlin/SanityCheck.h
@@ -577,8 +577,20 @@
       #elif !PIN_EXISTS(TEMP_3)
         #error "TEMP_3_PIN not defined for this board."
       #endif
+    #elif TEMP_SENSOR_3 != 0
+      #error "TEMP_SENSOR_3 shouldn't be set with only 3 extruders."
     #endif
-  #endif
+  #elif TEMP_SENSOR_2 != 0
+    #error "TEMP_SENSOR_2 shouldn't be set with only 2 extruders."
+  #elif TEMP_SENSOR_3 != 0
+    #error "TEMP_SENSOR_3 shouldn't be set with only 2 extruders."
+  #endif
+#elif TEMP_SENSOR_1 != 0 && DISABLED(TEMP_SENSOR_1_AS_REDUNDANT)
+  #error "TEMP_SENSOR_1 shouldn't be set with only 1 extruder."
+#elif TEMP_SENSOR_2 != 0
+  #error "TEMP_SENSOR_2 shouldn't be set with only 1 extruder."
+#elif TEMP_SENSOR_3 != 0
+  #error "TEMP_SENSOR_3 shouldn't be set with only 1 extruder."
 #endif
 
 #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT) && TEMP_SENSOR_1 == 0
diff --git a/Marlin/configuration_store.cpp b/Marlin/configuration_store.cpp
index 3d61f77..a8bc7b8 100644
--- a/Marlin/configuration_store.cpp
+++ b/Marlin/configuration_store.cpp
@@ -171,10 +171,16 @@ void Config_Postprocess() {
   // steps per s2 needs to be updated to agree with units per s2
   planner.reset_acceleration_rates();
 
+  // Make sure delta kinematics are updated before refreshing the
+  // planner position so the stepper counts will be set correctly.
   #if ENABLED(DELTA)
     recalc_delta_settings(delta_radius, delta_diagonal_rod);
   #endif
 
+  // Refresh steps_to_mm with the reciprocal of axis_steps_per_mm
+  // and init stepper.count[], planner.position[] with current_position
+  planner.refresh_positioning();
+
   #if ENABLED(PIDTEMP)
     thermalManager.updatePID();
   #endif
diff --git a/Marlin/example_configurations/delta/generic/Configuration.h b/Marlin/example_configurations/delta/generic/Configuration.h
index cb84cb9..e257309 100644
--- a/Marlin/example_configurations/delta/generic/Configuration.h
+++ b/Marlin/example_configurations/delta/generic/Configuration.h
@@ -239,7 +239,7 @@
 //#define DUMMY_THERMISTOR_999_VALUE 100
 // :{ '0': "Not used",'1':"100k / 4.7k - EPCOS",'2':"200k / 4.7k - ATC Semitec 204GT-2",'3':"Mendel-parts / 4.7k",'4':"10k !! do not use for a hotend. Bad resolution at high temp. !!",'5':"100K / 4.7k - ATC Semitec 104GT-2 (Used in ParCan & J-Head)",'6':"100k / 4.7k EPCOS - Not as accurate as Table 1",'7':"100k / 4.7k Honeywell 135-104LAG-J01",'8':"100k / 4.7k 0603 SMD Vishay NTCS0603E3104FXT",'9':"100k / 4.7k GE Sensing AL03006-58.2K-97-G1",'10':"100k / 4.7k RS 198-961",'11':"100k / 4.7k beta 3950 1%",'12':"100k / 4.7k 0603 SMD Vishay NTCS0603E3104FXT (calibrated for Makibox hot bed)",'13':"100k Hisens 3950  1% up to 300Â°C for hotend 'Simple ONE ' & hotend 'All In ONE'",'20':"PT100 (Ultimainboard V2.x)",'51':"100k / 1k - EPCOS",'52':"200k / 1k - ATC Semitec 204GT-2",'55':"100k / 1k - ATC Semitec 104GT-2 (Used in ParCan & J-Head)",'60':"100k Maker's Tool Works Kapton Bed Thermistor beta=3950",'66':"Dyze Design 4.7M High Temperature thermistor",'70':"the 100K thermistor found in the bq Hephestos 2",'71':"100k / 4.7k Honeywell 135-104LAF-J01",'147':"Pt100 / 4.7k",'1047':"Pt1000 / 4.7k",'110':"Pt100 / 1k (non-standard)",'1010':"Pt1000 / 1k (non standard)",'-3':"Thermocouple + MAX31855 (only for sensor 0)",'-2':"Thermocouple + MAX6675 (only for sensor 0)",'-1':"Thermocouple + AD595",'998':"Dummy 1",'999':"Dummy 2" }
 #define TEMP_SENSOR_0 -1
-#define TEMP_SENSOR_1 -1
+#define TEMP_SENSOR_1 0
 #define TEMP_SENSOR_2 0
 #define TEMP_SENSOR_3 0
 #define TEMP_SENSOR_BED 0
diff --git a/Marlin/language_it.h b/Marlin/language_it.h
index acb4e8a..82bece1 100644
--- a/Marlin/language_it.h
+++ b/Marlin/language_it.h
@@ -94,6 +94,7 @@
 #define MSG_PID_I                           "PID-I"
 #define MSG_PID_D                           "PID-D"
 #define MSG_PID_C                           "PID-C"
+#define MSG_SELECT                          "Seleziona"
 #define MSG_ACC                             "Accel"
 #define MSG_VXY_JERK                        "Vxy-jerk"
 #define MSG_VZ_JERK                         "Vz-jerk"
@@ -165,6 +166,10 @@
 #define MSG_ERR_MINTEMP_BED                 "Err: TEMP MINIMA PIATTO"
 #define MSG_HALTED                          "STAMPANTE FERMATA"
 #define MSG_PLEASE_RESET                    "Riavviare prego"
+#define MSG_SHORT_DAY                       "g" // One character only
+#define MSG_SHORT_HOUR                      "h" // One character only
+#define MSG_SHORT_MINUTE                    "m" // One character only
+#define MSG_PRINT_TIME                      "Durata stampa"
 #define MSG_HEATING                         "Riscaldamento.."
 #define MSG_HEATING_COMPLETE                "Risc. completato"
 #define MSG_BED_HEATING                     "Risc. Piatto.."
@@ -184,12 +189,16 @@
 #define MSG_INFO_PROTOCOL                   "Protocollo"
 #if LCD_WIDTH > 19
   #define MSG_INFO_PRINT_COUNT              "Contat. stampa"
-  #define MSG_INFO_FINISHED_PRINTS          "Finiti        "
-  #define MSG_INFO_PRINT_TIME               "Tempo totale  "
+  #define MSG_INFO_COMPLETED_PRINTS         "Completati"
+  #define MSG_INFO_PRINT_TIME               "Tempo totale"
+  #define MSG_INFO_PRINT_LONGEST            "Lavoro piu lungo"
+  #define MSG_INFO_PRINT_FILAMENT           "Totale estruso"
 #else
-  #define MSG_INFO_PRINT_COUNT              "Stampe   "
-  #define MSG_INFO_FINISHED_PRINTS          "Finiti   "
-  #define MSG_INFO_PRINT_TIME               "Durata   "
+  #define MSG_INFO_PRINT_COUNT              "Stampe"
+  #define MSG_INFO_COMPLETED_PRINTS         "Completati"
+  #define MSG_INFO_PRINT_TIME               "Durata"
+  #define MSG_INFO_PRINT_LONGEST            "Piu lungo"
+  #define MSG_INFO_PRINT_FILAMENT           "Estruso"
 #endif
 #define MSG_INFO_MIN_TEMP                   "Temp min"
 #define MSG_INFO_MAX_TEMP                   "Temp max"
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index 35e5d3b..d59f6c8 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -80,29 +80,31 @@ block_t Planner::block_buffer[BLOCK_BUFFER_SIZE];
 volatile uint8_t Planner::block_buffer_head = 0;           // Index of the next block to be pushed
 volatile uint8_t Planner::block_buffer_tail = 0;
 
-float Planner::max_feedrate_mm_s[NUM_AXIS]; // Max speeds in mm per second
-float Planner::axis_steps_per_mm[NUM_AXIS];
-unsigned long Planner::max_acceleration_steps_per_s2[NUM_AXIS];
-unsigned long Planner::max_acceleration_mm_per_s2[NUM_AXIS]; // Use M201 to override by software
+float Planner::max_feedrate_mm_s[NUM_AXIS], // Max speeds in mm per second
+      Planner::axis_steps_per_mm[NUM_AXIS],
+      Planner::steps_to_mm[NUM_AXIS];
+
+unsigned long Planner::max_acceleration_steps_per_s2[NUM_AXIS],
+              Planner::max_acceleration_mm_per_s2[NUM_AXIS]; // Use M201 to override by software
 
 millis_t Planner::min_segment_time;
-float Planner::min_feedrate_mm_s;
-float Planner::acceleration;         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
-float Planner::retract_acceleration; // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX
-float Planner::travel_acceleration;  // Travel acceleration mm/s^2  DEFAULT ACCELERATION for all NON printing moves. M204 MXXXX
-float Planner::max_xy_jerk;          // The largest speed change requiring no acceleration
-float Planner::max_z_jerk;
-float Planner::max_e_jerk;
-float Planner::min_travel_feedrate_mm_s;
+float Planner::min_feedrate_mm_s,
+      Planner::acceleration,         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
+      Planner::retract_acceleration, // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX
+      Planner::travel_acceleration,  // Travel acceleration mm/s^2  DEFAULT ACCELERATION for all NON printing moves. M204 MXXXX
+      Planner::max_xy_jerk,          // The largest speed change requiring no acceleration
+      Planner::max_z_jerk,
+      Planner::max_e_jerk,
+      Planner::min_travel_feedrate_mm_s;
 
 #if ENABLED(AUTO_BED_LEVELING_FEATURE)
   matrix_3x3 Planner::bed_level_matrix; // Transform to compensate for bed level
 #endif
 
 #if ENABLED(AUTOTEMP)
-  float Planner::autotemp_max = 250;
-  float Planner::autotemp_min = 210;
-  float Planner::autotemp_factor = 0.1;
+  float Planner::autotemp_max = 250,
+        Planner::autotemp_min = 210,
+        Planner::autotemp_factor = 0.1;
   bool Planner::autotemp_enabled = false;
 #endif
 
@@ -110,9 +112,8 @@ float Planner::min_travel_feedrate_mm_s;
 
 long Planner::position[NUM_AXIS] = { 0 };
 
-float Planner::previous_speed[NUM_AXIS];
-
-float Planner::previous_nominal_speed;
+float Planner::previous_speed[NUM_AXIS],
+      Planner::previous_nominal_speed;
 
 #if ENABLED(DISABLE_INACTIVE_EXTRUDER)
   uint8_t Planner::g_uc_extruder_last_move[EXTRUDERS] = { 0 };
@@ -783,31 +784,37 @@ void Planner::check_axes_activity() {
   #if ENABLED(COREXY) || ENABLED(COREXZ) || ENABLED(COREYZ)
     float delta_mm[6];
     #if ENABLED(COREXY)
-      delta_mm[X_HEAD] = dx / axis_steps_per_mm[A_AXIS];
-      delta_mm[Y_HEAD] = dy / axis_steps_per_mm[B_AXIS];
-      delta_mm[Z_AXIS] = dz / axis_steps_per_mm[Z_AXIS];
-      delta_mm[A_AXIS] = (dx + dy) / axis_steps_per_mm[A_AXIS];
-      delta_mm[B_AXIS] = (dx - dy) / axis_steps_per_mm[B_AXIS];
+      delta_mm[X_HEAD] = dx * steps_to_mm[A_AXIS];
+      delta_mm[Y_HEAD] = dy * steps_to_mm[B_AXIS];
+      delta_mm[Z_AXIS] = dz * steps_to_mm[Z_AXIS];
+      delta_mm[A_AXIS] = (dx + dy) * steps_to_mm[A_AXIS];
+      delta_mm[B_AXIS] = (dx - dy) * steps_to_mm[B_AXIS];
     #elif ENABLED(COREXZ)
-      delta_mm[X_HEAD] = dx / axis_steps_per_mm[A_AXIS];
-      delta_mm[Y_AXIS] = dy / axis_steps_per_mm[Y_AXIS];
-      delta_mm[Z_HEAD] = dz / axis_steps_per_mm[C_AXIS];
-      delta_mm[A_AXIS] = (dx + dz) / axis_steps_per_mm[A_AXIS];
-      delta_mm[C_AXIS] = (dx - dz) / axis_steps_per_mm[C_AXIS];
+      delta_mm[X_HEAD] = dx * steps_to_mm[A_AXIS];
+      delta_mm[Y_AXIS] = dy * steps_to_mm[Y_AXIS];
+      delta_mm[Z_HEAD] = dz * steps_to_mm[C_AXIS];
+      delta_mm[A_AXIS] = (dx + dz) * steps_to_mm[A_AXIS];
+      delta_mm[C_AXIS] = (dx - dz) * steps_to_mm[C_AXIS];
     #elif ENABLED(COREYZ)
-      delta_mm[X_AXIS] = dx / axis_steps_per_mm[A_AXIS];
-      delta_mm[Y_HEAD] = dy / axis_steps_per_mm[Y_AXIS];
-      delta_mm[Z_HEAD] = dz / axis_steps_per_mm[C_AXIS];
-      delta_mm[B_AXIS] = (dy + dz) / axis_steps_per_mm[B_AXIS];
-      delta_mm[C_AXIS] = (dy - dz) / axis_steps_per_mm[C_AXIS];
+      delta_mm[X_AXIS] = dx * steps_to_mm[X_AXIS];
+      delta_mm[Y_HEAD] = dy * steps_to_mm[B_AXIS];
+      delta_mm[Z_HEAD] = dz * steps_to_mm[C_AXIS];
+      delta_mm[B_AXIS] = (dy + dz) * steps_to_mm[B_AXIS];
+      delta_mm[C_AXIS] = (dy - dz) * steps_to_mm[C_AXIS];
     #endif
   #else
     float delta_mm[4];
-    delta_mm[X_AXIS] = dx / axis_steps_per_mm[X_AXIS];
-    delta_mm[Y_AXIS] = dy / axis_steps_per_mm[Y_AXIS];
-    delta_mm[Z_AXIS] = dz / axis_steps_per_mm[Z_AXIS];
+    #if ENABLED(DELTA)
+      // On delta all axes (should!) have the same steps-per-mm
+      // so calculate distance in steps first, then do one division
+      // at the end to get millimeters
+    #else
+      delta_mm[X_AXIS] = dx * steps_to_mm[X_AXIS];
+      delta_mm[Y_AXIS] = dy * steps_to_mm[Y_AXIS];
+      delta_mm[Z_AXIS] = dz * steps_to_mm[Z_AXIS];
+    #endif
   #endif
-  delta_mm[E_AXIS] = (de / axis_steps_per_mm[E_AXIS]) * volumetric_multiplier[extruder] * extruder_multiplier[extruder] / 100.0;
+  delta_mm[E_AXIS] = 0.01 * (de * steps_to_mm[E_AXIS]) * volumetric_multiplier[extruder] * extruder_multiplier[extruder];
 
   if (block->steps[X_AXIS] <= dropsegments && block->steps[Y_AXIS] <= dropsegments && block->steps[Z_AXIS] <= dropsegments) {
     block->millimeters = fabs(delta_mm[E_AXIS]);
@@ -820,10 +827,16 @@ void Planner::check_axes_activity() {
         sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_HEAD])
       #elif ENABLED(COREYZ)
         sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_HEAD])
+      #elif ENABLED(DELTA)
+        sq(dx) + sq(dy) + sq(dz)
       #else
         sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_AXIS])
       #endif
-    );
+    )
+      #if ENABLED(DELTA)
+        * steps_to_mm[X_AXIS]
+      #endif
+    ;
   }
   float inverse_millimeters = 1.0 / block->millimeters;  // Inverse millimeters to remove multiple divides
 
@@ -875,7 +888,7 @@ void Planner::check_axes_activity() {
         while (filwidth_delay_dist >= MMD_MM) filwidth_delay_dist -= MMD_MM;
 
         // Convert into an index into the measurement array
-        filwidth_delay_index1 = (int)(filwidth_delay_dist / 10.0 + 0.0001);
+        filwidth_delay_index1 = (int)(filwidth_delay_dist * 0.1 + 0.0001);
 
         // If the index has changed (must have gone forward)...
         if (filwidth_delay_index1 != filwidth_delay_index2) {
@@ -962,7 +975,7 @@ void Planner::check_axes_activity() {
       block->acceleration_steps_per_s2 = (max_acceleration_steps_per_s2[E_AXIS] * block->step_event_count) / block->steps[E_AXIS];
   }
   block->acceleration = block->acceleration_steps_per_s2 / steps_per_mm;
-  block->acceleration_rate = (long)(block->acceleration_steps_per_s2 * 16777216.0 / ((F_CPU) / 8.0));
+  block->acceleration_rate = (long)(block->acceleration_steps_per_s2 * 16777216.0 / ((F_CPU) * 0.125));
 
   #if 0  // Use old jerk for now
 
@@ -1008,10 +1021,12 @@ void Planner::check_axes_activity() {
   #endif
 
   // Start with a safe speed
-  float vmax_junction = max_xy_jerk / 2;
-  float vmax_junction_factor = 1.0;
-  float mz2 = max_z_jerk / 2, me2 = max_e_jerk / 2;
-  float csz = current_speed[Z_AXIS], cse = current_speed[E_AXIS];
+  float vmax_junction = max_xy_jerk * 0.5,
+        vmax_junction_factor = 1.0,
+        mz2 = max_z_jerk * 0.5,
+        me2 = max_e_jerk * 0.5,
+        csz = current_speed[Z_AXIS],
+        cse = current_speed[E_AXIS];
   if (fabs(csz) > mz2) vmax_junction = min(vmax_junction, mz2);
   if (fabs(cse) > me2) vmax_junction = min(vmax_junction, me2);
   vmax_junction = min(vmax_junction, block->nominal_speed);
@@ -1164,6 +1179,7 @@ void Planner::check_axes_activity() {
 void Planner::set_e_position_mm(const float& e) {
   position[E_AXIS] = lround(e * axis_steps_per_mm[E_AXIS]);
   stepper.set_e_position(position[E_AXIS]);
+  previous_speed[E_AXIS] = 0.0;
 }
 
 // Recalculate the steps/s^2 acceleration rates, based on the mm/s^2
@@ -1172,6 +1188,13 @@ void Planner::reset_acceleration_rates() {
     max_acceleration_steps_per_s2[i] = max_acceleration_mm_per_s2[i] * axis_steps_per_mm[i];
 }
 
+// Recalculate position, steps_to_mm if axis_steps_per_mm changes!
+void Planner::refresh_positioning() {
+  LOOP_XYZE(i) planner.steps_to_mm[i] = 1.0 / planner.axis_steps_per_mm[i];
+  set_position_mm(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+  reset_acceleration_rates();
+}
+
 #if ENABLED(AUTOTEMP)
 
   void Planner::autotemp_M109() {
diff --git a/Marlin/planner.h b/Marlin/planner.h
index 74abd1c..eac1ae5 100644
--- a/Marlin/planner.h
+++ b/Marlin/planner.h
@@ -121,6 +121,7 @@ class Planner {
 
     static float max_feedrate_mm_s[NUM_AXIS]; // Max speeds in mm per second
     static float axis_steps_per_mm[NUM_AXIS];
+    static float steps_to_mm[NUM_AXIS];
     static unsigned long max_acceleration_steps_per_s2[NUM_AXIS];
     static unsigned long max_acceleration_mm_per_s2[NUM_AXIS]; // Use M201 to override by software
 
@@ -142,7 +143,7 @@ class Planner {
 
     /**
      * The current position of the tool in absolute steps
-     * Reclculated if any axis_steps_per_mm are changed by gcode
+     * Recalculated if any axis_steps_per_mm are changed by gcode
      */
     static long position[NUM_AXIS];
 
@@ -187,6 +188,7 @@ class Planner {
      */
 
     static void reset_acceleration_rates();
+    static void refresh_positioning();
 
     // Manage fans, paste pressure, etc.
     static void check_axes_activity();
diff --git a/Marlin/stepper.cpp b/Marlin/stepper.cpp
index 90a1ddf..88e8cd5 100644
--- a/Marlin/stepper.cpp
+++ b/Marlin/stepper.cpp
@@ -944,14 +944,14 @@ float Stepper::get_axis_position_mm(AxisEnum axis) {
       CRITICAL_SECTION_END;
       // ((a1+a2)+(a1-a2))/2 -> (a1+a2+a1-a2)/2 -> (a1+a1)/2 -> a1
       // ((a1+a2)-(a1-a2))/2 -> (a1+a2-a1+a2)/2 -> (a2+a2)/2 -> a2
-      axis_steps = (pos1 + ((axis == CORE_AXIS_1) ? pos2 : -pos2)) / 2.0f;
+      axis_steps = (pos1 + ((axis == CORE_AXIS_1) ? pos2 : -pos2)) * 0.5f;
     }
     else
       axis_steps = position(axis);
   #else
     axis_steps = position(axis);
   #endif
-  return axis_steps / planner.axis_steps_per_mm[axis];
+  return axis_steps * planner.steps_to_mm[axis];
 }
 
 void Stepper::finish_and_disable() {
@@ -973,9 +973,9 @@ void Stepper::endstop_triggered(AxisEnum axis) {
 
     float axis_pos = count_position[axis];
     if (axis == CORE_AXIS_1)
-      axis_pos = (axis_pos + count_position[CORE_AXIS_2]) / 2;
+      axis_pos = (axis_pos + count_position[CORE_AXIS_2]) * 0.5;
     else if (axis == CORE_AXIS_2)
-      axis_pos = (count_position[CORE_AXIS_1] - axis_pos) / 2;
+      axis_pos = (count_position[CORE_AXIS_1] - axis_pos) * 0.5;
     endstops_trigsteps[axis] = axis_pos;
 
   #else // !COREXY && !COREXZ && !COREYZ
diff --git a/Marlin/stepper.h b/Marlin/stepper.h
index 45c8753..3ecf93a 100644
--- a/Marlin/stepper.h
+++ b/Marlin/stepper.h
@@ -262,7 +262,7 @@ class Stepper {
     // Triggered position of an axis in mm (not core-savvy)
     //
     static FORCE_INLINE float triggered_position_mm(AxisEnum axis) {
-      return endstops_trigsteps[axis] / planner.axis_steps_per_mm[axis];
+      return endstops_trigsteps[axis] * planner.steps_to_mm[axis];
     }
 
     #if ENABLED(LIN_ADVANCE)
diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index db28052..666edd9 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -319,13 +319,13 @@ unsigned char Temperature::soft_pwm[HOTENDS];
               SERIAL_PROTOCOLPAIR(MSG_T_MIN, min);
               SERIAL_PROTOCOLPAIR(MSG_T_MAX, max);
               if (cycles > 2) {
-                Ku = (4.0 * d) / (3.14159265 * (max - min) / 2.0);
-                Tu = ((float)(t_low + t_high) / 1000.0);
+                Ku = (4.0 * d) / (3.14159265 * (max - min) * 0.5);
+                Tu = ((float)(t_low + t_high) * 0.001);
                 SERIAL_PROTOCOLPAIR(MSG_KU, Ku);
                 SERIAL_PROTOCOLPAIR(MSG_TU, Tu);
                 workKp = 0.6 * Ku;
                 workKi = 2 * workKp / Tu;
-                workKd = workKp * Tu / 8;
+                workKd = workKp * Tu * 0.125;
                 SERIAL_PROTOCOLLNPGM(MSG_CLASSIC_PID);
                 SERIAL_PROTOCOLPAIR(MSG_KP, workKp);
                 SERIAL_PROTOCOLPAIR(MSG_KI, workKi);
@@ -572,7 +572,7 @@ float Temperature::get_pid_output(int e) {
               lpq[lpq_ptr] = 0;
             }
             if (++lpq_ptr >= lpq_len) lpq_ptr = 0;
-            cTerm[HOTEND_INDEX] = (lpq[lpq_ptr] / planner.axis_steps_per_mm[E_AXIS]) * PID_PARAM(Kc, HOTEND_INDEX);
+            cTerm[HOTEND_INDEX] = (lpq[lpq_ptr] * planner.steps_to_mm[E_AXIS]) * PID_PARAM(Kc, HOTEND_INDEX);
             pid_output += cTerm[HOTEND_INDEX];
           }
         #endif //PID_ADD_EXTRUSION_RATE
@@ -753,7 +753,7 @@ void Temperature::manage_heater() {
       // Get the delayed info and add 100 to reconstitute to a percent of
       // the nominal filament diameter then square it to get an area
       meas_shift_index = constrain(meas_shift_index, 0, MAX_MEASUREMENT_DELAY);
-      float vm = pow((measurement_delay[meas_shift_index] + 100.0) / 100.0, 2);
+      float vm = pow((measurement_delay[meas_shift_index] + 100.0) * 0.01, 2);
       NOLESS(vm, 0.01);
       volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM] = vm;
     }
diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
index 7d687ac..e372989 100755
--- a/Marlin/ultralcd.cpp
+++ b/Marlin/ultralcd.cpp
@@ -678,7 +678,7 @@ void kill_screen(const char* lcd_msg) {
       }
       if (lcdDrawUpdate)
         lcd_implementation_drawedit(msg, ftostr43sign(
-          ((1000 * babysteps_done) / planner.axis_steps_per_mm[axis]) * 0.001f
+          ((1000 * babysteps_done) * planner.steps_to_mm[axis]) * 0.001f
         ));
     }
 
@@ -1769,6 +1769,7 @@ void kill_screen(const char* lcd_msg) {
   }
 
   static void _reset_acceleration_rates() { planner.reset_acceleration_rates(); }
+  static void _planner_refresh_positioning() { planner.refresh_positioning(); }
 
   /**
    *
@@ -1805,14 +1806,14 @@ void kill_screen(const char* lcd_msg) {
     MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &planner.max_acceleration_mm_per_s2[E_AXIS], 100, 99000, _reset_acceleration_rates);
     MENU_ITEM_EDIT(float5, MSG_A_RETRACT, &planner.retract_acceleration, 100, 99000);
     MENU_ITEM_EDIT(float5, MSG_A_TRAVEL, &planner.travel_acceleration, 100, 99000);
-    MENU_ITEM_EDIT(float52, MSG_XSTEPS, &planner.axis_steps_per_mm[X_AXIS], 5, 9999);
-    MENU_ITEM_EDIT(float52, MSG_YSTEPS, &planner.axis_steps_per_mm[Y_AXIS], 5, 9999);
+    MENU_ITEM_EDIT_CALLBACK(float52, MSG_XSTEPS, &planner.axis_steps_per_mm[X_AXIS], 5, 9999, _planner_refresh_positioning);
+    MENU_ITEM_EDIT_CALLBACK(float52, MSG_YSTEPS, &planner.axis_steps_per_mm[Y_AXIS], 5, 9999, _planner_refresh_positioning);
     #if ENABLED(DELTA)
-      MENU_ITEM_EDIT(float52, MSG_ZSTEPS, &planner.axis_steps_per_mm[Z_AXIS], 5, 9999);
+      MENU_ITEM_EDIT_CALLBACK(float52, MSG_ZSTEPS, &planner.axis_steps_per_mm[Z_AXIS], 5, 9999, _planner_refresh_positioning);
     #else
-      MENU_ITEM_EDIT(float51, MSG_ZSTEPS, &planner.axis_steps_per_mm[Z_AXIS], 5, 9999);
+      MENU_ITEM_EDIT_CALLBACK(float51, MSG_ZSTEPS, &planner.axis_steps_per_mm[Z_AXIS], 5, 9999, _planner_refresh_positioning);
     #endif
-    MENU_ITEM_EDIT(float51, MSG_ESTEPS, &planner.axis_steps_per_mm[E_AXIS], 5, 9999);
+    MENU_ITEM_EDIT_CALLBACK(float51, MSG_ESTEPS, &planner.axis_steps_per_mm[E_AXIS], 5, 9999, _planner_refresh_positioning);
     #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
       MENU_ITEM_EDIT(bool, MSG_ENDSTOP_ABORT, &stepper.abort_on_endstop_hit);
     #endif
diff --git a/Marlin/ultralcd_impl_DOGM.h b/Marlin/ultralcd_impl_DOGM.h
index ff9cc62..f53f926 100644
--- a/Marlin/ultralcd_impl_DOGM.h
+++ b/Marlin/ultralcd_impl_DOGM.h
@@ -385,7 +385,7 @@ static void lcd_implementation_status_screen() {
     // SD Card Progress bar and clock
     if (IS_SD_PRINTING) {
       // Progress bar solid part
-      u8g.drawBox(55, 50, (unsigned int)(71.f * card.percentDone() / 100.f), 2 - (TALL_FONT_CORRECTION));
+      u8g.drawBox(55, 50, (unsigned int)(71 * card.percentDone() * 0.01), 2 - (TALL_FONT_CORRECTION));
     }
 
     u8g.setPrintPos(80,48);

