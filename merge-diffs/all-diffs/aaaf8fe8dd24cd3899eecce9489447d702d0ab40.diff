commit aaaf8fe8dd24cd3899eecce9489447d702d0ab40 (from b360306881533084c0478582a14950e26ada8d8a)
Merge: b360306 40ba644
Author: Erik van der Zalm <erik@vdzalm.eu>
Date:   Mon Oct 6 13:41:38 2014 +0200

    Merge pull request #1068 from darkjavi/Marlin_v1
    
    Added profile for RAMPS with 2 extruders and 1 fan, no heated bed

diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index c6e9a2a..9f9141a 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -48,6 +48,7 @@
 // 33 = RAMPS 1.3 / 1.4 (Power outputs: Extruder, Fan, Bed)
 // 34 = RAMPS 1.3 / 1.4 (Power outputs: Extruder0, Extruder1, Bed)
 // 35 = RAMPS 1.3 / 1.4 (Power outputs: Extruder, Fan, Fan)
+// 36 = RAMPS 1.3 / 1.4 (Power outputs: Extruder0, Extruder1, Fan)
 // 4  = Duemilanove w/ ATMega328P pin assignment
 // 5  = Gen6
 // 51 = Gen6 deluxe
diff --git a/Marlin/pins.h b/Marlin/pins.h
index caf0101..4b418ce 100644
--- a/Marlin/pins.h
+++ b/Marlin/pins.h
@@ -531,7 +531,7 @@
 * Arduino Mega pin assignment
 *
 ****************************************************************************************/
-#if MOTHERBOARD == 3 || MOTHERBOARD == 33 || MOTHERBOARD == 34 || MOTHERBOARD == 35 || MOTHERBOARD == 77 || MOTHERBOARD == 67 || MOTHERBOARD == 68
+#if MOTHERBOARD == 3 || MOTHERBOARD == 33 || MOTHERBOARD == 34 || MOTHERBOARD == 35 || MOTHERBOARD == 36 || MOTHERBOARD == 77 || MOTHERBOARD == 67 || MOTHERBOARD == 68
 #define KNOWN_BOARD 1
 
 //////////////////FIX THIS//////////////
@@ -547,7 +547,7 @@
 // #define RAMPS_V_1_0
 
 
-#if MOTHERBOARD == 33 || MOTHERBOARD == 34 || MOTHERBOARD == 35 || MOTHERBOARD == 77 || MOTHERBOARD == 67 || MOTHERBOARD == 68
+#if MOTHERBOARD == 33 || MOTHERBOARD == 34 || MOTHERBOARD == 35 || MOTHERBOARD == 36 ||  MOTHERBOARD == 77 || MOTHERBOARD == 67 || MOTHERBOARD == 68
 
   #define LARGE_FLASH true
 
@@ -653,7 +653,7 @@
     #define FAN_PIN            4 // IO pin. Buffer needed
   #endif
 
-  #if MOTHERBOARD == 77
+  #if MOTHERBOARD == 77 || MOTHERBOARD == 36
     #define FAN_PIN            8
   #endif
 
@@ -709,7 +709,7 @@
     #define TEMP_2_PIN         -1   // ANALOG NUMBERING
   #endif
 
-  #if MOTHERBOARD == 35
+  #if MOTHERBOARD == 35 || MOTHERBOARD == 36
     #define HEATER_BED_PIN     -1    // NO BED
   #else
     #if MOTHERBOARD == 77

commit aaaf8fe8dd24cd3899eecce9489447d702d0ab40 (from 40ba644bb4c7e073f0e082f28f6d982654fe0d42)
Merge: b360306 40ba644
Author: Erik van der Zalm <erik@vdzalm.eu>
Date:   Mon Oct 6 13:41:38 2014 +0200

    Merge pull request #1068 from darkjavi/Marlin_v1
    
    Added profile for RAMPS with 2 extruders and 1 fan, no heated bed

diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index 86a262f..9f9141a 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -31,7 +31,6 @@
 #define SERIAL_PORT 0
 
 // This determines the communication speed of the printer
-// This determines the communication speed of the printer
 #define BAUDRATE 250000
 
 // This enables the serial port associated to the Bluetooth interface
@@ -128,6 +127,7 @@
 // 10 is 100k RS thermistor 198-961 (4.7k pullup)
 // 11 is 100k beta 3950 1% thermistor (4.7k pullup)
 // 12 is 100k 0603 SMD Vishay NTCS0603E3104FXT (4.7k pullup) (calibrated for Makibox hot bed)
+// 13 is 100k Hisens 3950  1% up to 300°C for hotend "Simple ONE " & "Hotend "All In ONE" 
 // 20 is the PT100 circuit found in the Ultimainboard V2.x
 // 60 is 100k Maker's Tool Works Kapton Bed Thermistor beta=3950
 //
diff --git a/Marlin/ConfigurationStore.cpp b/Marlin/ConfigurationStore.cpp
index 7bbfede..dbbe33a 100644
--- a/Marlin/ConfigurationStore.cpp
+++ b/Marlin/ConfigurationStore.cpp
@@ -65,7 +65,7 @@ void Config_StoreSettings()
   EEPROM_WRITE_VAR(i,max_xy_jerk);
   EEPROM_WRITE_VAR(i,max_z_jerk);
   EEPROM_WRITE_VAR(i,max_e_jerk);
-  EEPROM_WRITE_VAR(i,add_homeing);
+  EEPROM_WRITE_VAR(i,add_homing);
   #ifdef DELTA
   EEPROM_WRITE_VAR(i,endstop_adj);
   EEPROM_WRITE_VAR(i,delta_radius);
@@ -170,9 +170,9 @@ SERIAL_ECHOLNPGM("Scaling factors:");
     SERIAL_ECHO_START;
     SERIAL_ECHOLNPGM("Home offset (mm):");
     SERIAL_ECHO_START;
-    SERIAL_ECHOPAIR("  M206 X",add_homeing[0] );
-    SERIAL_ECHOPAIR(" Y" ,add_homeing[1] );
-    SERIAL_ECHOPAIR(" Z" ,add_homeing[2] );
+    SERIAL_ECHOPAIR("  M206 X",add_homing[0] );
+    SERIAL_ECHOPAIR(" Y" ,add_homing[1] );
+    SERIAL_ECHOPAIR(" Z" ,add_homing[2] );
     SERIAL_ECHOLN("");
 #ifdef DELTA
     SERIAL_ECHO_START;
@@ -229,7 +229,7 @@ void Config_RetrieveSettings()
         EEPROM_READ_VAR(i,max_xy_jerk);
         EEPROM_READ_VAR(i,max_z_jerk);
         EEPROM_READ_VAR(i,max_e_jerk);
-        EEPROM_READ_VAR(i,add_homeing);
+        EEPROM_READ_VAR(i,add_homing);
         #ifdef DELTA
 		EEPROM_READ_VAR(i,endstop_adj);
 		EEPROM_READ_VAR(i,delta_radius);
@@ -303,7 +303,7 @@ void Config_ResetDefault()
     max_xy_jerk=DEFAULT_XYJERK;
     max_z_jerk=DEFAULT_ZJERK;
     max_e_jerk=DEFAULT_EJERK;
-    add_homeing[0] = add_homeing[1] = add_homeing[2] = 0;
+    add_homing[0] = add_homing[1] = add_homing[2] = 0;
 #ifdef DELTA
 	endstop_adj[0] = endstop_adj[1] = endstop_adj[2] = 0;
 	delta_radius= DELTA_RADIUS;
diff --git a/Marlin/Marlin.h b/Marlin/Marlin.h
index 9e6ba26..adc58b4 100644
--- a/Marlin/Marlin.h
+++ b/Marlin/Marlin.h
@@ -211,7 +211,7 @@ extern int extrudemultiply; // Sets extrude multiply factor (in percent) for all
 extern int extruder_multiply[EXTRUDERS]; // sets extrude multiply factor (in percent) for each extruder individually
 extern float volumetric_multiplier[EXTRUDERS]; // reciprocal of cross-sectional area of filament (in square millimeters), stored this way to reduce computational burden in planner
 extern float current_position[NUM_AXIS] ;
-extern float add_homeing[3];
+extern float add_homing[3];
 #ifdef DELTA
 extern float endstop_adj[3];
 extern float delta_radius;
diff --git a/Marlin/MarlinSerial.cpp b/Marlin/MarlinSerial.cpp
index a7251dd..e4e7374 100644
--- a/Marlin/MarlinSerial.cpp
+++ b/Marlin/MarlinSerial.cpp
@@ -73,7 +73,7 @@ void MarlinSerial::begin(long baud)
   bool useU2X = true;
 
 #if F_CPU == 16000000UL && SERIAL_PORT == 0
-  // hard coded exception for compatibility with the bootloader shipped
+  // hard-coded exception for compatibility with the bootloader shipped
   // with the Duemilanove and previous boards and the firmware on the 8U2
   // on the Uno and Mega 2560.
   if (baud == 57600) {
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index 493d649..9c9dd38 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -220,7 +220,7 @@ float volumetric_multiplier[EXTRUDERS] = {1.0
   #endif
 };
 float current_position[NUM_AXIS] = { 0.0, 0.0, 0.0, 0.0 };
-float add_homeing[3]={0,0,0};
+float add_homing[3]={0,0,0};
 #ifdef DELTA
 float endstop_adj[3]={0,0,0};
 #endif
@@ -318,7 +318,11 @@ bool cancel_heatup = false ;
 //===========================================================================
 const char axis_codes[NUM_AXIS] = {'X', 'Y', 'Z', 'E'};
 static float destination[NUM_AXIS] = {  0.0, 0.0, 0.0, 0.0};
+
+#ifndef DELTA
 static float delta[3] = {0.0, 0.0, 0.0};
+#endif
+
 static float offset[3] = {0.0, 0.0, 0.0};
 static bool home_all_axis = true;
 static float feedrate = 1500.0, next_feedrate, saved_feedrate;
@@ -852,7 +856,7 @@ static int dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
 
 static float x_home_pos(int extruder) {
   if (extruder == 0)
-    return base_home_pos(X_AXIS) + add_homeing[X_AXIS];
+    return base_home_pos(X_AXIS) + add_homing[X_AXIS];
   else
     // In dual carriage mode the extruder offset provides an override of the
     // second X-carriage offset when homed - otherwise X2_HOME_POS is used.
@@ -884,9 +888,9 @@ static void axis_is_at_home(int axis) {
       return;
     }
     else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && active_extruder == 0) {
-      current_position[X_AXIS] = base_home_pos(X_AXIS) + add_homeing[X_AXIS];
-      min_pos[X_AXIS] =          base_min_pos(X_AXIS) + add_homeing[X_AXIS];
-      max_pos[X_AXIS] =          min(base_max_pos(X_AXIS) + add_homeing[X_AXIS],
+      current_position[X_AXIS] = base_home_pos(X_AXIS) + add_homing[X_AXIS];
+      min_pos[X_AXIS] =          base_min_pos(X_AXIS) + add_homing[X_AXIS];
+      max_pos[X_AXIS] =          min(base_max_pos(X_AXIS) + add_homing[X_AXIS],
                                   max(extruder_offset[X_AXIS][1], X2_MAX_POS) - duplicate_extruder_x_offset);
       return;
     }
@@ -914,11 +918,11 @@ static void axis_is_at_home(int axis) {
      
      for (i=0; i<2; i++)
      {
-        delta[i] -= add_homeing[i];
+        delta[i] -= add_homing[i];
      } 
      
-    // SERIAL_ECHOPGM("addhome X="); SERIAL_ECHO(add_homeing[X_AXIS]);
-	// SERIAL_ECHOPGM(" addhome Y="); SERIAL_ECHO(add_homeing[Y_AXIS]);
+    // SERIAL_ECHOPGM("addhome X="); SERIAL_ECHO(add_homing[X_AXIS]);
+	// SERIAL_ECHOPGM(" addhome Y="); SERIAL_ECHO(add_homing[Y_AXIS]);
     // SERIAL_ECHOPGM(" addhome Theta="); SERIAL_ECHO(delta[X_AXIS]);
     // SERIAL_ECHOPGM(" addhome Psi+Theta="); SERIAL_ECHOLN(delta[Y_AXIS]);
       
@@ -936,14 +940,14 @@ static void axis_is_at_home(int axis) {
    } 
    else
    {
-      current_position[axis] = base_home_pos(axis) + add_homeing[axis];
-      min_pos[axis] =          base_min_pos(axis) + add_homeing[axis];
-      max_pos[axis] =          base_max_pos(axis) + add_homeing[axis];
+      current_position[axis] = base_home_pos(axis) + add_homing[axis];
+      min_pos[axis] =          base_min_pos(axis) + add_homing[axis];
+      max_pos[axis] =          base_max_pos(axis) + add_homing[axis];
    }
 #else
-  current_position[axis] = base_home_pos(axis) + add_homeing[axis];
-  min_pos[axis] =          base_min_pos(axis) + add_homeing[axis];
-  max_pos[axis] =          base_max_pos(axis) + add_homeing[axis];
+  current_position[axis] = base_home_pos(axis) + add_homing[axis];
+  min_pos[axis] =          base_min_pos(axis) + add_homing[axis];
+  max_pos[axis] =          base_max_pos(axis) + add_homing[axis];
 #endif
 }
 
@@ -1202,7 +1206,9 @@ static void homeaxis(int axis) {
       }
     #endif
 #if defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY > 0)
-//    if (axis==Z_AXIS) retract_z_probe();
+  #ifndef Z_PROBE_SLED
+    if (axis==Z_AXIS) retract_z_probe();
+  #endif
 #endif
 
   }
@@ -1268,7 +1274,7 @@ void refresh_cmd_timeout(void)
   } //retract
 #endif //FWRETRACT
 
-#ifdef ENABLE_AUTO_BED_LEVELING
+#ifdef Z_PROBE_SLED
 //
 // Method to dock/undock a sled designed by Charles Bell.
 //
@@ -1430,12 +1436,12 @@ void process_commands()
           HOMEAXIS(Z);
 
           calculate_delta(current_position);
-          plan_set_position(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS]);		  
-		  
+          plan_set_position(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS]);
+
 #else // NOT DELTA
 
       home_all_axis = !((code_seen(axis_codes[X_AXIS])) || (code_seen(axis_codes[Y_AXIS])) || (code_seen(axis_codes[Z_AXIS])));
-	  
+
       #if Z_HOME_DIR > 0                      // If homing away from BED do Z first
       if((home_all_axis) || (code_seen(axis_codes[Z_AXIS]))) {
         HOMEAXIS(Z);
@@ -1514,7 +1520,7 @@ void process_commands()
 		#ifdef SCARA
 		   current_position[X_AXIS]=code_value();
 		#else
-		   current_position[X_AXIS]=code_value()+add_homeing[0];
+		   current_position[X_AXIS]=code_value()+add_homing[0];
 		#endif
         }
       }
@@ -1524,7 +1530,7 @@ void process_commands()
          #ifdef SCARA
 		   current_position[Y_AXIS]=code_value();
 		#else
-		   current_position[Y_AXIS]=code_value()+add_homeing[1];
+		   current_position[Y_AXIS]=code_value()+add_homing[1];
 		#endif
         }
       }
@@ -1589,7 +1595,7 @@ void process_commands()
 
       if(code_seen(axis_codes[Z_AXIS])) {
         if(code_value_long() != 0) {
-          current_position[Z_AXIS]=code_value()+add_homeing[2];
+          current_position[Z_AXIS]=code_value()+add_homing[2];
         }
       }
       #ifdef ENABLE_AUTO_BED_LEVELING
@@ -1818,10 +1824,10 @@ void process_commands()
                 	current_position[i] = code_value();  
 		}
 		else {
-                current_position[i] = code_value()+add_homeing[i];  
+                current_position[i] = code_value()+add_homing[i];  
             	}  
 #else
-		current_position[i] = code_value()+add_homeing[i];
+		current_position[i] = code_value()+add_homing[i];
 #endif
             plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
            }
@@ -2698,9 +2704,9 @@ Sigma_Exit:
       SERIAL_PROTOCOLLN("");
       
       SERIAL_PROTOCOLPGM("SCARA Cal - Theta:");
-      SERIAL_PROTOCOL(delta[X_AXIS]+add_homeing[0]);
+      SERIAL_PROTOCOL(delta[X_AXIS]+add_homing[0]);
       SERIAL_PROTOCOLPGM("   Psi+Theta (90):");
-      SERIAL_PROTOCOL(delta[Y_AXIS]-delta[X_AXIS]-90+add_homeing[1]);
+      SERIAL_PROTOCOL(delta[Y_AXIS]-delta[X_AXIS]-90+add_homing[1]);
       SERIAL_PROTOCOLLN("");
       
       SERIAL_PROTOCOLPGM("SCARA step Cal - Theta:");
@@ -2826,19 +2832,19 @@ Sigma_Exit:
       if(code_seen('E')) max_e_jerk = code_value() ;
     }
     break;
-    case 206: // M206 additional homeing offset
+    case 206: // M206 additional homing offset
       for(int8_t i=0; i < 3; i++)
       {
-        if(code_seen(axis_codes[i])) add_homeing[i] = code_value();
+        if(code_seen(axis_codes[i])) add_homing[i] = code_value();
       }
 	  #ifdef SCARA
 	   if(code_seen('T'))       // Theta
       {
-        add_homeing[0] = code_value() ;
+        add_homing[0] = code_value() ;
       }
       if(code_seen('P'))       // Psi
       {
-        add_homeing[1] = code_value() ;
+        add_homing[1] = code_value() ;
       }
 	  #endif
       break;
diff --git a/Marlin/example_configurations/delta/Configuration.h b/Marlin/example_configurations/delta/Configuration.h
index c724484..975e52e 100644
--- a/Marlin/example_configurations/delta/Configuration.h
+++ b/Marlin/example_configurations/delta/Configuration.h
@@ -8,7 +8,7 @@
 //===========================================================================
 //============================= DELTA Printer ===============================
 //===========================================================================
-// For a Delta printer rplace the configuration files wilth the files in the
+// For a Delta printer replace the configuration files with the files in the
 // example_configurations/delta directory.
 //
 
@@ -66,7 +66,7 @@
 // 702= Minitronics v1.0
 // 90 = Alpha OMCA board
 // 91 = Final OMCA board
-// 301 = Rambo
+// 301= Rambo
 // 21 = Elefu Ra Board (v3)
 
 #ifndef MOTHERBOARD
@@ -89,7 +89,7 @@
 
 #define POWER_SUPPLY 1
 
-// Define this to have the electronics keep the powersupply off on startup. If you don't know what this is leave it.
+// Define this to have the electronics keep the power supply off on startup. If you don't know what this is leave it.
 // #define PS_DEFAULT_OFF
 
 //===========================================================================
@@ -103,7 +103,7 @@
 // and processor overload (too many expensive sqrt calls).
 #define DELTA_SEGMENTS_PER_SECOND 200
 
-// NOTE NB all values for DELTA_* values MOUST be floating point, so always have a decimal point in them
+// NOTE NB all values for DELTA_* values MUST be floating point, so always have a decimal point in them
 
 // Center-to-center distance of the holes in the diagonal push rods.
 #define DELTA_DIAGONAL_ROD 250.0 // mm
@@ -132,7 +132,7 @@
 // 0 is not used
 // 1 is 100k thermistor - best choice for EPCOS 100k (4.7k pullup)
 // 2 is 200k thermistor - ATC Semitec 204GT-2 (4.7k pullup)
-// 3 is mendel-parts thermistor (4.7k pullup)
+// 3 is Mendel-parts thermistor (4.7k pullup)
 // 4 is 10k thermistor !! do not use it for a hotend. It gives bad resolution at high temp. !!
 // 5 is 100K thermistor - ATC Semitec 104GT-2 (Used in ParCan & J-Head) (4.7k pullup)
 // 6 is 100k EPCOS - Not as accurate as table 1 (created using a fluke thermocouple) (4.7k pullup)
@@ -141,13 +141,18 @@
 // 8 is 100k 0603 SMD Vishay NTCS0603E3104FXT (4.7k pullup)
 // 9 is 100k GE Sensing AL03006-58.2K-97-G1 (4.7k pullup)
 // 10 is 100k RS thermistor 198-961 (4.7k pullup)
-// 60 is 100k Maker's Tool Works Kapton Bed Thermister
+// 60 is 100k Maker's Tool Works Kapton Bed Thermistor
 //
 //    1k ohm pullup tables - This is not normal, you would have to have changed out your 4.7k for 1k
 //                          (but gives greater accuracy and more stable PID)
 // 51 is 100k thermistor - EPCOS (1k pullup)
 // 52 is 200k thermistor - ATC Semitec 204GT-2 (1k pullup)
 // 55 is 100k thermistor - ATC Semitec 104GT-2 (Used in ParCan & J-Head) (1k pullup)
+//
+// 1047 is Pt1000 with 4k7 pullup
+// 1010 is Pt1000 with 1k pullup (non standard)
+// 147 is Pt100 with 4k7 pullup
+// 110 is Pt100 with 1k pullup (non standard)
 
 #define TEMP_SENSOR_0 -1
 #define TEMP_SENSOR_1 -1
@@ -184,6 +189,10 @@
 // HEATER_BED_DUTY_CYCLE_DIVIDER intervals.
 //#define HEATER_BED_DUTY_CYCLE_DIVIDER 4
 
+// If you want the M105 heater power reported in watts, define the BED_WATTS, and (shared for all extruders) EXTRUDER_WATTS
+//#define EXTRUDER_WATTS (12.0*12.0/6.7) //  P=I^2/R
+//#define BED_WATTS (12.0*12.0/1.1)      // P=I^2/R
+
 // PID settings:
 // Comment the following line to disable PID and enable bang-bang.
 #define PIDTEMP
@@ -198,13 +207,13 @@
   #define K1 0.95 //smoothing factor within the PID
   #define PID_dT ((16.0 * 8.0)/(F_CPU / 64.0 / 256.0)) //sampling period of the temperature routine
 
-// If you are using a preconfigured hotend then you can use one of the value sets by uncommenting it
+// If you are using a pre-configured hotend then you can use one of the value sets by uncommenting it
 // Ultimaker
     #define  DEFAULT_Kp 22.2
     #define  DEFAULT_Ki 1.08
     #define  DEFAULT_Kd 114
 
-// Makergear
+// MakerGear
 //    #define  DEFAULT_Kp 7.0
 //    #define  DEFAULT_Ki 0.1
 //    #define  DEFAULT_Kd 12
@@ -273,7 +282,7 @@
 #define ENDSTOPPULLUPS // Comment this out (using // at the start of the line) to disable the endstop pullup resistors
 
 #ifndef ENDSTOPPULLUPS
-  // fine Enstop settings: Individual Pullups. will be ignored if ENDSTOPPULLUPS is defined
+  // fine endstop settings: Individual pullups. will be ignored if ENDSTOPPULLUPS is defined
   // #define ENDSTOPPULLUP_XMAX
   // #define ENDSTOPPULLUP_YMAX
   // #define ENDSTOPPULLUP_ZMAX
@@ -359,7 +368,7 @@ const bool Z_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of
   #define BACK_PROBE_BED_POSITION 180
   #define FRONT_PROBE_BED_POSITION 20
 
-  // these are the offsets to the prob relative to the extruder tip (Hotend - Probe)
+  // these are the offsets to the probe relative to the extruder tip (Hotend - Probe)
   #define X_PROBE_OFFSET_FROM_EXTRUDER -25
   #define Y_PROBE_OFFSET_FROM_EXTRUDER -29
   #define Z_PROBE_OFFSET_FROM_EXTRUDER -12.35
@@ -380,7 +389,7 @@ const bool Z_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of
 //  #define PROBE_SERVO_DEACTIVATION_DELAY 300
 
 
-//If you have enabled the Bed Auto Levelling and are using the same Z Probe for Z Homing,
+//If you have enabled the Bed Auto Leveling and are using the same Z Probe for Z Homing,
 //it is highly recommended you let this Z_SAFE_HOMING enabled!!!
 
   #define Z_SAFE_HOMING   // This feature is meant to avoid Z homing with probe outside the bed area.
@@ -407,7 +416,7 @@ const bool Z_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of
 //Manual homing switch locations:
 
 #define MANUAL_HOME_POSITIONS  // MANUAL_*_HOME_POS below will be used
-// For deltabots this means top and center of the cartesian print volume.
+// For deltabots this means top and center of the Cartesian print volume.
 #define MANUAL_X_HOME_POS 0
 #define MANUAL_Y_HOME_POS 0
 #define MANUAL_Z_HOME_POS 250 // For delta: Distance between nozzle and print surface after homing.
@@ -443,11 +452,11 @@ const bool Z_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of
 //===========================================================================
 
 // EEPROM
-// the microcontroller can store settings in the EEPROM, e.g. max velocity...
-// M500 - stores paramters in EEPROM
+// The microcontroller can store settings in the EEPROM, e.g. max velocity...
+// M500 - stores parameters in EEPROM
 // M501 - reads parameters from EEPROM (if you need reset them after you changed them temporarily).
 // M502 - reverts to the default "factory settings".  You still need to store them in EEPROM afterwards if you want to.
-//define this to enable eeprom support
+//define this to enable EEPROM support
 //#define EEPROM_SETTINGS
 //to disable EEPROM Serial responses and decrease program space by ~1700 byte: comment this out:
 // please keep turned on if you can.
@@ -463,14 +472,14 @@ const bool Z_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of
 #define ABS_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
 
 //LCD and SD support
-//#define ULTRA_LCD  //general lcd support, also 16x2
+//#define ULTRA_LCD  //general LCD support, also 16x2
 //#define DOGLCD  // Support for SPI LCD 128x64 (Controller ST7565R graphic Display Family)
 //#define SDSUPPORT // Enable SD Card Support in Hardware Console
 //#define SDSLOW // Use slower SD transfer mode (not normally needed - uncomment if you're getting volume init error)
 //#define ENCODER_PULSES_PER_STEP 1 // Increase if you have a high resolution encoder
 //#define ENCODER_STEPS_PER_MENU_ITEM 5 // Set according to ENCODER_PULSES_PER_STEP or your liking
-//#define ULTIMAKERCONTROLLER //as available from the ultimaker online store.
-//#define ULTIPANEL  //the ultipanel as on thingiverse
+//#define ULTIMAKERCONTROLLER //as available from the Ultimaker online store.
+//#define ULTIPANEL  //the UltiPanel as on Thingiverse
 
 // The MaKr3d Makr-Panel with graphic controller and SD support
 // http://reprap.org/wiki/MaKr3d_MaKrPanel
@@ -594,7 +603,7 @@ const bool Z_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of
     #define LCD_WIDTH 20
     #define LCD_HEIGHT 4
   #endif
-#else //no panel but just lcd
+#else //no panel but just LCD
   #ifdef ULTRA_LCD
   #ifdef DOGLCD // Change number of lines to match the 128x64 graphics display
     #define LCD_WIDTH 20
@@ -616,8 +625,8 @@ const bool Z_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of
 // Increase the FAN pwm frequency. Removes the PWM noise but increases heating in the FET/Arduino
 //#define FAST_PWM_FAN
 
-// Temperature status leds that display the hotend and bet temperature.
-// If alle hotends and bed temperature and temperature setpoint are < 54C then the BLUE led is on.
+// Temperature status LEDs that display the hotend and bet temperature.
+// If all hotends and bed temperature and temperature setpoint are < 54C then the BLUE led is on.
 // Otherwise the RED led is on. There is 1C hysteresis.
 //#define TEMP_STAT_LEDS
 
diff --git a/Marlin/language.h b/Marlin/language.h
index 54ca5bc..ee5d77d 100644
--- a/Marlin/language.h
+++ b/Marlin/language.h
@@ -155,6 +155,7 @@
 	#define MSG_AUTOSTART "Autostart"
 	#define MSG_DISABLE_STEPPERS "Disable steppers"
 	#define MSG_AUTO_HOME "Auto home"
+	#define MSG_SET_HOME_OFFSETS "Set home offsets"
 	#define MSG_SET_ORIGIN "Set origin"
 	#define MSG_PREHEAT_PLA "Preheat PLA"
 	#define MSG_PREHEAT_PLA0 "Preheat PLA 1"
@@ -279,6 +280,7 @@
 	#define MSG_AUTOSTART "Autostart"
 	#define MSG_DISABLE_STEPPERS "Wylacz silniki"
 	#define MSG_AUTO_HOME "Auto. poz. zerowa"
+	#define MSG_SET_HOME_OFFSETS "Set home offsets"
 	#define MSG_SET_ORIGIN "Ustaw punkt zero"
 	#define MSG_PREHEAT_PLA "Rozgrzej PLA"
 	#define MSG_PREHEAT_PLA0 "Rozgrzej PLA 1"
@@ -406,10 +408,11 @@
 	#define MSG_AUTOSTART "Demarrage auto"
 	#define MSG_DISABLE_STEPPERS "Arreter moteurs"
 	#define MSG_AUTO_HOME "Home auto."
+	#define MSG_SET_HOME_OFFSETS "Set home offsets"
 	#define MSG_SET_ORIGIN "Regler origine"
 	#define MSG_PREHEAT_PLA " Prechauffage PLA"
 	#define MSG_PREHEAT_PLA0 "Prechauff. PLA 1"
-        #define MSG_PREHEAT_PLA1 "Prechauff. PLA 2"
+    #define MSG_PREHEAT_PLA1 "Prechauff. PLA 2"
 	#define MSG_PREHEAT_PLA2 "Prechauff. PLA 3"
 	#define MSG_PREHEAT_PLA012 "Prech. PLA Tout"
 	#define MSG_PREHEAT_PLA_BEDONLY "Prech. PLA Plateau"
@@ -534,6 +537,7 @@
 	#define MSG_AUTOSTART        "Autostart"
 	#define MSG_DISABLE_STEPPERS "Stepper abschalt."
 	#define MSG_AUTO_HOME        "Auto Nullpunkt"
+	#define MSG_SET_HOME_OFFSETS "Set home offsets"
 	#define MSG_SET_ORIGIN       "Setze Nullpunkt"
 	#define MSG_PREHEAT_PLA      "Vorwärmen PLA"
 	#define MSG_PREHEAT_PLA0     "Vorwärmen PLA 1"
@@ -661,6 +665,7 @@
 	#define MSG_AUTOSTART " Autostart"
 	#define MSG_DISABLE_STEPPERS "Apagar motores"
 	#define MSG_AUTO_HOME "Llevar al origen"
+	#define MSG_SET_HOME_OFFSETS "Set home offsets"
 	#define MSG_SET_ORIGIN "Establecer cero"
 	#define MSG_PREHEAT_PLA "Precalentar PLA"
 	#define MSG_PREHEAT_PLA0 "Precalentar PLA 1"
@@ -794,6 +799,7 @@
 	#define MSG_AUTOSTART						"Автостарт"
 	#define MSG_DISABLE_STEPPERS 				"Выкл. двигатели"
 	#define MSG_AUTO_HOME						"Парковка"
+	#define MSG_SET_HOME_OFFSETS				"Set home offsets"
 	#define MSG_SET_ORIGIN						"Запомнить ноль"
 	#define MSG_PREHEAT_PLA 					"Преднагрев PLA"
 	#define MSG_PREHEAT_PLA0					"Преднагрев PLA0"
@@ -885,11 +891,11 @@
 	#define MSG_KILLED							"УБИТО."
 	#define MSG_STOPPED							"ОСТАНОВЛЕНО."
 	#define MSG_CONTROL_RETRACT					"Откат mm:"
-	#define MSG_CONTROL_RETRACT_SWAP				"своп Откат mm:"
+	#define MSG_CONTROL_RETRACT_SWAP			"своп Откат mm:"
 	#define MSG_CONTROL_RETRACTF				"Откат  V:"
 	#define MSG_CONTROL_RETRACT_ZLIFT			"Прыжок mm:"
 	#define MSG_CONTROL_RETRACT_RECOVER			"Возврат +mm:"
-	#define MSG_CONTROL_RETRACT_RECOVER_SWAP		"своп Возврат +mm:"
+	#define MSG_CONTROL_RETRACT_RECOVER_SWAP	"своп Возврат +mm:"
 	#define MSG_CONTROL_RETRACT_RECOVERF		"Возврат  V:"
 	#define MSG_AUTORETRACT						"АвтоОткат:"
 	#define MSG_FILAMENTCHANGE 					"Change filament"
@@ -919,6 +925,7 @@
 	#define MSG_AUTOSTART            "Autostart"
 	#define MSG_DISABLE_STEPPERS     "Disabilita Motori"
 	#define MSG_AUTO_HOME            "Auto Home"
+	#define MSG_SET_HOME_OFFSETS     "Set home offsets"
 	#define MSG_SET_ORIGIN           "Imposta Origine"
 	#define MSG_PREHEAT_PLA          "Preriscalda PLA"
 	#define MSG_PREHEAT_PLA0         "Preriscalda PLA 1"
@@ -1044,6 +1051,7 @@
 	#define MSG_AUTOSTART "Autostart"
 	#define MSG_DISABLE_STEPPERS " Apagar motores"
 	#define MSG_AUTO_HOME "Ir para origen"
+	#define MSG_SET_HOME_OFFSETS "Set home offsets"
 	#define MSG_SET_ORIGIN "Estabelecer orig."
 	#define MSG_PREHEAT_PLA "Pre-aquecer PLA"
 	#define MSG_PREHEAT_PLA0 " pre-aquecer PLA 1"
@@ -1176,6 +1184,7 @@
 	#define MSG_AUTOSTART "Automaatti"
 	#define MSG_DISABLE_STEPPERS "Vapauta moottorit"
 	#define MSG_AUTO_HOME "Aja referenssiin"
+	#define MSG_SET_HOME_OFFSETS "Set home offsets"
 	#define MSG_SET_ORIGIN "Aseta origo"
 	#define MSG_PREHEAT_PLA "Esilammita PLA"
 	#define MSG_PREHEAT_PLA0 "Esilammita PLA 1"
@@ -1299,6 +1308,7 @@
 	#define MSG_AUTOSTART " Autostart"
 	#define MSG_DISABLE_STEPPERS "Amortar motors"
 	#define MSG_AUTO_HOME "Levar a l'orichen"
+	#define MSG_SET_HOME_OFFSETS "Set home offsets"
 	#define MSG_SET_ORIGIN "Establir zero"
 	#define MSG_PREHEAT_PLA "Precalentar PLA"
 	#define MSG_PREHEAT_PLA0 "Precalentar PLA0"
@@ -1431,6 +1441,7 @@
 	#define MSG_AUTOSTART "Autostart"
 	#define MSG_DISABLE_STEPPERS "Motoren uit"
 	#define MSG_AUTO_HOME "Auto home"
+	#define MSG_SET_HOME_OFFSETS "Set home offsets"
 	#define MSG_SET_ORIGIN "Nulpunt instellen"
 	#define MSG_PREHEAT_PLA "PLA voorverwarmen"
 	#define MSG_PREHEAT_PLA0 "PLA voorverw. 0"
diff --git a/Marlin/motion_control.cpp b/Marlin/motion_control.cpp
index 7660905..b26cbaf 100644
--- a/Marlin/motion_control.cpp
+++ b/Marlin/motion_control.cpp
@@ -44,6 +44,14 @@ void mc_arc(float *position, float *target, float *offset, uint8_t axis_0, uint8
   if (angular_travel < 0) { angular_travel += 2*M_PI; }
   if (isclockwise) { angular_travel -= 2*M_PI; }
   
+  //20141002:full circle for G03 did not work, e.g. G03 X80 Y80 I20 J0 F2000 is giving an Angle of zero so head is not moving
+  //to compensate when start pos = target pos && angle is zero -> angle = 2Pi
+  if (position[axis_0] == target[axis_0] && position[axis_1] == target[axis_1] && angular_travel == 0)
+  {
+	  angular_travel += 2*M_PI;
+  }
+  //end fix G03
+  
   float millimeters_of_travel = hypot(angular_travel*radius, fabs(linear_travel));
   if (millimeters_of_travel < 0.001) { return; }
   uint16_t segments = floor(millimeters_of_travel/MM_PER_ARC_SEGMENT);
diff --git a/Marlin/pins.h b/Marlin/pins.h
index 69de774..4b418ce 100644
--- a/Marlin/pins.h
+++ b/Marlin/pins.h
@@ -2078,8 +2078,8 @@ DaveX plan for Teensylu/printrboard-type pinouts (ref teensylu & sprinter) for a
 #define Z_DIR_PIN          28
 #define Z_STOP_PIN         30
 
-#define E0_STEP_PIN         17
-#define E0_DIR_PIN          21
+#define E0_STEP_PIN        17
+#define E0_DIR_PIN         21
 
 #define LED_PIN            -1
 
diff --git a/Marlin/stepper.cpp b/Marlin/stepper.cpp
index 9bc8eb8..9e22eb1 100644
--- a/Marlin/stepper.cpp
+++ b/Marlin/stepper.cpp
@@ -1241,7 +1241,7 @@ void microstep_init()
   pinMode(Y_MS1_PIN,OUTPUT);
   pinMode(Y_MS2_PIN,OUTPUT);
   pinMode(Z_MS1_PIN,OUTPUT);
-  pinMode(Z_MS2_PIN,OUTPUT);  
+  pinMode(Z_MS2_PIN,OUTPUT);
   pinMode(E0_MS1_PIN,OUTPUT);
   pinMode(E0_MS2_PIN,OUTPUT);
   for(int i=0;i<=4;i++) microstep_mode(i,microstep_modes[i]);
diff --git a/Marlin/thermistortables.h b/Marlin/thermistortables.h
index 07b385e..bda6976 100644
--- a/Marlin/thermistortables.h
+++ b/Marlin/thermistortables.h
@@ -621,6 +621,75 @@ const short temptable_11[][2] PROGMEM = {
 };
 #endif
 
+#if (THERMISTORHEATER_0 == 13) || (THERMISTORHEATER_1 == 13) || (THERMISTORHEATER_2 == 13) || (THERMISTORBED == 13)
+// Hisens thermistor B25/50 =3950 +/-1%
+
+const short temptable_12[][2] PROGMEM = {
+ {	22.5*OVERSAMPLENR,	300	},
+{	24.125*OVERSAMPLENR,	295	},
+{	25.875*OVERSAMPLENR,	290	},
+{	27.8125*OVERSAMPLENR,	285	},
+{	29.9375*OVERSAMPLENR,	280	},
+{	32.25*OVERSAMPLENR,	275	},
+{	34.8125*OVERSAMPLENR,	270	},
+{	37.625*OVERSAMPLENR,	265	},
+{	40.6875*OVERSAMPLENR,	260	},
+{	44.0625*OVERSAMPLENR,	255	},
+{	47.75*OVERSAMPLENR,	250	},
+{	51.8125*OVERSAMPLENR,	245	},
+{	56.3125*OVERSAMPLENR,	240	},
+{	61.25*OVERSAMPLENR,	235	},
+{	66.75*OVERSAMPLENR,	230	},
+{	72.8125*OVERSAMPLENR,	225	},
+{	79.5*OVERSAMPLENR,	220	},
+{	87*OVERSAMPLENR,	215	},
+{	95.3125*OVERSAMPLENR,	210	},
+{	104.1875*OVERSAMPLENR,	205	},
+{	112.75*OVERSAMPLENR,	200	},
+{	123.125*OVERSAMPLENR,	195	},
+{	135.75*OVERSAMPLENR,	190	},
+{	148.3125*OVERSAMPLENR,	185	},
+{	163.8125*OVERSAMPLENR,	180	},
+{	179*OVERSAMPLENR,	175	},
+{	211.125*OVERSAMPLENR,	170	},
+{	216.125*OVERSAMPLENR,	165	},
+{	236.5625*OVERSAMPLENR,	160	},
+{	258.5*OVERSAMPLENR,	155	},
+{	279.875*OVERSAMPLENR,	150	},
+{	305.375*OVERSAMPLENR,	145	},
+{	333.25*OVERSAMPLENR,	140	},
+{	362.5625*OVERSAMPLENR,	135	},
+{	393.6875*OVERSAMPLENR,	130	},
+{	425*OVERSAMPLENR,	125	},
+{	460.625*OVERSAMPLENR,	120	},
+{	495.1875*OVERSAMPLENR,	115	},
+{	530.875*OVERSAMPLENR,	110	},
+{	567.25*OVERSAMPLENR,	105	},
+{	601.625*OVERSAMPLENR,	100	},
+{	637.875*OVERSAMPLENR,	95	},
+{	674.5625*OVERSAMPLENR,	90	},
+{	710*OVERSAMPLENR,	85	},
+{	744.125*OVERSAMPLENR,	80	},
+{	775.9375*OVERSAMPLENR,	75	},
+{	806.875*OVERSAMPLENR,	70	},
+{	835.1875*OVERSAMPLENR,	65	},
+{	861.125*OVERSAMPLENR,	60	},
+{	884.375*OVERSAMPLENR,	55	},
+{	904.5625*OVERSAMPLENR,	50	},
+{	923.8125*OVERSAMPLENR,	45	},
+{	940.375*OVERSAMPLENR,	40	},
+{	954.625*OVERSAMPLENR,	35	},
+{	966.875*OVERSAMPLENR,	30	},
+{	977.0625*OVERSAMPLENR,	25	},
+{	986*OVERSAMPLENR,	20	},
+{	993.375*OVERSAMPLENR,	15	},
+{	999.5*OVERSAMPLENR,	10	},
+{	1004.5*OVERSAMPLENR,	5	},
+{	1008.5*OVERSAMPLENR,	0	}
+
+ };
+#endif
+
 #if (THERMISTORHEATER_0 == 20) || (THERMISTORHEATER_1 == 20) || (THERMISTORHEATER_2 == 20) || (THERMISTORBED == 20) // PT100 with INA826 amp on Ultimaker v2.0 electronics
 /* The PT100 in the Ultimaker v2.0 electronics has a high sample value for a high temperature.
 This does not match the normal thermistor behaviour so we need to set the following defines */
diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
index fb2ddbf..54d1b8b 100644
--- a/Marlin/ultralcd.cpp
+++ b/Marlin/ultralcd.cpp
@@ -307,6 +307,23 @@ static void lcd_autostart_sd()
 }
 #endif
 
+void lcd_set_home_offsets()
+{
+    for(int8_t i=0; i < NUM_AXIS; i++) {
+      if (i != E_AXIS) {
+        add_homeing[i] -= current_position[i];
+        current_position[i] = 0.0;
+      }
+    }
+    plan_set_position(0.0, 0.0, 0.0, current_position[E_AXIS]);
+
+    // Audio feedback
+    enquecommand_P(PSTR("M300 S659 P200"));
+    enquecommand_P(PSTR("M300 S698 P200"));
+    lcd_return_to_status();
+}
+
+
 #ifdef BABYSTEPPING
 static void lcd_babystep_x()
 {
@@ -374,7 +391,9 @@ static void lcd_tune_menu()
     START_MENU();
     MENU_ITEM(back, MSG_MAIN, lcd_main_menu);
     MENU_ITEM_EDIT(int3, MSG_SPEED, &feedmultiply, 10, 999);
+#if TEMP_SENSOR_0 != 0
     MENU_ITEM_EDIT(int3, MSG_NOZZLE, &target_temperature[0], 0, HEATER_0_MAXTEMP - 15);
+#endif
 #if TEMP_SENSOR_1 != 0
     MENU_ITEM_EDIT(int3, MSG_NOZZLE1, &target_temperature[1], 0, HEATER_1_MAXTEMP - 15);
 #endif
@@ -566,6 +585,7 @@ static void lcd_prepare_menu()
 #endif
     MENU_ITEM(gcode, MSG_DISABLE_STEPPERS, PSTR("M84"));
     MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
+    MENU_ITEM(function, MSG_SET_HOME_OFFSETS, lcd_set_home_offsets);
     //MENU_ITEM(gcode, MSG_SET_ORIGIN, PSTR("G92 X0 Y0 Z0"));
 #if TEMP_SENSOR_0 != 0
   #if TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_BED != 0
@@ -780,7 +800,9 @@ static void lcd_control_temperature_menu()
 
     START_MENU();
     MENU_ITEM(back, MSG_CONTROL, lcd_control_menu);
+#if TEMP_SENSOR_1 != 0
     MENU_ITEM_EDIT(int3, MSG_NOZZLE, &target_temperature[0], 0, HEATER_0_MAXTEMP - 15);
+#endif
 #if TEMP_SENSOR_1 != 0
     MENU_ITEM_EDIT(int3, MSG_NOZZLE1, &target_temperature[1], 0, HEATER_1_MAXTEMP - 15);
 #endif
@@ -791,7 +813,7 @@ static void lcd_control_temperature_menu()
     MENU_ITEM_EDIT(int3, MSG_BED, &target_temperature_bed, 0, BED_MAXTEMP - 15);
 #endif
     MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &fanSpeed, 0, 255);
-#ifdef AUTOTEMP
+#if defined AUTOTEMP && (TEMP_SENSOR_0 != 0)
     MENU_ITEM_EDIT(bool, MSG_AUTOTEMP, &autotemp_enabled);
     MENU_ITEM_EDIT(float3, MSG_MIN, &autotemp_min, 0, HEATER_0_MAXTEMP - 15);
     MENU_ITEM_EDIT(float3, MSG_MAX, &autotemp_max, 0, HEATER_0_MAXTEMP - 15);
@@ -816,7 +838,9 @@ static void lcd_control_temperature_preheat_pla_settings_menu()
     START_MENU();
     MENU_ITEM(back, MSG_TEMPERATURE, lcd_control_temperature_menu);
     MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &plaPreheatFanSpeed, 0, 255);
+#if TEMP_SENSOR_0 != 0
     MENU_ITEM_EDIT(int3, MSG_NOZZLE, &plaPreheatHotendTemp, 0, HEATER_0_MAXTEMP - 15);
+#endif
 #if TEMP_SENSOR_BED != 0
     MENU_ITEM_EDIT(int3, MSG_BED, &plaPreheatHPBTemp, 0, BED_MAXTEMP - 15);
 #endif
@@ -831,7 +855,9 @@ static void lcd_control_temperature_preheat_abs_settings_menu()
     START_MENU();
     MENU_ITEM(back, MSG_TEMPERATURE, lcd_control_temperature_menu);
     MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &absPreheatFanSpeed, 0, 255);
+#if TEMP_SENSOR_0 != 0
     MENU_ITEM_EDIT(int3, MSG_NOZZLE, &absPreheatHotendTemp, 0, HEATER_0_MAXTEMP - 15);
+#endif
 #if TEMP_SENSOR_BED != 0
     MENU_ITEM_EDIT(int3, MSG_BED, &absPreheatHPBTemp, 0, BED_MAXTEMP - 15);
 #endif
diff --git a/Marlin/ultralcd_implementation_hitachi_HD44780.h b/Marlin/ultralcd_implementation_hitachi_HD44780.h
index 11e0a95..befb25b 100644
--- a/Marlin/ultralcd_implementation_hitachi_HD44780.h
+++ b/Marlin/ultralcd_implementation_hitachi_HD44780.h
@@ -467,7 +467,7 @@ static void lcd_implementation_status_screen()
 # endif//LCD_WIDTH > 19
     lcd.setCursor(LCD_WIDTH - 8, 1);
     lcd.print('Z');
-    lcd.print(ftostr32(current_position[Z_AXIS]));
+    lcd.print(ftostr32(current_position[Z_AXIS] + 0.00001));
 #endif//LCD_HEIGHT > 2
 
 #if LCD_HEIGHT > 3
diff --git a/Marlin/vector_3.cpp b/Marlin/vector_3.cpp
index 82b6925..5f1c294 100644
--- a/Marlin/vector_3.cpp
+++ b/Marlin/vector_3.cpp
@@ -121,7 +121,7 @@ matrix_3x3 matrix_3x3::create_look_at(vector_3 target)
 {
     vector_3 z_row = target.get_normal();
     vector_3 x_row = vector_3(1, 0, -target.x/target.z).get_normal();
-    vector_3 y_row = vector_3(0, 1, -target.y/target.z).get_normal();
+    vector_3 y_row = vector_3::cross(z_row, x_row).get_normal();
 
    // x_row.debug("x_row");
    // y_row.debug("y_row");

