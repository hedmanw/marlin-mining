commit 32f8300cc68f182272f67e985f1a1893df4a30df (from 9c87bf835ce638b8406eeb328750f0ef7d0b64a2)
Merge: 9c87bf8 5390c84
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 3 17:08:41 2016 -0700

    Merge pull request #3944 from thinkyhead/rc_eboston_lcd_contrast
    
    Improved LCD contrast handling

diff --git a/Marlin/Conditionals.h b/Marlin/Conditionals.h
index 2e6e55e..7ec8fe5 100644
--- a/Marlin/Conditionals.h
+++ b/Marlin/Conditionals.h
@@ -61,10 +61,14 @@
     #define ULTIMAKERCONTROLLER //as available from the Ultimaker online store.
 
     #if ENABLED(miniVIKI)
+      #define LCD_CONTRAST_MIN  75
+      #define LCD_CONTRAST_MAX 115
       #define DEFAULT_LCD_CONTRAST 95
     #elif ENABLED(VIKI2)
       #define DEFAULT_LCD_CONTRAST 40
     #elif ENABLED(ELB_FULL_GRAPHIC_CONTROLLER)
+      #define LCD_CONTRAST_MIN  90
+      #define LCD_CONTRAST_MAX 130
       #define DEFAULT_LCD_CONTRAST 110
       #define U8GLIB_LM6059_AF
       #define SD_DETECT_INVERTED
@@ -245,9 +249,24 @@
    * Default LCD contrast for dogm-like LCD displays
    */
   #if ENABLED(DOGLCD)
-    #define HAS_LCD_CONTRAST (DISABLED(U8GLIB_ST7920) && DISABLED(U8GLIB_SSD1306) && DISABLED(U8GLIB_SH1106))
-    #if HAS_LCD_CONTRAST && !defined(DEFAULT_LCD_CONTRAST)
-      #define DEFAULT_LCD_CONTRAST 32
+
+    #define HAS_LCD_CONTRAST ( \
+        ENABLED(MAKRPANEL) \
+     || ENABLED(VIKI2) \
+     || ENABLED(miniVIKI) \
+     || ENABLED(ELB_FULL_GRAPHIC_CONTROLLER) \
+    )
+
+    #if HAS_LCD_CONTRAST
+      #ifndef LCD_CONTRAST_MIN
+        #define LCD_CONTRAST_MIN 0
+      #endif
+      #ifndef LCD_CONTRAST_MAX
+        #define LCD_CONTRAST_MAX 63
+      #endif
+      #ifndef DEFAULT_LCD_CONTRAST
+        #define DEFAULT_LCD_CONTRAST 32
+      #endif
     #endif
   #endif
 
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index af11c19..d109055 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -5655,7 +5655,7 @@ inline void gcode_M226() {
    * M250: Read and optionally set the LCD contrast
    */
   inline void gcode_M250() {
-    if (code_seen('C')) lcd_setcontrast(code_value_short() & 0x3F);
+    if (code_seen('C')) set_lcd_contrast(code_value_short());
     SERIAL_PROTOCOLPGM("lcd contrast value: ");
     SERIAL_PROTOCOL(lcd_contrast);
     SERIAL_EOL;
diff --git a/Marlin/SanityCheck.h b/Marlin/SanityCheck.h
index d2c53be..19edb75 100644
--- a/Marlin/SanityCheck.h
+++ b/Marlin/SanityCheck.h
@@ -367,7 +367,14 @@
 #endif
 
 #if ENCODER_PULSES_PER_STEP < 0
-  #error "ENCODER_PULSES_PER_STEP should not be negative, use REVERSE_MENU_DIRECTION instead"
+  #error "ENCODER_PULSES_PER_STEP should not be negative, use REVERSE_MENU_DIRECTION instead."
+#endif
+
+/**
+ * SAV_3DGLCD display options
+ */
+#if ENABLED(U8GLIB_SSD1306) && ENABLED(U8GLIB_SH1106)
+  #error "Only enable one SAV_3DGLCD display type: U8GLIB_SSD1306 or U8GLIB_SH1106."
 #endif
 
 /**
diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
index 1a0071d..94a1e3f 100644
--- a/Marlin/ultralcd.cpp
+++ b/Marlin/ultralcd.cpp
@@ -1720,23 +1720,18 @@ static void lcd_control_volumetric_menu() {
   static void lcd_set_contrast() {
     ENCODER_DIRECTION_NORMAL();
     if (encoderPosition) {
-      #if ENABLED(U8GLIB_LM6059_AF)
-        lcd_contrast += encoderPosition;
-        lcd_contrast &= 0xFF;
-      #else
-        lcd_contrast -= encoderPosition;
-        lcd_contrast &= 0x3F;
-      #endif
+      set_lcd_contrast(lcd_contrast + encoderPosition);
       encoderPosition = 0;
       lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
-      u8g.setContrast(lcd_contrast);
     }
     if (lcdDrawUpdate) {
-      #if ENABLED(U8GLIB_LM6059_AF)
-        lcd_implementation_drawedit(PSTR(MSG_CONTRAST), itostr3(lcd_contrast));
-      #else
-        lcd_implementation_drawedit(PSTR(MSG_CONTRAST), itostr2(lcd_contrast));
-      #endif
+      lcd_implementation_drawedit(PSTR(MSG_CONTRAST),
+        #if LCD_CONTRAST_MAX >= 100
+          itostr3(lcd_contrast)
+        #else
+          itostr2(lcd_contrast)
+        #endif
+      );
     }
     if (LCD_CLICKED) lcd_goto_previous_menu(true);
   }
@@ -2388,8 +2383,8 @@ void lcd_setalertstatuspgm(const char* message) {
 void lcd_reset_alert_level() { lcd_status_message_level = 0; }
 
 #if HAS_LCD_CONTRAST
-  void lcd_setcontrast(uint8_t value) {
-    lcd_contrast = value & 0x3F;
+  void set_lcd_contrast(int value) {
+    lcd_contrast = constrain(value, LCD_CONTRAST_MIN, LCD_CONTRAST_MAX);
     u8g.setContrast(lcd_contrast);
   }
 #endif
diff --git a/Marlin/ultralcd.h b/Marlin/ultralcd.h
index e20f5cc..b1e97bf 100644
--- a/Marlin/ultralcd.h
+++ b/Marlin/ultralcd.h
@@ -53,7 +53,7 @@
 
   #if ENABLED(DOGLCD)
     extern int lcd_contrast;
-    void lcd_setcontrast(uint8_t value);
+    void set_lcd_contrast(int value);
   #endif
 
   #define LCD_MESSAGEPGM(x) lcd_setstatuspgm(PSTR(x))

commit 32f8300cc68f182272f67e985f1a1893df4a30df (from 5390c846a545e05e37708100af14c1da893a9597)
Merge: 9c87bf8 5390c84
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 3 17:08:41 2016 -0700

    Merge pull request #3944 from thinkyhead/rc_eboston_lcd_contrast
    
    Improved LCD contrast handling

diff --git a/Marlin/Conditionals.h b/Marlin/Conditionals.h
index edaf371..7ec8fe5 100644
--- a/Marlin/Conditionals.h
+++ b/Marlin/Conditionals.h
@@ -751,7 +751,7 @@
       #define Z_ENDSTOP_SERVO_NR -1
     #endif
     #if X_ENDSTOP_SERVO_NR >= 0 || Y_ENDSTOP_SERVO_NR >= 0 || HAS_Z_ENDSTOP_SERVO
-      #define HAS_SERVO_ENDSTOPS true
+      #define HAS_SERVO_ENDSTOPS
       #define SERVO_ENDSTOP_IDS { X_ENDSTOP_SERVO_NR, Y_ENDSTOP_SERVO_NR, Z_ENDSTOP_SERVO_NR }
     #endif
   #endif
diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index b67d0a0..968fca6 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -440,6 +440,12 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // If you're using the Z MIN endstop connector for your Z probe, this has no effect.
 //#define DISABLE_Z_MIN_PROBE_ENDSTOP
 
+// Probe Raise options provide clearance for the probe to deploy and stow.
+// For G28 these apply when the probe deploys and stows.
+// For G29 these apply before and after the full procedure.
+#define Z_RAISE_BEFORE_PROBING 15   // Raise before probe deploy (e.g., the first probe).
+#define Z_RAISE_AFTER_PROBING 15    // Raise before probe stow (e.g., the last probe).
+
 // For Inverting Stepper Enable Pins (Active Low) use 0, Non Inverting (Active High) use 1
 // :{0:'Low',1:'High'}
 #define X_ENABLE_ON 0
@@ -585,7 +591,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
     #define ABL_PROBE_PT_3_X 170
     #define ABL_PROBE_PT_3_Y 20
 
-  #endif // AUTO_BED_LEVELING_GRID
+  #endif // !AUTO_BED_LEVELING_GRID
 
   // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
   // X and Y offsets must be integers.
@@ -610,9 +616,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 
   #define XY_TRAVEL_SPEED 8000         // X and Y axis travel speed between probes, in mm/min.
 
-  #define Z_RAISE_BEFORE_PROBING 15   // How much the Z axis will be raised before traveling to the first probing point.
   #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points.
-  #define Z_RAISE_AFTER_PROBING 15    // How much the Z axis will be raised after the last probing point.
 
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
diff --git a/Marlin/Marlin.h b/Marlin/Marlin.h
index d5bd54f..ab85ab5 100644
--- a/Marlin/Marlin.h
+++ b/Marlin/Marlin.h
@@ -227,6 +227,10 @@ void reset_bed_level();
 void prepare_move();
 void kill(const char*);
 
+#if DISABLED(DELTA) && DISABLED(SCARA)
+  void set_current_position_from_planner();
+#endif
+
 #if ENABLED(FILAMENT_RUNOUT_SENSOR)
   void handle_filament_runout();
 #endif
@@ -253,6 +257,7 @@ inline bool IsStopped() { return !Running; }
 bool enqueue_and_echo_command(const char* cmd, bool say_ok=false); //put a single ASCII command at the end of the current buffer or return false when it is full
 void enqueue_and_echo_command_now(const char* cmd); // enqueue now, only return when the command has been enqueued
 void enqueue_and_echo_commands_P(const char* cmd); //put one or many ASCII commands at the end of the current buffer, read from flash
+void clear_command_queue();
 
 void clamp_to_software_endstops(float target[3]);
 
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index c097030..d109055 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -372,7 +372,7 @@ static uint8_t target_extruder;
   };
 #endif
 
-#if HAS_SERVO_ENDSTOPS
+#if ENABLED(HAS_SERVO_ENDSTOPS)
   const int servo_endstop_id[] = SERVO_ENDSTOP_IDS;
   const int servo_endstop_angle[][2] = SERVO_ENDSTOP_ANGLES;
 #endif
@@ -552,7 +552,7 @@ static void report_current_position();
       if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position_delta", current_position);
     #endif
     calculate_delta(current_position);
-    planner.set_position(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS]);
+    planner.set_position_mm(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS]);
   }
 #endif
 
@@ -613,6 +613,11 @@ void enqueue_and_echo_commands_P(const char* pgcode) {
   drain_queued_commands_P(); // first command executed asap (when possible)
 }
 
+void clear_command_queue() {
+  cmd_queue_index_r = cmd_queue_index_w;
+  commands_in_queue = 0;
+}
+
 /**
  * Once a new command is in the ring buffer, call this to commit it
  */
@@ -719,7 +724,7 @@ void servo_init() {
     servo[3].detach();
   #endif
 
-   #if HAS_SERVO_ENDSTOPS
+   #if ENABLED(HAS_SERVO_ENDSTOPS)
 
     endstops.enable_z_probe(false);
 
@@ -1448,9 +1453,9 @@ inline void sync_plan_position() {
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position", current_position);
   #endif
-  planner.set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+  planner.set_position_mm(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
 }
-inline void sync_plan_position_e() { planner.set_e_position(current_position[E_AXIS]); }
+inline void sync_plan_position_e() { planner.set_e_position_mm(current_position[E_AXIS]); }
 inline void set_current_to_destination() { memcpy(current_position, destination, sizeof(current_position)); }
 inline void set_destination_to_current() { memcpy(destination, current_position, sizeof(destination)); }
 
@@ -1607,7 +1612,7 @@ static void setup_for_endstop_move() {
 
       // Tell the planner where we ended up - Get this from the stepper handler
       zPosition = stepper.get_axis_position_mm(Z_AXIS);
-      planner.set_position(
+      planner.set_position_mm(
         current_position[X_AXIS], current_position[Y_AXIS], zPosition,
         current_position[E_AXIS]
       );
@@ -1696,7 +1701,12 @@ static void setup_for_endstop_move() {
   }
 
   inline void raise_z_after_probing() {
-    do_blocking_move_to_z(current_position[Z_AXIS] + Z_RAISE_AFTER_PROBING);
+    #if Z_RAISE_AFTER_PROBING > 0
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("raise_z_after_probing()");
+      #endif
+      do_blocking_move_to_z(current_position[Z_AXIS] + Z_RAISE_AFTER_PROBING);
+    #endif
   }
 
   static void clean_up_after_endstop_move() {
@@ -1719,7 +1729,7 @@ static void setup_for_endstop_move() {
 
     if (endstops.z_probe_enabled) return;
 
-    #if HAS_SERVO_ENDSTOPS
+    #if ENABLED(HAS_SERVO_ENDSTOPS)
 
       // Engage Z Servo endstop if enabled
       if (servo_endstop_id[Z_AXIS] >= 0) servo[servo_endstop_id[Z_AXIS]].move(servo_endstop_angle[Z_AXIS][0]);
@@ -1806,7 +1816,7 @@ static void setup_for_endstop_move() {
   }
 
   static void stow_z_probe(bool doRaise = true) {
-    #if !(HAS_SERVO_ENDSTOPS && (Z_RAISE_AFTER_PROBING > 0))
+    #if !(ENABLED(HAS_SERVO_ENDSTOPS) && (Z_RAISE_AFTER_PROBING > 0))
       UNUSED(doRaise);
     #endif
     #if ENABLED(DEBUG_LEVELING_FEATURE)
@@ -1815,21 +1825,13 @@ static void setup_for_endstop_move() {
 
     if (!endstops.z_probe_enabled) return;
 
-    #if HAS_SERVO_ENDSTOPS
+    #if ENABLED(HAS_SERVO_ENDSTOPS)
 
       // Retract Z Servo endstop if enabled
       if (servo_endstop_id[Z_AXIS] >= 0) {
 
         #if Z_RAISE_AFTER_PROBING > 0
           if (doRaise) {
-            #if ENABLED(DEBUG_LEVELING_FEATURE)
-              if (DEBUGGING(LEVELING)) {
-                SERIAL_ECHOPAIR("Raise Z (after) by ", Z_RAISE_AFTER_PROBING);
-                SERIAL_EOL;
-                SERIAL_ECHO("> SERVO_ENDSTOPS > raise_z_after_probing()");
-                SERIAL_EOL;
-              }
-            #endif
             raise_z_after_probing(); // this also updates current_position
             stepper.synchronize();
           }
@@ -2057,7 +2059,7 @@ static void setup_for_endstop_move() {
 
   #endif // DELTA
 
-  #if HAS_SERVO_ENDSTOPS && DISABLED(Z_PROBE_SLED)
+  #if ENABLED(HAS_SERVO_ENDSTOPS) && DISABLED(Z_PROBE_SLED)
 
     void raise_z_for_servo() {
       float zpos = current_position[Z_AXIS], z_dest = Z_RAISE_BEFORE_PROBING;
@@ -2117,9 +2119,7 @@ static void setup_for_endstop_move() {
 
     float oldXpos = current_position[X_AXIS]; // save x position
     if (dock) {
-      #if Z_RAISE_AFTER_PROBING > 0
-        raise_z_after_probing(); // raise Z
-      #endif
+      raise_z_after_probing(); // raise Z
       // Dock sled a bit closer to ensure proper capturing
       do_blocking_move_to_x(X_MAX_POS + SLED_DOCKING_OFFSET + offset - 1);
       digitalWrite(SLED_PIN, LOW); // turn off magnet
@@ -2168,33 +2168,36 @@ static void homeaxis(AxisEnum axis) {
     sync_plan_position();
 
     #if ENABLED(Z_PROBE_SLED)
-      #define _Z_SERVO_TEST       (axis != Z_AXIS)      // deploy Z, servo.move XY
-      #define _Z_PROBE_SUBTEST    false                 // Z will never be invoked
+      #define _Z_SERVO_TEST       (axis != Z_AXIS)      // already deployed Z
+      #define _Z_SERVO_SUBTEST    false                 // Z will never be invoked
       #define _Z_DEPLOY           (dock_sled(false))
       #define _Z_STOW             (dock_sled(true))
     #elif SERVO_LEVELING || ENABLED(FIX_MOUNTED_PROBE)
-      #define _Z_SERVO_TEST       (axis != Z_AXIS)      // servo.move XY
-      #define _Z_PROBE_SUBTEST    false                 // Z will never be invoked
+      #define _Z_SERVO_TEST       (axis != Z_AXIS)      // already deployed Z
+      #define _Z_SERVO_SUBTEST    false                 // Z will never be invoked
       #define _Z_DEPLOY           (deploy_z_probe())
       #define _Z_STOW             (stow_z_probe())
-    #elif HAS_SERVO_ENDSTOPS
-      #define _Z_SERVO_TEST       true                  // servo.move X, Y, Z
-      #define _Z_PROBE_SUBTEST    (axis == Z_AXIS)      // Z is a probe
+    #elif ENABLED(HAS_SERVO_ENDSTOPS)
+      #define _Z_SERVO_TEST       true                  // Z not deployed yet
+      #define _Z_SERVO_SUBTEST    (axis == Z_AXIS)      // Z is a probe
     #endif
 
-    if (axis == Z_AXIS) {
-      // If there's a Z probe that needs deployment...
-      #if ENABLED(Z_PROBE_SLED) || SERVO_LEVELING || ENABLED(FIX_MOUNTED_PROBE)
-        // ...and homing Z towards the bed? Deploy it.
-        if (axis_home_dir < 0) _Z_DEPLOY;
-      #endif
-    }
+    // If there's a Z probe that needs deployment...
+    #if ENABLED(Z_PROBE_SLED) || SERVO_LEVELING || ENABLED(FIX_MOUNTED_PROBE)
+      // ...and homing Z towards the bed? Deploy it.
+      if (axis == Z_AXIS && axis_home_dir < 0) {
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> SERVO_LEVELING > " STRINGIFY(_Z_DEPLOY));
+        #endif
+        _Z_DEPLOY;
+      }
+    #endif
 
-    #if HAS_SERVO_ENDSTOPS
-      // Engage an X or Y Servo endstop if enabled
+    #if ENABLED(HAS_SERVO_ENDSTOPS)
+      // Engage an X, Y (or Z) Servo endstop if enabled
       if (_Z_SERVO_TEST && servo_endstop_id[axis] >= 0) {
         servo[servo_endstop_id[axis]].move(servo_endstop_angle[axis][0]);
-        if (_Z_PROBE_SUBTEST) endstops.z_probe_enabled = true;
+        if (_Z_SERVO_SUBTEST) endstops.z_probe_enabled = true;
       }
     #endif
 
@@ -2311,7 +2314,7 @@ static void homeaxis(AxisEnum axis) {
     axis_known_position[axis] = true;
     axis_homed[axis] = true;
 
-    // Put away the Z probe
+    // Put away the Z probe with a function
     #if ENABLED(Z_PROBE_SLED) || SERVO_LEVELING || ENABLED(FIX_MOUNTED_PROBE)
       if (axis == Z_AXIS && axis_home_dir < 0) {
         #if ENABLED(DEBUG_LEVELING_FEATURE)
@@ -2321,16 +2324,32 @@ static void homeaxis(AxisEnum axis) {
       }
     #endif
 
-    // Retract Servo endstop if enabled
-    #if HAS_SERVO_ENDSTOPS
+    // Retract X, Y (or Z) Servo endstop if enabled
+    #if ENABLED(HAS_SERVO_ENDSTOPS)
       if (_Z_SERVO_TEST && servo_endstop_id[axis] >= 0) {
+        // Raise the servo probe before stow outside ABL context.
+        // This is a workaround to allow use of a Servo Probe without
+        // ABL until more global probe handling is implemented.
+        #if Z_RAISE_AFTER_PROBING > 0
+          if (axis == Z_AXIS) {
+            #if ENABLED(DEBUG_LEVELING_FEATURE)
+              if (DEBUGGING(LEVELING)) SERIAL_ECHOPAIR("Raise Z (after) by ", Z_RAISE_AFTER_PROBING);
+            #endif
+            current_position[Z_AXIS] = Z_RAISE_AFTER_PROBING;
+            feedrate = homing_feedrate[Z_AXIS];
+            line_to_current_position();
+            stepper.synchronize();
+          }
+        #endif
+
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> SERVO_ENDSTOPS > Stow with servo.move()");
         #endif
         servo[servo_endstop_id[axis]].move(servo_endstop_angle[axis][1]);
-        if (_Z_PROBE_SUBTEST) endstops.enable_z_probe(false);
+        if (_Z_SERVO_SUBTEST) endstops.enable_z_probe(false);
       }
-    #endif
+
+    #endif // HAS_SERVO_ENDSTOPS
 
   }
 
@@ -3559,7 +3578,7 @@ inline void gcode_G28() {
       // Allen Key Probe for Delta
       #if ENABLED(Z_PROBE_ALLEN_KEY) || SERVO_LEVELING
         stow_z_probe();
-      #elif Z_RAISE_AFTER_PROBING > 0
+      #else
         raise_z_after_probing(); // for non Allen Key probes, such as simple mechanical probe
       #endif
     #else // !DELTA
@@ -3593,7 +3612,7 @@ inline void gcode_G28() {
          * Get the current Z position and send it to the planner.
          *
          * >> (z_tmp - real_z) : The rotated current Z minus the uncorrected Z
-         * (most recent planner.set_position/sync_plan_position)
+         * (most recent planner.set_position_mm/sync_plan_position)
          *
          * >> zprobe_zoffset : Z distance from nozzle to Z probe
          * (set by default, M851, EEPROM, or Menu)
@@ -3619,7 +3638,7 @@ inline void gcode_G28() {
         #endif
 
         current_position[Z_AXIS] = -zprobe_zoffset + (z_tmp - real_z)
-          #if HAS_SERVO_ENDSTOPS || ENABLED(Z_PROBE_ALLEN_KEY) || ENABLED(Z_PROBE_SLED)
+          #if ENABLED(HAS_SERVO_ENDSTOPS) || ENABLED(Z_PROBE_ALLEN_KEY) || ENABLED(Z_PROBE_SLED)
              + Z_RAISE_AFTER_PROBING
           #endif
           ;
@@ -3634,9 +3653,9 @@ inline void gcode_G28() {
       // Sled assembly for Cartesian bots
       #if ENABLED(Z_PROBE_SLED)
         dock_sled(true); // dock the sled
-      #elif Z_RAISE_AFTER_PROBING > 0
+      #else
         // Raise Z axis for non-delta and non servo based probes
-        #if !defined(HAS_SERVO_ENDSTOPS) && DISABLED(Z_PROBE_ALLEN_KEY) && DISABLED(Z_PROBE_SLED)
+        #if DISABLED(HAS_SERVO_ENDSTOPS) && DISABLED(Z_PROBE_ALLEN_KEY) && DISABLED(Z_PROBE_SLED)
           raise_z_after_probing();
         #endif
       #endif
@@ -3680,7 +3699,7 @@ inline void gcode_G28() {
      * G30: Do a single Z probe at the current XY
      */
     inline void gcode_G30() {
-      #if HAS_SERVO_ENDSTOPS
+      #if ENABLED(HAS_SERVO_ENDSTOPS)
         raise_z_for_servo();
       #endif
       deploy_z_probe(); // Engage Z Servo endstop if available. Z_PROBE_SLED is missed here.
@@ -3702,7 +3721,7 @@ inline void gcode_G28() {
 
       clean_up_after_endstop_move(); // Too early. must be done after the stowing.
 
-      #if HAS_SERVO_ENDSTOPS
+      #if ENABLED(HAS_SERVO_ENDSTOPS)
         raise_z_for_servo();
       #endif
       stow_z_probe(false); // Retract Z Servo endstop if available. Z_PROBE_SLED is missed here.
@@ -5811,13 +5830,13 @@ inline void gcode_M303() {
  */
 inline void gcode_M400() { stepper.synchronize(); }
 
-#if ENABLED(AUTO_BED_LEVELING_FEATURE) && DISABLED(Z_PROBE_SLED) && (HAS_SERVO_ENDSTOPS || ENABLED(Z_PROBE_ALLEN_KEY))
+#if ENABLED(AUTO_BED_LEVELING_FEATURE) && DISABLED(Z_PROBE_SLED) && (ENABLED(HAS_SERVO_ENDSTOPS) || ENABLED(Z_PROBE_ALLEN_KEY))
 
   /**
    * M401: Engage Z Servo endstop if available
    */
   inline void gcode_M401() {
-    #if HAS_SERVO_ENDSTOPS
+    #if ENABLED(HAS_SERVO_ENDSTOPS)
       raise_z_for_servo();
     #endif
     deploy_z_probe();
@@ -5827,13 +5846,13 @@ inline void gcode_M400() { stepper.synchronize(); }
    * M402: Retract Z Servo endstop if enabled
    */
   inline void gcode_M402() {
-    #if HAS_SERVO_ENDSTOPS
+    #if ENABLED(HAS_SERVO_ENDSTOPS)
       raise_z_for_servo();
     #endif
     stow_z_probe(false);
   }
 
-#endif // AUTO_BED_LEVELING_FEATURE && (HAS_SERVO_ENDSTOPS || Z_PROBE_ALLEN_KEY) && !Z_PROBE_SLED
+#endif // AUTO_BED_LEVELING_FEATURE && (ENABLED(HAS_SERVO_ENDSTOPS) || Z_PROBE_ALLEN_KEY) && !Z_PROBE_SLED
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
 
@@ -5889,13 +5908,35 @@ inline void gcode_M400() { stepper.synchronize(); }
 
 #endif // FILAMENT_WIDTH_SENSOR
 
+#if DISABLED(DELTA) && DISABLED(SCARA)
+  void set_current_position_from_planner() {
+    stepper.synchronize();
+    #if ENABLED(AUTO_BED_LEVELING_FEATURE)
+      vector_3 pos = planner.adjusted_position(); // values directly from steppers...
+      current_position[X_AXIS] = pos.x;
+      current_position[Y_AXIS] = pos.y;
+      current_position[Z_AXIS] = pos.z;
+    #else
+      current_position[X_AXIS] = stepper.get_axis_position_mm(X_AXIS);
+      current_position[Y_AXIS] = stepper.get_axis_position_mm(Y_AXIS);
+      current_position[Z_AXIS] = stepper.get_axis_position_mm(Z_AXIS);
+    #endif
+    sync_plan_position();                       // ...re-apply to planner position
+  }
+#endif
+
 /**
  * M410: Quickstop - Abort all planned moves
  *
  * This will stop the carriages mid-move, so most likely they
  * will be out of sync with the stepper position after this.
  */
-inline void gcode_M410() { stepper.quick_stop(); }
+inline void gcode_M410() {
+  stepper.quick_stop();
+  #if DISABLED(DELTA) && DISABLED(SCARA)
+    set_current_position_from_planner();
+  #endif
+}
 
 
 #if ENABLED(MESH_BED_LEVELING)
@@ -5978,7 +6019,11 @@ inline void gcode_M428() {
   }
 
   if (!err) {
-    sync_plan_position();
+    #if ENABLED(DELTA) && ENABLED(SCARA)
+      sync_plan_position_delta();
+    #else
+      sync_plan_position();
+    #endif
     report_current_position();
     LCD_MESSAGEPGM(MSG_HOME_OFFSETS_APPLIED);
     #if HAS_BUZZER
@@ -7027,14 +7072,14 @@ void process_next_command() {
         gcode_M400();
         break;
 
-      #if ENABLED(AUTO_BED_LEVELING_FEATURE) && (HAS_SERVO_ENDSTOPS || ENABLED(Z_PROBE_ALLEN_KEY)) && DISABLED(Z_PROBE_SLED)
+      #if ENABLED(AUTO_BED_LEVELING_FEATURE) && (ENABLED(HAS_SERVO_ENDSTOPS) || ENABLED(Z_PROBE_ALLEN_KEY)) && DISABLED(Z_PROBE_SLED)
         case 401:
           gcode_M401();
           break;
         case 402:
           gcode_M402();
           break;
-      #endif // AUTO_BED_LEVELING_FEATURE && (HAS_SERVO_ENDSTOPS || Z_PROBE_ALLEN_KEY) && !Z_PROBE_SLED
+      #endif // AUTO_BED_LEVELING_FEATURE && (ENABLED(HAS_SERVO_ENDSTOPS) || Z_PROBE_ALLEN_KEY) && !Z_PROBE_SLED
 
       #if ENABLED(FILAMENT_WIDTH_SENSOR)
         case 404:  //M404 Enter the nominal filament width (3mm, 1.75mm ) N<3.0> or display nominal filament width
@@ -7436,7 +7481,7 @@ void mesh_buffer_line(float x, float y, float z, const float e, float feed_rate,
     if (active_extruder_parked) {
       if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && active_extruder == 0) {
         // move duplicate extruder into correct duplication position.
-        planner.set_position(inactive_extruder_x_pos, current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+        planner.set_position_mm(inactive_extruder_x_pos, current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
         planner.buffer_line(current_position[X_AXIS] + duplicate_extruder_x_offset,
                          current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], planner.max_feedrate[X_AXIS], 1);
         sync_plan_position();
@@ -7989,7 +8034,7 @@ void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
                          (EXTRUDER_RUNOUT_SPEED) / 60. * (EXTRUDER_RUNOUT_ESTEPS) / planner.axis_steps_per_unit[E_AXIS], active_extruder);
       current_position[E_AXIS] = oldepos;
       destination[E_AXIS] = oldedes;
-      planner.set_e_position(oldepos);
+      planner.set_e_position_mm(oldepos);
       previous_cmd_ms = ms; // refresh_cmd_timeout()
       stepper.synchronize();
       switch (active_extruder) {
diff --git a/Marlin/SanityCheck.h b/Marlin/SanityCheck.h
index f92961a..19edb75 100644
--- a/Marlin/SanityCheck.h
+++ b/Marlin/SanityCheck.h
@@ -174,7 +174,7 @@
 /**
  * Servo deactivation depends on servo endstops
  */
-#if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE) && !HAS_SERVO_ENDSTOPS
+#if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE) && DISABLED(HAS_SERVO_ENDSTOPS)
   #error "At least one of the ?_ENDSTOP_SERVO_NR is required for DEACTIVATE_SERVOS_AFTER_MOVE."
 #endif
 
diff --git a/Marlin/dogm_lcd_implementation.h b/Marlin/dogm_lcd_implementation.h
index b0cd312..fda1f53 100644
--- a/Marlin/dogm_lcd_implementation.h
+++ b/Marlin/dogm_lcd_implementation.h
@@ -139,15 +139,12 @@
 #if ENABLED(U8GLIB_ST7920)
   //U8GLIB_ST7920_128X64_RRD u8g(0,0,0);
   U8GLIB_ST7920_128X64_RRD u8g(0);
-#elif ENABLED(MAKRPANEL)
-  // The MaKrPanel display, ST7565 controller as well
-  U8GLIB_NHD_C12864 u8g(DOGLCD_CS, DOGLCD_A0);
-#elif ENABLED(VIKI2) || ENABLED(miniVIKI)
-  // Mini Viki and Viki 2.0 LCD, ST7565 controller as well
-  U8GLIB_NHD_C12864 u8g(DOGLCD_CS, DOGLCD_A0);
 #elif ENABLED(U8GLIB_LM6059_AF)
   // Based on the Adafruit ST7565 (http://www.adafruit.com/products/250)
   U8GLIB_LM6059 u8g(DOGLCD_CS, DOGLCD_A0);
+#elif ENABLED(MAKRPANEL) || ENABLED(VIKI2) || ENABLED(miniVIKI)
+  // The MaKrPanel, Mini Viki, and Viki 2.0, ST7565 controller as well
+  U8GLIB_NHD_C12864 u8g(DOGLCD_CS, DOGLCD_A0);
 #elif ENABLED(U8GLIB_SSD1306)
   // Generic support for SSD1306 OLED I2C LCDs
   U8GLIB_SSD1306_128X64 u8g(U8G_I2C_OPT_NONE | U8G_I2C_OPT_FAST);
diff --git a/Marlin/endstops.cpp b/Marlin/endstops.cpp
index f5dea69..945b615 100644
--- a/Marlin/endstops.cpp
+++ b/Marlin/endstops.cpp
@@ -187,6 +187,9 @@ void Endstops::report_state() {
         card.sdprinting = false;
         card.closefile();
         stepper.quick_stop();
+        #if DISABLED(DELTA) && DISABLED(SCARA)
+          set_current_position_from_planner();
+        #endif
         thermalManager.disable_all_heaters(); // switch off all heaters.
       }
     #endif
diff --git a/Marlin/example_configurations/Felix/Configuration.h b/Marlin/example_configurations/Felix/Configuration.h
index 39e5ce4..55b8061 100644
--- a/Marlin/example_configurations/Felix/Configuration.h
+++ b/Marlin/example_configurations/Felix/Configuration.h
@@ -422,6 +422,12 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // If you're using the Z MIN endstop connector for your Z probe, this has no effect.
 //#define DISABLE_Z_MIN_PROBE_ENDSTOP
 
+// Probe Raise options provide clearance for the probe to deploy and stow.
+// For G28 these apply when the probe deploys and stows.
+// For G29 these apply before and after the full procedure.
+#define Z_RAISE_BEFORE_PROBING 15   // Raise before probe deploy (e.g., the first probe).
+#define Z_RAISE_AFTER_PROBING 15    // Raise before probe stow (e.g., the last probe).
+
 // For Inverting Stepper Enable Pins (Active Low) use 0, Non Inverting (Active High) use 1
 // :{0:'Low',1:'High'}
 #define X_ENABLE_ON 0
@@ -567,7 +573,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
     #define ABL_PROBE_PT_3_X 170
     #define ABL_PROBE_PT_3_Y 20
 
-  #endif // AUTO_BED_LEVELING_GRID
+  #endif // !AUTO_BED_LEVELING_GRID
 
   // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
   // X and Y offsets must be integers.
@@ -592,9 +598,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 
   #define XY_TRAVEL_SPEED 8000         // X and Y axis travel speed between probes, in mm/min.
 
-  #define Z_RAISE_BEFORE_PROBING 15   // How much the Z axis will be raised before traveling to the first probing point.
   #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points.
-  #define Z_RAISE_AFTER_PROBING 15    // How much the Z axis will be raised after the last probing point.
 
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
diff --git a/Marlin/example_configurations/Felix/DUAL/Configuration.h b/Marlin/example_configurations/Felix/DUAL/Configuration.h
index 107f838..cebc679 100644
--- a/Marlin/example_configurations/Felix/DUAL/Configuration.h
+++ b/Marlin/example_configurations/Felix/DUAL/Configuration.h
@@ -420,6 +420,12 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // If you're using the Z MIN endstop connector for your Z probe, this has no effect.
 //#define DISABLE_Z_MIN_PROBE_ENDSTOP
 
+// Probe Raise options provide clearance for the probe to deploy and stow.
+// For G28 these apply when the probe deploys and stows.
+// For G29 these apply before and after the full procedure.
+#define Z_RAISE_BEFORE_PROBING 15   // Raise before probe deploy (e.g., the first probe).
+#define Z_RAISE_AFTER_PROBING 15    // Raise before probe stow (e.g., the last probe).
+
 // For Inverting Stepper Enable Pins (Active Low) use 0, Non Inverting (Active High) use 1
 // :{0:'Low',1:'High'}
 #define X_ENABLE_ON 0
@@ -565,7 +571,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
     #define ABL_PROBE_PT_3_X 170
     #define ABL_PROBE_PT_3_Y 20
 
-  #endif // AUTO_BED_LEVELING_GRID
+  #endif // !AUTO_BED_LEVELING_GRID
 
   // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
   // X and Y offsets must be integers.
@@ -590,9 +596,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 
   #define XY_TRAVEL_SPEED 8000         // X and Y axis travel speed between probes, in mm/min.
 
-  #define Z_RAISE_BEFORE_PROBING 15   // How much the Z axis will be raised before traveling to the first probing point.
   #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points.
-  #define Z_RAISE_AFTER_PROBING 15    // How much the Z axis will be raised after the last probing point.
 
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
diff --git a/Marlin/example_configurations/Hephestos/Configuration.h b/Marlin/example_configurations/Hephestos/Configuration.h
index 5b41fb3..e2dd327 100644
--- a/Marlin/example_configurations/Hephestos/Configuration.h
+++ b/Marlin/example_configurations/Hephestos/Configuration.h
@@ -432,6 +432,12 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 // If you're using the Z MIN endstop connector for your Z probe, this has no effect.
 //#define DISABLE_Z_MIN_PROBE_ENDSTOP
 
+// Probe Raise options provide clearance for the probe to deploy and stow.
+// For G28 these apply when the probe deploys and stows.
+// For G29 these apply before and after the full procedure.
+#define Z_RAISE_BEFORE_PROBING 15   // Raise before probe deploy (e.g., the first probe).
+#define Z_RAISE_AFTER_PROBING 15    // Raise before probe stow (e.g., the last probe).
+
 // For Inverting Stepper Enable Pins (Active Low) use 0, Non Inverting (Active High) use 1
 // :{0:'Low',1:'High'}
 #define X_ENABLE_ON 0
@@ -577,7 +583,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
     #define ABL_PROBE_PT_3_X 170
     #define ABL_PROBE_PT_3_Y 20
 
-  #endif // AUTO_BED_LEVELING_GRID
+  #endif // !AUTO_BED_LEVELING_GRID
 
   // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
   // X and Y offsets must be integers.
@@ -602,9 +608,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 
   #define XY_TRAVEL_SPEED 8000         // X and Y axis travel speed between probes, in mm/min.
 
-  #define Z_RAISE_BEFORE_PROBING 15   // How much the Z axis will be raised before traveling to the first probing point.
   #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points.
-  #define Z_RAISE_AFTER_PROBING 15    // How much the Z axis will be raised after the last probing point.
 
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
diff --git a/Marlin/example_configurations/Hephestos_2/Configuration.h b/Marlin/example_configurations/Hephestos_2/Configuration.h
index 3f6f4b6..1ea120a 100644
--- a/Marlin/example_configurations/Hephestos_2/Configuration.h
+++ b/Marlin/example_configurations/Hephestos_2/Configuration.h
@@ -434,6 +434,12 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // If you're using the Z MIN endstop connector for your Z probe, this has no effect.
 //#define DISABLE_Z_MIN_PROBE_ENDSTOP
 
+// Probe Raise options provide clearance for the probe to deploy and stow.
+// For G28 these apply when the probe deploys and stows.
+// For G29 these apply before and after the full procedure.
+#define Z_RAISE_BEFORE_PROBING 5    // Raise before probe deploy (e.g., the first probe).
+#define Z_RAISE_AFTER_PROBING 5     // Raise before probe stow (e.g., the last probe).
+
 // For Inverting Stepper Enable Pins (Active Low) use 0, Non Inverting (Active High) use 1
 // :{0:'Low',1:'High'}
 #define X_ENABLE_ON 0
@@ -579,7 +585,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
     #define ABL_PROBE_PT_3_X ((X_MIN_POS + X_MAX_POS) / 2)
     #define ABL_PROBE_PT_3_Y Y_MAX_POS - (Y_PROBE_OFFSET_FROM_EXTRUDER)
 
-  #endif // AUTO_BED_LEVELING_GRID
+  #endif // !AUTO_BED_LEVELING_GRID
 
   // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
   // X and Y offsets must be integers.
@@ -604,9 +610,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 
   #define XY_TRAVEL_SPEED 8000         // X and Y axis travel speed between probes, in mm/min.
 
-  #define Z_RAISE_BEFORE_PROBING   5  // How much the Z axis will be raised before traveling to the first probing point.
   #define Z_RAISE_BETWEEN_PROBINGS 2  // How much the Z axis will be raised when traveling from between next probing points.
-  #define Z_RAISE_AFTER_PROBING    5  // How much the Z axis will be raised after the last probing point.
 
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
diff --git a/Marlin/example_configurations/K8200/Configuration.h b/Marlin/example_configurations/K8200/Configuration.h
index 4b74fe5..ada2698 100644
--- a/Marlin/example_configurations/K8200/Configuration.h
+++ b/Marlin/example_configurations/K8200/Configuration.h
@@ -457,6 +457,12 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // If you're using the Z MIN endstop connector for your Z probe, this has no effect.
 //#define DISABLE_Z_MIN_PROBE_ENDSTOP
 
+// Probe Raise options provide clearance for the probe to deploy and stow.
+// For G28 these apply when the probe deploys and stows.
+// For G29 these apply before and after the full procedure.
+#define Z_RAISE_BEFORE_PROBING 15   // Raise before probe deploy (e.g., the first probe).
+#define Z_RAISE_AFTER_PROBING 15    // Raise before probe stow (e.g., the last probe).
+
 // For Inverting Stepper Enable Pins (Active Low) use 0, Non Inverting (Active High) use 1
 // :{0:'Low',1:'High'}
 #define X_ENABLE_ON 0
@@ -602,7 +608,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
     #define ABL_PROBE_PT_3_X 170
     #define ABL_PROBE_PT_3_Y 20
 
-  #endif // AUTO_BED_LEVELING_GRID
+  #endif // !AUTO_BED_LEVELING_GRID
 
   // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
   // X and Y offsets must be integers.
@@ -627,9 +633,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 
   #define XY_TRAVEL_SPEED 8000         // X and Y axis travel speed between probes, in mm/min.
 
-  #define Z_RAISE_BEFORE_PROBING 15   // How much the Z axis will be raised before traveling to the first probing point.
   #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points.
-  #define Z_RAISE_AFTER_PROBING 15    // How much the Z axis will be raised after the last probing point.
 
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
diff --git a/Marlin/example_configurations/RepRapWorld/Megatronics/Configuration.h b/Marlin/example_configurations/RepRapWorld/Megatronics/Configuration.h
index d9c8b9b..3df2b7b 100644
--- a/Marlin/example_configurations/RepRapWorld/Megatronics/Configuration.h
+++ b/Marlin/example_configurations/RepRapWorld/Megatronics/Configuration.h
@@ -440,6 +440,12 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // If you're using the Z MIN endstop connector for your Z probe, this has no effect.
 //#define DISABLE_Z_MIN_PROBE_ENDSTOP
 
+// Probe Raise options provide clearance for the probe to deploy and stow.
+// For G28 these apply when the probe deploys and stows.
+// For G29 these apply before and after the full procedure.
+#define Z_RAISE_BEFORE_PROBING 15   // Raise before probe deploy (e.g., the first probe).
+#define Z_RAISE_AFTER_PROBING 15    // Raise before probe stow (e.g., the last probe).
+
 // For Inverting Stepper Enable Pins (Active Low) use 0, Non Inverting (Active High) use 1
 // :{0:'Low',1:'High'}
 #define X_ENABLE_ON 0
@@ -585,7 +591,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
     #define ABL_PROBE_PT_3_X 170
     #define ABL_PROBE_PT_3_Y 20
 
-  #endif // AUTO_BED_LEVELING_GRID
+  #endif // !AUTO_BED_LEVELING_GRID
 
   // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
   // X and Y offsets must be integers.
@@ -610,9 +616,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 
   #define XY_TRAVEL_SPEED 8000         // X and Y axis travel speed between probes, in mm/min.
 
-  #define Z_RAISE_BEFORE_PROBING 15   // How much the Z axis will be raised before traveling to the first probing point.
   #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points.
-  #define Z_RAISE_AFTER_PROBING 15    // How much the Z axis will be raised after the last probing point.
 
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
diff --git a/Marlin/example_configurations/RigidBot/Configuration.h b/Marlin/example_configurations/RigidBot/Configuration.h
index 967927d..d153fa9 100644
--- a/Marlin/example_configurations/RigidBot/Configuration.h
+++ b/Marlin/example_configurations/RigidBot/Configuration.h
@@ -434,6 +434,12 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // If you're using the Z MIN endstop connector for your Z probe, this has no effect.
 //#define DISABLE_Z_MIN_PROBE_ENDSTOP
 
+// Probe Raise options provide clearance for the probe to deploy and stow.
+// For G28 these apply when the probe deploys and stows.
+// For G29 these apply before and after the full procedure.
+#define Z_RAISE_BEFORE_PROBING 15   // Raise before probe deploy (e.g., the first probe).
+#define Z_RAISE_AFTER_PROBING 15    // Raise before probe stow (e.g., the last probe).
+
 // For Inverting Stepper Enable Pins (Active Low) use 0, Non Inverting (Active High) use 1
 // :{0:'Low',1:'High'}
 #define X_ENABLE_ON 0
@@ -579,7 +585,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
     #define ABL_PROBE_PT_3_X 170
     #define ABL_PROBE_PT_3_Y 20
 
-  #endif // AUTO_BED_LEVELING_GRID
+  #endif // !AUTO_BED_LEVELING_GRID
 
   // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
   // X and Y offsets must be integers.
@@ -604,9 +610,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 
   #define XY_TRAVEL_SPEED 8000         // X and Y axis travel speed between probes, in mm/min.
 
-  #define Z_RAISE_BEFORE_PROBING 15   // How much the Z axis will be raised before traveling to the first probing point.
   #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points.
-  #define Z_RAISE_AFTER_PROBING 15    // How much the Z axis will be raised after the last probing point.
 
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
diff --git a/Marlin/example_configurations/SCARA/Configuration.h b/Marlin/example_configurations/SCARA/Configuration.h
index a801823..1b28aae 100644
--- a/Marlin/example_configurations/SCARA/Configuration.h
+++ b/Marlin/example_configurations/SCARA/Configuration.h
@@ -448,6 +448,12 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // If you're using the Z MIN endstop connector for your Z probe, this has no effect.
 //#define DISABLE_Z_MIN_PROBE_ENDSTOP
 
+// Probe Raise options provide clearance for the probe to deploy and stow.
+// For G28 these apply when the probe deploys and stows.
+// For G29 these apply before and after the full procedure.
+#define Z_RAISE_BEFORE_PROBING 15   // Raise before probe deploy (e.g., the first probe).
+#define Z_RAISE_AFTER_PROBING 15    // Raise before probe stow (e.g., the last probe).
+
 // For Inverting Stepper Enable Pins (Active Low) use 0, Non Inverting (Active High) use 1
 // :{0:'Low',1:'High'}
 #define X_ENABLE_ON 0
@@ -593,7 +599,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
     #define ABL_PROBE_PT_3_X 170
     #define ABL_PROBE_PT_3_Y 20
 
-  #endif // AUTO_BED_LEVELING_GRID
+  #endif // !AUTO_BED_LEVELING_GRID
 
   // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
   // X and Y offsets must be integers.
@@ -618,9 +624,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 
   #define XY_TRAVEL_SPEED 8000         // X and Y axis travel speed between probes, in mm/min.
 
-  #define Z_RAISE_BEFORE_PROBING 15   // How much the Z axis will be raised before traveling to the first probing point.
   #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points.
-  #define Z_RAISE_AFTER_PROBING 15    // How much the Z axis will be raised after the last probing point.
 
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
diff --git a/Marlin/example_configurations/TAZ4/Configuration.h b/Marlin/example_configurations/TAZ4/Configuration.h
index b2bd2ce..a019790 100644
--- a/Marlin/example_configurations/TAZ4/Configuration.h
+++ b/Marlin/example_configurations/TAZ4/Configuration.h
@@ -461,6 +461,12 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // If you're using the Z MIN endstop connector for your Z probe, this has no effect.
 //#define DISABLE_Z_MIN_PROBE_ENDSTOP
 
+// Probe Raise options provide clearance for the probe to deploy and stow.
+// For G28 these apply when the probe deploys and stows.
+// For G29 these apply before and after the full procedure.
+#define Z_RAISE_BEFORE_PROBING 15   // Raise before probe deploy (e.g., the first probe).
+#define Z_RAISE_AFTER_PROBING 15    // Raise before probe stow (e.g., the last probe).
+
 // For Inverting Stepper Enable Pins (Active Low) use 0, Non Inverting (Active High) use 1
 // :{0:'Low',1:'High'}
 #define X_ENABLE_ON 0
@@ -606,7 +612,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
     #define ABL_PROBE_PT_3_X 170
     #define ABL_PROBE_PT_3_Y 20
 
-  #endif // AUTO_BED_LEVELING_GRID
+  #endif // !AUTO_BED_LEVELING_GRID
 
   // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
   // X and Y offsets must be integers.
@@ -631,9 +637,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 
   #define XY_TRAVEL_SPEED 8000         // X and Y axis travel speed between probes, in mm/min.
 
-  #define Z_RAISE_BEFORE_PROBING 15   // How much the Z axis will be raised before traveling to the first probing point.
   #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points.
-  #define Z_RAISE_AFTER_PROBING 15    // How much the Z axis will be raised after the last probing point.
 
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
diff --git a/Marlin/example_configurations/WITBOX/Configuration.h b/Marlin/example_configurations/WITBOX/Configuration.h
index f32e071..cdd075c 100644
--- a/Marlin/example_configurations/WITBOX/Configuration.h
+++ b/Marlin/example_configurations/WITBOX/Configuration.h
@@ -432,6 +432,12 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 // If you're using the Z MIN endstop connector for your Z probe, this has no effect.
 //#define DISABLE_Z_MIN_PROBE_ENDSTOP
 
+// Probe Raise options provide clearance for the probe to deploy and stow.
+// For G28 these apply when the probe deploys and stows.
+// For G29 these apply before and after the full procedure.
+#define Z_RAISE_BEFORE_PROBING 15   // Raise before probe deploy (e.g., the first probe).
+#define Z_RAISE_AFTER_PROBING 15    // Raise before probe stow (e.g., the last probe).
+
 // For Inverting Stepper Enable Pins (Active Low) use 0, Non Inverting (Active High) use 1
 // :{0:'Low',1:'High'}
 #define X_ENABLE_ON 0
@@ -577,7 +583,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
     #define ABL_PROBE_PT_3_X 170
     #define ABL_PROBE_PT_3_Y 20
 
-  #endif // AUTO_BED_LEVELING_GRID
+  #endif // !AUTO_BED_LEVELING_GRID
 
   // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
   // X and Y offsets must be integers.
@@ -602,9 +608,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 
   #define XY_TRAVEL_SPEED 8000         // X and Y axis travel speed between probes, in mm/min.
 
-  #define Z_RAISE_BEFORE_PROBING 15   // How much the Z axis will be raised before traveling to the first probing point.
   #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points.
-  #define Z_RAISE_AFTER_PROBING 15    // How much the Z axis will be raised after the last probing point.
 
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
diff --git a/Marlin/example_configurations/adafruit/ST7565/Configuration.h b/Marlin/example_configurations/adafruit/ST7565/Configuration.h
index 151e16b..7a5d012 100644
--- a/Marlin/example_configurations/adafruit/ST7565/Configuration.h
+++ b/Marlin/example_configurations/adafruit/ST7565/Configuration.h
@@ -440,6 +440,12 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // If you're using the Z MIN endstop connector for your Z probe, this has no effect.
 //#define DISABLE_Z_MIN_PROBE_ENDSTOP
 
+// Probe Raise options provide clearance for the probe to deploy and stow.
+// For G28 these apply when the probe deploys and stows.
+// For G29 these apply before and after the full procedure.
+#define Z_RAISE_BEFORE_PROBING 15   // Raise before probe deploy (e.g., the first probe).
+#define Z_RAISE_AFTER_PROBING 15    // Raise before probe stow (e.g., the last probe).
+
 // For Inverting Stepper Enable Pins (Active Low) use 0, Non Inverting (Active High) use 1
 // :{0:'Low',1:'High'}
 #define X_ENABLE_ON 0
@@ -585,7 +591,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
     #define ABL_PROBE_PT_3_X 170
     #define ABL_PROBE_PT_3_Y 20
 
-  #endif // AUTO_BED_LEVELING_GRID
+  #endif // !AUTO_BED_LEVELING_GRID
 
   // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
   // X and Y offsets must be integers.
@@ -610,9 +616,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 
   #define XY_TRAVEL_SPEED 8000         // X and Y axis travel speed between probes, in mm/min.
 
-  #define Z_RAISE_BEFORE_PROBING 15   // How much the Z axis will be raised before traveling to the first probing point.
   #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points.
-  #define Z_RAISE_AFTER_PROBING 15    // How much the Z axis will be raised after the last probing point.
 
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
diff --git a/Marlin/example_configurations/delta/biv2.5/Configuration.h b/Marlin/example_configurations/delta/biv2.5/Configuration.h
index 026a727..739af6e 100644
--- a/Marlin/example_configurations/delta/biv2.5/Configuration.h
+++ b/Marlin/example_configurations/delta/biv2.5/Configuration.h
@@ -482,6 +482,12 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 // If you're using the Z MIN endstop connector for your Z probe, this has no effect.
 //#define DISABLE_Z_MIN_PROBE_ENDSTOP
 
+// Probe Raise options provide clearance for the probe to deploy and stow.
+// For G28 these apply when the probe deploys and stows.
+// For G29 these apply before and after the full procedure.
+#define Z_RAISE_BEFORE_PROBING 15   // Raise before probe deploy (e.g., the first probe).
+#define Z_RAISE_AFTER_PROBING 50    // Raise before probe stow (e.g., the last probe).
+
 // For Inverting Stepper Enable Pins (Active Low) use 0, Non Inverting (Active High) use 1
 // :{0:'Low',1:'High'}
 #define X_ENABLE_ON 0
@@ -631,7 +637,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
     #define ABL_PROBE_PT_3_X 170
     #define ABL_PROBE_PT_3_Y 20
 
-  #endif // AUTO_BED_LEVELING_GRID
+  #endif // !AUTO_BED_LEVELING_GRID
 
   // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
   // X and Y offsets must be integers.
@@ -656,9 +662,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 
   #define XY_TRAVEL_SPEED 4000         // X and Y axis travel speed between probes, in mm/min.
 
-  #define Z_RAISE_BEFORE_PROBING 15   // How much the Z axis will be raised before traveling to the first probing point.
   #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points.
-  #define Z_RAISE_AFTER_PROBING 50    // How much the Z axis will be raised after the last probing point.
 
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
diff --git a/Marlin/example_configurations/delta/generic/Configuration.h b/Marlin/example_configurations/delta/generic/Configuration.h
index dea1dfe..714152c 100644
--- a/Marlin/example_configurations/delta/generic/Configuration.h
+++ b/Marlin/example_configurations/delta/generic/Configuration.h
@@ -482,6 +482,12 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 // If you're using the Z MIN endstop connector for your Z probe, this has no effect.
 //#define DISABLE_Z_MIN_PROBE_ENDSTOP
 
+// Probe Raise options provide clearance for the probe to deploy and stow.
+// For G28 these apply when the probe deploys and stows.
+// For G29 these apply before and after the full procedure.
+#define Z_RAISE_BEFORE_PROBING 15   // Raise before probe deploy (e.g., the first probe).
+#define Z_RAISE_AFTER_PROBING 50    // Raise before probe stow (e.g., the last probe).
+
 // For Inverting Stepper Enable Pins (Active Low) use 0, Non Inverting (Active High) use 1
 // :{0:'Low',1:'High'}
 #define X_ENABLE_ON 0
@@ -631,7 +637,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
     #define ABL_PROBE_PT_3_X 170
     #define ABL_PROBE_PT_3_Y 20
 
-  #endif // AUTO_BED_LEVELING_GRID
+  #endif // !AUTO_BED_LEVELING_GRID
 
   // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
   // X and Y offsets must be integers.
@@ -656,9 +662,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 
   #define XY_TRAVEL_SPEED 4000         // X and Y axis travel speed between probes, in mm/min.
 
-  #define Z_RAISE_BEFORE_PROBING 15   // How much the Z axis will be raised before traveling to the first probing point.
   #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points
-  #define Z_RAISE_AFTER_PROBING 50    // How much the Z axis will be raised after the last probing point.
 
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
diff --git a/Marlin/example_configurations/delta/kossel_mini/Configuration.h b/Marlin/example_configurations/delta/kossel_mini/Configuration.h
index b262989..e9e5c42 100644
--- a/Marlin/example_configurations/delta/kossel_mini/Configuration.h
+++ b/Marlin/example_configurations/delta/kossel_mini/Configuration.h
@@ -482,6 +482,12 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // If you're using the Z MIN endstop connector for your Z probe, this has no effect.
 //#define DISABLE_Z_MIN_PROBE_ENDSTOP
 
+// Probe Raise options provide clearance for the probe to deploy and stow.
+// For G28 these apply when the probe deploys and stows.
+// For G29 these apply before and after the full procedure.
+#define Z_RAISE_BEFORE_PROBING 15   // Raise before probe deploy (e.g., the first probe).
+#define Z_RAISE_AFTER_PROBING 50    // Raise before probe stow (e.g., the last probe).
+
 // For Inverting Stepper Enable Pins (Active Low) use 0, Non Inverting (Active High) use 1
 // :{0:'Low',1:'High'}
 #define X_ENABLE_ON 0
@@ -631,7 +637,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
     #define ABL_PROBE_PT_3_X 170
     #define ABL_PROBE_PT_3_Y 20
 
-  #endif // AUTO_BED_LEVELING_GRID
+  #endif // !AUTO_BED_LEVELING_GRID
 
   // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
   // X and Y offsets must be integers.
@@ -656,9 +662,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 
   #define XY_TRAVEL_SPEED 4000         // X and Y axis travel speed between probes, in mm/min.
 
-  #define Z_RAISE_BEFORE_PROBING 15   // How much the Z axis will be raised before traveling to the first probing point.
   #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points
-  #define Z_RAISE_AFTER_PROBING 50    // How much the Z axis will be raised after the last probing point.
 
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
diff --git a/Marlin/example_configurations/delta/kossel_pro/Configuration.h b/Marlin/example_configurations/delta/kossel_pro/Configuration.h
index d87239d..406edd1 100644
--- a/Marlin/example_configurations/delta/kossel_pro/Configuration.h
+++ b/Marlin/example_configurations/delta/kossel_pro/Configuration.h
@@ -471,6 +471,12 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // If you're using the Z MIN endstop connector for your Z probe, this has no effect.
 //#define DISABLE_Z_MIN_PROBE_ENDSTOP
 
+// Probe Raise options provide clearance for the probe to deploy and stow.
+// For G28 these apply when the probe deploys and stows.
+// For G29 these apply before and after the full procedure.
+#define Z_RAISE_BEFORE_PROBING 100  // Raise before probe deploy (e.g., the first probe).
+#define Z_RAISE_AFTER_PROBING 15    // Raise before probe stow (e.g., the last probe).
+
 // For Inverting Stepper Enable Pins (Active Low) use 0, Non Inverting (Active High) use 1
 // :{0:'Low',1:'High'}
 #define X_ENABLE_ON 0
@@ -620,7 +626,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
     #define ABL_PROBE_PT_3_X 170
     #define ABL_PROBE_PT_3_Y 20
 
-  #endif // AUTO_BED_LEVELING_GRID
+  #endif // !AUTO_BED_LEVELING_GRID
 
   // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
   // X and Y offsets must be integers.
@@ -647,9 +653,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 
   #define XY_TRAVEL_SPEED 8000         // X and Y axis travel speed between probes, in mm/min.
 
-  #define Z_RAISE_BEFORE_PROBING 100  // How much the Z axis will be raised before traveling to the first probing point.
   #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points.
-  #define Z_RAISE_AFTER_PROBING 15    // How much the Z axis will be raised after the last probing point.
 
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
diff --git a/Marlin/example_configurations/delta/kossel_xl/Configuration.h b/Marlin/example_configurations/delta/kossel_xl/Configuration.h
index fa4e96d..ab54035 100644
--- a/Marlin/example_configurations/delta/kossel_xl/Configuration.h
+++ b/Marlin/example_configurations/delta/kossel_xl/Configuration.h
@@ -480,6 +480,12 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // If you're using the Z MIN endstop connector for your Z probe, this has no effect.
 //#define DISABLE_Z_MIN_PROBE_ENDSTOP
 
+// Probe Raise options provide clearance for the probe to deploy and stow.
+// For G28 these apply when the probe deploys and stows.
+// For G29 these apply before and after the full procedure.
+#define Z_RAISE_BEFORE_PROBING 20   // Raise before probe deploy (e.g., the first probe).
+#define Z_RAISE_AFTER_PROBING 20    // Raise before probe stow (e.g., the last probe).
+
 // For Inverting Stepper Enable Pins (Active Low) use 0, Non Inverting (Active High) use 1
 // :{0:'Low',1:'High'}
 #define X_ENABLE_ON 0
@@ -629,7 +635,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
     #define ABL_PROBE_PT_3_X 170
     #define ABL_PROBE_PT_3_Y 20
 
-  #endif // AUTO_BED_LEVELING_GRID
+  #endif // !AUTO_BED_LEVELING_GRID
 
   // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
   // X and Y offsets must be integers.
@@ -654,9 +660,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 
   #define XY_TRAVEL_SPEED 8000         // X and Y axis travel speed between probes, in mm/min.
 
-  #define Z_RAISE_BEFORE_PROBING 20   // How much the Z axis will be raised before traveling to the first probing point.
   #define Z_RAISE_BETWEEN_PROBINGS 10 // How much the Z axis will be raised when traveling from between next probing points.
-  #define Z_RAISE_AFTER_PROBING 20    // How much the Z axis will be raised after the last probing point.
 
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
diff --git a/Marlin/example_configurations/makibox/Configuration.h b/Marlin/example_configurations/makibox/Configuration.h
index 1991ee6..5569695 100644
--- a/Marlin/example_configurations/makibox/Configuration.h
+++ b/Marlin/example_configurations/makibox/Configuration.h
@@ -443,6 +443,12 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // If you're using the Z MIN endstop connector for your Z probe, this has no effect.
 //#define DISABLE_Z_MIN_PROBE_ENDSTOP
 
+// Probe Raise options provide clearance for the probe to deploy and stow.
+// For G28 these apply when the probe deploys and stows.
+// For G29 these apply before and after the full procedure.
+#define Z_RAISE_BEFORE_PROBING 15   // Raise before probe deploy (e.g., the first probe).
+#define Z_RAISE_AFTER_PROBING 15    // Raise before probe stow (e.g., the last probe).
+
 // For Inverting Stepper Enable Pins (Active Low) use 0, Non Inverting (Active High) use 1
 // :{0:'Low',1:'High'}
 #define X_ENABLE_ON 0
@@ -588,7 +594,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
     #define ABL_PROBE_PT_3_X 170
     #define ABL_PROBE_PT_3_Y 20
 
-  #endif // AUTO_BED_LEVELING_GRID
+  #endif // !AUTO_BED_LEVELING_GRID
 
   // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
   // X and Y offsets must be integers.
@@ -613,9 +619,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 
   #define XY_TRAVEL_SPEED 8000         // X and Y axis travel speed between probes, in mm/min.
 
-  #define Z_RAISE_BEFORE_PROBING 15   // How much the Z axis will be raised before traveling to the first probing point.
   #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points.
-  #define Z_RAISE_AFTER_PROBING 15    // How much the Z axis will be raised after the last probing point.
 
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
diff --git a/Marlin/example_configurations/tvrrug/Round2/Configuration.h b/Marlin/example_configurations/tvrrug/Round2/Configuration.h
index c380ee2..fc52ac4 100644
--- a/Marlin/example_configurations/tvrrug/Round2/Configuration.h
+++ b/Marlin/example_configurations/tvrrug/Round2/Configuration.h
@@ -430,6 +430,12 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 // If you're using the Z MIN endstop connector for your Z probe, this has no effect.
 //#define DISABLE_Z_MIN_PROBE_ENDSTOP
 
+// Probe Raise options provide clearance for the probe to deploy and stow.
+// For G28 these apply when the probe deploys and stows.
+// For G29 these apply before and after the full procedure.
+#define Z_RAISE_BEFORE_PROBING 15   // Raise before probe deploy (e.g., the first probe).
+#define Z_RAISE_AFTER_PROBING 15    // Raise before probe stow (e.g., the last probe).
+
 // For Inverting Stepper Enable Pins (Active Low) use 0, Non Inverting (Active High) use 1
 // :{0:'Low',1:'High'}
 #define X_ENABLE_ON 1
@@ -575,7 +581,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
     #define ABL_PROBE_PT_3_X 170
     #define ABL_PROBE_PT_3_Y 20
 
-  #endif // AUTO_BED_LEVELING_GRID
+  #endif // !AUTO_BED_LEVELING_GRID
 
   // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
   // X and Y offsets must be integers.
@@ -600,9 +606,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 
   #define XY_TRAVEL_SPEED 8000         // X and Y axis travel speed between probes, in mm/min.
 
-  #define Z_RAISE_BEFORE_PROBING 15   // How much the Z axis will be raised before traveling to the first probing point.
   #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points.
-  #define Z_RAISE_AFTER_PROBING 15    // How much the Z axis will be raised after the last probing point.
 
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
diff --git a/Marlin/language_da.h b/Marlin/language_da.h
index a66ceb5..6610edf 100644
--- a/Marlin/language_da.h
+++ b/Marlin/language_da.h
@@ -172,6 +172,7 @@
 #define MSG_CNG_SDCARD                      "Skift SD kort"
 #define MSG_ZPROBE_OUT                      "Probe udenfor plade"
 #define MSG_YX_UNHOMED                      "Home X/Y fr Z"
+#define MSG_XYZ_UNHOMED                     "Home XYZ first"
 #define MSG_ZPROBE_ZOFFSET                  "Z Offset"
 #define MSG_BABYSTEP_X                      "Babystep X"
 #define MSG_BABYSTEP_Y                      "Babystep Y"
@@ -182,8 +183,8 @@
 #define MSG_THERMAL_RUNAWAY                 "Temp lber lbsk"
 #define MSG_ERR_MAXTEMP                     "Fejl: Maks temp"
 #define MSG_ERR_MINTEMP                     "Fejl: Min temp"
-#define MSG_ERR_MAXTEMP_BED                 "Fejl: Maks P temp"
-#define MSG_ERR_MINTEMP_BED                 "Fejl: Min P temp"
+#define MSG_ERR_MAXTEMP_BED                 "Fejl: Maks Plsde temp"
+#define MSG_ERR_MINTEMP_BED                 "Fejl: Min Plade temp"
 #define MSG_END_HOUR                        "Timer"
 #define MSG_END_MINUTE                      "Minutter"
 #define MSG_HEATING                         "Opvarmer..."
diff --git a/Marlin/language_gl.h b/Marlin/language_gl.h
index ad4e53e..5365f3c 100644
--- a/Marlin/language_gl.h
+++ b/Marlin/language_gl.h
@@ -38,17 +38,20 @@
 #define WELCOME_MSG                         MACHINE_NAME " lista."
 #define MSG_SD_INSERTED                     "Tarxeta inserida"
 #define MSG_SD_REMOVED                      "Tarxeta retirada"
-#define MSG_LCD_ENDSTOPS                    "Endstops" // Max length 8 characters
+#define MSG_LCD_ENDSTOPS                    "FinCarro"
 #define MSG_MAIN                            "Menu principal"
 #define MSG_AUTOSTART                       "Autoarranque"
 #define MSG_DISABLE_STEPPERS                "Apagar motores"
 #define MSG_AUTO_HOME                       "Ir a orixe"
+#define MSG_AUTO_HOME_X                     "Ir orixe X"
+#define MSG_AUTO_HOME_Y                     "Ir orixe Y"
+#define MSG_AUTO_HOME_Z                     "Ir orixe Z"
 #define MSG_LEVEL_BED_HOMING                "Ir orixes XYZ"
 #define MSG_LEVEL_BED_WAITING               "Prema pulsador"
 #define MSG_LEVEL_BED_NEXT_POINT            "Seguinte punto"
-#define MSG_LEVEL_BED_DONE                  "Nivelado feito!"
+#define MSG_LEVEL_BED_DONE                  "Nivelado feito"
 #define MSG_LEVEL_BED_CANCEL                "Cancelar"
-#define MSG_SET_HOME_OFFSETS                "Offsets a orixe"
+#define MSG_SET_HOME_OFFSETS                "Offsets na orixe"
 #define MSG_HOME_OFFSETS_APPLIED            "Offsets fixados"
 #define MSG_SET_ORIGIN                      "Fixar orixe"
 #define MSG_PREHEAT_PLA                     "Prequentar PLA"
@@ -168,6 +171,7 @@
 #define MSG_CNG_SDCARD                      "Cambiar SD"
 #define MSG_ZPROBE_OUT                      "Sonda-Z sen cama"
 #define MSG_YX_UNHOMED                      "X/Y antes que Z"
+#define MSG_XYZ_UNHOMED                     "Orixe XYZ antes"
 #define MSG_ZPROBE_ZOFFSET                  "Offset Z"
 #define MSG_BABYSTEP_X                      "Micropaso X"
 #define MSG_BABYSTEP_Y                      "Micropaso Y"
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index 05a3c71..d38f2d3 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -71,6 +71,64 @@
 
 Planner planner;
 
+  // public:
+
+/**
+ * A ring buffer of moves described in steps
+ */
+block_t Planner::block_buffer[BLOCK_BUFFER_SIZE];
+volatile uint8_t Planner::block_buffer_head = 0;           // Index of the next block to be pushed
+volatile uint8_t Planner::block_buffer_tail = 0;
+
+float Planner::max_feedrate[NUM_AXIS]; // Max speeds in mm per minute
+float Planner::axis_steps_per_unit[NUM_AXIS];
+unsigned long Planner::axis_steps_per_sqr_second[NUM_AXIS];
+unsigned long Planner::max_acceleration_units_per_sq_second[NUM_AXIS]; // Use M201 to override by software
+
+millis_t Planner::min_segment_time;
+float Planner::min_feedrate;
+float Planner::acceleration;         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
+float Planner::retract_acceleration; // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX
+float Planner::travel_acceleration;  // Travel acceleration mm/s^2  DEFAULT ACCELERATION for all NON printing moves. M204 MXXXX
+float Planner::max_xy_jerk;          // The largest speed change requiring no acceleration
+float Planner::max_z_jerk;
+float Planner::max_e_jerk;
+float Planner::min_travel_feedrate;
+
+#if ENABLED(AUTO_BED_LEVELING_FEATURE)
+  matrix_3x3 Planner::bed_level_matrix; // Transform to compensate for bed level
+#endif
+
+#if ENABLED(AUTOTEMP)
+  float Planner::autotemp_max = 250;
+  float Planner::autotemp_min = 210;
+  float Planner::autotemp_factor = 0.1;
+  bool Planner::autotemp_enabled = false;
+#endif
+
+// private:
+
+long Planner::position[NUM_AXIS] = { 0 };
+
+float Planner::previous_speed[NUM_AXIS];
+
+float Planner::previous_nominal_speed;
+
+#if ENABLED(DISABLE_INACTIVE_EXTRUDER)
+  uint8_t Planner::g_uc_extruder_last_move[EXTRUDERS] = { 0 };
+#endif // DISABLE_INACTIVE_EXTRUDER
+
+#ifdef XY_FREQUENCY_LIMIT
+  // Old direction bits. Used for speed calculations
+  unsigned char Planner::old_direction_bits = 0;
+  // Segment times (in s). Used for speed calculations
+  long Planner::axis_segment_time[2][3] = { {MAX_FREQ_TIME + 1, 0, 0}, {MAX_FREQ_TIME + 1, 0, 0} };
+#endif
+
+/**
+ * Class and Instance Methods
+ */
+
 Planner::Planner() {
   #if ENABLED(AUTO_BED_LEVELING_FEATURE)
     bed_level_matrix.set_to_identity();
@@ -1056,9 +1114,9 @@ void Planner::check_axes_activity() {
  * On CORE machines stepper ABC will be translated from the given XYZ.
  */
 #if ENABLED(AUTO_BED_LEVELING_FEATURE) || ENABLED(MESH_BED_LEVELING)
-  void Planner::set_position(float x, float y, float z, const float& e)
+  void Planner::set_position_mm(float x, float y, float z, const float& e)
 #else
-  void Planner::set_position(const float& x, const float& y, const float& z, const float& e)
+  void Planner::set_position_mm(const float& x, const float& y, const float& z, const float& e)
 #endif // AUTO_BED_LEVELING_FEATURE || MESH_BED_LEVELING
   {
     #if ENABLED(MESH_BED_LEVELING)
@@ -1080,7 +1138,7 @@ void Planner::check_axes_activity() {
 /**
  * Directly set the planner E position (hence the stepper E position).
  */
-void Planner::set_e_position(const float& e) {
+void Planner::set_e_position_mm(const float& e) {
   position[E_AXIS] = lround(e * axis_steps_per_unit[E_AXIS]);
   stepper.set_e_position(position[E_AXIS]);
 }
diff --git a/Marlin/planner.h b/Marlin/planner.h
index f623983..96e580d 100644
--- a/Marlin/planner.h
+++ b/Marlin/planner.h
@@ -108,27 +108,27 @@ class Planner {
     /**
      * A ring buffer of moves described in steps
      */
-    block_t block_buffer[BLOCK_BUFFER_SIZE];
-    volatile uint8_t block_buffer_head = 0;           // Index of the next block to be pushed
-    volatile uint8_t block_buffer_tail = 0;
-
-    float max_feedrate[NUM_AXIS]; // Max speeds in mm per minute
-    float axis_steps_per_unit[NUM_AXIS];
-    unsigned long axis_steps_per_sqr_second[NUM_AXIS];
-    unsigned long max_acceleration_units_per_sq_second[NUM_AXIS]; // Use M201 to override by software
-
-    millis_t min_segment_time;
-    float min_feedrate;
-    float acceleration;         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
-    float retract_acceleration; // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX
-    float travel_acceleration;  // Travel acceleration mm/s^2  DEFAULT ACCELERATION for all NON printing moves. M204 MXXXX
-    float max_xy_jerk;          // The largest speed change requiring no acceleration
-    float max_z_jerk;
-    float max_e_jerk;
-    float min_travel_feedrate;
+    static block_t block_buffer[BLOCK_BUFFER_SIZE];
+    static volatile uint8_t block_buffer_head;           // Index of the next block to be pushed
+    static volatile uint8_t block_buffer_tail;
+
+    static float max_feedrate[NUM_AXIS]; // Max speeds in mm per minute
+    static float axis_steps_per_unit[NUM_AXIS];
+    static unsigned long axis_steps_per_sqr_second[NUM_AXIS];
+    static unsigned long max_acceleration_units_per_sq_second[NUM_AXIS]; // Use M201 to override by software
+
+    static millis_t min_segment_time;
+    static float min_feedrate;
+    static float acceleration;         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
+    static float retract_acceleration; // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX
+    static float travel_acceleration;  // Travel acceleration mm/s^2  DEFAULT ACCELERATION for all NON printing moves. M204 MXXXX
+    static float max_xy_jerk;          // The largest speed change requiring no acceleration
+    static float max_z_jerk;
+    static float max_e_jerk;
+    static float min_travel_feedrate;
 
     #if ENABLED(AUTO_BED_LEVELING_FEATURE)
-      matrix_3x3 bed_level_matrix; // Transform to compensate for bed level
+      static matrix_3x3 bed_level_matrix; // Transform to compensate for bed level
     #endif
 
   private:
@@ -137,49 +137,57 @@ class Planner {
      * The current position of the tool in absolute steps
      * Reclculated if any axis_steps_per_unit are changed by gcode
      */
-    long position[NUM_AXIS] = { 0 };
+    static long position[NUM_AXIS];
 
     /**
      * Speed of previous path line segment
      */
-    float previous_speed[NUM_AXIS];
+    static float previous_speed[NUM_AXIS];
 
     /**
      * Nominal speed of previous path line segment
      */
-    float previous_nominal_speed;
+    static float previous_nominal_speed;
 
     #if ENABLED(DISABLE_INACTIVE_EXTRUDER)
       /**
        * Counters to manage disabling inactive extruders
        */
-      uint8_t g_uc_extruder_last_move[EXTRUDERS] = { 0 };
+      static uint8_t g_uc_extruder_last_move[EXTRUDERS];
     #endif // DISABLE_INACTIVE_EXTRUDER
 
     #ifdef XY_FREQUENCY_LIMIT
       // Used for the frequency limit
-      #define MAX_FREQ_TIME (1000000.0/XY_FREQUENCY_LIMIT)
+      #define MAX_FREQ_TIME long(1000000.0/XY_FREQUENCY_LIMIT)
       // Old direction bits. Used for speed calculations
-      static unsigned char old_direction_bits = 0;
+      static unsigned char old_direction_bits;
       // Segment times (in s). Used for speed calculations
-      static long axis_segment_time[2][3] = { {MAX_FREQ_TIME + 1, 0, 0}, {MAX_FREQ_TIME + 1, 0, 0} };
+      static long axis_segment_time[2][3];
     #endif
 
   public:
 
+    /**
+     * Instance Methods
+     */
+
     Planner();
 
     void init();
 
-    void reset_acceleration_rates();
+    /**
+     * Static (class) Methods
+     */
+
+    static void reset_acceleration_rates();
 
     // Manage fans, paste pressure, etc.
-    void check_axes_activity();
+    static void check_axes_activity();
 
     /**
      * Number of moves currently in the planner
      */
-    FORCE_INLINE uint8_t movesplanned() { return BLOCK_MOD(block_buffer_head - block_buffer_tail + BLOCK_BUFFER_SIZE); }
+    static uint8_t movesplanned() { return BLOCK_MOD(block_buffer_head - block_buffer_tail + BLOCK_BUFFER_SIZE); }
 
     #if ENABLED(AUTO_BED_LEVELING_FEATURE) || ENABLED(MESH_BED_LEVELING)
 
@@ -187,7 +195,7 @@ class Planner {
         /**
          * The corrected position, applying the bed level matrix
          */
-        vector_3 adjusted_position();
+        static vector_3 adjusted_position();
       #endif
 
       /**
@@ -197,7 +205,7 @@ class Planner {
        *  feed_rate - (target) speed of the move
        *  extruder  - target extruder
        */
-      void buffer_line(float x, float y, float z, const float& e, float feed_rate, const uint8_t extruder);
+      static void buffer_line(float x, float y, float z, const float& e, float feed_rate, const uint8_t extruder);
 
       /**
        * Set the planner.position and individual stepper positions.
@@ -208,30 +216,30 @@ class Planner {
        *
        * Clears previous speed values.
        */
-      void set_position(float x, float y, float z, const float& e);
+      static void set_position_mm(float x, float y, float z, const float& e);
 
     #else
 
-      void buffer_line(const float& x, const float& y, const float& z, const float& e, float feed_rate, const uint8_t extruder);
-      void set_position(const float& x, const float& y, const float& z, const float& e);
+      static void buffer_line(const float& x, const float& y, const float& z, const float& e, float feed_rate, const uint8_t extruder);
+      static void set_position_mm(const float& x, const float& y, const float& z, const float& e);
 
     #endif // AUTO_BED_LEVELING_FEATURE || MESH_BED_LEVELING
 
     /**
      * Set the E position (mm) of the planner (and the E stepper)
      */
-    void set_e_position(const float& e);
+    static void set_e_position_mm(const float& e);
 
     /**
      * Does the buffer have any blocks queued?
      */
-    FORCE_INLINE bool blocks_queued() { return (block_buffer_head != block_buffer_tail); }
+    static bool blocks_queued() { return (block_buffer_head != block_buffer_tail); }
 
     /**
      * "Discards" the block and "releases" the memory.
      * Called when the current block is no longer needed.
      */
-    FORCE_INLINE void discard_current_block() {
+    static void discard_current_block() {
       if (blocks_queued())
         block_buffer_tail = BLOCK_MOD(block_buffer_tail + 1);
     }
@@ -240,7 +248,7 @@ class Planner {
      * The current block. NULL if the buffer is empty.
      * This also marks the block as busy.
      */
-    FORCE_INLINE block_t* get_current_block() {
+    static block_t* get_current_block() {
       if (blocks_queued()) {
         block_t* block = &block_buffer[block_buffer_tail];
         block->busy = true;
@@ -251,12 +259,12 @@ class Planner {
     }
 
     #if ENABLED(AUTOTEMP)
-      float autotemp_max = 250;
-      float autotemp_min = 210;
-      float autotemp_factor = 0.1;
-      bool autotemp_enabled = false;
-      void getHighESpeed();
-      void autotemp_M109();
+      static float autotemp_max;
+      static float autotemp_min;
+      static float autotemp_factor;
+      static bool autotemp_enabled;
+      static void getHighESpeed();
+      static void autotemp_M109();
     #endif
 
   private:
@@ -264,14 +272,14 @@ class Planner {
     /**
      * Get the index of the next / previous block in the ring buffer
      */
-    FORCE_INLINE int8_t next_block_index(int8_t block_index) { return BLOCK_MOD(block_index + 1); }
-    FORCE_INLINE int8_t prev_block_index(int8_t block_index) { return BLOCK_MOD(block_index - 1); }
+    static int8_t next_block_index(int8_t block_index) { return BLOCK_MOD(block_index + 1); }
+    static int8_t prev_block_index(int8_t block_index) { return BLOCK_MOD(block_index - 1); }
 
     /**
      * Calculate the distance (not time) it takes to accelerate
      * from initial_rate to target_rate using the given acceleration:
      */
-    FORCE_INLINE float estimate_acceleration_distance(float initial_rate, float target_rate, float acceleration) {
+    static float estimate_acceleration_distance(float initial_rate, float target_rate, float acceleration) {
       if (acceleration == 0) return 0; // acceleration was 0, set acceleration distance to 0
       return (target_rate * target_rate - initial_rate * initial_rate) / (acceleration * 2);
     }
@@ -284,7 +292,7 @@ class Planner {
      * This is used to compute the intersection point between acceleration and deceleration
      * in cases where the "trapezoid" has no plateau (i.e., never reaches maximum speed)
      */
-    FORCE_INLINE float intersection_distance(float initial_rate, float final_rate, float acceleration, float distance) {
+    static float intersection_distance(float initial_rate, float final_rate, float acceleration, float distance) {
       if (acceleration == 0) return 0; // acceleration was 0, set intersection distance to 0
       return (acceleration * 2 * distance - initial_rate * initial_rate + final_rate * final_rate) / (acceleration * 4);
     }
@@ -294,21 +302,21 @@ class Planner {
      * to reach 'target_velocity' using 'acceleration' within a given
      * 'distance'.
      */
-    FORCE_INLINE float max_allowable_speed(float acceleration, float target_velocity, float distance) {
+    static float max_allowable_speed(float acceleration, float target_velocity, float distance) {
       return sqrt(target_velocity * target_velocity - 2 * acceleration * distance);
     }
 
-    void calculate_trapezoid_for_block(block_t* block, float entry_factor, float exit_factor);
+    static void calculate_trapezoid_for_block(block_t* block, float entry_factor, float exit_factor);
 
-    void reverse_pass_kernel(block_t* previous, block_t* current, block_t* next);
-    void forward_pass_kernel(block_t* previous, block_t* current, block_t* next);
+    static void reverse_pass_kernel(block_t* previous, block_t* current, block_t* next);
+    static void forward_pass_kernel(block_t* previous, block_t* current, block_t* next);
 
-    void reverse_pass();
-    void forward_pass();
+    static void reverse_pass();
+    static void forward_pass();
 
-    void recalculate_trapezoids();
+    static void recalculate_trapezoids();
 
-    void recalculate();
+    static void recalculate();
 
 };
 
diff --git a/Marlin/stepper.cpp b/Marlin/stepper.cpp
index e1a06be..3df97cd 100644
--- a/Marlin/stepper.cpp
+++ b/Marlin/stepper.cpp
@@ -60,6 +60,55 @@
 
 Stepper stepper; // Singleton
 
+// public:
+
+block_t* Stepper::current_block = NULL;  // A pointer to the block currently being traced
+
+#if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
+  bool Stepper::abort_on_endstop_hit = false;
+#endif
+
+#if ENABLED(Z_DUAL_ENDSTOPS)
+  bool Stepper::performing_homing = false;
+#endif
+
+// private:
+
+unsigned char Stepper::last_direction_bits = 0;        // The next stepping-bits to be output
+unsigned int Stepper::cleaning_buffer_counter = 0;
+
+#if ENABLED(Z_DUAL_ENDSTOPS)
+  bool Stepper::locked_z_motor = false;
+  bool Stepper::locked_z2_motor = false;
+#endif
+
+long  Stepper::counter_X = 0,
+      Stepper::counter_Y = 0,
+      Stepper::counter_Z = 0,
+      Stepper::counter_E = 0;
+
+volatile unsigned long Stepper::step_events_completed = 0; // The number of step events executed in the current block
+
+#if ENABLED(ADVANCE)
+  unsigned char Stepper::old_OCR0A;
+  long  Stepper::final_advance = 0,
+        Stepper::old_advance = 0,
+        Stepper::e_steps[4],
+        Stepper::advance_rate,
+        Stepper::advance;
+#endif
+
+long Stepper::acceleration_time, Stepper::deceleration_time;
+
+volatile long Stepper::count_position[NUM_AXIS] = { 0 };
+volatile signed char Stepper::count_direction[NUM_AXIS] = { 1, 1, 1, 1 };
+
+unsigned short Stepper::acc_step_rate; // needed for deceleration start point
+uint8_t Stepper::step_loops, Stepper::step_loops_nominal;
+unsigned short Stepper::OCR1A_nominal;
+
+volatile long Stepper::endstops_trigsteps[3];
+
 #if ENABLED(DUAL_X_CARRIAGE)
   #define X_APPLY_DIR(v,ALWAYS) \
     if (extruder_duplication_enabled || ALWAYS) { \
@@ -238,7 +287,7 @@ void Stepper::set_directions() {
 
 // "The Stepper Driver Interrupt" - This timer interrupt is the workhorse.
 // It pops blocks from the block_buffer and executes them by pulsing the stepper pins appropriately.
-ISR(TIMER1_COMPA_vect) { stepper.isr(); }
+ISR(TIMER1_COMPA_vect) { Stepper::isr(); }
 
 void Stepper::isr() {
   if (cleaning_buffer_counter) {
@@ -405,7 +454,7 @@ void Stepper::isr() {
 #if ENABLED(ADVANCE)
   // Timer interrupt for E. e_steps is set in the main routine;
   // Timer 0 is shared with millies
-  ISR(TIMER0_COMPA_vect) { stepper.advance_isr(); }
+  ISR(TIMER0_COMPA_vect) { Stepper::advance_isr(); }
 
   void Stepper::advance_isr() {
     old_OCR0A += 52; // ~10kHz interrupt (250000 / 26 = 9615kHz)
@@ -443,6 +492,7 @@ void Stepper::isr() {
 #endif // ADVANCE
 
 void Stepper::init() {
+
   digipot_init(); //Initialize Digipot Motor Current
   microstep_init(); //Initialize Microstepping Pins
 
diff --git a/Marlin/stepper.h b/Marlin/stepper.h
index ae1051c..ce4c1c1 100644
--- a/Marlin/stepper.h
+++ b/Marlin/stepper.h
@@ -80,49 +80,46 @@ class Stepper {
 
   public:
 
-    block_t* current_block = NULL;  // A pointer to the block currently being traced
+    static block_t* current_block;  // A pointer to the block currently being traced
 
     #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
-      bool abort_on_endstop_hit = false;
+      static bool abort_on_endstop_hit;
     #endif
 
     #if ENABLED(Z_DUAL_ENDSTOPS)
-      bool performing_homing = false;
+      static bool performing_homing;
     #endif
 
     #if ENABLED(ADVANCE)
-      long e_steps[4];
+      static long e_steps[4];
     #endif
 
   private:
 
-    unsigned char last_direction_bits = 0;        // The next stepping-bits to be output
-    unsigned int cleaning_buffer_counter = 0;
+    static unsigned char last_direction_bits;        // The next stepping-bits to be output
+    static unsigned int cleaning_buffer_counter;
 
     #if ENABLED(Z_DUAL_ENDSTOPS)
-      bool locked_z_motor = false,
-           locked_z2_motor = false;
+      static bool locked_z_motor, locked_z2_motor;
     #endif
 
     // Counter variables for the Bresenham line tracer
-    long counter_X = 0, counter_Y = 0, counter_Z = 0, counter_E = 0;
-    volatile unsigned long step_events_completed = 0; // The number of step events executed in the current block
+    static long counter_X, counter_Y, counter_Z, counter_E;
+    static volatile unsigned long step_events_completed; // The number of step events executed in the current block
 
     #if ENABLED(ADVANCE)
-      unsigned char old_OCR0A;
-      long advance_rate, advance, final_advance = 0;
-      long old_advance = 0;
+      static unsigned char old_OCR0A;
+      static long advance_rate, advance, old_advance, final_advance;
     #endif
 
-    long acceleration_time, deceleration_time;
+    static long acceleration_time, deceleration_time;
     //unsigned long accelerate_until, decelerate_after, acceleration_rate, initial_rate, final_rate, nominal_rate;
-    unsigned short acc_step_rate; // needed for deceleration start point
-    uint8_t step_loops;
-    uint8_t step_loops_nominal;
-    unsigned short OCR1A_nominal;
+    static unsigned short acc_step_rate; // needed for deceleration start point
+    static uint8_t step_loops, step_loops_nominal;
+    static unsigned short OCR1A_nominal;
 
-    volatile long endstops_trigsteps[3];
-    volatile long endstops_stepsTotal, endstops_stepsDone;
+    static volatile long endstops_trigsteps[3];
+    static volatile long endstops_stepsTotal, endstops_stepsDone;
 
     #if HAS_MOTOR_CURRENT_PWM
       #ifndef PWM_MOTOR_CURRENT
@@ -134,124 +131,124 @@ class Stepper {
     //
     // Positions of stepper motors, in step units
     //
-    volatile long count_position[NUM_AXIS] = { 0 };
+    static volatile long count_position[NUM_AXIS];
 
     //
     // Current direction of stepper motors (+1 or -1)
     //
-    volatile signed char count_direction[NUM_AXIS] = { 1, 1, 1, 1 };
+    static volatile signed char count_direction[NUM_AXIS];
 
   public:
 
     //
     // Constructor / initializer
     //
-    Stepper() {};
+    Stepper() { };
 
     //
     // Initialize stepper hardware
     //
-    void init();
+    static void init();
 
     //
     // Interrupt Service Routines
     //
 
-    void isr();
+    static void isr();
 
     #if ENABLED(ADVANCE)
-      void advance_isr();
+      static void advance_isr();
     #endif
 
     //
     // Block until all buffered steps are executed
     //
-    void synchronize();
+    static void synchronize();
 
     //
     // Set the current position in steps
     //
-    void set_position(const long& x, const long& y, const long& z, const long& e);
-    void set_e_position(const long& e);
+    static void set_position(const long& x, const long& y, const long& z, const long& e);
+    static void set_e_position(const long& e);
 
     //
     // Set direction bits for all steppers
     //
-    void set_directions();
+    static void set_directions();
 
     //
     // Get the position of a stepper, in steps
     //
-    long position(AxisEnum axis);
+    static long position(AxisEnum axis);
 
     //
     // Report the positions of the steppers, in steps
     //
-    void report_positions();
+    static void report_positions();
 
     //
     // Get the position (mm) of an axis based on stepper position(s)
     //
-    float get_axis_position_mm(AxisEnum axis);
+    static float get_axis_position_mm(AxisEnum axis);
 
     //
     // The stepper subsystem goes to sleep when it runs out of things to execute. Call this
     // to notify the subsystem that it is time to go to work.
     //
-    void wake_up();
+    static void wake_up();
 
     //
     // Wait for moves to finish and disable all steppers
     //
-    void finish_and_disable();
+    static void finish_and_disable();
 
     //
     // Quickly stop all steppers and clear the blocks queue
     //
-    void quick_stop();
+    static void quick_stop();
 
     //
     // The direction of a single motor
     //
-    FORCE_INLINE bool motor_direction(AxisEnum axis) { return TEST(last_direction_bits, axis); }
+    static FORCE_INLINE bool motor_direction(AxisEnum axis) { return TEST(last_direction_bits, axis); }
 
     #if HAS_DIGIPOTSS
-      void digitalPotWrite(int address, int value);
+      static void digitalPotWrite(int address, int value);
     #endif
-    void microstep_ms(uint8_t driver, int8_t ms1, int8_t ms2);
-    void digipot_current(uint8_t driver, int current);
-    void microstep_mode(uint8_t driver, uint8_t stepping);
-    void microstep_readings();
+    static void microstep_ms(uint8_t driver, int8_t ms1, int8_t ms2);
+    static void digipot_current(uint8_t driver, int current);
+    static void microstep_mode(uint8_t driver, uint8_t stepping);
+    static void microstep_readings();
 
     #if ENABLED(Z_DUAL_ENDSTOPS)
-      FORCE_INLINE void set_homing_flag(bool state) { performing_homing = state; }
-      FORCE_INLINE void set_z_lock(bool state) { locked_z_motor = state; }
-      FORCE_INLINE void set_z2_lock(bool state) { locked_z2_motor = state; }
+      static FORCE_INLINE void set_homing_flag(bool state) { performing_homing = state; }
+      static FORCE_INLINE void set_z_lock(bool state) { locked_z_motor = state; }
+      static FORCE_INLINE void set_z2_lock(bool state) { locked_z2_motor = state; }
     #endif
 
     #if ENABLED(BABYSTEPPING)
-      void babystep(const uint8_t axis, const bool direction); // perform a short step with a single stepper motor, outside of any convention
+      static void babystep(const uint8_t axis, const bool direction); // perform a short step with a single stepper motor, outside of any convention
     #endif
 
-    inline void kill_current_block() {
+    static inline void kill_current_block() {
       step_events_completed = current_block->step_event_count;
     }
 
     //
     // Handle a triggered endstop
     //
-    void endstop_triggered(AxisEnum axis);
+    static void endstop_triggered(AxisEnum axis);
 
     //
     // Triggered position of an axis in mm (not core-savvy)
     //
-    FORCE_INLINE float triggered_position_mm(AxisEnum axis) {
+    static FORCE_INLINE float triggered_position_mm(AxisEnum axis) {
       return endstops_trigsteps[axis] / planner.axis_steps_per_unit[axis];
     }
 
   private:
 
-    FORCE_INLINE unsigned short calc_timer(unsigned short step_rate) {
+    static FORCE_INLINE unsigned short calc_timer(unsigned short step_rate) {
       unsigned short timer;
 
       NOMORE(step_rate, MAX_STEP_FREQUENCY);
@@ -283,13 +280,17 @@ class Stepper {
         timer = (unsigned short)pgm_read_word_near(table_address);
         timer -= (((unsigned short)pgm_read_word_near(table_address + 2) * (unsigned char)(step_rate & 0x0007)) >> 3);
       }
-      if (timer < 100) { timer = 100; MYSERIAL.print(MSG_STEPPER_TOO_HIGH); MYSERIAL.println(step_rate); }//(20kHz this should never happen)
+      if (timer < 100) { // (20kHz - this should never happen)
+        timer = 100;
+        MYSERIAL.print(MSG_STEPPER_TOO_HIGH);
+        MYSERIAL.println(step_rate);
+      }
       return timer;
     }
 
     // Initializes the trapezoid generator from the current block. Called whenever a new
     // block begins.
-    FORCE_INLINE void trapezoid_generator_reset() {
+    static FORCE_INLINE void trapezoid_generator_reset() {
 
       static int8_t last_extruder = -1;
 
@@ -326,8 +327,8 @@ class Stepper {
       // SERIAL_ECHOLN(current_block->final_advance/256.0);
     }
 
-    void digipot_init();
-    void microstep_init();
+    static void digipot_init();
+    static void microstep_init();
 
 };
 
diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index 07299a3..02766f8 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -48,6 +48,145 @@
 
 Temperature thermalManager;
 
+// public:
+
+int Temperature::current_temperature_raw[EXTRUDERS] = { 0 };
+float Temperature::current_temperature[EXTRUDERS] = { 0.0 };
+int Temperature::target_temperature[EXTRUDERS] = { 0 };
+
+int Temperature::current_temperature_bed_raw = 0;
+float Temperature::current_temperature_bed = 0.0;
+int Temperature::target_temperature_bed = 0;
+
+#if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
+  float Temperature::redundant_temperature = 0.0;
+#endif
+
+unsigned char Temperature::soft_pwm_bed;
+
+#if ENABLED(FAN_SOFT_PWM)
+  unsigned char Temperature::fanSpeedSoftPwm[FAN_COUNT];
+#endif
+
+#if ENABLED(PIDTEMP)
+  #if ENABLED(PID_PARAMS_PER_EXTRUDER)
+    float Temperature::Kp[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(DEFAULT_Kp),
+          Temperature::Ki[EXTRUDERS] = ARRAY_BY_EXTRUDERS1((DEFAULT_Ki) * (PID_dT)),
+          Temperature::Kd[EXTRUDERS] = ARRAY_BY_EXTRUDERS1((DEFAULT_Kd) / (PID_dT));
+    #if ENABLED(PID_ADD_EXTRUSION_RATE)
+      float Temperature::Kc[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(DEFAULT_Kc);
+    #endif
+  #else
+    float Temperature::Kp = DEFAULT_Kp,
+          Temperature::Ki = (DEFAULT_Ki) * (PID_dT),
+          Temperature::Kd = (DEFAULT_Kd) / (PID_dT);
+    #if ENABLED(PID_ADD_EXTRUSION_RATE)
+      float Temperature::Kc = DEFAULT_Kc;
+    #endif
+  #endif
+#endif
+
+#if ENABLED(PIDTEMPBED)
+  float Temperature::bedKp = DEFAULT_bedKp,
+        Temperature::bedKi = ((DEFAULT_bedKi) * PID_dT),
+        Temperature::bedKd = ((DEFAULT_bedKd) / PID_dT);
+#endif
+
+#if ENABLED(BABYSTEPPING)
+  volatile int Temperature::babystepsTodo[3] = { 0 };
+#endif
+
+#if ENABLED(THERMAL_PROTECTION_HOTENDS) && WATCH_TEMP_PERIOD > 0
+  int Temperature::watch_target_temp[EXTRUDERS] = { 0 };
+  millis_t Temperature::watch_heater_next_ms[EXTRUDERS] = { 0 };
+#endif
+
+#if ENABLED(THERMAL_PROTECTION_HOTENDS) && WATCH_BED_TEMP_PERIOD > 0
+  int Temperature::watch_target_bed_temp = 0;
+  millis_t Temperature::watch_bed_next_ms = 0;
+#endif
+
+#if ENABLED(PREVENT_DANGEROUS_EXTRUDE)
+  float Temperature::extrude_min_temp = EXTRUDE_MINTEMP;
+#endif
+
+// private:
+
+#if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
+  int Temperature::redundant_temperature_raw = 0;
+  float Temperature::redundant_temperature = 0.0;
+#endif
+
+volatile bool Temperature::temp_meas_ready = false;
+
+#if ENABLED(PIDTEMP)
+  float Temperature::temp_iState[EXTRUDERS] = { 0 };
+  float Temperature::temp_dState[EXTRUDERS] = { 0 };
+  float Temperature::pTerm[EXTRUDERS];
+  float Temperature::iTerm[EXTRUDERS];
+  float Temperature::dTerm[EXTRUDERS];
+
+  #if ENABLED(PID_ADD_EXTRUSION_RATE)
+    float Temperature::cTerm[EXTRUDERS];
+    long Temperature::last_position[EXTRUDERS];
+    long Temperature::lpq[LPQ_MAX_LEN];
+    int Temperature::lpq_ptr = 0;
+  #endif
+
+  float Temperature::pid_error[EXTRUDERS];
+  float Temperature::temp_iState_min[EXTRUDERS];
+  float Temperature::temp_iState_max[EXTRUDERS];
+  bool Temperature::pid_reset[EXTRUDERS];
+#endif
+
+#if ENABLED(PIDTEMPBED)
+  float Temperature::temp_iState_bed = { 0 };
+  float Temperature::temp_dState_bed = { 0 };
+  float Temperature::pTerm_bed;
+  float Temperature::iTerm_bed;
+  float Temperature::dTerm_bed;
+  float Temperature::pid_error_bed;
+  float Temperature::temp_iState_min_bed;
+  float Temperature::temp_iState_max_bed;
+#else
+  millis_t Temperature::next_bed_check_ms;
+#endif
+
+unsigned long Temperature::raw_temp_value[4] = { 0 };
+unsigned long Temperature::raw_temp_bed_value = 0;
+
+// Init min and max temp with extreme values to prevent false errors during startup
+int Temperature::minttemp_raw[EXTRUDERS] = ARRAY_BY_EXTRUDERS(HEATER_0_RAW_LO_TEMP , HEATER_1_RAW_LO_TEMP , HEATER_2_RAW_LO_TEMP, HEATER_3_RAW_LO_TEMP);
+int Temperature::maxttemp_raw[EXTRUDERS] = ARRAY_BY_EXTRUDERS(HEATER_0_RAW_HI_TEMP , HEATER_1_RAW_HI_TEMP , HEATER_2_RAW_HI_TEMP, HEATER_3_RAW_HI_TEMP);
+int Temperature::minttemp[EXTRUDERS] = { 0 };
+int Temperature::maxttemp[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(16383);
+
+#ifdef BED_MINTEMP
+  int Temperature::bed_minttemp_raw = HEATER_BED_RAW_LO_TEMP;
+#endif
+
+#ifdef BED_MAXTEMP
+  int Temperature::bed_maxttemp_raw = HEATER_BED_RAW_HI_TEMP;
+#endif
+
+#if ENABLED(FILAMENT_WIDTH_SENSOR)
+  int Temperature::meas_shift_index;  // Index of a delayed sample in buffer
+#endif
+
+#if HAS_AUTO_FAN
+  millis_t Temperature::next_auto_fan_check_ms;
+#endif
+
+unsigned char Temperature::soft_pwm[EXTRUDERS];
+
+#if ENABLED(FAN_SOFT_PWM)
+  unsigned char Temperature::soft_pwm_fan[FAN_COUNT];
+#endif
+
+#if ENABLED(FILAMENT_WIDTH_SENSOR)
+  int Temperature::current_raw_filwidth = 0;  //Holds measured filament diameter - one extruder only
+#endif
+
 #if HAS_PID_HEATING
 
   void Temperature::PID_autotune(float temp, int extruder, int ncycles, bool set_result/*=false*/) {
@@ -283,31 +422,9 @@ Temperature thermalManager;
 
 #endif // HAS_PID_HEATING
 
-#if ENABLED(PIDTEMP)
-
-  #if ENABLED(PID_PARAMS_PER_EXTRUDER)
-
-    float Temperature::Kp[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(DEFAULT_Kp),
-          Temperature::Ki[EXTRUDERS] = ARRAY_BY_EXTRUDERS1((DEFAULT_Ki) * (PID_dT)),
-          Temperature::Kd[EXTRUDERS] = ARRAY_BY_EXTRUDERS1((DEFAULT_Kd) / (PID_dT));
-
-    #if ENABLED(PID_ADD_EXTRUSION_RATE)
-      float Temperature::Kc[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(DEFAULT_Kc);
-    #endif
-
-  #else
-
-    float Temperature::Kp = DEFAULT_Kp,
-          Temperature::Ki = (DEFAULT_Ki) * (PID_dT),
-          Temperature::Kd = (DEFAULT_Kd) / (PID_dT);
-
-    #if ENABLED(PID_ADD_EXTRUSION_RATE)
-      float Temperature::Kc = DEFAULT_Kc;
-    #endif
-
-  #endif
-
-#endif
+/**
+ * Class and Instance Methods
+ */
 
 Temperature::Temperature() { }
 
@@ -1045,7 +1162,17 @@ void Temperature::init() {
 
 #if ENABLED(THERMAL_PROTECTION_HOTENDS) || HAS_THERMALLY_PROTECTED_BED
 
-  void Temperature::thermal_runaway_protection(TRState* state, millis_t* timer, float temperature, float target_temperature, int heater_id, int period_seconds, int hysteresis_degc) {
+  #if ENABLED(THERMAL_PROTECTION_HOTENDS)
+    Temperature::TRState Temperature::thermal_runaway_state_machine[EXTRUDERS] = { TRInactive };
+    millis_t Temperature::thermal_runaway_timer[EXTRUDERS] = { 0 };
+  #endif
+
+  #if HAS_THERMALLY_PROTECTED_BED
+    Temperature::TRState Temperature::thermal_runaway_bed_state_machine = TRInactive;
+    millis_t Temperature::thermal_runaway_bed_timer;
+  #endif
+
+  void Temperature::thermal_runaway_protection(Temperature::TRState* state, millis_t* timer, float temperature, float target_temperature, int heater_id, int period_seconds, int hysteresis_degc) {
 
     static float tr_target_temperature[EXTRUDERS + 1] = { 0.0 };
 
@@ -1242,7 +1369,7 @@ void Temperature::set_current_temp_raw() {
  *  - Check new temperature values for MIN/MAX errors
  *  - Step the babysteps value for each axis towards 0
  */
-ISR(TIMER0_COMPB_vect) { thermalManager.isr(); }
+ISR(TIMER0_COMPB_vect) { Temperature::isr(); }
 
 void Temperature::isr() {
 
diff --git a/Marlin/temperature.h b/Marlin/temperature.h
index 1e9276a..cb57107 100644
--- a/Marlin/temperature.h
+++ b/Marlin/temperature.h
@@ -42,22 +42,22 @@ class Temperature {
 
   public:
 
-    int current_temperature_raw[EXTRUDERS] = { 0 };
-    float current_temperature[EXTRUDERS] = { 0.0 };
-    int target_temperature[EXTRUDERS] = { 0 };
+    static int current_temperature_raw[EXTRUDERS];
+    static float current_temperature[EXTRUDERS];
+    static int target_temperature[EXTRUDERS];
 
-    int current_temperature_bed_raw = 0;
-    float current_temperature_bed = 0.0;
-    int target_temperature_bed = 0;
+    static int current_temperature_bed_raw;
+    static float current_temperature_bed;
+    static int target_temperature_bed;
 
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-      float redundant_temperature = 0.0;
+      static float redundant_temperature;
     #endif
 
-    unsigned char soft_pwm_bed;
+    static unsigned char soft_pwm_bed;
 
     #if ENABLED(FAN_SOFT_PWM)
-      unsigned char fanSpeedSoftPwm[FAN_COUNT];
+      static unsigned char fanSpeedSoftPwm[FAN_COUNT];
     #endif
 
     #if ENABLED(PIDTEMP) || ENABLED(PIDTEMPBED)
@@ -70,7 +70,7 @@ class Temperature {
 
         static float Kp[EXTRUDERS], Ki[EXTRUDERS], Kd[EXTRUDERS];
         #if ENABLED(PID_ADD_EXTRUSION_RATE)
-          float Kc[EXTRUDERS];
+          static float Kc[EXTRUDERS];
         #endif
         #define PID_PARAM(param, e) Temperature::param[e]
 
@@ -93,118 +93,110 @@ class Temperature {
     #endif
 
     #if ENABLED(PIDTEMPBED)
-      float bedKp = DEFAULT_bedKp,
-            bedKi = ((DEFAULT_bedKi) * PID_dT),
-            bedKd = ((DEFAULT_bedKd) / PID_dT);
+      static float bedKp, bedKi, bedKd;
     #endif
 
     #if ENABLED(BABYSTEPPING)
-      volatile int babystepsTodo[3] = { 0 };
+      static volatile int babystepsTodo[3];
     #endif
 
     #if ENABLED(THERMAL_PROTECTION_HOTENDS) && WATCH_TEMP_PERIOD > 0
-      int watch_target_temp[EXTRUDERS] = { 0 };
-      millis_t watch_heater_next_ms[EXTRUDERS] = { 0 };
+      static int watch_target_temp[EXTRUDERS];
+      static millis_t watch_heater_next_ms[EXTRUDERS];
     #endif
 
     #if ENABLED(THERMAL_PROTECTION_HOTENDS) && WATCH_BED_TEMP_PERIOD > 0
-      int watch_target_bed_temp = 0;
-      millis_t watch_bed_next_ms = 0;
+      static int watch_target_bed_temp;
+      static millis_t watch_bed_next_ms;
     #endif
 
     #if ENABLED(PREVENT_DANGEROUS_EXTRUDE)
-      float extrude_min_temp = EXTRUDE_MINTEMP;
-      FORCE_INLINE bool tooColdToExtrude(uint8_t e) { return degHotend(e) < extrude_min_temp; }
+      static float extrude_min_temp;
+      static bool tooColdToExtrude(uint8_t e) { return degHotend(e) < extrude_min_temp; }
     #else
-      FORCE_INLINE bool tooColdToExtrude(uint8_t e) { UNUSED(e); return false; }
+      static bool tooColdToExtrude(uint8_t e) { UNUSED(e); return false; }
     #endif
 
   private:
 
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-      int redundant_temperature_raw = 0;
-      float redundant_temperature = 0.0;
+      static int redundant_temperature_raw;
+      static float redundant_temperature;
     #endif
 
-    volatile bool temp_meas_ready = false;
+    static volatile bool temp_meas_ready;
 
     #if ENABLED(PIDTEMP)
-      float temp_iState[EXTRUDERS] = { 0 };
-      float temp_dState[EXTRUDERS] = { 0 };
-      float pTerm[EXTRUDERS];
-      float iTerm[EXTRUDERS];
-      float dTerm[EXTRUDERS];
+      static float temp_iState[EXTRUDERS];
+      static float temp_dState[EXTRUDERS];
+      static float pTerm[EXTRUDERS];
+      static float iTerm[EXTRUDERS];
+      static float dTerm[EXTRUDERS];
 
       #if ENABLED(PID_ADD_EXTRUSION_RATE)
-        float cTerm[EXTRUDERS];
-        long last_position[EXTRUDERS];
-        long lpq[LPQ_MAX_LEN];
-        int lpq_ptr = 0;
+        static float cTerm[EXTRUDERS];
+        static long last_position[EXTRUDERS];
+        static long lpq[LPQ_MAX_LEN];
+        static int lpq_ptr;
       #endif
 
-      float pid_error[EXTRUDERS];
-      float temp_iState_min[EXTRUDERS];
-      float temp_iState_max[EXTRUDERS];
-      bool pid_reset[EXTRUDERS];
+      static float pid_error[EXTRUDERS];
+      static float temp_iState_min[EXTRUDERS];
+      static float temp_iState_max[EXTRUDERS];
+      static bool pid_reset[EXTRUDERS];
     #endif
 
     #if ENABLED(PIDTEMPBED)
-      float temp_iState_bed = { 0 };
-      float temp_dState_bed = { 0 };
-      float pTerm_bed;
-      float iTerm_bed;
-      float dTerm_bed;
-      float pid_error_bed;
-      float temp_iState_min_bed;
-      float temp_iState_max_bed;
+      static float temp_iState_bed;
+      static float temp_dState_bed;
+      static float pTerm_bed;
+      static float iTerm_bed;
+      static float dTerm_bed;
+      static float pid_error_bed;
+      static float temp_iState_min_bed;
+      static float temp_iState_max_bed;
     #else
-      millis_t next_bed_check_ms;
+      static millis_t next_bed_check_ms;
     #endif
 
-    unsigned long raw_temp_value[4] = { 0 };
-    unsigned long raw_temp_bed_value = 0;
+    static unsigned long raw_temp_value[4];
+    static unsigned long raw_temp_bed_value;
 
     // Init min and max temp with extreme values to prevent false errors during startup
-    int minttemp_raw[EXTRUDERS] = ARRAY_BY_EXTRUDERS(HEATER_0_RAW_LO_TEMP , HEATER_1_RAW_LO_TEMP , HEATER_2_RAW_LO_TEMP, HEATER_3_RAW_LO_TEMP);
-    int maxttemp_raw[EXTRUDERS] = ARRAY_BY_EXTRUDERS(HEATER_0_RAW_HI_TEMP , HEATER_1_RAW_HI_TEMP , HEATER_2_RAW_HI_TEMP, HEATER_3_RAW_HI_TEMP);
-    int minttemp[EXTRUDERS] = { 0 };
-    int maxttemp[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(16383);
+    static int minttemp_raw[EXTRUDERS];
+    static int maxttemp_raw[EXTRUDERS];
+    static int minttemp[EXTRUDERS];
+    static int maxttemp[EXTRUDERS];
 
     #ifdef BED_MINTEMP
-      int bed_minttemp_raw = HEATER_BED_RAW_LO_TEMP;
+      static int bed_minttemp_raw;
     #endif
 
     #ifdef BED_MAXTEMP
-      int bed_maxttemp_raw = HEATER_BED_RAW_HI_TEMP;
+      static int bed_maxttemp_raw;
     #endif
 
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
-      int meas_shift_index;  // Index of a delayed sample in buffer
+      static int meas_shift_index;  // Index of a delayed sample in buffer
     #endif
 
     #if HAS_AUTO_FAN
-      millis_t next_auto_fan_check_ms;
+      static millis_t next_auto_fan_check_ms;
     #endif
 
-    unsigned char soft_pwm[EXTRUDERS];
+    static unsigned char soft_pwm[EXTRUDERS];
 
     #if ENABLED(FAN_SOFT_PWM)
-      unsigned char soft_pwm_fan[FAN_COUNT];
+      static unsigned char soft_pwm_fan[FAN_COUNT];
     #endif
 
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
-      int current_raw_filwidth = 0;  //Holds measured filament diameter - one extruder only
+      static int current_raw_filwidth;  //Holds measured filament diameter - one extruder only
     #endif
 
   public:
 
     /**
-     * Static (class) methods
-     */
-    static float analog2temp(int raw, uint8_t e);
-    static float analog2tempBed(int raw);
-
-    /**
      * Instance Methods
      */
 
@@ -213,18 +205,24 @@ class Temperature {
     void init();
 
     /**
+     * Static (class) methods
+     */
+    static float analog2temp(int raw, uint8_t e);
+    static float analog2tempBed(int raw);
+
+    /**
      * Called from the Temperature ISR
      */
-    void isr();
+    static void isr();
 
     /**
      * Call periodically to manage heaters
      */
-    void manage_heater();
+    static void manage_heater();
 
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
-      float analog2widthFil(); // Convert raw Filament Width to millimeters
-      int widthFil_to_size_ratio(); // Convert raw Filament Width to an extrusion ratio
+      static float analog2widthFil(); // Convert raw Filament Width to millimeters
+      static int widthFil_to_size_ratio(); // Convert raw Filament Width to an extrusion ratio
     #endif
 
 
@@ -232,68 +230,68 @@ class Temperature {
     //inline so that there is no performance decrease.
     //deg=degreeCelsius
 
-    FORCE_INLINE float degHotend(uint8_t extruder) { return current_temperature[extruder]; }
-    FORCE_INLINE float degBed() { return current_temperature_bed; }
+    static float degHotend(uint8_t extruder) { return current_temperature[extruder]; }
+    static float degBed() { return current_temperature_bed; }
 
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
-    FORCE_INLINE float rawHotendTemp(uint8_t extruder) { return current_temperature_raw[extruder]; }
-    FORCE_INLINE float rawBedTemp() { return current_temperature_bed_raw; }
+    static float rawHotendTemp(uint8_t extruder) { return current_temperature_raw[extruder]; }
+    static float rawBedTemp() { return current_temperature_bed_raw; }
     #endif
 
-    FORCE_INLINE float degTargetHotend(uint8_t extruder) { return target_temperature[extruder]; }
-    FORCE_INLINE float degTargetBed() { return target_temperature_bed; }
+    static float degTargetHotend(uint8_t extruder) { return target_temperature[extruder]; }
+    static float degTargetBed() { return target_temperature_bed; }
 
     #if ENABLED(THERMAL_PROTECTION_HOTENDS) && WATCH_TEMP_PERIOD > 0
-      void start_watching_heater(int e = 0);
+      static void start_watching_heater(int e = 0);
     #endif
 
     #if ENABLED(THERMAL_PROTECTION_BED) && WATCH_BED_TEMP_PERIOD > 0
-      void start_watching_bed();
+      static void start_watching_bed();
     #endif
 
-    FORCE_INLINE void setTargetHotend(const float& celsius, uint8_t extruder) {
+    static void setTargetHotend(const float& celsius, uint8_t extruder) {
       target_temperature[extruder] = celsius;
       #if ENABLED(THERMAL_PROTECTION_HOTENDS) && WATCH_TEMP_PERIOD > 0
         start_watching_heater(extruder);
       #endif
     }
 
-    FORCE_INLINE void setTargetBed(const float& celsius) {
+    static void setTargetBed(const float& celsius) {
       target_temperature_bed = celsius;
       #if ENABLED(THERMAL_PROTECTION_BED) && WATCH_BED_TEMP_PERIOD > 0
         start_watching_bed();
       #endif
     }
 
-    FORCE_INLINE bool isHeatingHotend(uint8_t extruder) { return target_temperature[extruder] > current_temperature[extruder]; }
-    FORCE_INLINE bool isHeatingBed() { return target_temperature_bed > current_temperature_bed; }
+    static bool isHeatingHotend(uint8_t extruder) { return target_temperature[extruder] > current_temperature[extruder]; }
+    static bool isHeatingBed() { return target_temperature_bed > current_temperature_bed; }
 
-    FORCE_INLINE bool isCoolingHotend(uint8_t extruder) { return target_temperature[extruder] < current_temperature[extruder]; }
-    FORCE_INLINE bool isCoolingBed() { return target_temperature_bed < current_temperature_bed; }
+    static bool isCoolingHotend(uint8_t extruder) { return target_temperature[extruder] < current_temperature[extruder]; }
+    static bool isCoolingBed() { return target_temperature_bed < current_temperature_bed; }
 
     /**
      * The software PWM power for a heater
      */
-    int getHeaterPower(int heater);
+    static int getHeaterPower(int heater);
 
     /**
      * Switch off all heaters, set all target temperatures to 0
      */
-    void disable_all_heaters();
+    static void disable_all_heaters();
 
     /**
      * Perform auto-tuning for hotend or bed in response to M303
      */
     #if HAS_PID_HEATING
-      void PID_autotune(float temp, int extruder, int ncycles, bool set_result=false);
+      static void PID_autotune(float temp, int extruder, int ncycles, bool set_result=false);
     #endif
 
     /**
      * Update the temp manager when PID values change
      */
-    void updatePID();
+    static void updatePID();
 
-    FORCE_INLINE void autotempShutdown() {
+    static void autotempShutdown() {
       #if ENABLED(AUTOTEMP)
         if (planner.autotemp_enabled) {
           planner.autotemp_enabled = false;
@@ -305,7 +303,7 @@ class Temperature {
 
     #if ENABLED(BABYSTEPPING)
 
-      FORCE_INLINE void babystep_axis(AxisEnum axis, int distance) {
+      static void babystep_axis(AxisEnum axis, int distance) {
         #if ENABLED(COREXY) || ENABLED(COREXZ) || ENABLED(COREYZ)
           #if ENABLED(BABYSTEP_XY)
             switch (axis) {
@@ -337,40 +335,40 @@ class Temperature {
 
   private:
 
-    void set_current_temp_raw();
+    static void set_current_temp_raw();
 
-    void updateTemperaturesFromRawValues();
+    static void updateTemperaturesFromRawValues();
 
     #if ENABLED(HEATER_0_USES_MAX6675)
-      int read_max6675();
+      static int read_max6675();
     #endif
 
-    void checkExtruderAutoFans();
+    static void checkExtruderAutoFans();
 
-    float get_pid_output(int e);
+    static float get_pid_output(int e);
 
     #if ENABLED(PIDTEMPBED)
-      float get_pid_output_bed();
+      static float get_pid_output_bed();
     #endif
 
-    void _temp_error(int e, const char* serial_msg, const char* lcd_msg);
-    void min_temp_error(uint8_t e);
-    void max_temp_error(uint8_t e);
+    static void _temp_error(int e, const char* serial_msg, const char* lcd_msg);
+    static void min_temp_error(uint8_t e);
+    static void max_temp_error(uint8_t e);
 
     #if ENABLED(THERMAL_PROTECTION_HOTENDS) || HAS_THERMALLY_PROTECTED_BED
 
       typedef enum TRState { TRInactive, TRFirstHeating, TRStable, TRRunaway } TRstate;
 
-      void thermal_runaway_protection(TRState* state, millis_t* timer, float temperature, float target_temperature, int heater_id, int period_seconds, int hysteresis_degc);
+      static void thermal_runaway_protection(TRState* state, millis_t* timer, float temperature, float target_temperature, int heater_id, int period_seconds, int hysteresis_degc);
 
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
-        TRState thermal_runaway_state_machine[EXTRUDERS] = { TRInactive };
-        millis_t thermal_runaway_timer[EXTRUDERS] = { 0 };
+        static TRState thermal_runaway_state_machine[EXTRUDERS];
+        static millis_t thermal_runaway_timer[EXTRUDERS];
       #endif
 
       #if HAS_THERMALLY_PROTECTED_BED
-        TRState thermal_runaway_bed_state_machine = TRInactive;
-        millis_t thermal_runaway_bed_timer;
+        static TRState thermal_runaway_bed_state_machine;
+        static millis_t thermal_runaway_bed_timer;
       #endif
 
     #endif // THERMAL_PROTECTION
diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
index 605bdf8..94a1e3f 100644
--- a/Marlin/ultralcd.cpp
+++ b/Marlin/ultralcd.cpp
@@ -482,6 +482,10 @@ inline void line_to_current(AxisEnum axis) {
 
   static void lcd_sdcard_stop() {
     stepper.quick_stop();
+    #if DISABLED(DELTA) && DISABLED(SCARA)
+      set_current_position_from_planner();
+    #endif
+    clear_command_queue();
     card.sdprinting = false;
     card.closefile();
     print_job_timer.stop();
@@ -1037,7 +1041,7 @@ void lcd_cooldown() {
     if (LCD_CLICKED) {
       _lcd_level_bed_position = 0;
       current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;
-      planner.set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+      planner.set_position_mm(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
       lcd_goto_menu(_lcd_level_goto_next_point, true);
     }
   }

