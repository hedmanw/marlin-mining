commit 5fd4582cc8b25b9569ff43917b60469ca03193ce (from 8b88e3b386e04491183c7ad6f64b33a51faba688)
Merge: 8b88e3b be1e099
Author: daid <daid303@gmail.com>
Date:   Tue Jan 8 03:29:20 2013 -0800

    Merge pull request #242 from Drakelive/Marlin_v1
    
    Fixes issues # 216 and # 135 for Gen6 and Gen6 Deluxe board

diff --git a/Marlin/Boards/boards.txt b/Marlin/Boards/boards.txt
new file mode 100644
index 0000000..327d8d1
--- /dev/null
+++ b/Marlin/Boards/boards.txt
@@ -0,0 +1,35 @@
+##############################################################
+
+Generation_Series.name=Gen6 & Gen6 Deluxe 
+Generation_Series.upload.protocol=stk500
+Generation_Series.upload.maximum_size=63488
+Generation_Series.upload.speed=38400
+Generation_Series.bootloader.low_fuses=0xFF
+Generation_Series.bootloader.high_fuses=0xDC
+Generation_Series.bootloader.extended_fuses=0xFD
+Generation_Series.bootloader.path=atmega644p
+Generation_Series.bootloader.file=ATmegaBOOT_644P.hex
+Generation_Series.bootloader.unlock_bits=0x3F
+Generation_Series.bootloader.lock_bits=0x0F
+Generation_Series.build.mcu=atmega644p
+Generation_Series.build.f_cpu=16000000L
+Generation_Series.build.core=arduino
+
+
+##############################################################
+
+
+Sanguinololu.name=Sanguinololu 1.2 and above
+Sanguinololu.upload.protocol=stk500
+Sanguinololu.upload.maximum_size=63488
+Sanguinololu.upload.speed=38400
+Sanguinololu.bootloader.low_fuses=0xFF
+Sanguinololu.bootloader.high_fuses=0xDC
+Sanguinololu.bootloader.extended_fuses=0xFD
+Sanguinololu.bootloader.path=atmega644p
+Sanguinololu.bootloader.file=ATmegaBOOT_644P.hex
+Sanguinololu.bootloader.unlock_bits=0x3F
+Sanguinololu.bootloader.lock_bits=0x0F
+Sanguinololu.build.mcu=atmega644p
+Sanguinololu.build.f_cpu=16000000L
+Sanguinololu.build.core=arduino
diff --git a/Marlin/Boards/bootloaders/atmega644p/ATmegaBOOT.c b/Marlin/Boards/bootloaders/atmega644p/ATmegaBOOT.c
new file mode 100644
index 0000000..1711014
--- /dev/null
+++ b/Marlin/Boards/bootloaders/atmega644p/ATmegaBOOT.c
@@ -0,0 +1,713 @@
+/**********************************************************/
+/* Serial Bootloader for Atmel megaAVR Controllers        */
+/*                                                        */
+/* tested with ATmega644 and ATmega644P                   */
+/* should work with other mega's, see code for details    */
+/*                                                        */
+/* ATmegaBOOT.c                                           */
+/*                                                        */
+/* 20090131: Added 324P support from Alex Leone           */
+/*           Marius Kintel                                */
+/* 20080915: applied ADABoot mods for Sanguino 644P       */
+/*           Brian Riley                                  */
+/* 20080711: hacked for Sanguino by Zach Smith            */
+/*           and Justin Day                               */
+/* 20070626: hacked for Arduino Diecimila (which auto-    */
+/*           resets when a USB connection is made to it)  */
+/*           by D. Mellis                                 */
+/* 20060802: hacked for Arduino by D. Cuartielles         */
+/*           based on a previous hack by D. Mellis        */
+/*           and D. Cuartielles                           */
+/*                                                        */
+/* Monitor and debug functions were added to the original */
+/* code by Dr. Erik Lins, chip45.com. (See below)         */
+/*                                                        */
+/* Thanks to Karl Pitrich for fixing a bootloader pin     */
+/* problem and more informative LED blinking!             */
+/*                                                        */
+/* For the latest version see:                            */
+/* http://www.chip45.com/                                 */
+/*                                                        */
+/* ------------------------------------------------------ */
+/*                                                        */
+/* based on stk500boot.c                                  */
+/* Copyright (c) 2003, Jason P. Kyle                      */
+/* All rights reserved.                                   */
+/* see avr1.org for original file and information         */
+/*                                                        */
+/* This program is free software; you can redistribute it */
+/* and/or modify it under the terms of the GNU General    */
+/* Public License as published by the Free Software       */
+/* Foundation; either version 2 of the License, or        */
+/* (at your option) any later version.                    */
+/*                                                        */
+/* This program is distributed in the hope that it will   */
+/* be useful, but WITHOUT ANY WARRANTY; without even the  */
+/* implied warranty of MERCHANTABILITY or FITNESS FOR A   */
+/* PARTICULAR PURPOSE.  See the GNU General Public        */
+/* License for more details.                              */
+/*                                                        */
+/* You should have received a copy of the GNU General     */
+/* Public License along with this program; if not, write  */
+/* to the Free Software Foundation, Inc.,                 */
+/* 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA */
+/*                                                        */
+/* Licence can be viewed at                               */
+/* http://www.fsf.org/licenses/gpl.txt                    */
+/*                                                        */
+/* Target = Atmel AVR m128,m64,m32,m16,m8,m162,m163,m169, */
+/* m8515,m8535. ATmega161 has a very small boot block so  */
+/* isn't supported.                                       */
+/*                                                        */
+/* Tested with m168                                       */
+/**********************************************************/
+
+/* $Id$ */
+
+
+/* some includes */
+#include <inttypes.h>
+#include <avr/io.h>
+#include <avr/pgmspace.h>
+#include <avr/interrupt.h>
+#include <avr/wdt.h>
+#include <avr/boot.h>
+
+#ifdef ADABOOT
+    #define NUM_LED_FLASHES 3
+    #define ADABOOT_VER	1
+#endif
+
+
+/* 20070707: hacked by David A. Mellis - after this many errors give up and launch application */
+#define MAX_ERROR_COUNT 5
+
+/* set the UART baud rate */
+/* 20080711: hack by Zach Hoeken */
+#define BAUD_RATE   38400
+
+/* SW_MAJOR and MINOR needs to be updated from time to time to avoid warning message from AVR Studio */
+/* never allow AVR Studio to do an update !!!! */
+#define HW_VER	 0x02
+#define SW_MAJOR 0x01
+#define SW_MINOR 0x10
+
+/* onboard LED is used to indicate, that the bootloader was entered (3x flashing) */
+/* if monitor functions are included, LED goes on after monitor was entered */
+#define LED_DDR  DDRB
+#define LED_PORT PORTB
+#define LED_PIN  PINB
+#define LED      PINB0
+
+/* define various device id's */
+/* manufacturer byte is always the same */
+#define SIG1	0x1E	// Yep, Atmel is the only manufacturer of AVR micros.  Single source :(
+#if defined(__AVR_ATmega644P__)
+#define SIG2	0x96
+#define SIG3	0x0A
+#elif defined(__AVR_ATmega644__)
+#define SIG2	0x96
+#define SIG3	0x09
+#elif defined(__AVR_ATmega324P__)
+#define SIG2	0x95
+#define SIG3	0x08
+#endif
+#define PAGE_SIZE		0x080U   //128 words
+#define PAGE_SIZE_BYTES	0x100U   //256 bytes
+
+/* function prototypes */
+void putch(char);
+char getch(void);
+void getNch(uint8_t);
+void byte_response(uint8_t);
+void nothing_response(void);
+char gethex(void);
+void puthex(char);
+void flash_led(uint8_t);
+
+/* some variables */
+union address_union
+{
+    uint16_t word;
+    uint8_t  byte[2];
+} address;
+
+union length_union
+{
+    uint16_t word;
+    uint8_t  byte[2];
+} length;
+
+struct flags_struct
+{
+    unsigned eeprom : 1;
+    unsigned rampz  : 1;
+} flags;
+
+uint8_t buff[256];
+
+uint8_t error_count = 0;
+uint8_t sreg;
+
+void (*app_start)(void) = 0x0000;
+
+/* main program starts here */
+int main(void)
+{
+    uint8_t ch,ch2;
+    uint16_t w;
+	uint16_t i;
+	
+    asm volatile("nop\n\t");
+
+#ifdef ADABOOT		// BBR/LF 10/8/2007 & 9/13/2008
+    ch = MCUSR;
+    MCUSR = 0;
+
+    WDTCSR |= _BV(WDCE) | _BV(WDE);
+    WDTCSR = 0;
+
+    // Check if the WDT was used to reset, in which case we dont bootload and skip straight to the code. woot.
+    if (! (ch &  _BV(EXTRF))) // if its a not an external reset...
+      app_start();  // skip bootloader
+#endif
+
+
+	//initialize our serial port.
+    UBRR0L = (uint8_t)(F_CPU/(BAUD_RATE*16L)-1);
+    UBRR0H = (F_CPU/(BAUD_RATE*16L)-1) >> 8;
+    UCSR0B = (1<<RXEN0) | (1<<TXEN0);
+    UCSR0C = (1<<UCSZ00) | (1<<UCSZ01);
+
+    /* Enable internal pull-up resistor on pin D0 (RX), in order
+    to supress line noise that prevents the bootloader from
+    timing out (DAM: 20070509) */
+    DDRD &= ~_BV(PIND0);
+    PORTD |= _BV(PIND0);
+
+    /* set LED pin as output */
+    LED_DDR |= _BV(LED);
+
+	    /* flash onboard LED to signal entering of bootloader                   */
+	    /* ADABOOT will do two series of flashes. first 4 - signifying ADABOOT  */
+	    /* then a pause and another flash series signifying ADABOOT sub-version */
+
+
+	flash_led(NUM_LED_FLASHES);
+
+	#ifdef	ADABOOT
+		flash_led(ADABOOT_VER);		// BBR 9/13/2008
+	#endif 
+
+    /* forever loop */
+    for (;;)
+	{
+		/* get character from UART */
+		ch = getch();
+
+		/* A bunch of if...else if... gives smaller code than switch...case ! */
+
+		/* Hello is anyone home ? */ 
+		if(ch=='0')
+		    nothing_response();
+
+
+		/* Request programmer ID */
+		/* Not using PROGMEM string due to boot block in m128 being beyond 64kB boundry  */
+		/* Would need to selectively manipulate RAMPZ, and it's only 9 characters anyway so who cares.  */
+		else if(ch=='1')
+		{
+		    if (getch() == ' ')
+			{
+				putch(0x14);
+				putch('A');
+				putch('V');
+				putch('R');
+				putch(' ');
+				putch('I');
+				putch('S');
+				putch('P');
+				putch(0x10);
+		    }
+			else
+			{
+				if (++error_count == MAX_ERROR_COUNT)
+				    app_start();
+		    }
+		}
+
+
+		/* AVR ISP/STK500 board commands  DON'T CARE so default nothing_response */
+		else if(ch=='@')
+		{
+		    ch2 = getch();
+		    if (ch2 > 0x85)
+				getch();
+		    nothing_response();
+		}
+
+
+		/* AVR ISP/STK500 board requests */
+		else if(ch=='A')
+		{
+		    ch2 = getch();
+		    if(ch2 == 0x80)
+				byte_response(HW_VER);		// Hardware version
+		    else if(ch2==0x81)
+				byte_response(SW_MAJOR);	// Software major version
+		    else if(ch2==0x82)
+				byte_response(SW_MINOR);	// Software minor version
+		    else if(ch2==0x98)
+				byte_response(0x03);		// Unknown but seems to be required by avr studio 3.56
+		    else
+				byte_response(0x00);		// Covers various unnecessary responses we don't care about
+		}
+
+
+		/* Device Parameters  DON'T CARE, DEVICE IS FIXED  */
+		else if(ch=='B')
+		{
+		    getNch(20);
+		    nothing_response();
+		}
+
+
+		/* Parallel programming stuff  DON'T CARE  */
+		else if(ch=='E')
+		{
+		    getNch(5);
+		    nothing_response();
+		}
+
+
+		/* Enter programming mode  */
+		else if(ch=='P')
+		{
+		    nothing_response();
+		}
+
+
+		/* Leave programming mode  */
+		else if(ch=='Q')
+		{
+		    nothing_response();
+#ifdef ADABOOT		
+			// autoreset via watchdog (sneaky!) BBR/LF 9/13/2008
+	  		WDTCSR = _BV(WDE);
+	  		while (1); // 16 ms
+#endif		
+		}
+
+
+		/* Erase device, don't care as we will erase one page at a time anyway.  */
+		else if(ch=='R')
+		{
+		    nothing_response();
+		}
+
+
+		/* Set address, little endian. EEPROM in bytes, FLASH in words  */
+		/* Perhaps extra address bytes may be added in future to support > 128kB FLASH.  */
+		/* This might explain why little endian was used here, big endian used everywhere else.  */
+		else if(ch=='U')
+		{
+		    address.byte[0] = getch();
+		    address.byte[1] = getch();
+		    nothing_response();
+		}
+
+
+		/* Universal SPI programming command, disabled.  Would be used for fuses and lock bits.  */
+		else if(ch=='V')
+		{
+		    getNch(4);
+		    byte_response(0x00);
+		}
+
+
+		/* Write memory, length is big endian and is in bytes  */
+		else if(ch=='d')
+		{
+		    length.byte[1] = getch();
+		    length.byte[0] = getch();
+	
+		    flags.eeprom = 0;
+		    if (getch() == 'E')
+				flags.eeprom = 1;
+
+			for (i=0; i<PAGE_SIZE; i++)
+				buff[i] = 0;
+		
+		    for (w = 0; w < length.word; w++)
+			{
+				// Store data in buffer, can't keep up with serial data stream whilst programming pages
+				buff[w] = getch();
+		    }
+	
+		    if (getch() == ' ')
+			{
+				if (flags.eeprom)
+				{		                
+					//Write to EEPROM one byte at a time
+				    for(w=0;w<length.word;w++)
+					{
+						while(EECR & (1<<EEPE));
+					
+						EEAR = (uint16_t)(void *)address.word;
+						EEDR = buff[w];
+						EECR |= (1<<EEMPE);
+						EECR |= (1<<EEPE);
+
+						address.word++;
+				    }			
+				}
+				else
+				{
+					//address * 2 -> byte location
+				    address.word = address.word << 1;
+			    
+					//Even up an odd number of bytes
+					if ((length.byte[0] & 0x01))
+						length.word++;
+				
+					// HACKME: EEPE used to be EEWE
+				    //Wait for previous EEPROM writes to complete
+					//while(bit_is_set(EECR,EEPE));
+					while(EECR & (1<<EEPE));
+				
+				    asm volatile(
+						 "clr	r17		\n\t"	//page_word_count
+						 "lds	r30,address	\n\t"	//Address of FLASH location (in bytes)
+						 "lds	r31,address+1	\n\t"
+						 "ldi	r28,lo8(buff)	\n\t"	//Start of buffer array in RAM
+						 "ldi	r29,hi8(buff)	\n\t"
+						 "lds	r24,length	\n\t"	//Length of data to be written (in bytes)
+						 "lds	r25,length+1	\n\t"
+						 "length_loop:		\n\t"	//Main loop, repeat for number of words in block							 							 
+						 "cpi	r17,0x00	\n\t"	//If page_word_count=0 then erase page
+						 "brne	no_page_erase	\n\t"						 
+						 "wait_spm1:		\n\t"
+						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+						 "andi	r16,1           \n\t"
+						 "cpi	r16,1           \n\t"
+						 "breq	wait_spm1       \n\t"
+						 "ldi	r16,0x03	\n\t"	//Erase page pointed to by Z
+						 "sts	%0,r16		\n\t"
+						 "spm			\n\t"							 
+						 "wait_spm2:		\n\t"
+						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+						 "andi	r16,1           \n\t"
+						 "cpi	r16,1           \n\t"
+						 "breq	wait_spm2       \n\t"									 
+
+						 "ldi	r16,0x11	\n\t"	//Re-enable RWW section
+						 "sts	%0,r16		\n\t"						 			 
+						 "spm			\n\t"
+						 "no_page_erase:		\n\t"							 
+						 "ld	r0,Y+		\n\t"	//Write 2 bytes into page buffer
+						 "ld	r1,Y+		\n\t"							 
+							 
+						 "wait_spm3:		\n\t"
+						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+						 "andi	r16,1           \n\t"
+						 "cpi	r16,1           \n\t"
+						 "breq	wait_spm3       \n\t"
+						 "ldi	r16,0x01	\n\t"	//Load r0,r1 into FLASH page buffer
+						 "sts	%0,r16		\n\t"
+						 "spm			\n\t"
+							 
+						 "inc	r17		\n\t"	//page_word_count++
+						 "cpi r17,%1	        \n\t"
+						 "brlo	same_page	\n\t"	//Still same page in FLASH
+						 "write_page:		\n\t"
+						 "clr	r17		\n\t"	//New page, write current one first
+						 "wait_spm4:		\n\t"
+						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+						 "andi	r16,1           \n\t"
+						 "cpi	r16,1           \n\t"
+						 "breq	wait_spm4       \n\t"						 							 
+						 "ldi	r16,0x05	\n\t"	//Write page pointed to by Z
+						 "sts	%0,r16		\n\t"
+						 "spm			\n\t"
+						 "wait_spm5:		\n\t"
+						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+						 "andi	r16,1           \n\t"
+						 "cpi	r16,1           \n\t"
+						 "breq	wait_spm5       \n\t"									 
+						 "ldi	r16,0x11	\n\t"	//Re-enable RWW section
+						 "sts	%0,r16		\n\t"						 			 
+						 "spm			\n\t"					 		 
+						 "same_page:		\n\t"							 
+						 "adiw	r30,2		\n\t"	//Next word in FLASH
+						 "sbiw	r24,2		\n\t"	//length-2
+						 "breq	final_write	\n\t"	//Finished
+						 "rjmp	length_loop	\n\t"
+						 "final_write:		\n\t"
+						 "cpi	r17,0		\n\t"
+						 "breq	block_done	\n\t"
+						 "adiw	r24,2		\n\t"	//length+2, fool above check on length after short page write
+						 "rjmp	write_page	\n\t"
+						 "block_done:		\n\t"
+						 "clr	__zero_reg__	\n\t"	//restore zero register
+						 : "=m" (SPMCSR) : "M" (PAGE_SIZE) : "r0","r16","r17","r24","r25","r28","r29","r30","r31"
+
+						 );
+				}
+				putch(0x14);
+				putch(0x10);
+		    }
+			else
+			{
+				if (++error_count == MAX_ERROR_COUNT)
+				    app_start();
+		    }		
+		}
+    
+		/* Read memory block mode, length is big endian.  */
+		else if(ch=='t')
+		{
+			length.byte[1] = getch();
+			length.byte[0] = getch();
+
+			if (getch() == 'E')
+				flags.eeprom = 1;
+			else
+			{
+				flags.eeprom = 0;
+				address.word = address.word << 1;	        // address * 2 -> byte location
+			}
+
+			// Command terminator
+			if (getch() == ' ')
+			{
+				putch(0x14);
+				for (w=0; w<length.word; w++)
+				{
+					// Can handle odd and even lengths okay
+				    if (flags.eeprom) 
+					{
+						// Byte access EEPROM read
+						while(EECR & (1<<EEPE));
+						EEAR = (uint16_t)(void *)address.word;
+						EECR |= (1<<EERE);
+						putch(EEDR);
+
+						address.word++;
+				    }
+				    else
+					{
+						if (!flags.rampz)
+							putch(pgm_read_byte_near(address.word));
+
+						address.word++;
+				    }
+				}
+				putch(0x10);
+		    }
+		}
+
+
+		/* Get device signature bytes  */
+		else if(ch=='u')
+		{
+			if (getch() == ' ')
+			{
+				putch(0x14);
+				putch(SIG1);
+				putch(SIG2);
+				putch(SIG3);
+				putch(0x10);
+			}
+			else
+			{
+				if (++error_count == MAX_ERROR_COUNT)
+					app_start();
+			}
+		}
+
+
+		/* Read oscillator calibration byte */
+		else if(ch=='v')
+			byte_response(0x00);
+
+		else if (++error_count == MAX_ERROR_COUNT)
+		    app_start();
+
+	}
+    /* end of forever loop */
+}
+
+
+char gethex(void)
+{
+    char ah,al;
+
+    ah = getch();
+	putch(ah);
+    al = getch();
+	putch(al);
+    
+	if(ah >= 'a')
+		ah = ah - 'a' + 0x0a;
+	else if(ah >= '0')
+		ah -= '0';
+    if(al >= 'a')
+		al = al - 'a' + 0x0a;
+	else if(al >= '0')
+		al -= '0';
+
+    return (ah << 4) + al;
+}
+
+
+void puthex(char ch)
+{
+    char ah,al;
+
+    ah = (ch & 0xf0) >> 4;
+	if(ah >= 0x0a)
+		ah = ah - 0x0a + 'a';
+	else
+		ah += '0';
+
+    al = (ch & 0x0f);
+	if(al >= 0x0a)
+		al = al - 0x0a + 'a';
+	else
+		al += '0';
+
+    putch(ah);
+    putch(al);
+}
+
+
+void putch(char ch)
+{
+    while (!(UCSR0A & _BV(UDRE0)));
+    UDR0 = ch;
+}
+
+
+
+
+char getch(void)
+{
+    uint32_t count = 0;
+
+#ifdef ADABOOT
+	LED_PORT &= ~_BV(LED);          // toggle LED to show activity - BBR/LF 10/3/2007 & 9/13/2008
+#endif
+
+    while(!(UCSR0A & _BV(RXC0)))
+	{
+    	/* 20060803 DojoCorp:: Addon coming from the previous Bootloader*/               
+    	/* HACKME:: here is a good place to count times*/
+    	count++;
+    	if (count > MAX_TIME_COUNT)
+    		app_start();
+     }
+
+#ifdef ADABOOT
+	LED_PORT |= _BV(LED);          // toggle LED to show activity - BBR/LF 10/3/2007 & 9/13/2008
+#endif
+
+    return UDR0;
+}
+
+
+void getNch(uint8_t count)
+{
+    uint8_t i;
+    for(i=0;i<count;i++)
+	{
+		while(!(UCSR0A & _BV(RXC0)));
+		UDR0;
+    }
+}
+
+
+void byte_response(uint8_t val)
+{
+    if (getch() == ' ')
+	{
+		putch(0x14);
+		putch(val);
+		putch(0x10);
+    }
+	else
+	{
+		if (++error_count == MAX_ERROR_COUNT)
+		    app_start();
+    }
+}
+
+
+void nothing_response(void)
+{
+    if (getch() == ' ')
+	{
+		putch(0x14);
+		putch(0x10);
+    }
+	else
+	{
+		if (++error_count == MAX_ERROR_COUNT)
+		    app_start();
+    }
+}
+
+#ifdef ADABOOT
+
+void flash_led(uint8_t count)
+{
+    /* flash onboard LED count times to signal entering of bootloader */
+	/* l needs to be volatile or the delay loops below might get      */
+	/* optimized away if compiling with optimizations (DAM).          */
+	
+    volatile uint32_t l;
+
+    if (count == 0) {
+      count = ADABOOT;
+    }
+    
+
+	int8_t i;
+    for (i = 0; i < count; ++i) {
+		LED_PORT |= _BV(LED);					// LED on
+		for(l = 0; l < (F_CPU / 1000); ++l);		// delay NGvalue was 1000 for both loops - BBR
+		LED_PORT &= ~_BV(LED);					// LED off
+		for(l = 0; l < (F_CPU / 250); ++l);		// delay asymmteric for ADA BOOT BBR 
+	}
+
+	for(l = 0; l < (F_CPU / 100); ++l);		    // pause ADA BOOT BBR 
+		
+}
+
+#else
+
+void flash_led(uint8_t count)
+{
+    /* flash onboard LED three times to signal entering of bootloader */
+	/* l needs to be volatile or the delay loops below might get
+	optimized away if compiling with optimizations (DAM). */
+    volatile uint32_t l;
+
+    if (count == 0) {
+      count = 3;
+    }
+    
+	int8_t i;
+    for (i = 0; i < count; ++i) {
+		LED_PORT |= _BV(LED);
+		for(l = 0; l < (F_CPU / 1000); ++l);
+		LED_PORT &= ~_BV(LED);
+		for(l = 0; l < (F_CPU / 1000); ++l); 
+	}
+		
+}
+
+
+#endif
+
+
+/* end of file ATmegaBOOT.c */
diff --git a/Marlin/Boards/bootloaders/atmega644p/ATmegaBOOT_324P.hex b/Marlin/Boards/bootloaders/atmega644p/ATmegaBOOT_324P.hex
new file mode 100644
index 0000000..e67fe88
--- /dev/null
+++ b/Marlin/Boards/bootloaders/atmega644p/ATmegaBOOT_324P.hex
@@ -0,0 +1,121 @@
+:10F800000C943E7C0C945B7C0C945B7C0C945B7C39
+:10F810000C945B7C0C945B7C0C945B7C0C945B7C0C
+:10F820000C945B7C0C945B7C0C945B7C0C945B7CFC
+:10F830000C945B7C0C945B7C0C945B7C0C945B7CEC
+:10F840000C945B7C0C945B7C0C945B7C0C945B7CDC
+:10F850000C945B7C0C945B7C0C945B7C0C945B7CCC
+:10F860000C945B7C0C945B7C0C945B7C0C945B7CBC
+:10F870000C945B7C0C945B7C0C945B7C11241FBE11
+:10F88000CFEFD8E0DEBFCDBF11E0A0E0B1E0E6E60B
+:10F89000FFEF02C005900D92A030B107D9F712E03A
+:10F8A000A0E0B1E001C01D92A930B107E1F70E94CC
+:10F8B000537D0C94B27F0C94007CCF93DF93CDB733
+:10F8C000DEB724970FB6F894DEBF0FBECDBF8823F6
+:10F8D00009F481E020E0482F55274115510509F42E
+:10F8E0003DC0289A19821A821B821C820BC0898112
+:10F8F0009A81AB81BC810196A11DB11D89839A8338
+:10F90000AB83BC8389819A81AB81BC8180589E4343
+:10F91000A040B04060F3289819821A821B821C8292
+:10F920000BC089819A81AB81BC810196A11DB11D5B
+:10F9300089839A83AB83BC8389819A81AB81BC81A3
+:10F9400080509A4FA040B04060F32F5F822F9927DC
+:10F9500087FD9095841795070CF4C3CF19821A82FE
+:10F960001B821C8289819A81AB81BC818050914726
+:10F97000A240B040A0F489819A81AB81BC810196FC
+:10F98000A11DB11D89839A83AB83BC8389819A8130
+:10F99000AB81BC8180509147A240B04060F3249677
+:10F9A0000FB6F894DEBF0FBECDBFDF91CF910895A3
+:10F9B000EF92FF920F931F93EE24FF248701289864
+:10F9C0008091C00087FD17C00894E11CF11C011D47
+:10F9D000111D81E0E81689E0F8068DE3080780E054
+:10F9E000180770F3E0910001F091010109958091F1
+:10F9F000C00087FFE9CF289A8091C600992787FD2C
+:10FA000090951F910F91FF90EF900895982F8091FE
+:10FA1000C00085FFFCCF9093C60008950E94D87C5B
+:10FA2000803271F0809102018F5F809302018530F6
+:10FA300009F00895E0910001F09101010995089500
+:10FA400084E10E94067D80E10E94067D0895CF93A7
+:10FA5000C82F0E94D87C803241F0809102018F5FD4
+:10FA600080930201853081F40AC084E10E94067D02
+:10FA70008C2F0E94067D80E10E94067D05C0E091EA
+:10FA80000001F09101010995CF910895282F90E090
+:10FA900007C08091C0008823E4F78091C6009F5F73
+:10FAA0009217B8F30895CFEFD8E0DEBFCDBF0000C6
+:10FAB00094B714BE809160008861809360001092BA
+:10FAC000600091FF74C189E18093C4001092C50069
+:10FAD00088E18093C10086E08093C2005098589AD4
+:10FAE000209A83E00E945D7C81E00E945D7C0E9400
+:10FAF000D87C8033B9F18133C1F1803409F456C028
+:10FB0000813409F45CC0823409F46EC0853409F490
+:10FB100071C0803539F1813509F4F3C0823511F1B6
+:10FB2000853509F4D3C0863509F4CBC0843609F491
+:10FB300065C0843709F4EBC0853709F4D2C0863735
+:10FB400009F44AC0809102018F5F809302018530E1
+:10FB500071F6E0910001F091010109950E94D87CB5
+:10FB6000803349F60E940E7DC2CF0E94D87CC82FF8
+:10FB7000803241F784E10E94067D81E40E94067D87
+:10FB800086E50E94067D82E50E94067D8C2F0E94FC
+:10FB9000067D89E40E94067D83E50E94067D80E55E
+:10FBA0000E94067D80E10E94067DA1CF0E94D87C44
+:10FBB0008638C0F20E94D87C0E940E7D98CF0E94A9
+:10FBC000D87C803809F407C1813809F400C1823833
+:10FBD00009F4F9C0883921F080E00E94277D87CFA1
+:10FBE00083E00E94277D83CF84E10E94467D0E94AE
+:10FBF0000E7D7DCF85E00E94467DF9CF0E94D87CA6
+:10FC0000809306020E94D87C8093050280910802AE
+:10FC10008E7F809308020E94D87C853409F44BC003
+:10FC2000E5E0F1E0119281E0E438F807D9F3D0F390
+:10FC3000C0E0D0E0809105029091060218161906E6
+:10FC400078F405E011E00E94D87CF80181938F01DF
+:10FC500021968091050290910602C817D90798F362
+:10FC60000E94D87C803209F06DCF8091080280FF1D
+:10FC7000B6C0C0E0D0E02091050230910602121615
+:10FC80001306B8F4E0910301F0910401A5E0B1E09E
+:10FC9000F999FECFF2BDE1BD8D9180BDFA9AF99A36
+:10FCA00031962196C217D30798F3F0930401E0939D
+:10FCB000030184E175CF809108028160809308027E
+:10FCC000AFCF84E00E94467D80E087CF0E94D87C41
+:10FCD000809303010E94D87C809304010E940E7DD2
+:10FCE00006CF0E94D87C803209F02CCF84E10E949C
+:10FCF000067D8EE10E94067D85E90E94067D88E0F2
+:10FD00004FCF0E940E7D88E080936000FFCF0E945D
+:10FD1000D87C809306020E94D87C809305020E94C2
+:10FD2000D87C853409F449C0809108028E7F809385
+:10FD300008028091030190910401880F991F90930C
+:10FD40000401809303010E94D87C803209F0CFCE59
+:10FD500084E10E94067DC0E0D0E020910502309150
+:10FD600006021216130608F01DCFE0910301F09170
+:10FD700004018091080280FF96C0F999FECFF2BD80
+:10FD8000E1BDF89A80B50E94067DE0910301F091F3
+:10FD900004013196F0930401E093030120910502E0
+:10FDA000309106022196C217D30718F3FBCEE091DB
+:10FDB0000001F0910101099586CE809108028160D1
+:10FDC00080930802C0CF80E10E94277D90CE81E021
+:10FDD0000E94277D8CCE82E00E94277D88CE809174
+:10FDE000030190910401880F991F9093040180935F
+:10FDF00003018091050280FF09C080910502909166
+:10FE0000060201969093060280930502F999FECFAF
+:10FE10001127E0910301F0910401C5E0D1E0809148
+:10FE2000050290910602103091F400915700017084
+:10FE30000130D9F303E000935700E8950091570093
+:10FE400001700130D9F301E100935700E895099062
+:10FE500019900091570001700130D9F301E000932F
+:10FE60005700E8951395103898F011270091570026
+:10FE700001700130D9F305E000935700E895009137
+:10FE8000570001700130D9F301E100935700E89564
+:10FE90003296029709F0C7CF103011F00296E5CFE5
+:10FEA000112484E17DCE869580FF06C03196F093C3
+:10FEB0000401E093030176CF84910E94067D209196
+:10FEC000050230910602E0910301F0910401EECFAA
+:10FED0001F93CF930E94D87CC82F0E94067D0E945A
+:10FEE000D87C182F0E94067DC1362CF0C7551136DC
+:10FEF0003CF0175508C0C033D4F3C0531136CCF7CB
+:10FF000010330CF01053C295C07FC10F8C2F99276E
+:10FF100087FD9095CF911F910895CF93282F992712
+:10FF200087FD9095807F907095958795959587959D
+:10FF300095958795959587958A303CF0895AC22F7B
+:10FF4000CF70CA303CF0C95A06C0805DC22FCF7056
+:10FF5000CA30CCF7C05D0E94067D8C2F0E94067DC2
+:06FF6000CF910895FFCFD0
+:040000030000F80001
+:00000001FF
diff --git a/Marlin/Boards/bootloaders/atmega644p/ATmegaBOOT_644.hex b/Marlin/Boards/bootloaders/atmega644p/ATmegaBOOT_644.hex
new file mode 100644
index 0000000..d5557de
--- /dev/null
+++ b/Marlin/Boards/bootloaders/atmega644p/ATmegaBOOT_644.hex
@@ -0,0 +1,120 @@
+:10F800000C94387C0C94557C0C94557C0C94557C51
+:10F810000C94557C0C94557C0C94557C0C94557C24
+:10F820000C94557C0C94557C0C94557C0C94557C14
+:10F830000C94557C0C94557C0C94557C0C94557C04
+:10F840000C94557C0C94557C0C94557C0C94557CF4
+:10F850000C94557C0C94557C0C94557C0C94557CE4
+:10F860000C94557C0C94557C0C94557C0C94557CD4
+:10F8700011241FBECFEFD0E1DEBFCDBF11E0A0E06D
+:10F88000B1E0EAE5FFEF02C005900D92A030B107AC
+:10F89000D9F712E0A0E0B1E001C01D92A930B10794
+:10F8A000E1F70E944D7D0C94AC7F0C94007CCF93CB
+:10F8B000DF93CDB7DEB724970FB6F894DEBF0FBE47
+:10F8C000CDBF882309F481E020E0482F552741155A
+:10F8D000510509F43DC0289A19821A821B821C82A4
+:10F8E0000BC089819A81AB81BC810196A11DB11D9C
+:10F8F00089839A83AB83BC8389819A81AB81BC81E4
+:10F9000080589E43A040B04060F3289819821A8224
+:10F910001B821C820BC089819A81AB81BC810196BC
+:10F92000A11DB11D89839A83AB83BC8389819A8190
+:10F93000AB81BC8180509A4FA040B04060F32F5FF4
+:10F94000822F992787FD9095841795070CF4C3CFD4
+:10F9500019821A821B821C8289819A81AB81BC81A7
+:10F9600080509147A240B040A0F489819A81AB8138
+:10F97000BC810196A11DB11D89839A83AB83BC8391
+:10F9800089819A81AB81BC8180509147A240B0406F
+:10F9900060F324960FB6F894DEBF0FBECDBFDF91A3
+:10F9A000CF910895EF92FF920F931F93EE24FF24BF
+:10F9B000870128988091C00087FD17C00894E11C3A
+:10F9C000F11C011D111D81E0E81689E0F8068DE3A8
+:10F9D000080780E0180770F3E0910001F091010141
+:10F9E00009958091C00087FFE9CF289A8091C600D1
+:10F9F000992787FD90951F910F91FF90EF900895A3
+:10FA0000982F8091C00085FFFCCF9093C600089589
+:10FA10000E94D27C803271F0809102018F5F8093CE
+:10FA20000201853009F00895E0910001F091010193
+:10FA30000995089584E10E94007D80E10E94007D87
+:10FA40000895CF93C82F0E94D27C803241F08091DC
+:10FA500002018F5F80930201853081F40AC084E146
+:10FA60000E94007D8C2F0E94007D80E10E94007D1D
+:10FA700005C0E0910001F09101010995CF91089531
+:10FA8000282F90E007C08091C0008823E4F7809180
+:10FA9000C6009F5F9217B8F30895CFEFD0E1DEBFA5
+:10FAA000CDBF000094B714BE809160008861809340
+:10FAB00060001092600091FF74C189E18093C400DE
+:10FAC0001092C50088E18093C10086E08093C20057
+:10FAD0005098589A209A83E00E94577C81E00E94B7
+:10FAE000577C0E94D27C8033B9F18133C1F18034DC
+:10FAF00009F456C0813409F45CC0823409F46EC044
+:10FB0000853409F471C0803539F1813509F4F3C0C9
+:10FB1000823511F1853509F4D3C0863509F4CBC09F
+:10FB2000843609F465C0843709F4EBC0853709F4DD
+:10FB3000D2C0863709F44AC0809102018F5F80935A
+:10FB40000201853071F6E0910001F0910101099503
+:10FB50000E94D27C803349F60E94087DC2CF0E9469
+:10FB6000D27CC82F803241F784E10E94007D81E47D
+:10FB70000E94007D86E50E94007D82E50E94007D56
+:10FB80008C2F0E94007D89E40E94007D83E50E9405
+:10FB9000007D80E50E94007D80E10E94007DA1CF74
+:10FBA0000E94D27C8638C0F20E94D27C0E94087DDE
+:10FBB00098CF0E94D27C803809F407C1813809F4BB
+:10FBC00000C1823809F4F9C0883921F080E00E9430
+:10FBD000217D87CF83E00E94217D83CF84E10E9435
+:10FBE000407D0E94087D7DCF85E00E94407DF9CF59
+:10FBF0000E94D27C809306020E94D27C80930502F0
+:10FC0000809108028E7F809308020E94D27C853406
+:10FC100009F44BC0E5E0F1E0119281E0E438F80727
+:10FC2000D9F3D0F3C0E0D0E08091050290910602B4
+:10FC30001816190678F405E011E00E94D27CF8014C
+:10FC400081938F0121968091050290910602C81739
+:10FC5000D90798F30E94D27C803209F06DCF809151
+:10FC6000080280FFB6C0C0E0D0E0209105023091CC
+:10FC7000060212161306B8F4E0910301F091040194
+:10FC8000A5E0B1E0F999FECFF2BDE1BD8D9180BD57
+:10FC9000FA9AF99A31962196C217D30798F3F093FE
+:10FCA0000401E093030184E175CF80910802816033
+:10FCB00080930802AFCF84E00E94407D80E087CF30
+:10FCC0000E94D27C809303010E94D27C8093040125
+:10FCD0000E94087D06CF0E94D27C803209F02CCF92
+:10FCE00084E10E94007D8EE10E94007D86E90E94F1
+:10FCF000007D89E04FCF0E94087D88E080936000FE
+:10FD0000FFCF0E94D27C809306020E94D27C809317
+:10FD100005020E94D27C853409F449C08091080212
+:10FD20008E7F809308028091030190910401880FD7
+:10FD3000991F90930401809303010E94D27C80322A
+:10FD400009F0CFCE84E10E94007DC0E0D0E0209198
+:10FD50000502309106021216130608F01DCFE0913D
+:10FD60000301F09104018091080280FF96C0F99987
+:10FD7000FECFF2BDE1BDF89A80B50E94007DE09112
+:10FD80000301F09104013196F0930401E093030123
+:10FD900020910502309106022196C217D30718F36D
+:10FDA000FBCEE0910001F0910101099586CE809192
+:10FDB0000802816080930802C0CF80E10E94217D0B
+:10FDC00090CE81E00E94217D8CCE82E00E94217D38
+:10FDD00088CE8091030190910401880F991F909320
+:10FDE0000401809303018091050280FF09C0809186
+:10FDF00005029091060201969093060280930502F7
+:10FE0000F999FECF1127E0910301F0910401C5E0BB
+:10FE1000D1E08091050290910602103091F400919A
+:10FE2000570001700130D9F303E000935700E895C3
+:10FE30000091570001700130D9F301E100935700A0
+:10FE4000E895099019900091570001700130D9F39D
+:10FE500001E000935700E8951395103898F01127AA
+:10FE60000091570001700130D9F305E0009357006D
+:10FE7000E8950091570001700130D9F301E100933A
+:10FE80005700E8953296029709F0C7CF103011F06D
+:10FE90000296E5CF112484E17DCE869580FF06C0D1
+:10FEA0003196F0930401E093030176CF84910E9490
+:10FEB000007D2091050230910602E0910301F0914E
+:10FEC0000401EECF1F93CF930E94D27CC82F0E94D3
+:10FED000007D0E94D27C182F0E94007DC1362CF03C
+:10FEE000C75511363CF0175508C0C033D4F3C05382
+:10FEF0001136CCF710330CF01053C295C07FC10FF0
+:10FF00008C2F992787FD9095CF911F910895CF93BE
+:10FF1000282F992787FD9095807F907095958795DC
+:10FF20009595879595958795959587958A303CF019
+:10FF3000895AC22FCF70CA303CF0C95A06C0805DC2
+:10FF4000C22FCF70CA30CCF7C05D0E94007D8C2FCD
+:0AFF50000E94007DCF910895FFCFBD
+:040000030000F80001
+:00000001FF
diff --git a/Marlin/Boards/bootloaders/atmega644p/ATmegaBOOT_644P.hex b/Marlin/Boards/bootloaders/atmega644p/ATmegaBOOT_644P.hex
new file mode 100644
index 0000000..99a6ae1
--- /dev/null
+++ b/Marlin/Boards/bootloaders/atmega644p/ATmegaBOOT_644P.hex
@@ -0,0 +1,121 @@
+:10F800000C943E7C0C945B7C0C945B7C0C945B7C39
+:10F810000C945B7C0C945B7C0C945B7C0C945B7C0C
+:10F820000C945B7C0C945B7C0C945B7C0C945B7CFC
+:10F830000C945B7C0C945B7C0C945B7C0C945B7CEC
+:10F840000C945B7C0C945B7C0C945B7C0C945B7CDC
+:10F850000C945B7C0C945B7C0C945B7C0C945B7CCC
+:10F860000C945B7C0C945B7C0C945B7C0C945B7CBC
+:10F870000C945B7C0C945B7C0C945B7C11241FBE11
+:10F88000CFEFD0E1DEBFCDBF11E0A0E0B1E0E6E612
+:10F89000FFEF02C005900D92A030B107D9F712E03A
+:10F8A000A0E0B1E001C01D92A930B107E1F70E94CC
+:10F8B000537D0C94B27F0C94007CCF93DF93CDB733
+:10F8C000DEB724970FB6F894DEBF0FBECDBF8823F6
+:10F8D00009F481E020E0482F55274115510509F42E
+:10F8E0003DC0289A19821A821B821C820BC0898112
+:10F8F0009A81AB81BC810196A11DB11D89839A8338
+:10F90000AB83BC8389819A81AB81BC8180589E4343
+:10F91000A040B04060F3289819821A821B821C8292
+:10F920000BC089819A81AB81BC810196A11DB11D5B
+:10F9300089839A83AB83BC8389819A81AB81BC81A3
+:10F9400080509A4FA040B04060F32F5F822F9927DC
+:10F9500087FD9095841795070CF4C3CF19821A82FE
+:10F960001B821C8289819A81AB81BC818050914726
+:10F97000A240B040A0F489819A81AB81BC810196FC
+:10F98000A11DB11D89839A83AB83BC8389819A8130
+:10F99000AB81BC8180509147A240B04060F3249677
+:10F9A0000FB6F894DEBF0FBECDBFDF91CF910895A3
+:10F9B000EF92FF920F931F93EE24FF248701289864
+:10F9C0008091C00087FD17C00894E11CF11C011D47
+:10F9D000111D81E0E81689E0F8068DE3080780E054
+:10F9E000180770F3E0910001F091010109958091F1
+:10F9F000C00087FFE9CF289A8091C600992787FD2C
+:10FA000090951F910F91FF90EF900895982F8091FE
+:10FA1000C00085FFFCCF9093C60008950E94D87C5B
+:10FA2000803271F0809102018F5F809302018530F6
+:10FA300009F00895E0910001F09101010995089500
+:10FA400084E10E94067D80E10E94067D0895CF93A7
+:10FA5000C82F0E94D87C803241F0809102018F5FD4
+:10FA600080930201853081F40AC084E10E94067D02
+:10FA70008C2F0E94067D80E10E94067D05C0E091EA
+:10FA80000001F09101010995CF910895282F90E090
+:10FA900007C08091C0008823E4F78091C6009F5F73
+:10FAA0009217B8F30895CFEFD0E1DEBFCDBF0000CD
+:10FAB00094B714BE809160008861809360001092BA
+:10FAC000600091FF74C189E18093C4001092C50069
+:10FAD00088E18093C10086E08093C2005098589AD4
+:10FAE000209A83E00E945D7C81E00E945D7C0E9400
+:10FAF000D87C8033B9F18133C1F1803409F456C028
+:10FB0000813409F45CC0823409F46EC0853409F490
+:10FB100071C0803539F1813509F4F3C0823511F1B6
+:10FB2000853509F4D3C0863509F4CBC0843609F491
+:10FB300065C0843709F4EBC0853709F4D2C0863735
+:10FB400009F44AC0809102018F5F809302018530E1
+:10FB500071F6E0910001F091010109950E94D87CB5
+:10FB6000803349F60E940E7DC2CF0E94D87CC82FF8
+:10FB7000803241F784E10E94067D81E40E94067D87
+:10FB800086E50E94067D82E50E94067D8C2F0E94FC
+:10FB9000067D89E40E94067D83E50E94067D80E55E
+:10FBA0000E94067D80E10E94067DA1CF0E94D87C44
+:10FBB0008638C0F20E94D87C0E940E7D98CF0E94A9
+:10FBC000D87C803809F407C1813809F400C1823833
+:10FBD00009F4F9C0883921F080E00E94277D87CFA1
+:10FBE00083E00E94277D83CF84E10E94467D0E94AE
+:10FBF0000E7D7DCF85E00E94467DF9CF0E94D87CA6
+:10FC0000809306020E94D87C8093050280910802AE
+:10FC10008E7F809308020E94D87C853409F44BC003
+:10FC2000E5E0F1E0119281E0E438F807D9F3D0F390
+:10FC3000C0E0D0E0809105029091060218161906E6
+:10FC400078F405E011E00E94D87CF80181938F01DF
+:10FC500021968091050290910602C817D90798F362
+:10FC60000E94D87C803209F06DCF8091080280FF1D
+:10FC7000B6C0C0E0D0E02091050230910602121615
+:10FC80001306B8F4E0910301F0910401A5E0B1E09E
+:10FC9000F999FECFF2BDE1BD8D9180BDFA9AF99A36
+:10FCA00031962196C217D30798F3F0930401E0939D
+:10FCB000030184E175CF809108028160809308027E
+:10FCC000AFCF84E00E94467D80E087CF0E94D87C41
+:10FCD000809303010E94D87C809304010E940E7DD2
+:10FCE00006CF0E94D87C803209F02CCF84E10E949C
+:10FCF000067D8EE10E94067D86E90E94067D8AE0EF
+:10FD00004FCF0E940E7D88E080936000FFCF0E945D
+:10FD1000D87C809306020E94D87C809305020E94C2
+:10FD2000D87C853409F449C0809108028E7F809385
+:10FD300008028091030190910401880F991F90930C
+:10FD40000401809303010E94D87C803209F0CFCE59
+:10FD500084E10E94067DC0E0D0E020910502309150
+:10FD600006021216130608F01DCFE0910301F09170
+:10FD700004018091080280FF96C0F999FECFF2BD80
+:10FD8000E1BDF89A80B50E94067DE0910301F091F3
+:10FD900004013196F0930401E093030120910502E0
+:10FDA000309106022196C217D30718F3FBCEE091DB
+:10FDB0000001F0910101099586CE809108028160D1
+:10FDC00080930802C0CF80E10E94277D90CE81E021
+:10FDD0000E94277D8CCE82E00E94277D88CE809174
+:10FDE000030190910401880F991F9093040180935F
+:10FDF00003018091050280FF09C080910502909166
+:10FE0000060201969093060280930502F999FECFAF
+:10FE10001127E0910301F0910401C5E0D1E0809148
+:10FE2000050290910602103091F400915700017084
+:10FE30000130D9F303E000935700E8950091570093
+:10FE400001700130D9F301E100935700E895099062
+:10FE500019900091570001700130D9F301E000932F
+:10FE60005700E8951395103898F011270091570026
+:10FE700001700130D9F305E000935700E895009137
+:10FE8000570001700130D9F301E100935700E89564
+:10FE90003296029709F0C7CF103011F00296E5CFE5
+:10FEA000112484E17DCE869580FF06C03196F093C3
+:10FEB0000401E093030176CF84910E94067D209196
+:10FEC000050230910602E0910301F0910401EECFAA
+:10FED0001F93CF930E94D87CC82F0E94067D0E945A
+:10FEE000D87C182F0E94067DC1362CF0C7551136DC
+:10FEF0003CF0175508C0C033D4F3C0531136CCF7CB
+:10FF000010330CF01053C295C07FC10F8C2F99276E
+:10FF100087FD9095CF911F910895CF93282F992712
+:10FF200087FD9095807F907095958795959587959D
+:10FF300095958795959587958A303CF0895AC22F7B
+:10FF4000CF70CA303CF0C95A06C0805DC22FCF7056
+:10FF5000CA30CCF7C05D0E94067D8C2F0E94067DC2
+:06FF6000CF910895FFCFD0
+:040000030000F80001
+:00000001FF
diff --git a/Marlin/Boards/bootloaders/atmega644p/Makefile b/Marlin/Boards/bootloaders/atmega644p/Makefile
new file mode 100644
index 0000000..5714395
--- /dev/null
+++ b/Marlin/Boards/bootloaders/atmega644p/Makefile
@@ -0,0 +1,56 @@
+# Makefile for ATmegaBOOT
+# E.Lins, 18.7.2005
+# $Id$
+
+
+# program name should not be changed...
+PROGRAM    = ATmegaBOOT_644P
+
+# enter the target CPU frequency
+AVR_FREQ   = 16000000L
+
+MCU_TARGET = atmega644p
+LDSECTION  = --section-start=.text=0xF800
+
+OBJ        = $(PROGRAM).o
+OPTIMIZE   = -O2
+
+DEFS       = 
+LIBS       = 
+
+CC         = avr-gcc
+
+
+# Override is only needed by avr-lib build system.
+
+override CFLAGS        = -g -Wall $(OPTIMIZE) -mmcu=$(MCU_TARGET) -DF_CPU=$(AVR_FREQ) $(DEFS)
+override LDFLAGS       = -Wl,$(LDSECTION)
+#override LDFLAGS       = -Wl,-Map,$(PROGRAM).map,$(LDSECTION)
+
+OBJCOPY        = avr-objcopy
+OBJDUMP        = avr-objdump
+
+all: CFLAGS += '-DMAX_TIME_COUNT=8000000L>>1' -DADABOOT
+all: $(PROGRAM).hex
+
+$(PROGRAM).hex: $(PROGRAM).elf
+	$(OBJCOPY) -j .text -j .data -O ihex $< $@
+	
+$(PROGRAM).elf: $(OBJ)
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^ $(LIBS)
+	
+$(OBJ): ATmegaBOOT.c
+	avr-gcc $(CFLAGS) $(LDFLAGS) -c -g -O2 -Wall -mmcu=$(MCU_TARGET) ATmegaBOOT.c -o $(PROGRAM).o
+
+%.lst: %.elf
+	$(OBJDUMP) -h -S $< > $@
+
+%.srec: %.elf
+	$(OBJCOPY) -j .text -j .data -O srec $< $@
+
+%.bin: %.elf
+	$(OBJCOPY) -j .text -j .data -O binary $< $@
+
+clean:
+	rm -rf *.o *.elf *.lst *.map *.sym *.lss *.eep *.srec *.bin *.hex
+	
\ No newline at end of file
diff --git a/Marlin/Boards/bootloaders/atmega644p/README.txt b/Marlin/Boards/bootloaders/atmega644p/README.txt
new file mode 100644
index 0000000..8286007
--- /dev/null
+++ b/Marlin/Boards/bootloaders/atmega644p/README.txt
@@ -0,0 +1,3 @@
+Note: This bootloader support ATmega644, ATmega644P and ATmega324P.
+To build, set PROGRAM and MCU_TARGET in the Makefile according to your target device.
+
diff --git a/Marlin/Boards/cores/arduino/Arduino.h b/Marlin/Boards/cores/arduino/Arduino.h
new file mode 100644
index 0000000..90ee918
--- /dev/null
+++ b/Marlin/Boards/cores/arduino/Arduino.h
@@ -0,0 +1 @@
+    #include "WProgram.h"
diff --git a/Marlin/Boards/cores/arduino/Copy of wiring.h b/Marlin/Boards/cores/arduino/Copy of wiring.h
new file mode 100644
index 0000000..e29959b
--- /dev/null
+++ b/Marlin/Boards/cores/arduino/Copy of wiring.h	
@@ -0,0 +1,135 @@
+/*
+  wiring.h - Partial implementation of the Wiring API for the ATmega8.
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id$
+*/
+
+#ifndef Wiring_h
+#define Wiring_h
+
+#include <avr/io.h>
+#include <stdlib.h>
+#include "binary.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+#define HIGH 0x1
+#define LOW  0x0
+
+#define INPUT 0x0
+#define OUTPUT 0x1
+
+#define true 0x1
+#define false 0x0
+
+#define PI 3.1415926535897932384626433832795
+#define HALF_PI 1.5707963267948966192313216916398
+#define TWO_PI 6.283185307179586476925286766559
+#define DEG_TO_RAD 0.017453292519943295769236907684886
+#define RAD_TO_DEG 57.295779513082320876798154814105
+
+#define SERIAL  0x0
+#define DISPLAY 0x1
+
+#define LSBFIRST 0
+#define MSBFIRST 1
+
+#define CHANGE 1
+#define FALLING 2
+#define RISING 3
+
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+#define INTERNAL1V1 2
+#define INTERNAL2V56 3
+#else
+#define INTERNAL 3
+#endif
+#define DEFAULT 1
+#define EXTERNAL 0
+
+// undefine stdlib's abs if encountered
+#ifdef abs
+#undef abs
+#endif
+
+#define min(a,b) ((a)<(b)?(a):(b))
+#define max(a,b) ((a)>(b)?(a):(b))
+#define abs(x) ((x)>0?(x):-(x))
+#define constrain(amt,low,high) ((amt)<(low)?(low):((amt)>(high)?(high):(amt)))
+#define round(x)     ((x)>=0?(long)((x)+0.5):(long)((x)-0.5))
+#define radians(deg) ((deg)*DEG_TO_RAD)
+#define degrees(rad) ((rad)*RAD_TO_DEG)
+#define sq(x) ((x)*(x))
+
+#define interrupts() sei()
+#define noInterrupts() cli()
+
+#define clockCyclesPerMicrosecond() ( F_CPU / 1000000L )
+#define clockCyclesToMicroseconds(a) ( ((a) * 1000L) / (F_CPU / 1000L) )
+#define microsecondsToClockCycles(a) ( ((a) * (F_CPU / 1000L)) / 1000L )
+
+#define lowByte(w) ((uint8_t) ((w) & 0xff))
+#define highByte(w) ((uint8_t) ((w) >> 8))
+
+#define bitRead(value, bit) (((value) >> (bit)) & 0x01)
+#define bitSet(value, bit) ((value) |= (1UL << (bit)))
+#define bitClear(value, bit) ((value) &= ~(1UL << (bit)))
+#define bitWrite(value, bit, bitvalue) (bitvalue ? bitSet(value, bit) : bitClear(value, bit))
+
+
+typedef unsigned int word;
+
+#define bit(b) (1UL << (b))
+
+typedef uint8_t boolean;
+typedef uint8_t byte;
+
+void init(void);
+
+void pinMode(uint8_t, uint8_t);
+void digitalWrite(uint8_t, uint8_t);
+int digitalRead(uint8_t);
+int analogRead(uint8_t);
+void analogReference(uint8_t mode);
+void analogWrite(uint8_t, int);
+
+unsigned long millis(void);
+unsigned long micros(void);
+void delay(unsigned long);
+void delayMicroseconds(unsigned int us);
+unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout);
+
+void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val);
+uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder);
+
+void attachInterrupt(uint8_t, void (*)(void), int mode);
+void detachInterrupt(uint8_t);
+
+void setup(void);
+void loop(void);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif
diff --git a/Marlin/Boards/cores/arduino/HardwareSerial.cpp b/Marlin/Boards/cores/arduino/HardwareSerial.cpp
new file mode 100644
index 0000000..bf7cb69
--- /dev/null
+++ b/Marlin/Boards/cores/arduino/HardwareSerial.cpp
@@ -0,0 +1,202 @@
+/*
+  HardwareSerial.cpp - Hardware serial library for Wiring
+  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+  
+  Modified 23 November 2006 by David A. Mellis
+  Modified 28 September 2010 by Mark Sproul
+*/
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <inttypes.h>
+#include "wiring.h"
+#include "wiring_private.h"
+
+// this next line disables the entire HardwareSerial.cpp, 
+// this is so I can support Attiny series and any other chip without a uart
+#if defined(UBRRH) || defined(UBRR0H) || defined(UBRR1H) || defined(UBRR2H) || defined(UBRR3H)
+
+#include "HardwareSerial.h"
+
+// Define constants and variables for buffering incoming serial data.  We're
+// using a ring buffer (I think), in which rx_buffer_head is the index of the
+// location to which to write the next incoming character and rx_buffer_tail
+// is the index of the location from which to read.
+#define RX_BUFFER_SIZE 128
+
+struct ring_buffer
+{
+  unsigned char buffer[RX_BUFFER_SIZE];
+  int head;
+  int tail;
+};
+
+ring_buffer rx_buffer  =  { { 0 }, 0, 0 };
+
+inline void store_char(unsigned char c, ring_buffer *rx_buffer)
+{
+  int i = (unsigned int)(rx_buffer->head + 1) & (RX_BUFFER_SIZE -1);
+
+  // if we should be storing the received character into the location
+  // just before the tail (meaning that the head would advance to the
+  // current location of the tail), we're about to overflow the buffer
+  // and so we don't write the character or advance the head.
+  if (i != rx_buffer->tail) {
+    rx_buffer->buffer[rx_buffer->head] = c;
+    rx_buffer->head = i;
+  }
+}
+
+// fixed by Mark Sproul this is on the 644/644p
+//SIGNAL(SIG_USART_RECV)
+SIGNAL(USART0_RX_vect)
+{
+  unsigned char c  =  UDR0;
+  store_char(c, &rx_buffer);
+}
+
+
+// Constructors ////////////////////////////////////////////////////////////////
+
+HardwareSerial::HardwareSerial(ring_buffer *rx_buffer,
+  volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
+  volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
+  volatile uint8_t *udr,
+  uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udre, uint8_t u2x)
+{
+  _rx_buffer = rx_buffer;
+  _ubrrh = ubrrh;
+  _ubrrl = ubrrl;
+  _ucsra = ucsra;
+  _ucsrb = ucsrb;
+  _udr = udr;
+  _rxen = rxen;
+  _txen = txen;
+  _rxcie = rxcie;
+  _udre = udre;
+  _u2x = u2x;
+}
+
+// Public Methods //////////////////////////////////////////////////////////////
+
+void HardwareSerial::begin(long baud)
+{
+  uint16_t baud_setting;
+  bool use_u2x = true;
+
+#if F_CPU == 16000000UL
+  // hardcoded exception for compatibility with the bootloader shipped
+  // with the Duemilanove and previous boards and the firmware on the 8U2
+  // on the Uno and Mega 2560.
+  if (baud == 57600) {
+    use_u2x = false;
+  }
+#endif
+  
+  if (use_u2x) {
+    *_ucsra = 1 << _u2x;
+    baud_setting = (F_CPU / 4 / baud - 1) / 2;
+  } else {
+    *_ucsra = 0;
+    baud_setting = (F_CPU / 8 / baud - 1) / 2;
+  }
+
+  // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)
+  *_ubrrh = baud_setting >> 8;
+  *_ubrrl = baud_setting;
+
+  sbi(*_ucsrb, _rxen);
+  sbi(*_ucsrb, _txen);
+  sbi(*_ucsrb, _rxcie);
+}
+
+void HardwareSerial::end()
+{
+  cbi(*_ucsrb, _rxen);
+  cbi(*_ucsrb, _txen);
+  cbi(*_ucsrb, _rxcie);  
+}
+
+int HardwareSerial::available(void)
+{
+  return (unsigned int)(RX_BUFFER_SIZE + _rx_buffer->head - _rx_buffer->tail) & (RX_BUFFER_SIZE-1);
+}
+
+int HardwareSerial::peek(void)
+{
+  if (_rx_buffer->head == _rx_buffer->tail) {
+    return -1;
+  } else {
+    return _rx_buffer->buffer[_rx_buffer->tail];
+  }
+}
+
+int HardwareSerial::read(void)
+{
+  // if the head isn't ahead of the tail, we don't have any characters
+  if (_rx_buffer->head == _rx_buffer->tail) {
+    return -1;
+  } else {
+    unsigned char c = _rx_buffer->buffer[_rx_buffer->tail];
+    _rx_buffer->tail = (unsigned int)(_rx_buffer->tail + 1) & (RX_BUFFER_SIZE-1);
+    return c;
+  }
+}
+
+void HardwareSerial::flush()
+{
+  // don't reverse this or there may be problems if the RX interrupt
+  // occurs after reading the value of rx_buffer_head but before writing
+  // the value to rx_buffer_tail; the previous value of rx_buffer_head
+  // may be written to rx_buffer_tail, making it appear as if the buffer
+  // don't reverse this or there may be problems if the RX interrupt
+  // occurs after reading the value of rx_buffer_head but before writing
+  // the value to rx_buffer_tail; the previous value of rx_buffer_head
+  // may be written to rx_buffer_tail, making it appear as if the buffer
+  // were full, not empty.
+  _rx_buffer->head = _rx_buffer->tail;
+}
+
+//
+// Drakelive  2012-09-04
+//
+#if ARDUINO >= 100 
+	size_t  HardwareSerial::write(uint8_t c)
+	{
+	  while (!((*_ucsra) & (1 << _udre)))
+	    ;
+
+	  *_udr = c;
+	}
+#else
+	void HardwareSerial::write(uint8_t c)
+	{
+	  while (!((*_ucsra) & (1 << _udre)))
+		 ;
+
+	  *_udr = c;
+	}        
+#endif
+
+// Drakelive  2012-09-04
+
+// Preinstantiate Objects //////////////////////////////////////////////////////
+HardwareSerial Serial(&rx_buffer, &UBRR0H, &UBRR0L, &UCSR0A, &UCSR0B, &UDR0, RXEN0, TXEN0, RXCIE0, UDRE0, U2X0);
+
+#endif // whole file
+
diff --git a/Marlin/Boards/cores/arduino/HardwareSerial.h b/Marlin/Boards/cores/arduino/HardwareSerial.h
new file mode 100644
index 0000000..89ebc7a
--- /dev/null
+++ b/Marlin/Boards/cores/arduino/HardwareSerial.h
@@ -0,0 +1,87 @@
+/*
+  HardwareSerial.h - Hardware serial library for Wiring
+  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+  Modified 28 September 2010 by Mark Sproul
+*/
+
+#ifndef HardwareSerial_h
+#define HardwareSerial_h
+
+#include <inttypes.h>
+
+#include "Stream.h"
+
+struct ring_buffer;
+
+class HardwareSerial : public Stream
+{
+  private:
+    ring_buffer *_rx_buffer;
+    volatile uint8_t *_ubrrh;
+    volatile uint8_t *_ubrrl;
+    volatile uint8_t *_ucsra;
+    volatile uint8_t *_ucsrb;
+    volatile uint8_t *_udr;
+    uint8_t _rxen;
+    uint8_t _txen;
+    uint8_t _rxcie;
+    uint8_t _udre;
+    uint8_t _u2x;
+  public:
+    HardwareSerial(ring_buffer *rx_buffer,
+      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
+      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
+      volatile uint8_t *udr,
+      uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udre, uint8_t u2x);
+    void begin(long);
+    void end();
+    virtual int available(void);
+    virtual int peek(void);
+    virtual int read(void);
+    virtual void flush(void);
+    
+    //
+    // Drakelive  2012-09-04
+    //
+    #if ARDUINO >= 100 
+        virtual size_t write(uint8_t);
+    #else
+        virtual void write(uint8_t);
+    #endif
+     
+    // Drakelive  2012-09-04
+
+    using Print::write; // pull in write(str) and write(buf, size) from Print
+};
+
+#if defined(UBRRH) || defined(UBRR0H)
+  extern HardwareSerial Serial;
+#elif defined(USBCON)
+  #include "usb_api.h"
+#endif
+#if defined(UBRR1H)
+  extern HardwareSerial Serial1;
+#endif
+#if defined(UBRR2H)
+  extern HardwareSerial Serial2;
+#endif
+#if defined(UBRR3H)
+  extern HardwareSerial Serial3;
+#endif
+
+#endif
diff --git a/Marlin/Boards/cores/arduino/Print.cpp b/Marlin/Boards/cores/arduino/Print.cpp
new file mode 100644
index 0000000..4ee556d
--- /dev/null
+++ b/Marlin/Boards/cores/arduino/Print.cpp
@@ -0,0 +1,220 @@
+/*
+ Print.cpp - Base class that provides print() and println()
+ Copyright (c) 2008 David A. Mellis.  All right reserved.
+ 
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Lesser General Public
+ License as published by the Free Software Foundation; either
+ version 2.1 of the License, or (at your option) any later version.
+ 
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Lesser General Public License for more details.
+ 
+ You should have received a copy of the GNU Lesser General Public
+ License along with this library; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ 
+ Modified 23 November 2006 by David A. Mellis
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include "wiring.h"
+
+#include "Print.h"
+
+// Public Methods //////////////////////////////////////////////////////////////
+
+/* default implementation: may be overridden */
+void Print::write(const char *str)
+{
+  while (*str)
+    write(*str++);
+}
+
+/* default implementation: may be overridden */
+void Print::write(const uint8_t *buffer, size_t size)
+{
+  while (size--)
+    write(*buffer++);
+}
+
+void Print::print(const String &s)
+{
+  for (int i = 0; i < s.length(); i++) {
+    write(s[i]);
+  }
+}
+
+void Print::print(const char str[])
+{
+  write(str);
+}
+
+void Print::print(char c, int base)
+{
+  print((long) c, base);
+}
+
+void Print::print(unsigned char b, int base)
+{
+  print((unsigned long) b, base);
+}
+
+void Print::print(int n, int base)
+{
+  print((long) n, base);
+}
+
+void Print::print(unsigned int n, int base)
+{
+  print((unsigned long) n, base);
+}
+
+void Print::print(long n, int base)
+{
+  if (base == 0) {
+    write(n);
+  } else if (base == 10) {
+    if (n < 0) {
+      print('-');
+      n = -n;
+    }
+    printNumber(n, 10);
+  } else {
+    printNumber(n, base);
+  }
+}
+
+void Print::print(unsigned long n, int base)
+{
+  if (base == 0) write(n);
+  else printNumber(n, base);
+}
+
+void Print::print(double n, int digits)
+{
+  printFloat(n, digits);
+}
+
+void Print::println(void)
+{
+  print('\r');
+  print('\n');  
+}
+
+void Print::println(const String &s)
+{
+  print(s);
+  println();
+}
+
+void Print::println(const char c[])
+{
+  print(c);
+  println();
+}
+
+void Print::println(char c, int base)
+{
+  print(c, base);
+  println();
+}
+
+void Print::println(unsigned char b, int base)
+{
+  print(b, base);
+  println();
+}
+
+void Print::println(int n, int base)
+{
+  print(n, base);
+  println();
+}
+
+void Print::println(unsigned int n, int base)
+{
+  print(n, base);
+  println();
+}
+
+void Print::println(long n, int base)
+{
+  print(n, base);
+  println();
+}
+
+void Print::println(unsigned long n, int base)
+{
+  print(n, base);
+  println();
+}
+
+void Print::println(double n, int digits)
+{
+  print(n, digits);
+  println();
+}
+
+// Private Methods /////////////////////////////////////////////////////////////
+
+void Print::printNumber(unsigned long n, uint8_t base)
+{
+  unsigned char buf[8 * sizeof(long)]; // Assumes 8-bit chars. 
+  unsigned long i = 0;
+
+  if (n == 0) {
+    print('0');
+    return;
+  } 
+
+  while (n > 0) {
+    buf[i++] = n % base;
+    n /= base;
+  }
+
+  for (; i > 0; i--)
+    print((char) (buf[i - 1] < 10 ?
+      '0' + buf[i - 1] :
+      'A' + buf[i - 1] - 10));
+}
+
+void Print::printFloat(double number, uint8_t digits) 
+{ 
+  // Handle negative numbers
+  if (number < 0.0)
+  {
+     print('-');
+     number = -number;
+  }
+
+  // Round correctly so that print(1.999, 2) prints as "2.00"
+  double rounding = 0.5;
+  for (uint8_t i=0; i<digits; ++i)
+    rounding /= 10.0;
+  
+  number += rounding;
+
+  // Extract the integer part of the number and print it
+  unsigned long int_part = (unsigned long)number;
+  double remainder = number - (double)int_part;
+  print(int_part);
+
+  // Print the decimal point, but only if there are digits beyond
+  if (digits > 0)
+    print("."); 
+
+  // Extract digits from the remainder one at a time
+  while (digits-- > 0)
+  {
+    remainder *= 10.0;
+    int toPrint = int(remainder);
+    print(toPrint);
+    remainder -= toPrint; 
+  } 
+}
diff --git a/Marlin/Boards/cores/arduino/Print.h b/Marlin/Boards/cores/arduino/Print.h
new file mode 100644
index 0000000..3f9cb96
--- /dev/null
+++ b/Marlin/Boards/cores/arduino/Print.h
@@ -0,0 +1,77 @@
+/*
+  Print.h - Base class that provides print() and println()
+  Copyright (c) 2008 David A. Mellis.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef Print_h
+#define Print_h
+
+#include <inttypes.h>
+#include <stdio.h> // for size_t
+
+#include "WString.h"
+
+#define DEC 10
+#define HEX 16
+#define OCT 8
+#define BIN 2
+#define BYTE 0
+
+class Print
+{
+  private:
+    void printNumber(unsigned long, uint8_t);
+    void printFloat(double, uint8_t);
+  public:
+     
+    //
+    // Drakelive  2012-09-04
+    //
+    #if ARDUINO >= 100 
+        virtual size_t write(uint8_t) = 0;
+    #else
+        virtual void write(uint8_t) = 0;
+    #endif
+     
+    // Drakelive  2012-09-04     
+
+    virtual void write(const char *str);
+    virtual void write(const uint8_t *buffer, size_t size);
+    
+    void print(const String &);
+    void print(const char[]);
+    void print(char, int = BYTE);
+    void print(unsigned char, int = BYTE);
+    void print(int, int = DEC);
+    void print(unsigned int, int = DEC);
+    void print(long, int = DEC);
+    void print(unsigned long, int = DEC);
+    void print(double, int = 2);
+
+    void println(const String &s);
+    void println(const char[]);
+    void println(char, int = BYTE);
+    void println(unsigned char, int = BYTE);
+    void println(int, int = DEC);
+    void println(unsigned int, int = DEC);
+    void println(long, int = DEC);
+    void println(unsigned long, int = DEC);
+    void println(double, int = 2);
+    void println(void);
+};
+
+#endif
diff --git a/Marlin/Boards/cores/arduino/Stream.h b/Marlin/Boards/cores/arduino/Stream.h
new file mode 100644
index 0000000..93d8275
--- /dev/null
+++ b/Marlin/Boards/cores/arduino/Stream.h
@@ -0,0 +1,35 @@
+/*
+  Stream.h - base class for character-based streams.
+  Copyright (c) 2010 David A. Mellis.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef Stream_h
+#define Stream_h
+
+#include <inttypes.h>
+#include "Print.h"
+
+class Stream : public Print
+{
+  public:
+    virtual int available() = 0;
+    virtual int read() = 0;
+    virtual int peek() = 0;
+    virtual void flush() = 0;
+};
+
+#endif
diff --git a/Marlin/Boards/cores/arduino/Tone.cpp b/Marlin/Boards/cores/arduino/Tone.cpp
new file mode 100644
index 0000000..c3910e7
--- /dev/null
+++ b/Marlin/Boards/cores/arduino/Tone.cpp
@@ -0,0 +1,601 @@
+/* Tone.cpp
+
+  A Tone Generator Library
+
+  Written by Brett Hagman
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+Version Modified By Date     Comments
+------- ----------- -------- --------
+0001    B Hagman    09/08/02 Initial coding
+0002    B Hagman    09/08/18 Multiple pins
+0003    B Hagman    09/08/18 Moved initialization from constructor to begin()
+0004    B Hagman    09/09/26 Fixed problems with ATmega8
+0005    B Hagman    09/11/23 Scanned prescalars for best fit on 8 bit timers
+                    09/11/25 Changed pin toggle method to XOR
+                    09/11/25 Fixed timer0 from being excluded
+0006    D Mellis    09/12/29 Replaced objects with functions
+0007    M Sproul    10/08/29 Changed #ifdefs from cpu to register
+*************************************************/
+
+#include <avr/interrupt.h>
+#include <avr/pgmspace.h>
+#include "wiring.h"
+#include "pins_arduino.h"
+
+#if defined(__AVR_ATmega8__) || defined(__AVR_ATmega128__)
+#define TCCR2A TCCR2
+#define TCCR2B TCCR2
+#define COM2A1 COM21
+#define COM2A0 COM20
+#define OCR2A OCR2
+#define TIMSK2 TIMSK
+#define OCIE2A OCIE2
+#define TIMER2_COMPA_vect TIMER2_COMP_vect
+#define TIMSK1 TIMSK
+#endif
+
+// timerx_toggle_count:
+//  > 0 - duration specified
+//  = 0 - stopped
+//  < 0 - infinitely (until stop() method called, or new play() called)
+
+#if !defined(__AVR_ATmega8__)
+volatile long timer0_toggle_count;
+volatile uint8_t *timer0_pin_port;
+volatile uint8_t timer0_pin_mask;
+#endif
+
+volatile long timer1_toggle_count;
+volatile uint8_t *timer1_pin_port;
+volatile uint8_t timer1_pin_mask;
+volatile long timer2_toggle_count;
+volatile uint8_t *timer2_pin_port;
+volatile uint8_t timer2_pin_mask;
+
+#if defined(TIMSK3)
+volatile long timer3_toggle_count;
+volatile uint8_t *timer3_pin_port;
+volatile uint8_t timer3_pin_mask;
+#endif
+
+#if defined(TIMSK4)
+volatile long timer4_toggle_count;
+volatile uint8_t *timer4_pin_port;
+volatile uint8_t timer4_pin_mask;
+#endif
+
+#if defined(TIMSK5)
+volatile long timer5_toggle_count;
+volatile uint8_t *timer5_pin_port;
+volatile uint8_t timer5_pin_mask;
+#endif
+
+
+// MLS: This does not make sense, the 3 options are the same
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+
+#define AVAILABLE_TONE_PINS 1
+
+const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 3, 4, 5, 1, 0 */ };
+static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255, 255, 255, 255, 255 */ };
+
+#elif defined(__AVR_ATmega8__)
+
+#define AVAILABLE_TONE_PINS 1
+
+const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 1 */ };
+static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255 */ };
+
+#else
+
+#define AVAILABLE_TONE_PINS 1
+
+// Leave timer 0 to last.
+const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 1, 0 */ };
+static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255, 255 */ };
+
+#endif
+
+
+
+static int8_t toneBegin(uint8_t _pin)
+{
+  int8_t _timer = -1;
+
+  // if we're already using the pin, the timer should be configured.  
+  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
+    if (tone_pins[i] == _pin) {
+      return pgm_read_byte(tone_pin_to_timer_PGM + i);
+    }
+  }
+  
+  // search for an unused timer.
+  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
+    if (tone_pins[i] == 255) {
+      tone_pins[i] = _pin;
+      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
+      break;
+    }
+  }
+  
+  if (_timer != -1)
+  {
+    // Set timer specific stuff
+    // All timers in CTC mode
+    // 8 bit timers will require changing prescalar values,
+    // whereas 16 bit timers are set to either ck/1 or ck/64 prescalar
+    switch (_timer)
+    {
+      #if defined(TCCR0A) && defined(TCCR0B)
+      case 0:
+        // 8 bit timer
+        TCCR0A = 0;
+        TCCR0B = 0;
+        bitWrite(TCCR0A, WGM01, 1);
+        bitWrite(TCCR0B, CS00, 1);
+        timer0_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer0_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR1A) && defined(TCCR1B) && defined(WGM12)
+      case 1:
+        // 16 bit timer
+        TCCR1A = 0;
+        TCCR1B = 0;
+        bitWrite(TCCR1B, WGM12, 1);
+        bitWrite(TCCR1B, CS10, 1);
+        timer1_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer1_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR2A) && defined(TCCR2B)
+      case 2:
+        // 8 bit timer
+        TCCR2A = 0;
+        TCCR2B = 0;
+        bitWrite(TCCR2A, WGM21, 1);
+        bitWrite(TCCR2B, CS20, 1);
+        timer2_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer2_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR3A) && defined(TCCR3B) &&  defined(TIMSK3)
+      case 3:
+        // 16 bit timer
+        TCCR3A = 0;
+        TCCR3B = 0;
+        bitWrite(TCCR3B, WGM32, 1);
+        bitWrite(TCCR3B, CS30, 1);
+        timer3_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer3_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR4A) && defined(TCCR4B) &&  defined(TIMSK4)
+      case 4:
+        // 16 bit timer
+        TCCR4A = 0;
+        TCCR4B = 0;
+        #if defined(WGM42)
+          bitWrite(TCCR4B, WGM42, 1);
+        #elif defined(CS43)
+          #warning this may not be correct
+          // atmega32u4
+          bitWrite(TCCR4B, CS43, 1);
+        #endif
+        bitWrite(TCCR4B, CS40, 1);
+        timer4_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer4_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR5A) && defined(TCCR5B) &&  defined(TIMSK5)
+      case 5:
+        // 16 bit timer
+        TCCR5A = 0;
+        TCCR5B = 0;
+        bitWrite(TCCR5B, WGM52, 1);
+        bitWrite(TCCR5B, CS50, 1);
+        timer5_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer5_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+    }
+  }
+
+  return _timer;
+}
+
+
+
+// frequency (in hertz) and duration (in milliseconds).
+
+void tone(uint8_t _pin, unsigned int frequency, unsigned long duration)
+{
+  uint8_t prescalarbits = 0b001;
+  long toggle_count = 0;
+  uint32_t ocr = 0;
+  int8_t _timer;
+
+  _timer = toneBegin(_pin);
+
+  if (_timer >= 0)
+  {
+    // Set the pinMode as OUTPUT
+    pinMode(_pin, OUTPUT);
+    
+    // if we are using an 8 bit timer, scan through prescalars to find the best fit
+    if (_timer == 0 || _timer == 2)
+    {
+      ocr = F_CPU / frequency / 2 - 1;
+      prescalarbits = 0b001;  // ck/1: same for both timers
+      if (ocr > 255)
+      {
+        ocr = F_CPU / frequency / 2 / 8 - 1;
+        prescalarbits = 0b010;  // ck/8: same for both timers
+
+        if (_timer == 2 && ocr > 255)
+        {
+          ocr = F_CPU / frequency / 2 / 32 - 1;
+          prescalarbits = 0b011;
+        }
+
+        if (ocr > 255)
+        {
+          ocr = F_CPU / frequency / 2 / 64 - 1;
+          prescalarbits = _timer == 0 ? 0b011 : 0b100;
+
+          if (_timer == 2 && ocr > 255)
+          {
+            ocr = F_CPU / frequency / 2 / 128 - 1;
+            prescalarbits = 0b101;
+          }
+
+          if (ocr > 255)
+          {
+            ocr = F_CPU / frequency / 2 / 256 - 1;
+            prescalarbits = _timer == 0 ? 0b100 : 0b110;
+            if (ocr > 255)
+            {
+              // can't do any better than /1024
+              ocr = F_CPU / frequency / 2 / 1024 - 1;
+              prescalarbits = _timer == 0 ? 0b101 : 0b111;
+            }
+          }
+        }
+      }
+
+#if defined(TCCR0B)
+      if (_timer == 0)
+      {
+        TCCR0B = prescalarbits;
+      }
+      else
+#endif
+#if defined(TCCR2B)
+      {
+        TCCR2B = prescalarbits;
+      }
+#else
+      {
+        // dummy place holder to make the above ifdefs work
+      }
+#endif
+    }
+    else
+    {
+      // two choices for the 16 bit timers: ck/1 or ck/64
+      ocr = F_CPU / frequency / 2 - 1;
+
+      prescalarbits = 0b001;
+      if (ocr > 0xffff)
+      {
+        ocr = F_CPU / frequency / 2 / 64 - 1;
+        prescalarbits = 0b011;
+      }
+
+      if (_timer == 1)
+      {
+#if defined(TCCR1B)
+        TCCR1B = (TCCR1B & 0b11111000) | prescalarbits;
+#endif
+      }
+#if defined(TCCR3B)
+      else if (_timer == 3)
+        TCCR3B = (TCCR3B & 0b11111000) | prescalarbits;
+#endif
+#if defined(TCCR4B)
+      else if (_timer == 4)
+        TCCR4B = (TCCR4B & 0b11111000) | prescalarbits;
+#endif
+#if defined(TCCR5B)
+      else if (_timer == 5)
+        TCCR5B = (TCCR5B & 0b11111000) | prescalarbits;
+#endif
+
+    }
+    
+
+    // Calculate the toggle count
+    if (duration > 0)
+    {
+      toggle_count = 2 * frequency * duration / 1000;
+    }
+    else
+    {
+      toggle_count = -1;
+    }
+
+    // Set the OCR for the given timer,
+    // set the toggle count,
+    // then turn on the interrupts
+    switch (_timer)
+    {
+
+#if defined(OCR0A) && defined(TIMSK0) && defined(OCIE0A)
+      case 0:
+        OCR0A = ocr;
+        timer0_toggle_count = toggle_count;
+        bitWrite(TIMSK0, OCIE0A, 1);
+        break;
+#endif
+
+      case 1:
+#if defined(OCR1A) && defined(TIMSK1) && defined(OCIE1A)
+        OCR1A = ocr;
+        timer1_toggle_count = toggle_count;
+        bitWrite(TIMSK1, OCIE1A, 1);
+#elif defined(OCR1A) && defined(TIMSK) && defined(OCIE1A)
+        // this combination is for at least the ATmega32
+        OCR1A = ocr;
+        timer1_toggle_count = toggle_count;
+        bitWrite(TIMSK, OCIE1A, 1);
+#endif
+        break;
+
+#if defined(OCR2A) && defined(TIMSK2) && defined(OCIE2A)
+      case 2:
+        OCR2A = ocr;
+        timer2_toggle_count = toggle_count;
+        bitWrite(TIMSK2, OCIE2A, 1);
+        break;
+#endif
+
+#if defined(TIMSK3)
+      case 3:
+        OCR3A = ocr;
+        timer3_toggle_count = toggle_count;
+        bitWrite(TIMSK3, OCIE3A, 1);
+        break;
+#endif
+
+#if defined(TIMSK4)
+      case 4:
+        OCR4A = ocr;
+        timer4_toggle_count = toggle_count;
+        bitWrite(TIMSK4, OCIE4A, 1);
+        break;
+#endif
+
+#if defined(OCR5A) && defined(TIMSK5) && defined(OCIE5A)
+      case 5:
+        OCR5A = ocr;
+        timer5_toggle_count = toggle_count;
+        bitWrite(TIMSK5, OCIE5A, 1);
+        break;
+#endif
+
+    }
+  }
+}
+
+
+// XXX: this function only works properly for timer 2 (the only one we use
+// currently).  for the others, it should end the tone, but won't restore
+// proper PWM functionality for the timer.
+void disableTimer(uint8_t _timer)
+{
+  switch (_timer)
+  {
+    case 0:
+      #if defined(TIMSK0)
+        TIMSK0 = 0;
+      #elif defined(TIMSK)
+        TIMSK = 0; // atmega32
+      #endif
+      break;
+
+#if defined(TIMSK1) && defined(OCIE1A)
+    case 1:
+      bitWrite(TIMSK1, OCIE1A, 0);
+      break;
+#endif
+
+    case 2:
+      #if defined(TIMSK2) && defined(OCIE2A)
+        bitWrite(TIMSK2, OCIE2A, 0); // disable interrupt
+      #endif
+      #if defined(TCCR2A) && defined(WGM20)
+        TCCR2A = (1 << WGM20);
+      #endif
+      #if defined(TCCR2B) && defined(CS22)
+        TCCR2B = (TCCR2B & 0b11111000) | (1 << CS22);
+      #endif
+      #if defined(OCR2A)
+        OCR2A = 0;
+      #endif
+      break;
+
+#if defined(TIMSK3)
+    case 3:
+      TIMSK3 = 0;
+      break;
+#endif
+
+#if defined(TIMSK4)
+    case 4:
+      TIMSK4 = 0;
+      break;
+#endif
+
+#if defined(TIMSK5)
+    case 5:
+      TIMSK5 = 0;
+      break;
+#endif
+  }
+}
+
+
+void noTone(uint8_t _pin)
+{
+  int8_t _timer = -1;
+  
+  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
+    if (tone_pins[i] == _pin) {
+      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
+      tone_pins[i] = 255;
+    }
+  }
+  
+  disableTimer(_timer);
+
+  digitalWrite(_pin, 0);
+}
+
+#if 0
+#if !defined(__AVR_ATmega8__)
+ISR(TIMER0_COMPA_vect)
+{
+  if (timer0_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer0_pin_port ^= timer0_pin_mask;
+
+    if (timer0_toggle_count > 0)
+      timer0_toggle_count--;
+  }
+  else
+  {
+    disableTimer(0);
+    *timer0_pin_port &= ~(timer0_pin_mask);  // keep pin low after stop
+  }
+}
+#endif
+
+
+ISR(TIMER1_COMPA_vect)
+{
+  if (timer1_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer1_pin_port ^= timer1_pin_mask;
+
+    if (timer1_toggle_count > 0)
+      timer1_toggle_count--;
+  }
+  else
+  {
+    disableTimer(1);
+    *timer1_pin_port &= ~(timer1_pin_mask);  // keep pin low after stop
+  }
+}
+#endif
+
+
+ISR(TIMER2_COMPA_vect)
+{
+
+  if (timer2_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer2_pin_port ^= timer2_pin_mask;
+
+    if (timer2_toggle_count > 0)
+      timer2_toggle_count--;
+  }
+  else
+  {
+    // need to call noTone() so that the tone_pins[] entry is reset, so the
+    // timer gets initialized next time we call tone().
+    // XXX: this assumes timer 2 is always the first one used.
+    noTone(tone_pins[0]);
+//    disableTimer(2);
+//    *timer2_pin_port &= ~(timer2_pin_mask);  // keep pin low after stop
+  }
+}
+
+
+
+//#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+#if 0
+
+ISR(TIMER3_COMPA_vect)
+{
+  if (timer3_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer3_pin_port ^= timer3_pin_mask;
+
+    if (timer3_toggle_count > 0)
+      timer3_toggle_count--;
+  }
+  else
+  {
+    disableTimer(3);
+    *timer3_pin_port &= ~(timer3_pin_mask);  // keep pin low after stop
+  }
+}
+
+ISR(TIMER4_COMPA_vect)
+{
+  if (timer4_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer4_pin_port ^= timer4_pin_mask;
+
+    if (timer4_toggle_count > 0)
+      timer4_toggle_count--;
+  }
+  else
+  {
+    disableTimer(4);
+    *timer4_pin_port &= ~(timer4_pin_mask);  // keep pin low after stop
+  }
+}
+
+ISR(TIMER5_COMPA_vect)
+{
+  if (timer5_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer5_pin_port ^= timer5_pin_mask;
+
+    if (timer5_toggle_count > 0)
+      timer5_toggle_count--;
+  }
+  else
+  {
+    disableTimer(5);
+    *timer5_pin_port &= ~(timer5_pin_mask);  // keep pin low after stop
+  }
+}
+
+#endif
diff --git a/Marlin/Boards/cores/arduino/WCharacter.h b/Marlin/Boards/cores/arduino/WCharacter.h
new file mode 100644
index 0000000..79733b5
--- /dev/null
+++ b/Marlin/Boards/cores/arduino/WCharacter.h
@@ -0,0 +1,168 @@
+/*
+ WCharacter.h - Character utility functions for Wiring & Arduino
+ Copyright (c) 2010 Hernando Barragan.  All right reserved.
+ 
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Lesser General Public
+ License as published by the Free Software Foundation; either
+ version 2.1 of the License, or (at your option) any later version.
+ 
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Lesser General Public License for more details.
+ 
+ You should have received a copy of the GNU Lesser General Public
+ License along with this library; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef Character_h
+#define Character_h
+
+#include <ctype.h>
+
+// WCharacter.h prototypes
+inline boolean isAlphaNumeric(int c) __attribute__((always_inline));
+inline boolean isAlpha(int c) __attribute__((always_inline));
+inline boolean isAscii(int c) __attribute__((always_inline));
+inline boolean isWhitespace(int c) __attribute__((always_inline));
+inline boolean isControl(int c) __attribute__((always_inline));
+inline boolean isDigit(int c) __attribute__((always_inline));
+inline boolean isGraph(int c) __attribute__((always_inline));
+inline boolean isLowerCase(int c) __attribute__((always_inline));
+inline boolean isPrintable(int c) __attribute__((always_inline));
+inline boolean isPunct(int c) __attribute__((always_inline));
+inline boolean isSpace(int c) __attribute__((always_inline));
+inline boolean isUpperCase(int c) __attribute__((always_inline));
+inline boolean isHexadecimalDigit(int c) __attribute__((always_inline));
+inline int toAscii(int c) __attribute__((always_inline));
+inline int toLowerCase(int c) __attribute__((always_inline));
+inline int toUpperCase(int c)__attribute__((always_inline));
+
+
+// Checks for an alphanumeric character. 
+// It is equivalent to (isalpha(c) || isdigit(c)).
+inline boolean isAlphaNumeric(int c) 
+{
+  return ( isalnum(c) == 0 ? false : true);
+}
+
+
+// Checks for an alphabetic character. 
+// It is equivalent to (isupper(c) || islower(c)).
+inline boolean isAlpha(int c)
+{
+  return ( isalpha(c) == 0 ? false : true);
+}
+
+
+// Checks whether c is a 7-bit unsigned char value 
+// that fits into the ASCII character set.
+inline boolean isAscii(int c)
+{
+  return ( isascii (c) == 0 ? false : true);
+}
+
+
+// Checks for a blank character, that is, a space or a tab.
+inline boolean isWhitespace(int c)
+{
+  return ( isblank (c) == 0 ? false : true);
+}
+
+
+// Checks for a control character.
+inline boolean isControl(int c)
+{
+  return ( iscntrl (c) == 0 ? false : true);
+}
+
+
+// Checks for a digit (0 through 9).
+inline boolean isDigit(int c)
+{
+  return ( isdigit (c) == 0 ? false : true);
+}
+
+
+// Checks for any printable character except space.
+inline boolean isGraph(int c)
+{
+  return ( isgraph (c) == 0 ? false : true);
+}
+
+
+// Checks for a lower-case character.
+inline boolean isLowerCase(int c)
+{
+  return (islower (c) == 0 ? false : true);
+}
+
+
+// Checks for any printable character including space.
+inline boolean isPrintable(int c)
+{
+  return ( isprint (c) == 0 ? false : true);
+}
+
+
+// Checks for any printable character which is not a space 
+// or an alphanumeric character.
+inline boolean isPunct(int c)
+{
+  return ( ispunct (c) == 0 ? false : true);
+}
+
+
+// Checks for white-space characters. For the avr-libc library, 
+// these are: space, formfeed ('\f'), newline ('\n'), carriage 
+// return ('\r'), horizontal tab ('\t'), and vertical tab ('\v').
+inline boolean isSpace(int c)
+{
+  return ( isspace (c) == 0 ? false : true);
+}
+
+
+// Checks for an uppercase letter.
+inline boolean isUpperCase(int c)
+{
+  return ( isupper (c) == 0 ? false : true);
+}
+
+
+// Checks for a hexadecimal digits, i.e. one of 0 1 2 3 4 5 6 7 
+// 8 9 a b c d e f A B C D E F.
+inline boolean isHexadecimalDigit(int c)
+{
+  return ( isxdigit (c) == 0 ? false : true);
+}
+
+
+// Converts c to a 7-bit unsigned char value that fits into the 
+// ASCII character set, by clearing the high-order bits.
+inline int toAscii(int c)
+{
+  return toascii (c);
+}
+
+
+// Warning:
+// Many people will be unhappy if you use this function. 
+// This function will convert accented letters into random 
+// characters.
+
+// Converts the letter c to lower case, if possible.
+inline int toLowerCase(int c)
+{
+  return tolower (c);
+}
+
+
+// Converts the letter c to upper case, if possible.
+inline int toUpperCase(int c)
+{
+  return toupper (c);
+}
+
+#endif
\ No newline at end of file
diff --git a/Marlin/Boards/cores/arduino/WConstants.h b/Marlin/Boards/cores/arduino/WConstants.h
new file mode 100644
index 0000000..3e19ac4
--- /dev/null
+++ b/Marlin/Boards/cores/arduino/WConstants.h
@@ -0,0 +1 @@
+#include "wiring.h"
diff --git a/Marlin/Boards/cores/arduino/WInterrupts.c b/Marlin/Boards/cores/arduino/WInterrupts.c
new file mode 100644
index 0000000..3b3e0c9
--- /dev/null
+++ b/Marlin/Boards/cores/arduino/WInterrupts.c
@@ -0,0 +1,249 @@
+/* -*- mode: jde; c-basic-offset: 2; indent-tabs-mode: nil -*- */
+
+/*
+  Part of the Wiring project - http://wiring.uniandes.edu.co
+
+  Copyright (c) 2004-05 Hernando Barragan
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+  
+  Modified 24 November 2006 by David A. Mellis
+  Modified 1 August 2010 by Mark Sproul
+*/
+
+#include <inttypes.h>
+#include <avr/io.h>
+#include <avr/interrupt.h>
+#include <avr/pgmspace.h>
+#include <stdio.h>
+
+#include "WConstants.h"
+#include "wiring_private.h"
+
+volatile static voidFuncPtr intFunc[EXTERNAL_NUM_INTERRUPTS];
+// volatile static voidFuncPtr twiIntFunc;
+
+void attachInterrupt(uint8_t interruptNum, void (*userFunc)(void), int mode) {
+  if(interruptNum < EXTERNAL_NUM_INTERRUPTS) {
+    intFunc[interruptNum] = userFunc;
+    
+    // Configure the interrupt mode (trigger on low input, any change, rising
+    // edge, or falling edge).  The mode constants were chosen to correspond
+    // to the configuration bits in the hardware register, so we simply shift
+    // the mode into place.
+      
+    // Enable the interrupt.
+      
+    switch (interruptNum) {
+#if defined(EICRA) && defined(EICRB) && defined(EIMSK)
+    case 2:
+      EICRA = (EICRA & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
+      EIMSK |= (1 << INT0);
+      break;
+    case 3:
+      EICRA = (EICRA & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
+      EIMSK |= (1 << INT1);
+      break;
+    case 4:
+      EICRA = (EICRA & ~((1 << ISC20) | (1 << ISC21))) | (mode << ISC20);
+      EIMSK |= (1 << INT2);
+      break;
+    case 5:
+      EICRA = (EICRA & ~((1 << ISC30) | (1 << ISC31))) | (mode << ISC30);
+      EIMSK |= (1 << INT3);
+      break;
+    case 0:
+      EICRB = (EICRB & ~((1 << ISC40) | (1 << ISC41))) | (mode << ISC40);
+      EIMSK |= (1 << INT4);
+      break;
+    case 1:
+      EICRB = (EICRB & ~((1 << ISC50) | (1 << ISC51))) | (mode << ISC50);
+      EIMSK |= (1 << INT5);
+      break;
+    case 6:
+      EICRB = (EICRB & ~((1 << ISC60) | (1 << ISC61))) | (mode << ISC60);
+      EIMSK |= (1 << INT6);
+      break;
+    case 7:
+      EICRB = (EICRB & ~((1 << ISC70) | (1 << ISC71))) | (mode << ISC70);
+      EIMSK |= (1 << INT7);
+      break;
+#else
+    case 0:
+    #if defined(EICRA) && defined(ISC00) && defined(EIMSK)
+      EICRA = (EICRA & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
+      EIMSK |= (1 << INT0);
+    #elif defined(MCUCR) && defined(ISC00) && defined(GICR)
+      MCUCR = (MCUCR & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
+      GICR |= (1 << INT0);
+    #elif defined(MCUCR) && defined(ISC00) && defined(GIMSK)
+      MCUCR = (MCUCR & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
+      GIMSK |= (1 << INT0);
+    #else
+      #error attachInterrupt not finished for this CPU (case 0)
+    #endif
+      break;
+
+    case 1:
+    #if defined(EICRA) && defined(ISC10) && defined(ISC11) && defined(EIMSK)
+      EICRA = (EICRA & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
+      EIMSK |= (1 << INT1);
+    #elif defined(MCUCR) && defined(ISC10) && defined(ISC11) && defined(GICR)
+      MCUCR = (MCUCR & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
+      GICR |= (1 << INT1);
+    #elif defined(MCUCR) && defined(ISC10) && defined(GIMSK) && defined(GIMSK)
+      MCUCR = (MCUCR & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
+      GIMSK |= (1 << INT1);
+    #else
+      #warning attachInterrupt may need some more work for this cpu (case 1)
+    #endif
+      break;
+#endif
+    }
+  }
+}
+
+void detachInterrupt(uint8_t interruptNum) {
+  if(interruptNum < EXTERNAL_NUM_INTERRUPTS) {
+    // Disable the interrupt.  (We can't assume that interruptNum is equal
+    // to the number of the EIMSK bit to clear, as this isn't true on the 
+    // ATmega8.  There, INT0 is 6 and INT1 is 7.)
+    switch (interruptNum) {
+#if defined(EICRA) && defined(EICRB) && defined(EIMSK)
+    case 2:
+      EIMSK &= ~(1 << INT0);
+      break;
+    case 3:
+      EIMSK &= ~(1 << INT1);
+      break;
+    case 4:
+      EIMSK &= ~(1 << INT2);
+      break;
+    case 5:
+      EIMSK &= ~(1 << INT3);
+      break;
+    case 0:
+      EIMSK &= ~(1 << INT4);
+      break;
+    case 1:
+      EIMSK &= ~(1 << INT5);
+      break;
+    case 6:
+      EIMSK &= ~(1 << INT6);
+      break;
+    case 7:
+      EIMSK &= ~(1 << INT7);
+      break;
+#else
+    case 0:
+    #if defined(EIMSK) && defined(INT0)
+      EIMSK &= ~(1 << INT0);
+    #elif defined(GICR) && defined(ISC00)
+      GICR &= ~(1 << INT0); // atmega32
+    #elif defined(GIMSK) && defined(INT0)
+      GIMSK &= ~(1 << INT0);
+    #else
+      #error detachInterrupt not finished for this cpu
+    #endif
+      break;
+
+    case 1:
+    #if defined(EIMSK) && defined(INT1)
+      EIMSK &= ~(1 << INT1);
+    #elif defined(GICR) && defined(INT1)
+      GICR &= ~(1 << INT1); // atmega32
+    #elif defined(GIMSK) && defined(INT1)
+      GIMSK &= ~(1 << INT1);
+    #else
+      #warning detachInterrupt may need some more work for this cpu (case 1)
+    #endif
+      break;
+#endif
+    }
+      
+    intFunc[interruptNum] = 0;
+  }
+}
+
+/*
+void attachInterruptTwi(void (*userFunc)(void) ) {
+  twiIntFunc = userFunc;
+}
+*/
+
+#if defined(EICRA) && defined(EICRB)
+
+SIGNAL(INT0_vect) {
+  if(intFunc[EXTERNAL_INT_2])
+    intFunc[EXTERNAL_INT_2]();
+}
+
+SIGNAL(INT1_vect) {
+  if(intFunc[EXTERNAL_INT_3])
+    intFunc[EXTERNAL_INT_3]();
+}
+
+SIGNAL(INT2_vect) {
+  if(intFunc[EXTERNAL_INT_4])
+    intFunc[EXTERNAL_INT_4]();
+}
+
+SIGNAL(INT3_vect) {
+  if(intFunc[EXTERNAL_INT_5])
+    intFunc[EXTERNAL_INT_5]();
+}
+
+SIGNAL(INT4_vect) {
+  if(intFunc[EXTERNAL_INT_0])
+    intFunc[EXTERNAL_INT_0]();
+}
+
+SIGNAL(INT5_vect) {
+  if(intFunc[EXTERNAL_INT_1])
+    intFunc[EXTERNAL_INT_1]();
+}
+
+SIGNAL(INT6_vect) {
+  if(intFunc[EXTERNAL_INT_6])
+    intFunc[EXTERNAL_INT_6]();
+}
+
+SIGNAL(INT7_vect) {
+  if(intFunc[EXTERNAL_INT_7])
+    intFunc[EXTERNAL_INT_7]();
+}
+
+#else
+
+SIGNAL(INT0_vect) {
+  if(intFunc[EXTERNAL_INT_0])
+    intFunc[EXTERNAL_INT_0]();
+}
+
+SIGNAL(INT1_vect) {
+  if(intFunc[EXTERNAL_INT_1])
+    intFunc[EXTERNAL_INT_1]();
+}
+
+#endif
+
+/*
+SIGNAL(SIG_2WIRE_SERIAL) {
+  if(twiIntFunc)
+    twiIntFunc();
+}
+*/
+
diff --git a/Marlin/Boards/cores/arduino/WMath.cpp b/Marlin/Boards/cores/arduino/WMath.cpp
new file mode 100644
index 0000000..2120c4c
--- /dev/null
+++ b/Marlin/Boards/cores/arduino/WMath.cpp
@@ -0,0 +1,60 @@
+/* -*- mode: jde; c-basic-offset: 2; indent-tabs-mode: nil -*- */
+
+/*
+  Part of the Wiring project - http://wiring.org.co
+  Copyright (c) 2004-06 Hernando Barragan
+  Modified 13 August 2006, David A. Mellis for Arduino - http://www.arduino.cc/
+  
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+  
+  $Id$
+*/
+
+extern "C" {
+  #include "stdlib.h"
+}
+
+void randomSeed(unsigned int seed)
+{
+  if (seed != 0) {
+    srandom(seed);
+  }
+}
+
+long random(long howbig)
+{
+  if (howbig == 0) {
+    return 0;
+  }
+  return random() % howbig;
+}
+
+long random(long howsmall, long howbig)
+{
+  if (howsmall >= howbig) {
+    return howsmall;
+  }
+  long diff = howbig - howsmall;
+  return random(diff) + howsmall;
+}
+
+long map(long x, long in_min, long in_max, long out_min, long out_max)
+{
+  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
+}
+
+unsigned int makeWord(unsigned int w) { return w; }
+unsigned int makeWord(unsigned char h, unsigned char l) { return (h << 8) | l; }
\ No newline at end of file
diff --git a/Marlin/Boards/cores/arduino/WProgram.h b/Marlin/Boards/cores/arduino/WProgram.h
new file mode 100644
index 0000000..f73e760
--- /dev/null
+++ b/Marlin/Boards/cores/arduino/WProgram.h
@@ -0,0 +1,63 @@
+#ifndef WProgram_h
+#define WProgram_h
+
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+
+#include <avr/interrupt.h>
+
+#include "wiring.h"
+
+#ifdef __cplusplus
+#include "WCharacter.h"
+#include "WString.h"
+#include "HardwareSerial.h"
+
+uint16_t makeWord(uint16_t w);
+uint16_t makeWord(byte h, byte l);
+
+#define word(...) makeWord(__VA_ARGS__)
+
+unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout = 1000000L);
+
+void tone(uint8_t _pin, unsigned int frequency, unsigned long duration = 0);
+void noTone(uint8_t _pin);
+
+// WMath prototypes
+long random(long);
+long random(long, long);
+void randomSeed(unsigned int);
+long map(long, long, long, long, long);
+
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+const static uint8_t A0 = 54;
+const static uint8_t A1 = 55;
+const static uint8_t A2 = 56;
+const static uint8_t A3 = 57;
+const static uint8_t A4 = 58;
+const static uint8_t A5 = 59;
+const static uint8_t A6 = 60;
+const static uint8_t A7 = 61;
+const static uint8_t A8 = 62;
+const static uint8_t A9 = 63;
+const static uint8_t A10 = 64;
+const static uint8_t A11 = 65;
+const static uint8_t A12 = 66;
+const static uint8_t A13 = 67;
+const static uint8_t A14 = 68;
+const static uint8_t A15 = 69;
+#else
+const static uint8_t A0 = 14;
+const static uint8_t A1 = 15;
+const static uint8_t A2 = 16;
+const static uint8_t A3 = 17;
+const static uint8_t A4 = 18;
+const static uint8_t A5 = 19;
+const static uint8_t A6 = 20;
+const static uint8_t A7 = 21;
+#endif
+
+#endif
+
+#endif
\ No newline at end of file
diff --git a/Marlin/Boards/cores/arduino/WString.cpp b/Marlin/Boards/cores/arduino/WString.cpp
new file mode 100644
index 0000000..db5a441
--- /dev/null
+++ b/Marlin/Boards/cores/arduino/WString.cpp
@@ -0,0 +1,443 @@
+/*
+  WString.cpp - String library for Wiring & Arduino
+  Copyright (c) 2009-10 Hernando Barragan.  All rights reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include <stdlib.h>
+#include "WProgram.h"
+#include "WString.h"
+
+
+String::String( const char *value )
+{
+  if ( value == NULL )
+    value = "";
+  getBuffer( _length = strlen( value ) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, value );
+}
+
+String::String( const String &value )
+{
+  getBuffer( _length = value._length );
+  if ( _buffer != NULL )
+    strcpy( _buffer, value._buffer );
+}
+
+String::String( const char value )
+{
+  _length = 1;
+  getBuffer(1);
+  if ( _buffer != NULL ) {
+    _buffer[0] = value;
+    _buffer[1] = 0;
+  }
+}
+
+String::String( const unsigned char value )
+{
+  _length = 1;
+  getBuffer(1);
+  if ( _buffer != NULL) {
+    _buffer[0] = value;
+    _buffer[1] = 0;
+  }
+}
+
+String::String( const int value, const int base )
+{
+  char buf[33];   
+  itoa((signed long)value, buf, base);
+  getBuffer( _length = strlen(buf) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, buf );
+}
+
+String::String( const unsigned int value, const int base )
+{
+  char buf[33];   
+  ultoa((unsigned long)value, buf, base);
+  getBuffer( _length = strlen(buf) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, buf );
+}
+
+String::String( const long value, const int base )
+{
+  char buf[33];   
+  ltoa(value, buf, base);
+  getBuffer( _length = strlen(buf) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, buf );
+}
+
+String::String( const unsigned long value, const int base )
+{
+  char buf[33];   
+  ultoa(value, buf, 10);
+  getBuffer( _length = strlen(buf) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, buf );
+}
+
+char String::charAt( unsigned int loc ) const
+{
+  return operator[]( loc );
+}
+
+void String::setCharAt( unsigned int loc, const char aChar ) 
+{
+  if(_buffer == NULL) return;
+  if(_length > loc) {
+    _buffer[loc] = aChar;
+  }
+}
+
+int String::compareTo( const String &s2 ) const
+{
+  return strcmp( _buffer, s2._buffer );
+}
+
+const String & String::concat( const String &s2 )
+{
+  return (*this) += s2;
+}
+
+const String & String::operator=( const String &rhs )
+{
+  if ( this == &rhs )
+    return *this;
+
+  if ( rhs._length > _length )
+  {
+    free(_buffer);
+    getBuffer( rhs._length );
+  }
+  
+  if ( _buffer != NULL ) {
+    _length = rhs._length;
+    strcpy( _buffer, rhs._buffer );
+  }
+  return *this;
+}
+
+//const String & String::operator+=( const char aChar )
+//{
+//  if ( _length == _capacity )
+//    doubleBuffer();
+//
+//  _buffer[ _length++ ] = aChar;
+//  _buffer[ _length ] = '\0';
+//  return *this;
+//}
+
+const String & String::operator+=( const String &other )
+{
+  _length += other._length;
+  if ( _length > _capacity )
+  {
+    char *temp = (char *)realloc(_buffer, _length + 1);
+    if ( temp != NULL ) {
+      _buffer = temp;
+      _capacity = _length;
+    } else {
+      _length -= other._length;
+      return *this;
+    }
+  }
+  strcat( _buffer, other._buffer );
+  return *this;
+}
+
+
+int String::operator==( const String &rhs ) const
+{
+  return ( _length == rhs._length && strcmp( _buffer, rhs._buffer ) == 0 );
+}
+
+int String::operator!=( const String &rhs ) const
+{
+  return ( _length != rhs.length() || strcmp( _buffer, rhs._buffer ) != 0 );
+}
+
+int String::operator<( const String &rhs ) const
+{
+  return strcmp( _buffer, rhs._buffer ) < 0;
+}
+
+int String::operator>( const String &rhs ) const
+{
+  return strcmp( _buffer, rhs._buffer ) > 0;
+}
+
+int String::operator<=( const String &rhs ) const
+{
+  return strcmp( _buffer, rhs._buffer ) <= 0;
+}
+
+int String::operator>=( const String & rhs ) const
+{
+  return strcmp( _buffer, rhs._buffer ) >= 0;
+}
+
+char & String::operator[]( unsigned int index )
+{
+  static char dummy_writable_char;
+  if (index >= _length || !_buffer) {
+    dummy_writable_char = 0;
+    return dummy_writable_char;
+  }
+  return _buffer[ index ];
+}
+
+char String::operator[]( unsigned int index ) const
+{
+  // need to check for valid index, to do later
+  return _buffer[ index ];
+}
+
+boolean String::endsWith( const String &s2 ) const
+{
+  if ( _length < s2._length )
+    return 0;
+
+  return strcmp( &_buffer[ _length - s2._length], s2._buffer ) == 0;
+}
+
+boolean String::equals( const String &s2 ) const
+{
+  return ( _length == s2._length && strcmp( _buffer,s2._buffer ) == 0 );
+}
+
+boolean String::equalsIgnoreCase( const String &s2 ) const
+{
+  if ( this == &s2 )
+    return true; //1;
+  else if ( _length != s2._length )
+    return false; //0;
+
+  return strcmp(toLowerCase()._buffer, s2.toLowerCase()._buffer) == 0;
+}
+
+String String::replace( char findChar, char replaceChar )
+{
+  if ( _buffer == NULL ) return *this;
+  String theReturn = _buffer;
+  char* temp = theReturn._buffer;
+  while( (temp = strchr( temp, findChar )) != 0 )
+    *temp = replaceChar;
+
+  return theReturn;
+}
+
+String String::replace( const String& match, const String& replace )
+{
+  if ( _buffer == NULL ) return *this;
+  String temp = _buffer, newString;
+
+  int loc;
+  while ( (loc = temp.indexOf( match )) != -1 )
+  {
+    newString += temp.substring( 0, loc );
+    newString += replace;
+    temp = temp.substring( loc + match._length );
+  }
+  newString += temp;  
+  return newString;
+}
+
+int String::indexOf( char temp ) const
+{
+  return indexOf( temp, 0 );
+}
+
+int String::indexOf( char ch, unsigned int fromIndex ) const
+{
+  if ( fromIndex >= _length )
+    return -1;
+
+  const char* temp = strchr( &_buffer[fromIndex], ch );
+  if ( temp == NULL )
+    return -1;
+
+  return temp - _buffer;
+}
+
+int String::indexOf( const String &s2 ) const
+{
+  return indexOf( s2, 0 );
+}
+
+int String::indexOf( const String &s2, unsigned int fromIndex ) const
+{
+  if ( fromIndex >= _length )
+    return -1;
+
+  const char *theFind = strstr( &_buffer[ fromIndex ], s2._buffer );
+
+  if ( theFind == NULL )
+    return -1;
+
+  return theFind - _buffer; // pointer subtraction
+}
+
+int String::lastIndexOf( char theChar ) const
+{
+  return lastIndexOf( theChar, _length - 1 );
+}
+
+int String::lastIndexOf( char ch, unsigned int fromIndex ) const
+{
+  if ( fromIndex >= _length )
+    return -1;
+
+  char tempchar = _buffer[fromIndex + 1];
+  _buffer[fromIndex + 1] = '\0';
+  char* temp = strrchr( _buffer, ch );
+  _buffer[fromIndex + 1] = tempchar;
+
+  if ( temp == NULL )
+    return -1;
+
+  return temp - _buffer;
+}
+
+int String::lastIndexOf( const String &s2 ) const
+{
+  return lastIndexOf( s2, _length - s2._length );
+}
+
+int String::lastIndexOf( const String &s2, unsigned int fromIndex ) const
+{
+  // check for empty strings
+  if ( s2._length == 0 || s2._length - 1 > fromIndex || fromIndex >= _length )
+    return -1;
+
+  // matching first character
+  char temp = s2[ 0 ];
+
+  for ( int i = fromIndex; i >= 0; i-- )
+  {
+    if ( _buffer[ i ] == temp && (*this).substring( i, i + s2._length ).equals( s2 ) )
+    return i;
+  }
+  return -1;
+}
+
+boolean String::startsWith( const String &s2 ) const
+{
+  if ( _length < s2._length )
+    return 0;
+
+  return startsWith( s2, 0 );
+}
+
+boolean String::startsWith( const String &s2, unsigned int offset ) const
+{
+  if ( offset > _length - s2._length )
+    return 0;
+
+  return strncmp( &_buffer[offset], s2._buffer, s2._length ) == 0;
+}
+
+String String::substring( unsigned int left ) const
+{
+  return substring( left, _length );
+}
+
+String String::substring( unsigned int left, unsigned int right ) const
+{
+  if ( left > right )
+  {
+    int temp = right;
+    right = left;
+    left = temp;
+  }
+
+  if ( right > _length )
+  {
+    right = _length;
+  } 
+
+  char temp = _buffer[ right ];  // save the replaced character
+  _buffer[ right ] = '\0';	
+  String outPut = ( _buffer + left );  // pointer arithmetic
+  _buffer[ right ] = temp;  //restore character
+  return outPut;
+}
+
+String String::toLowerCase() const
+{
+  String temp = _buffer;
+
+  for ( unsigned int i = 0; i < _length; i++ )
+    temp._buffer[ i ] = (char)tolower( temp._buffer[ i ] );
+  return temp;
+}
+
+String String::toUpperCase() const
+{
+  String temp = _buffer;
+
+  for ( unsigned int i = 0; i < _length; i++ )
+    temp._buffer[ i ] = (char)toupper( temp._buffer[ i ] );
+  return temp;
+}
+
+String String::trim() const
+{
+  if ( _buffer == NULL ) return *this;
+  String temp = _buffer;
+  unsigned int i,j;
+
+  for ( i = 0; i < _length; i++ )
+  {
+    if ( !isspace(_buffer[i]) )
+      break;
+  }
+
+  for ( j = temp._length - 1; j > i; j-- )
+  {
+    if ( !isspace(_buffer[j]) )
+      break;
+  }
+
+  return temp.substring( i, j + 1);
+}
+
+void String::getBytes(unsigned char *buf, unsigned int bufsize)
+{
+  if (!bufsize || !buf) return;
+  unsigned int len = bufsize - 1;
+  if (len > _length) len = _length;
+  strncpy((char *)buf, _buffer, len);
+  buf[len] = 0;
+}
+
+void String::toCharArray(char *buf, unsigned int bufsize)
+{
+  if (!bufsize || !buf) return;
+  unsigned int len = bufsize - 1;
+  if (len > _length) len = _length;
+  strncpy(buf, _buffer, len);
+  buf[len] = 0;
+}
+
+
+long String::toInt() {
+  return atol(_buffer);
+}
diff --git a/Marlin/Boards/cores/arduino/WString.h b/Marlin/Boards/cores/arduino/WString.h
new file mode 100644
index 0000000..cadddb9
--- /dev/null
+++ b/Marlin/Boards/cores/arduino/WString.h
@@ -0,0 +1,112 @@
+/*
+  WString.h - String library for Wiring & Arduino
+  Copyright (c) 2009-10 Hernando Barragan.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef String_h
+#define String_h
+
+//#include "WProgram.h"
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+
+class String
+{
+  public:
+    // constructors
+    String( const char *value = "" );
+    String( const String &value );
+    String( const char );
+    String( const unsigned char );
+    String( const int, const int base=10);
+    String( const unsigned int, const int base=10 );
+    String( const long, const int base=10 );
+    String( const unsigned long, const int base=10 );
+    ~String() { free(_buffer); _length = _capacity = 0;}     //added _length = _capacity = 0;
+
+    // operators
+    const String & operator = ( const String &rhs );
+    const String & operator +=( const String &rhs );
+    //const String & operator +=( const char );
+    int operator ==( const String &rhs ) const;
+    int	operator !=( const String &rhs ) const;
+    int	operator < ( const String &rhs ) const;
+    int	operator > ( const String &rhs ) const;
+    int	operator <=( const String &rhs ) const;
+    int	operator >=( const String &rhs ) const;
+    char operator []( unsigned int index ) const;
+    char& operator []( unsigned int index );
+    //operator const char *() const { return _buffer; }
+    
+    // general methods
+    char charAt( unsigned int index ) const;
+    int	compareTo( const String &anotherString ) const;
+    unsigned char endsWith( const String &suffix ) const;
+    unsigned char equals( const String &anObject ) const;
+    unsigned char equalsIgnoreCase( const String &anotherString ) const;
+    int	indexOf( char ch ) const;
+    int	indexOf( char ch, unsigned int fromIndex ) const;
+    int	indexOf( const String &str ) const;
+    int	indexOf( const String &str, unsigned int fromIndex ) const;
+    int	lastIndexOf( char ch ) const;
+    int	lastIndexOf( char ch, unsigned int fromIndex ) const;
+    int	lastIndexOf( const String &str ) const;
+    int	lastIndexOf( const String &str, unsigned int fromIndex ) const;
+    const unsigned int length( ) const { return _length; }
+    void setCharAt(unsigned int index, const char ch);
+    unsigned char startsWith( const String &prefix ) const;
+    unsigned char startsWith( const String &prefix, unsigned int toffset ) const;
+    String substring( unsigned int beginIndex ) const;
+    String substring( unsigned int beginIndex, unsigned int endIndex ) const;
+    String toLowerCase( ) const;
+    String toUpperCase( ) const;
+    String trim( ) const;
+    void getBytes(unsigned char *buf, unsigned int bufsize);
+    void toCharArray(char *buf, unsigned int bufsize);
+    long toInt( );
+    const String& concat( const String &str );
+    String replace( char oldChar, char newChar );
+    String replace( const String& match, const String& replace );
+    friend String operator + ( String lhs, const String &rhs );
+
+  protected:
+    char *_buffer;	     // the actual char array
+    unsigned int _capacity;  // the array length minus one (for the '\0')
+    unsigned int _length;    // the String length (not counting the '\0')
+
+    void getBuffer(unsigned int maxStrLen);
+
+  private:
+
+};
+
+// allocate buffer space
+inline void String::getBuffer(unsigned int maxStrLen)
+{
+  _capacity = maxStrLen;
+  _buffer = (char *) malloc(_capacity + 1);
+  if (_buffer == NULL) _length = _capacity = 0;
+}
+
+inline String operator+( String lhs, const String &rhs )
+{
+  return lhs += rhs;
+}
+
+
+#endif
diff --git a/Marlin/Boards/cores/arduino/binary.h b/Marlin/Boards/cores/arduino/binary.h
new file mode 100644
index 0000000..af14980
--- /dev/null
+++ b/Marlin/Boards/cores/arduino/binary.h
@@ -0,0 +1,515 @@
+#ifndef Binary_h
+#define Binary_h
+
+#define B0 0
+#define B00 0
+#define B000 0
+#define B0000 0
+#define B00000 0
+#define B000000 0
+#define B0000000 0
+#define B00000000 0
+#define B1 1
+#define B01 1
+#define B001 1
+#define B0001 1
+#define B00001 1
+#define B000001 1
+#define B0000001 1
+#define B00000001 1
+#define B10 2
+#define B010 2
+#define B0010 2
+#define B00010 2
+#define B000010 2
+#define B0000010 2
+#define B00000010 2
+#define B11 3
+#define B011 3
+#define B0011 3
+#define B00011 3
+#define B000011 3
+#define B0000011 3
+#define B00000011 3
+#define B100 4
+#define B0100 4
+#define B00100 4
+#define B000100 4
+#define B0000100 4
+#define B00000100 4
+#define B101 5
+#define B0101 5
+#define B00101 5
+#define B000101 5
+#define B0000101 5
+#define B00000101 5
+#define B110 6
+#define B0110 6
+#define B00110 6
+#define B000110 6
+#define B0000110 6
+#define B00000110 6
+#define B111 7
+#define B0111 7
+#define B00111 7
+#define B000111 7
+#define B0000111 7
+#define B00000111 7
+#define B1000 8
+#define B01000 8
+#define B001000 8
+#define B0001000 8
+#define B00001000 8
+#define B1001 9
+#define B01001 9
+#define B001001 9
+#define B0001001 9
+#define B00001001 9
+#define B1010 10
+#define B01010 10
+#define B001010 10
+#define B0001010 10
+#define B00001010 10
+#define B1011 11
+#define B01011 11
+#define B001011 11
+#define B0001011 11
+#define B00001011 11
+#define B1100 12
+#define B01100 12
+#define B001100 12
+#define B0001100 12
+#define B00001100 12
+#define B1101 13
+#define B01101 13
+#define B001101 13
+#define B0001101 13
+#define B00001101 13
+#define B1110 14
+#define B01110 14
+#define B001110 14
+#define B0001110 14
+#define B00001110 14
+#define B1111 15
+#define B01111 15
+#define B001111 15
+#define B0001111 15
+#define B00001111 15
+#define B10000 16
+#define B010000 16
+#define B0010000 16
+#define B00010000 16
+#define B10001 17
+#define B010001 17
+#define B0010001 17
+#define B00010001 17
+#define B10010 18
+#define B010010 18
+#define B0010010 18
+#define B00010010 18
+#define B10011 19
+#define B010011 19
+#define B0010011 19
+#define B00010011 19
+#define B10100 20
+#define B010100 20
+#define B0010100 20
+#define B00010100 20
+#define B10101 21
+#define B010101 21
+#define B0010101 21
+#define B00010101 21
+#define B10110 22
+#define B010110 22
+#define B0010110 22
+#define B00010110 22
+#define B10111 23
+#define B010111 23
+#define B0010111 23
+#define B00010111 23
+#define B11000 24
+#define B011000 24
+#define B0011000 24
+#define B00011000 24
+#define B11001 25
+#define B011001 25
+#define B0011001 25
+#define B00011001 25
+#define B11010 26
+#define B011010 26
+#define B0011010 26
+#define B00011010 26
+#define B11011 27
+#define B011011 27
+#define B0011011 27
+#define B00011011 27
+#define B11100 28
+#define B011100 28
+#define B0011100 28
+#define B00011100 28
+#define B11101 29
+#define B011101 29
+#define B0011101 29
+#define B00011101 29
+#define B11110 30
+#define B011110 30
+#define B0011110 30
+#define B00011110 30
+#define B11111 31
+#define B011111 31
+#define B0011111 31
+#define B00011111 31
+#define B100000 32
+#define B0100000 32
+#define B00100000 32
+#define B100001 33
+#define B0100001 33
+#define B00100001 33
+#define B100010 34
+#define B0100010 34
+#define B00100010 34
+#define B100011 35
+#define B0100011 35
+#define B00100011 35
+#define B100100 36
+#define B0100100 36
+#define B00100100 36
+#define B100101 37
+#define B0100101 37
+#define B00100101 37
+#define B100110 38
+#define B0100110 38
+#define B00100110 38
+#define B100111 39
+#define B0100111 39
+#define B00100111 39
+#define B101000 40
+#define B0101000 40
+#define B00101000 40
+#define B101001 41
+#define B0101001 41
+#define B00101001 41
+#define B101010 42
+#define B0101010 42
+#define B00101010 42
+#define B101011 43
+#define B0101011 43
+#define B00101011 43
+#define B101100 44
+#define B0101100 44
+#define B00101100 44
+#define B101101 45
+#define B0101101 45
+#define B00101101 45
+#define B101110 46
+#define B0101110 46
+#define B00101110 46
+#define B101111 47
+#define B0101111 47
+#define B00101111 47
+#define B110000 48
+#define B0110000 48
+#define B00110000 48
+#define B110001 49
+#define B0110001 49
+#define B00110001 49
+#define B110010 50
+#define B0110010 50
+#define B00110010 50
+#define B110011 51
+#define B0110011 51
+#define B00110011 51
+#define B110100 52
+#define B0110100 52
+#define B00110100 52
+#define B110101 53
+#define B0110101 53
+#define B00110101 53
+#define B110110 54
+#define B0110110 54
+#define B00110110 54
+#define B110111 55
+#define B0110111 55
+#define B00110111 55
+#define B111000 56
+#define B0111000 56
+#define B00111000 56
+#define B111001 57
+#define B0111001 57
+#define B00111001 57
+#define B111010 58
+#define B0111010 58
+#define B00111010 58
+#define B111011 59
+#define B0111011 59
+#define B00111011 59
+#define B111100 60
+#define B0111100 60
+#define B00111100 60
+#define B111101 61
+#define B0111101 61
+#define B00111101 61
+#define B111110 62
+#define B0111110 62
+#define B00111110 62
+#define B111111 63
+#define B0111111 63
+#define B00111111 63
+#define B1000000 64
+#define B01000000 64
+#define B1000001 65
+#define B01000001 65
+#define B1000010 66
+#define B01000010 66
+#define B1000011 67
+#define B01000011 67
+#define B1000100 68
+#define B01000100 68
+#define B1000101 69
+#define B01000101 69
+#define B1000110 70
+#define B01000110 70
+#define B1000111 71
+#define B01000111 71
+#define B1001000 72
+#define B01001000 72
+#define B1001001 73
+#define B01001001 73
+#define B1001010 74
+#define B01001010 74
+#define B1001011 75
+#define B01001011 75
+#define B1001100 76
+#define B01001100 76
+#define B1001101 77
+#define B01001101 77
+#define B1001110 78
+#define B01001110 78
+#define B1001111 79
+#define B01001111 79
+#define B1010000 80
+#define B01010000 80
+#define B1010001 81
+#define B01010001 81
+#define B1010010 82
+#define B01010010 82
+#define B1010011 83
+#define B01010011 83
+#define B1010100 84
+#define B01010100 84
+#define B1010101 85
+#define B01010101 85
+#define B1010110 86
+#define B01010110 86
+#define B1010111 87
+#define B01010111 87
+#define B1011000 88
+#define B01011000 88
+#define B1011001 89
+#define B01011001 89
+#define B1011010 90
+#define B01011010 90
+#define B1011011 91
+#define B01011011 91
+#define B1011100 92
+#define B01011100 92
+#define B1011101 93
+#define B01011101 93
+#define B1011110 94
+#define B01011110 94
+#define B1011111 95
+#define B01011111 95
+#define B1100000 96
+#define B01100000 96
+#define B1100001 97
+#define B01100001 97
+#define B1100010 98
+#define B01100010 98
+#define B1100011 99
+#define B01100011 99
+#define B1100100 100
+#define B01100100 100
+#define B1100101 101
+#define B01100101 101
+#define B1100110 102
+#define B01100110 102
+#define B1100111 103
+#define B01100111 103
+#define B1101000 104
+#define B01101000 104
+#define B1101001 105
+#define B01101001 105
+#define B1101010 106
+#define B01101010 106
+#define B1101011 107
+#define B01101011 107
+#define B1101100 108
+#define B01101100 108
+#define B1101101 109
+#define B01101101 109
+#define B1101110 110
+#define B01101110 110
+#define B1101111 111
+#define B01101111 111
+#define B1110000 112
+#define B01110000 112
+#define B1110001 113
+#define B01110001 113
+#define B1110010 114
+#define B01110010 114
+#define B1110011 115
+#define B01110011 115
+#define B1110100 116
+#define B01110100 116
+#define B1110101 117
+#define B01110101 117
+#define B1110110 118
+#define B01110110 118
+#define B1110111 119
+#define B01110111 119
+#define B1111000 120
+#define B01111000 120
+#define B1111001 121
+#define B01111001 121
+#define B1111010 122
+#define B01111010 122
+#define B1111011 123
+#define B01111011 123
+#define B1111100 124
+#define B01111100 124
+#define B1111101 125
+#define B01111101 125
+#define B1111110 126
+#define B01111110 126
+#define B1111111 127
+#define B01111111 127
+#define B10000000 128
+#define B10000001 129
+#define B10000010 130
+#define B10000011 131
+#define B10000100 132
+#define B10000101 133
+#define B10000110 134
+#define B10000111 135
+#define B10001000 136
+#define B10001001 137
+#define B10001010 138
+#define B10001011 139
+#define B10001100 140
+#define B10001101 141
+#define B10001110 142
+#define B10001111 143
+#define B10010000 144
+#define B10010001 145
+#define B10010010 146
+#define B10010011 147
+#define B10010100 148
+#define B10010101 149
+#define B10010110 150
+#define B10010111 151
+#define B10011000 152
+#define B10011001 153
+#define B10011010 154
+#define B10011011 155
+#define B10011100 156
+#define B10011101 157
+#define B10011110 158
+#define B10011111 159
+#define B10100000 160
+#define B10100001 161
+#define B10100010 162
+#define B10100011 163
+#define B10100100 164
+#define B10100101 165
+#define B10100110 166
+#define B10100111 167
+#define B10101000 168
+#define B10101001 169
+#define B10101010 170
+#define B10101011 171
+#define B10101100 172
+#define B10101101 173
+#define B10101110 174
+#define B10101111 175
+#define B10110000 176
+#define B10110001 177
+#define B10110010 178
+#define B10110011 179
+#define B10110100 180
+#define B10110101 181
+#define B10110110 182
+#define B10110111 183
+#define B10111000 184
+#define B10111001 185
+#define B10111010 186
+#define B10111011 187
+#define B10111100 188
+#define B10111101 189
+#define B10111110 190
+#define B10111111 191
+#define B11000000 192
+#define B11000001 193
+#define B11000010 194
+#define B11000011 195
+#define B11000100 196
+#define B11000101 197
+#define B11000110 198
+#define B11000111 199
+#define B11001000 200
+#define B11001001 201
+#define B11001010 202
+#define B11001011 203
+#define B11001100 204
+#define B11001101 205
+#define B11001110 206
+#define B11001111 207
+#define B11010000 208
+#define B11010001 209
+#define B11010010 210
+#define B11010011 211
+#define B11010100 212
+#define B11010101 213
+#define B11010110 214
+#define B11010111 215
+#define B11011000 216
+#define B11011001 217
+#define B11011010 218
+#define B11011011 219
+#define B11011100 220
+#define B11011101 221
+#define B11011110 222
+#define B11011111 223
+#define B11100000 224
+#define B11100001 225
+#define B11100010 226
+#define B11100011 227
+#define B11100100 228
+#define B11100101 229
+#define B11100110 230
+#define B11100111 231
+#define B11101000 232
+#define B11101001 233
+#define B11101010 234
+#define B11101011 235
+#define B11101100 236
+#define B11101101 237
+#define B11101110 238
+#define B11101111 239
+#define B11110000 240
+#define B11110001 241
+#define B11110010 242
+#define B11110011 243
+#define B11110100 244
+#define B11110101 245
+#define B11110110 246
+#define B11110111 247
+#define B11111000 248
+#define B11111001 249
+#define B11111010 250
+#define B11111011 251
+#define B11111100 252
+#define B11111101 253
+#define B11111110 254
+#define B11111111 255
+
+#endif
diff --git a/Marlin/Boards/cores/arduino/main.cpp b/Marlin/Boards/cores/arduino/main.cpp
new file mode 100644
index 0000000..cc6e81d
--- /dev/null
+++ b/Marlin/Boards/cores/arduino/main.cpp
@@ -0,0 +1,14 @@
+#include <WProgram.h>
+
+int main(void)
+{
+	init();
+
+	setup();
+    
+	for (;;)
+		loop();
+        
+	return 0;
+}
+
diff --git a/Marlin/Boards/cores/arduino/pins_arduino.c b/Marlin/Boards/cores/arduino/pins_arduino.c
new file mode 100644
index 0000000..d5fa6fe
--- /dev/null
+++ b/Marlin/Boards/cores/arduino/pins_arduino.c
@@ -0,0 +1,200 @@
+/*
+  pins_arduino.c - pin definitions for the Arduino board
+  Part of Arduino / Wiring Lite
+
+  Copyright (c) 2005 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: pins_arduino.c 254 2007-04-20 23:17:38Z mellis $
+*/
+
+#include <avr/io.h>
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+// On the Sanguino board, digital pins are also used
+// for the analog output (software PWM).  Analog input
+// pins are a separate set.
+
+// ATMEL ATMEGA644P / SANGUINO
+//
+//                   +---\/---+
+//  INT0 (D 0) PB0  1|        |40  PA0 (AI 0 / D31)
+//  INT1 (D 1) PB1  2|        |39  PA1 (AI 1 / D30)
+//  INT2 (D 2) PB2  3|        |38  PA2 (AI 2 / D29)
+//   PWM (D 3) PB3  4|        |37  PA3 (AI 3 / D28)
+//   PWM (D 4) PB4  5|        |36  PA4 (AI 4 / D27)
+//  MOSI (D 5) PB5  6|        |35  PA5 (AI 5 / D26)
+//  MISO (D 6) PB6  7|        |34  PA6 (AI 6 / D25)
+//   SCK (D 7) PB7  8|        |33  PA7 (AI 7 / D24)
+//             RST  9|        |32  AREF
+//             VCC 10|        |31  GND 
+//             GND 11|        |30  AVCC
+//           XTAL2 12|        |29  PC7 (D 23)
+//           XTAL1 13|        |28  PC6 (D 22)
+//  RX0 (D 8)  PD0 14|        |27  PC5 (D 21) TDI
+//  TX0 (D 9)  PD1 15|        |26  PC4 (D 20) TDO
+//  RX1 (D 10) PD2 16|        |25  PC3 (D 19) TMS
+//  TX1 (D 11) PD3 17|        |24  PC2 (D 18) TCK
+//  PWM (D 12) PD4 18|        |23  PC1 (D 17) SDA
+//  PWM (D 13) PD5 19|        |22  PC0 (D 16) SCL
+//  PWM (D 14) PD6 20|        |21  PD7 (D 15) PWM
+//                   +--------+
+//
+
+#define PA 1
+#define PB 2
+#define PC 3
+#define PD 4
+
+// these arrays map port names (e.g. port B) to the
+// appropriate addresses for various functions (e.g. reading
+// and writing)
+const uint8_t PROGMEM port_to_mode_PGM[] =
+{
+	NOT_A_PORT,
+	(uint8_t) (uint16_t) &DDRA,
+	(uint8_t) (uint16_t) &DDRB,
+	(uint8_t) (uint16_t) &DDRC,
+	(uint8_t) (uint16_t) &DDRD,
+};
+
+const uint8_t PROGMEM port_to_output_PGM[] =
+{
+	NOT_A_PORT,
+	(uint8_t) (uint16_t) &PORTA,
+	(uint8_t) (uint16_t) &PORTB,
+	(uint8_t) (uint16_t) &PORTC,
+	(uint8_t) (uint16_t) &PORTD,
+};
+
+const uint8_t PROGMEM port_to_input_PGM[] =
+{
+	NOT_A_PORT,
+	(uint8_t) (uint16_t) &PINA,
+	(uint8_t) (uint16_t) &PINB,
+	(uint8_t) (uint16_t) &PINC,
+	(uint8_t) (uint16_t) &PIND,
+};
+
+const uint8_t PROGMEM digital_pin_to_port_PGM[] =
+{
+	PB, /* 0 */
+	PB,
+	PB,
+	PB,
+	PB,
+	PB,
+	PB,
+	PB,
+	PD, /* 8 */
+	PD,
+	PD,
+	PD,
+	PD,
+	PD,
+	PD,
+	PD,
+	PC, /* 16 */
+	PC,
+	PC,
+	PC,
+	PC,
+	PC,
+   	PC,
+	PC,
+	PA, /* 24 */
+	PA,
+	PA,
+	PA,
+	PA,
+	PA,
+	PA,
+	PA  /* 31 */
+};
+
+const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[] =
+{
+	_BV(0), /* 0, port B */
+	_BV(1),
+	_BV(2),
+	_BV(3),
+	_BV(4),
+	_BV(5),
+	_BV(6),
+	_BV(7),
+	_BV(0), /* 8, port D */
+	_BV(1),
+	_BV(2),
+	_BV(3),
+	_BV(4),
+	_BV(5),
+	_BV(6),
+	_BV(7),
+	_BV(0), /* 16, port C */
+	_BV(1),
+	_BV(2),
+	_BV(3),
+	_BV(4),
+	_BV(5),
+	_BV(6),
+	_BV(7),
+	_BV(7), /* 24, port A */
+	_BV(6),
+	_BV(5),
+	_BV(4),
+	_BV(3),
+	_BV(2),
+	_BV(1),
+	_BV(0)
+};
+
+const uint8_t PROGMEM digital_pin_to_timer_PGM[] =
+{
+	NOT_ON_TIMER, 	/* 0  - PB0 */
+	NOT_ON_TIMER, 	/* 1  - PB1 */
+	NOT_ON_TIMER, 	/* 2  - PB2 */
+	TIMER0A,     	/* 3  - PB3 */
+	TIMER0B, 		/* 4  - PB4 */
+	NOT_ON_TIMER, 	/* 5  - PB5 */
+	NOT_ON_TIMER, 	/* 6  - PB6 */
+	NOT_ON_TIMER,	/* 7  - PB7 */
+	NOT_ON_TIMER, 	/* 8  - PD0 */
+	NOT_ON_TIMER, 	/* 9  - PD1 */
+	NOT_ON_TIMER, 	/* 10 - PD2 */
+	NOT_ON_TIMER, 	/* 11 - PD3 */
+	TIMER1B,     	/* 12 - PD4 */
+	TIMER1A,     	/* 13 - PD5 */
+	TIMER2B,     	/* 14 - PD6 */
+	TIMER2A,     	/* 15 - PD7 */
+	NOT_ON_TIMER, 	/* 16 - PC0 */
+	NOT_ON_TIMER,   /* 17 - PC1 */
+	NOT_ON_TIMER,   /* 18 - PC2 */
+	NOT_ON_TIMER,   /* 19 - PC3 */
+	NOT_ON_TIMER,   /* 20 - PC4 */
+	NOT_ON_TIMER,   /* 21 - PC5 */
+	NOT_ON_TIMER,   /* 22 - PC6 */
+	NOT_ON_TIMER,   /* 23 - PC7 */
+	NOT_ON_TIMER,   /* 24 - PA0 */
+	NOT_ON_TIMER,   /* 25 - PA1 */
+	NOT_ON_TIMER,   /* 26 - PA2 */
+	NOT_ON_TIMER,   /* 27 - PA3 */
+	NOT_ON_TIMER,   /* 28 - PA4 */
+	NOT_ON_TIMER,   /* 29 - PA5 */
+	NOT_ON_TIMER,   /* 30 - PA6 */
+	NOT_ON_TIMER   /* 31 - PA7 */
+};
diff --git a/Marlin/Boards/cores/arduino/pins_arduino.h b/Marlin/Boards/cores/arduino/pins_arduino.h
new file mode 100644
index 0000000..fd7ee5c
--- /dev/null
+++ b/Marlin/Boards/cores/arduino/pins_arduino.h
@@ -0,0 +1,65 @@
+/*
+  pins_arduino.h - Pin definition functions for Arduino
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2007 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.h 249 2007-02-03 16:52:51Z mellis $
+*/
+
+#ifndef Pins_Arduino_h
+#define Pins_Arduino_h
+
+#include <avr/pgmspace.h>
+
+#define NOT_A_PIN 0
+#define NOT_A_PORT 0
+
+#define NOT_ON_TIMER 0
+#define TIMER0A 1
+#define TIMER0B 2
+#define TIMER1A 3
+#define TIMER1B 4
+#define TIMER2  5
+#define TIMER2A 6
+#define TIMER2B 7
+
+extern const uint8_t PROGMEM port_to_mode_PGM[];
+extern const uint8_t PROGMEM port_to_input_PGM[];
+extern const uint8_t PROGMEM port_to_output_PGM[];
+
+extern const uint8_t PROGMEM digital_pin_to_port_PGM[];
+extern const uint8_t PROGMEM digital_pin_to_bit_PGM[];
+extern const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[];
+
+extern const uint8_t PROGMEM digital_pin_to_timer_PGM[];
+
+// Get the bit location within the hardware port of the given virtual pin.
+// This comes from the pins_*.c file for the active board configuration.
+// 
+// These perform slightly better as macros compared to inline functions
+//
+#define digitalPinToPort(P) ( pgm_read_byte( digital_pin_to_port_PGM + (P) ) )
+#define digitalPinToBitMask(P) ( pgm_read_byte( digital_pin_to_bit_mask_PGM + (P) ) )
+#define digitalPinToTimer(P) ( pgm_read_byte( digital_pin_to_timer_PGM + (P) ) )
+#define analogInPinToBit(P) (P)
+#define portOutputRegister(P) ( (volatile uint8_t *)( (uint16_t) pgm_read_byte( port_to_output_PGM + (P))) )
+#define portInputRegister(P) ( (volatile uint8_t *)( (uint16_t) pgm_read_byte( port_to_input_PGM + (P))) )
+#define portModeRegister(P) ( (volatile uint8_t *)( (uint16_t) pgm_read_byte( port_to_mode_PGM + (P))) )
+
+#endif
diff --git a/Marlin/Boards/cores/arduino/wiring.c b/Marlin/Boards/cores/arduino/wiring.c
new file mode 100644
index 0000000..b90d07e
--- /dev/null
+++ b/Marlin/Boards/cores/arduino/wiring.c
@@ -0,0 +1,289 @@
+/*
+  wiring.c - Partial implementation of the Wiring API for the ATmega8.
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id$
+*/
+
+#include "wiring_private.h"
+
+// the prescaler is set so that timer0 ticks every 64 clock cycles, and the
+// the overflow handler is called every 256 ticks.
+#define MICROSECONDS_PER_TIMER0_OVERFLOW (clockCyclesToMicroseconds(64 * 256))
+
+// the whole number of milliseconds per timer0 overflow
+#define MILLIS_INC (MICROSECONDS_PER_TIMER0_OVERFLOW / 1000)
+
+// the fractional number of milliseconds per timer0 overflow. we shift right
+// by three to fit these numbers into a byte. (for the clock speeds we care
+// about - 8 and 16 MHz - this doesn't lose precision.)
+#define FRACT_INC ((MICROSECONDS_PER_TIMER0_OVERFLOW % 1000) >> 3)
+#define FRACT_MAX (1000 >> 3)
+
+volatile unsigned long timer0_overflow_count = 0;
+volatile unsigned long timer0_millis = 0;
+static unsigned char timer0_fract = 0;
+
+SIGNAL(TIMER0_OVF_vect)
+{
+	// copy these to local variables so they can be stored in registers
+	// (volatile variables must be read from memory on every access)
+	unsigned long m = timer0_millis;
+	unsigned char f = timer0_fract;
+
+	m += MILLIS_INC;
+	f += FRACT_INC;
+	if (f >= FRACT_MAX) {
+		f -= FRACT_MAX;
+		m += 1;
+	}
+
+	timer0_fract = f;
+	timer0_millis = m;
+	timer0_overflow_count++;
+}
+
+unsigned long millis()
+{
+	unsigned long m;
+	uint8_t oldSREG = SREG;
+
+	// disable interrupts while we read timer0_millis or we might get an
+	// inconsistent value (e.g. in the middle of a write to timer0_millis)
+	cli();
+	m = timer0_millis;
+	SREG = oldSREG;
+
+	return m;
+}
+
+unsigned long micros() {
+	unsigned long m;
+	uint8_t oldSREG = SREG, t;
+	
+	cli();
+	m = timer0_overflow_count;
+#if defined(TCNT0)
+	t = TCNT0;
+#elif defined(TCNT0L)
+	t = TCNT0L;
+#else
+	#error TIMER 0 not defined
+#endif
+
+  
+#ifdef TIFR0
+	if ((TIFR0 & _BV(TOV0)) && (t < 255))
+		m++;
+#else
+	if ((TIFR & _BV(TOV0)) && (t < 255))
+		m++;
+#endif
+
+	SREG = oldSREG;
+	
+	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
+}
+
+void delay(unsigned long ms)
+{
+	uint16_t start = (uint16_t)micros();
+
+	while (ms > 0) {
+		if (((uint16_t)micros() - start) >= 1000) {
+			ms--;
+			start += 1000;
+		}
+	}
+}
+
+/* Delay for the given number of microseconds.  Assumes a 8 or 16 MHz clock. */
+void delayMicroseconds(unsigned int us)
+{
+	// calling avrlib's delay_us() function with low values (e.g. 1 or
+	// 2 microseconds) gives delays longer than desired.
+	//delay_us(us);
+
+#if F_CPU >= 16000000L
+	// for the 16 MHz clock on most Arduino boards
+
+	// for a one-microsecond delay, simply return.  the overhead
+	// of the function call yields a delay of approximately 1 1/8 us.
+	if (--us == 0)
+		return;
+
+	// the following loop takes a quarter of a microsecond (4 cycles)
+	// per iteration, so execute it four times for each microsecond of
+	// delay requested.
+	us <<= 2;
+
+	// account for the time taken in the preceeding commands.
+	us -= 2;
+#else
+	// for the 8 MHz internal clock on the ATmega168
+
+	// for a one- or two-microsecond delay, simply return.  the overhead of
+	// the function calls takes more than two microseconds.  can't just
+	// subtract two, since us is unsigned; we'd overflow.
+	if (--us == 0)
+		return;
+	if (--us == 0)
+		return;
+
+	// the following loop takes half of a microsecond (4 cycles)
+	// per iteration, so execute it twice for each microsecond of
+	// delay requested.
+	us <<= 1;
+    
+	// partially compensate for the time taken by the preceeding commands.
+	// we can't subtract any more than this or we'd overflow w/ small delays.
+	us--;
+#endif
+
+	// busy wait
+	__asm__ __volatile__ (
+		"1: sbiw %0,1" "\n\t" // 2 cycles
+		"brne 1b" : "=w" (us) : "0" (us) // 2 cycles
+	);
+}
+
+void init()
+{
+	// this needs to be called before setup() or some functions won't
+	// work there
+	sei();
+	
+	// on the ATmega168, timer 0 is also used for fast hardware pwm
+	// (using phase-correct PWM would mean that timer 0 overflowed half as often
+	// resulting in different millis() behavior on the ATmega8 and ATmega168)
+#if defined(TCCR0A) && defined(WGM01)
+	sbi(TCCR0A, WGM01);
+	sbi(TCCR0A, WGM00);
+#endif  
+
+	// set timer 0 prescale factor to 64
+#if defined(__AVR_ATmega128__)
+	// CPU specific: different values for the ATmega128
+	sbi(TCCR0, CS02);
+#elif defined(TCCR0) && defined(CS01) && defined(CS00)
+	// this combination is for the standard atmega8
+	sbi(TCCR0, CS01);
+	sbi(TCCR0, CS00);
+#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
+	// this combination is for the standard 168/328/1280/2560
+	sbi(TCCR0B, CS01);
+	sbi(TCCR0B, CS00);
+#elif defined(TCCR0A) && defined(CS01) && defined(CS00)
+	// this combination is for the __AVR_ATmega645__ series
+	sbi(TCCR0A, CS01);
+	sbi(TCCR0A, CS00);
+#else
+	#error Timer 0 prescale factor 64 not set correctly
+#endif
+
+	// enable timer 0 overflow interrupt
+#if defined(TIMSK) && defined(TOIE0)
+	sbi(TIMSK, TOIE0);
+#elif defined(TIMSK0) && defined(TOIE0)
+	sbi(TIMSK0, TOIE0);
+#else
+	#error	Timer 0 overflow interrupt not set correctly
+#endif
+
+	// timers 1 and 2 are used for phase-correct hardware pwm
+	// this is better for motors as it ensures an even waveform
+	// note, however, that fast pwm mode can achieve a frequency of up
+	// 8 MHz (with a 16 MHz clock) at 50% duty cycle
+
+	TCCR1B = 0;
+
+	// set timer 1 prescale factor to 64
+#if defined(TCCR1B) && defined(CS11) && defined(CS10)
+	sbi(TCCR1B, CS11);
+	sbi(TCCR1B, CS10);
+#elif defined(TCCR1) && defined(CS11) && defined(CS10)
+	sbi(TCCR1, CS11);
+	sbi(TCCR1, CS10);
+#endif
+	// put timer 1 in 8-bit phase correct pwm mode
+#if defined(TCCR1A) && defined(WGM10)
+	sbi(TCCR1A, WGM10);
+#elif defined(TCCR1)
+	#warning this needs to be finished
+#endif
+
+	// set timer 2 prescale factor to 64
+#if defined(TCCR2) && defined(CS22)
+	sbi(TCCR2, CS22);
+#elif defined(TCCR2B) && defined(CS22)
+	sbi(TCCR2B, CS22);
+#else
+	#warning Timer 2 not finished (may not be present on this CPU)
+#endif
+
+	// configure timer 2 for phase correct pwm (8-bit)
+#if defined(TCCR2) && defined(WGM20)
+	sbi(TCCR2, WGM20);
+#elif defined(TCCR2A) && defined(WGM20)
+	sbi(TCCR2A, WGM20);
+#else
+	#warning Timer 2 not finished (may not be present on this CPU)
+#endif
+
+#if defined(TCCR3B) && defined(CS31) && defined(WGM30)
+	sbi(TCCR3B, CS31);		// set timer 3 prescale factor to 64
+	sbi(TCCR3B, CS30);
+	sbi(TCCR3A, WGM30);		// put timer 3 in 8-bit phase correct pwm mode
+#endif
+	
+#if defined(TCCR4B) && defined(CS41) && defined(WGM40)
+	sbi(TCCR4B, CS41);		// set timer 4 prescale factor to 64
+	sbi(TCCR4B, CS40);
+	sbi(TCCR4A, WGM40);		// put timer 4 in 8-bit phase correct pwm mode
+#endif
+
+#if defined(TCCR5B) && defined(CS51) && defined(WGM50)
+	sbi(TCCR5B, CS51);		// set timer 5 prescale factor to 64
+	sbi(TCCR5B, CS50);
+	sbi(TCCR5A, WGM50);		// put timer 5 in 8-bit phase correct pwm mode
+#endif
+
+#if defined(ADCSRA)
+	// set a2d prescale factor to 128
+	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.
+	// XXX: this will not work properly for other clock speeds, and
+	// this code should use F_CPU to determine the prescale factor.
+	sbi(ADCSRA, ADPS2);
+	sbi(ADCSRA, ADPS1);
+	sbi(ADCSRA, ADPS0);
+
+	// enable a2d conversions
+	sbi(ADCSRA, ADEN);
+#endif
+
+	// the bootloader connects pins 0 and 1 to the USART; disconnect them
+	// here so they can be used as normal digital i/o; they will be
+	// reconnected in Serial.begin()
+#if defined(UCSRB)
+	UCSRB = 0;
+#elif defined(UCSR0B)
+	UCSR0B = 0;
+#endif
+}
diff --git a/Marlin/Boards/cores/arduino/wiring.h b/Marlin/Boards/cores/arduino/wiring.h
new file mode 100644
index 0000000..0a93678
--- /dev/null
+++ b/Marlin/Boards/cores/arduino/wiring.h
@@ -0,0 +1,136 @@
+/*
+  wiring.h - Partial implementation of the Wiring API for the ATmega8.
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id$
+*/
+
+#ifndef Wiring_h
+#define Wiring_h
+
+#include <math.h>
+#include <avr/io.h>
+#include <stdlib.h>
+#include "binary.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+#define HIGH 0x1
+#define LOW  0x0
+
+#define INPUT 0x0
+#define OUTPUT 0x1
+
+#define true 0x1
+#define false 0x0
+
+#define PI 3.1415926535897932384626433832795
+#define HALF_PI 1.5707963267948966192313216916398
+#define TWO_PI 6.283185307179586476925286766559
+#define DEG_TO_RAD 0.017453292519943295769236907684886
+#define RAD_TO_DEG 57.295779513082320876798154814105
+
+#define SERIAL  0x0
+#define DISPLAY 0x1
+
+#define LSBFIRST 0
+#define MSBFIRST 1
+
+#define CHANGE 1
+#define FALLING 2
+#define RISING 3
+
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+#define INTERNAL1V1 2
+#define INTERNAL2V56 3
+#else
+#define INTERNAL 3
+#endif
+#define DEFAULT 1
+#define EXTERNAL 0
+
+// undefine stdlib's abs if encountered
+#ifdef abs
+#undef abs
+#endif
+
+#define min(a,b) ((a)<(b)?(a):(b))
+#define max(a,b) ((a)>(b)?(a):(b))
+#define abs(x) ((x)>0?(x):-(x))
+#define constrain(amt,low,high) ((amt)<(low)?(low):((amt)>(high)?(high):(amt)))
+#define round(x)     ((x)>=0?(long)((x)+0.5):(long)((x)-0.5))
+#define radians(deg) ((deg)*DEG_TO_RAD)
+#define degrees(rad) ((rad)*RAD_TO_DEG)
+#define sq(x) ((x)*(x))
+
+#define interrupts() sei()
+#define noInterrupts() cli()
+
+#define clockCyclesPerMicrosecond() ( F_CPU / 1000000L )
+#define clockCyclesToMicroseconds(a) ( ((a) * 1000L) / (F_CPU / 1000L) )
+#define microsecondsToClockCycles(a) ( ((a) * (F_CPU / 1000L)) / 1000L )
+
+#define lowByte(w) ((uint8_t) ((w) & 0xff))
+#define highByte(w) ((uint8_t) ((w) >> 8))
+
+#define bitRead(value, bit) (((value) >> (bit)) & 0x01)
+#define bitSet(value, bit) ((value) |= (1UL << (bit)))
+#define bitClear(value, bit) ((value) &= ~(1UL << (bit)))
+#define bitWrite(value, bit, bitvalue) (bitvalue ? bitSet(value, bit) : bitClear(value, bit))
+
+
+typedef unsigned int word;
+
+#define bit(b) (1UL << (b))
+
+typedef uint8_t boolean;
+typedef uint8_t byte;
+
+void init(void);
+
+void pinMode(uint8_t, uint8_t);
+void digitalWrite(uint8_t, uint8_t);
+int digitalRead(uint8_t);
+int analogRead(uint8_t);
+void analogReference(uint8_t mode);
+void analogWrite(uint8_t, int);
+
+unsigned long millis(void);
+unsigned long micros(void);
+void delay(unsigned long);
+void delayMicroseconds(unsigned int us);
+unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout);
+
+void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val);
+uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder);
+
+void attachInterrupt(uint8_t, void (*)(void), int mode);
+void detachInterrupt(uint8_t);
+
+void setup(void);
+void loop(void);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif
diff --git a/Marlin/Boards/cores/arduino/wiring_analog.c b/Marlin/Boards/cores/arduino/wiring_analog.c
new file mode 100644
index 0000000..d248f4c
--- /dev/null
+++ b/Marlin/Boards/cores/arduino/wiring_analog.c
@@ -0,0 +1,259 @@
+/*
+  wiring_analog.c - analog input and output
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  Modified 28 September 2010 by Mark Sproul
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+uint8_t analog_reference = DEFAULT;
+
+void analogReference(uint8_t mode)
+{
+	// can't actually set the register here because the default setting
+	// will connect AVCC and the AREF pin, which would cause a short if
+	// there's something connected to AREF.
+	analog_reference = mode;
+}
+
+int analogRead(uint8_t pin)
+{
+	uint8_t low, high;
+
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+	if (pin >= 54) pin -= 54; // allow for channel or pin numbers
+#else
+	if (pin >= 14) pin -= 14; // allow for channel or pin numbers
+#endif
+
+#if defined(ADCSRB) && defined(MUX5)
+	// the MUX5 bit of ADCSRB selects whether we're reading from channels
+	// 0 to 7 (MUX5 low) or 8 to 15 (MUX5 high).
+	ADCSRB = (ADCSRB & ~(1 << MUX5)) | (((pin >> 3) & 0x01) << MUX5);
+#endif
+  
+	// set the analog reference (high two bits of ADMUX) and select the
+	// channel (low 4 bits).  this also sets ADLAR (left-adjust result)
+	// to 0 (the default).
+#if defined(ADMUX)
+	ADMUX = (analog_reference << 6) | (pin & 0x07);
+#endif
+
+	// without a delay, we seem to read from the wrong channel
+	//delay(1);
+
+#if defined(ADCSRA) && defined(ADCL)
+	// start the conversion
+	sbi(ADCSRA, ADSC);
+
+	// ADSC is cleared when the conversion finishes
+	while (bit_is_set(ADCSRA, ADSC));
+
+	// we have to read ADCL first; doing so locks both ADCL
+	// and ADCH until ADCH is read.  reading ADCL second would
+	// cause the results of each conversion to be discarded,
+	// as ADCL and ADCH would be locked when it completed.
+	low  = ADCL;
+	high = ADCH;
+#else
+	// we dont have an ADC, return 0
+	low  = 0;
+	high = 0;
+#endif
+
+	// combine the two bytes
+	return (high << 8) | low;
+}
+
+// Right now, PWM output only works on the pins with
+// hardware support.  These are defined in the appropriate
+// pins_*.c file.  For the rest of the pins, we default
+// to digital output.
+void analogWrite(uint8_t pin, int val)
+{
+	// We need to make sure the PWM output is enabled for those pins
+	// that support it, as we turn it off when digitally reading or
+	// writing with them.  Also, make sure the pin is in output mode
+	// for consistenty with Wiring, which doesn't require a pinMode
+	// call for the analog output pins.
+	pinMode(pin, OUTPUT);
+	if (val == 0)
+	{
+		digitalWrite(pin, LOW);
+	}
+	else if (val == 255)
+	{
+		digitalWrite(pin, HIGH);
+	}
+	else
+	{
+		switch(digitalPinToTimer(pin))
+		{
+			// XXX fix needed for atmega8
+			#if defined(TCCR0) && defined(COM00) && !defined(__AVR_ATmega8__)
+			case TIMER0A:
+				// connect pwm to pin on timer 0
+				sbi(TCCR0, COM00);
+				OCR0 = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR0A) && defined(COM0A1)
+			case TIMER0A:
+				// connect pwm to pin on timer 0, channel A
+				sbi(TCCR0A, COM0A1);
+				OCR0A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR0A) && defined(COM0B1)
+			case TIMER0B:
+				// connect pwm to pin on timer 0, channel B
+				sbi(TCCR0A, COM0B1);
+				OCR0B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR1A) && defined(COM1A1)
+			case TIMER1A:
+				// connect pwm to pin on timer 1, channel A
+				sbi(TCCR1A, COM1A1);
+				OCR1A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR1A) && defined(COM1B1)
+			case TIMER1B:
+				// connect pwm to pin on timer 1, channel B
+				sbi(TCCR1A, COM1B1);
+				OCR1B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR2) && defined(COM21)
+			case TIMER2:
+				// connect pwm to pin on timer 2
+				sbi(TCCR2, COM21);
+				OCR2 = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR2A) && defined(COM2A1)
+			case TIMER2A:
+				// connect pwm to pin on timer 2, channel A
+				sbi(TCCR2A, COM2A1);
+				OCR2A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR2A) && defined(COM2B1)
+			case TIMER2B:
+				// connect pwm to pin on timer 2, channel B
+				sbi(TCCR2A, COM2B1);
+				OCR2B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR3A) && defined(COM3A1)
+			case TIMER3A:
+				// connect pwm to pin on timer 3, channel A
+				sbi(TCCR3A, COM3A1);
+				OCR3A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR3A) && defined(COM3B1)
+			case TIMER3B:
+				// connect pwm to pin on timer 3, channel B
+				sbi(TCCR3A, COM3B1);
+				OCR3B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR3A) && defined(COM3C1)
+			case TIMER3C:
+				// connect pwm to pin on timer 3, channel C
+				sbi(TCCR3A, COM3C1);
+				OCR3C = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR4A) && defined(COM4A1)
+			case TIMER4A:
+				// connect pwm to pin on timer 4, channel A
+				sbi(TCCR4A, COM4A1);
+				OCR4A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR4A) && defined(COM4B1)
+			case TIMER4B:
+				// connect pwm to pin on timer 4, channel B
+				sbi(TCCR4A, COM4B1);
+				OCR4B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR4A) && defined(COM4C1)
+			case TIMER4C:
+				// connect pwm to pin on timer 4, channel C
+				sbi(TCCR4A, COM4C1);
+				OCR4C = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR5A) && defined(COM5A1)
+			case TIMER5A:
+				// connect pwm to pin on timer 5, channel A
+				sbi(TCCR5A, COM5A1);
+				OCR5A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR5A) && defined(COM5B1)
+			case TIMER5B:
+				// connect pwm to pin on timer 5, channel B
+				sbi(TCCR5A, COM5B1);
+				OCR5B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR5A) && defined(COM5C1)
+			case TIMER5C:
+				// connect pwm to pin on timer 5, channel C
+				sbi(TCCR5A, COM5C1);
+				OCR5C = val; // set pwm duty
+				break;
+			#endif
+
+			case NOT_ON_TIMER:
+			default:
+				if (val < 128) {
+					digitalWrite(pin, LOW);
+				} else {
+					digitalWrite(pin, HIGH);
+				}
+		}
+	}
+}
diff --git a/Marlin/Boards/cores/arduino/wiring_digital.c b/Marlin/Boards/cores/arduino/wiring_digital.c
new file mode 100644
index 0000000..0949da4
--- /dev/null
+++ b/Marlin/Boards/cores/arduino/wiring_digital.c
@@ -0,0 +1,166 @@
+/*
+  wiring_digital.c - digital input and output functions
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  Modified 28 September 2010 by Mark Sproul
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+void pinMode(uint8_t pin, uint8_t mode)
+{
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+	volatile uint8_t *reg;
+
+	if (port == NOT_A_PIN) return;
+
+	// JWS: can I let the optimizer do this?
+	reg = portModeRegister(port);
+
+	if (mode == INPUT) { 
+		uint8_t oldSREG = SREG;
+                cli();
+		*reg &= ~bit;
+		SREG = oldSREG;
+	} else {
+		uint8_t oldSREG = SREG;
+                cli();
+		*reg |= bit;
+		SREG = oldSREG;
+	}
+}
+
+// Forcing this inline keeps the callers from having to push their own stuff
+// on the stack. It is a good performance win and only takes 1 more byte per
+// user than calling. (It will take more bytes on the 168.)
+//
+// But shouldn't this be moved into pinMode? Seems silly to check and do on
+// each digitalread or write.
+//
+// Mark Sproul:
+// - Removed inline. Save 170 bytes on atmega1280
+// - changed to a switch statment; added 32 bytes but much easier to read and maintain.
+// - Added more #ifdefs, now compiles for atmega645
+//
+//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
+//static inline void turnOffPWM(uint8_t timer)
+static void turnOffPWM(uint8_t timer)
+{
+	switch (timer)
+	{
+		#if defined(TCCR1A) && defined(COM1A1)
+		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
+		#endif
+		#if defined(TCCR1A) && defined(COM1B1)
+		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
+		#endif
+		
+		#if defined(TCCR2) && defined(COM21)
+		case  TIMER2:   cbi(TCCR2, COM21);      break;
+		#endif
+		
+		#if defined(TCCR0A) && defined(COM0A1)
+		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
+		#endif
+		
+		#if defined(TIMER0B) && defined(COM0B1)
+		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
+		#endif
+		#if defined(TCCR2A) && defined(COM2A1)
+		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
+		#endif
+		#if defined(TCCR2A) && defined(COM2B1)
+		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
+		#endif
+		
+		#if defined(TCCR3A) && defined(COM3A1)
+		case  TIMER3A:  cbi(TCCR3A, COM3A1);    break;
+		#endif
+		#if defined(TCCR3A) && defined(COM3B1)
+		case  TIMER3B:  cbi(TCCR3A, COM3B1);    break;
+		#endif
+		#if defined(TCCR3A) && defined(COM3C1)
+		case  TIMER3C:  cbi(TCCR3A, COM3C1);    break;
+		#endif
+
+		#if defined(TCCR4A) && defined(COM4A1)
+		case  TIMER4A:  cbi(TCCR4A, COM4A1);    break;
+		#endif
+		#if defined(TCCR4A) && defined(COM4B1)
+		case  TIMER4B:  cbi(TCCR4A, COM4B1);    break;
+		#endif
+		#if defined(TCCR4A) && defined(COM4C1)
+		case  TIMER4C:  cbi(TCCR4A, COM4C1);    break;
+		#endif
+		#if defined(TCCR5A)
+		case  TIMER5A:  cbi(TCCR5A, COM5A1);    break;
+		case  TIMER5B:  cbi(TCCR5A, COM5B1);    break;
+		case  TIMER5C:  cbi(TCCR5A, COM5C1);    break;
+		#endif
+	}
+}
+
+void digitalWrite(uint8_t pin, uint8_t val)
+{
+	uint8_t timer = digitalPinToTimer(pin);
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+	volatile uint8_t *out;
+
+	if (port == NOT_A_PIN) return;
+
+	// If the pin that support PWM output, we need to turn it off
+	// before doing a digital write.
+	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
+
+	out = portOutputRegister(port);
+
+	if (val == LOW) {
+		uint8_t oldSREG = SREG;
+                cli();
+		*out &= ~bit;
+		SREG = oldSREG;
+	} else {
+		uint8_t oldSREG = SREG;
+                cli();
+		*out |= bit;
+		SREG = oldSREG;
+	}
+}
+
+int digitalRead(uint8_t pin)
+{
+	uint8_t timer = digitalPinToTimer(pin);
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+
+	if (port == NOT_A_PIN) return LOW;
+
+	// If the pin that support PWM output, we need to turn it off
+	// before getting a digital reading.
+	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
+
+	if (*portInputRegister(port) & bit) return HIGH;
+	return LOW;
+}
diff --git a/Marlin/Boards/cores/arduino/wiring_private.h b/Marlin/Boards/cores/arduino/wiring_private.h
new file mode 100644
index 0000000..7449c76
--- /dev/null
+++ b/Marlin/Boards/cores/arduino/wiring_private.h
@@ -0,0 +1,68 @@
+/*
+  wiring_private.h - Internal header file.
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.h 239 2007-01-12 17:58:39Z mellis $
+*/
+
+#ifndef WiringPrivate_h
+#define WiringPrivate_h
+#include <math.h>
+#include <avr/io.h>
+#include <avr/interrupt.h>
+#include <util/delay.h>
+#include <stdio.h>
+#include <stdarg.h>
+
+#include "wiring.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+#ifndef cbi
+#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
+#endif
+#ifndef sbi
+#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
+#endif
+
+#define EXTERNAL_INT_0 0
+#define EXTERNAL_INT_1 1
+#define EXTERNAL_INT_2 2
+#define EXTERNAL_INT_3 3
+#define EXTERNAL_INT_4 4
+#define EXTERNAL_INT_5 5
+#define EXTERNAL_INT_6 6
+#define EXTERNAL_INT_7 7
+
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+#define EXTERNAL_NUM_INTERRUPTS 8
+#else
+#define EXTERNAL_NUM_INTERRUPTS 2
+#endif
+
+typedef void (*voidFuncPtr)(void);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif
diff --git a/Marlin/Boards/cores/arduino/wiring_pulse.c b/Marlin/Boards/cores/arduino/wiring_pulse.c
new file mode 100644
index 0000000..0d96886
--- /dev/null
+++ b/Marlin/Boards/cores/arduino/wiring_pulse.c
@@ -0,0 +1,69 @@
+/*
+  wiring_pulse.c - pulseIn() function
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+/* Measures the length (in microseconds) of a pulse on the pin; state is HIGH
+ * or LOW, the type of pulse to measure.  Works on pulses from 2-3 microseconds
+ * to 3 minutes in length, but must be called at least a few dozen microseconds
+ * before the start of the pulse. */
+unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout)
+{
+	// cache the port and bit of the pin in order to speed up the
+	// pulse width measuring loop and achieve finer resolution.  calling
+	// digitalRead() instead yields much coarser resolution.
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+	uint8_t stateMask = (state ? bit : 0);
+	unsigned long width = 0; // keep initialization out of time critical area
+	
+	// convert the timeout from microseconds to a number of times through
+	// the initial loop; it takes 16 clock cycles per iteration.
+	unsigned long numloops = 0;
+	unsigned long maxloops = microsecondsToClockCycles(timeout) / 16;
+	
+	// wait for any previous pulse to end
+	while ((*portInputRegister(port) & bit) == stateMask)
+		if (numloops++ == maxloops)
+			return 0;
+	
+	// wait for the pulse to start
+	while ((*portInputRegister(port) & bit) != stateMask)
+		if (numloops++ == maxloops)
+			return 0;
+	
+	// wait for the pulse to stop
+	while ((*portInputRegister(port) & bit) == stateMask) {
+		if (numloops++ == maxloops)
+			return 0;
+		width++;
+	}
+
+	// convert the reading to microseconds. The loop has been determined
+	// to be 20 clock cycles long and have about 16 clocks between the edge
+	// and the start of the loop. There will be some error introduced by
+	// the interrupt handlers.
+	return clockCyclesToMicroseconds(width * 21 + 16); 
+}
diff --git a/Marlin/Boards/cores/arduino/wiring_shift.c b/Marlin/Boards/cores/arduino/wiring_shift.c
new file mode 100644
index 0000000..cfe7867
--- /dev/null
+++ b/Marlin/Boards/cores/arduino/wiring_shift.c
@@ -0,0 +1,55 @@
+/*
+  wiring_shift.c - shiftOut() function
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+
+uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder) {
+	uint8_t value = 0;
+	uint8_t i;
+
+	for (i = 0; i < 8; ++i) {
+		digitalWrite(clockPin, HIGH);
+		if (bitOrder == LSBFIRST)
+			value |= digitalRead(dataPin) << i;
+		else
+			value |= digitalRead(dataPin) << (7 - i);
+		digitalWrite(clockPin, LOW);
+	}
+	return value;
+}
+
+void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val)
+{
+	uint8_t i;
+
+	for (i = 0; i < 8; i++)  {
+		if (bitOrder == LSBFIRST)
+			digitalWrite(dataPin, !!(val & (1 << i)));
+		else	
+			digitalWrite(dataPin, !!(val & (1 << (7 - i))));
+			
+		digitalWrite(clockPin, HIGH);
+		digitalWrite(clockPin, LOW);		
+	}
+}

commit 5fd4582cc8b25b9569ff43917b60469ca03193ce (from be1e099f1b446d5d12b6f89c6323427d1c3075f3)
Merge: 8b88e3b be1e099
Author: daid <daid303@gmail.com>
Date:   Tue Jan 8 03:29:20 2013 -0800

    Merge pull request #242 from Drakelive/Marlin_v1
    
    Fixes issues # 216 and # 135 for Gen6 and Gen6 Deluxe board

diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/boards.txt b/ArduinoAddons/Arduino_0.xx/Gen7/boards.txt
new file mode 100644
index 0000000..d6fbaee
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/boards.txt
@@ -0,0 +1,101 @@
+##############################################################
+
+Gen7-644-16.name=Gen7 with ATmega644 and 16 MHz
+Gen7-644-16.upload.protocol=stk500v2
+Gen7-644-16.upload.maximum_size=63488
+Gen7-644-16.upload.speed=115200
+Gen7-644-16.bootloader.low_fuses=0xF7
+Gen7-644-16.bootloader.high_fuses=0xD4
+Gen7-644-16.bootloader.extended_fuses=0xFD
+Gen7-644-16.bootloader.path=Gen7
+Gen7-644-16.bootloader.file=bootloader-644-16MHz.hex
+Gen7-644-16.bootloader.unlock_bits=0x3F
+Gen7-644-16.bootloader.lock_bits=0x0F
+Gen7-644-16.build.mcu=atmega644
+Gen7-644-16.build.f_cpu=16000000L
+Gen7-644-16.build.core=arduino
+
+##############################################################
+
+Gen7-644-20.name=Gen7 with ATmega644 and 20 MHz
+Gen7-644-20.upload.protocol=stk500v2
+Gen7-644-20.upload.maximum_size=63488
+Gen7-644-20.upload.speed=115200
+Gen7-644-20.bootloader.low_fuses=0xF7
+Gen7-644-20.bootloader.high_fuses=0xD4
+Gen7-644-20.bootloader.extended_fuses=0xFD
+Gen7-644-20.bootloader.path=Gen7
+Gen7-644-20.bootloader.file=bootloader-644-20MHz.hex
+Gen7-644-20.bootloader.unlock_bits=0x3F
+Gen7-644-20.bootloader.lock_bits=0x0F
+Gen7-644-20.build.mcu=atmega644
+Gen7-644-20.build.f_cpu=20000000L
+Gen7-644-20.build.core=arduino
+
+##############################################################
+
+Gen7-644P-16.name=Gen7 with ATmega644P and 16 MHz
+Gen7-644P-16.upload.protocol=stk500v2
+Gen7-644P-16.upload.maximum_size=63488
+Gen7-644P-16.upload.speed=115200
+Gen7-644P-16.bootloader.low_fuses=0xF7
+Gen7-644P-16.bootloader.high_fuses=0xD4
+Gen7-644P-16.bootloader.extended_fuses=0xFD
+Gen7-644P-16.bootloader.path=Gen7
+Gen7-644P-16.bootloader.file=bootloader-644P-16MHz.hex
+Gen7-644P-16.bootloader.unlock_bits=0x3F
+Gen7-644P-16.bootloader.lock_bits=0x0F
+Gen7-644P-16.build.mcu=atmega644p
+Gen7-644P-16.build.f_cpu=16000000L
+Gen7-644P-16.build.core=arduino
+
+##############################################################
+
+Gen7-644P-20.name=Gen7 with ATmega644P and 20 MHz
+Gen7-644P-20.upload.protocol=stk500v2
+Gen7-644P-20.upload.maximum_size=63488
+Gen7-644P-20.upload.speed=115200
+Gen7-644P-20.bootloader.low_fuses=0xF7
+Gen7-644P-20.bootloader.high_fuses=0xD4
+Gen7-644P-20.bootloader.extended_fuses=0xFD
+Gen7-644P-20.bootloader.path=Gen7
+Gen7-644P-20.bootloader.file=bootloader-644P-20MHz.hex
+Gen7-644P-20.bootloader.unlock_bits=0x3F
+Gen7-644P-20.bootloader.lock_bits=0x0F
+Gen7-644P-20.build.mcu=atmega644p
+Gen7-644P-20.build.f_cpu=20000000L
+Gen7-644P-20.build.core=arduino
+
+##############################################################
+
+Gen7-1284p-16.name=Gen7 with ATmega1284 and 16 MHz
+Gen7-1284p-16.upload.protocol=stk500v2
+Gen7-1284p-16.upload.maximum_size=129024
+Gen7-1284p-16.upload.speed=115200
+Gen7-1284p-16.bootloader.low_fuses=0xF7
+Gen7-1284p-16.bootloader.high_fuses=0xD4
+Gen7-1284p-16.bootloader.extended_fuses=0xFD
+Gen7-1284p-16.bootloader.path=Gen7
+Gen7-1284p-16.bootloader.file=bootloader-1284P-16MHz.hex
+Gen7-1284p-16.bootloader.unlock_bits=0x3F
+Gen7-1284p-16.bootloader.lock_bits=0x2F
+Gen7-1284p-16.build.mcu=atmega1284p
+Gen7-1284p-16.build.f_cpu=16000000L
+Gen7-1284p-16.build.core=arduino
+
+##############################################################
+
+Gen7-1284p-20.name=Gen7 with ATmega1284 and 20 MHz
+Gen7-1284p-20.upload.protocol=stk500v2
+Gen7-1284p-20.upload.maximum_size=129024
+Gen7-1284p-20.upload.speed=115200
+Gen7-1284p-20.bootloader.low_fuses=0xF7
+Gen7-1284p-20.bootloader.high_fuses=0xD4
+Gen7-1284p-20.bootloader.extended_fuses=0xFD
+Gen7-1284p-20.bootloader.path=Gen7
+Gen7-1284p-20.bootloader.file=bootloader-1284P-16MHz.hex
+Gen7-1284p-20.bootloader.unlock_bits=0x3F
+Gen7-1284p-20.bootloader.lock_bits=0x2F
+Gen7-1284p-20.build.mcu=atmega1284p
+Gen7-1284p-20.build.f_cpu=20000000L
+Gen7-1284p-20.build.core=arduino
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/bootloaders/Gen7/bootloader-1284P-16MHz.hex b/ArduinoAddons/Arduino_0.xx/Gen7/bootloaders/Gen7/bootloader-1284P-16MHz.hex
new file mode 100644
index 0000000..93df372
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/bootloaders/Gen7/bootloader-1284P-16MHz.hex
@@ -0,0 +1,113 @@
+:020000021000EC
+:10F8000011241FBE8FEF90E49EBF8DBF01C32F92C6
+:10F810003F924F925F926F927F928F929F92AF92A0
+:10F82000BF92CF92DF92EF92FF920F931F93DF93DD
+:10F83000CF93CDB7DEB7C252D1400FB6F894DEBF3A
+:10F840000FBECDBF44245524DD24C25EDE4F188296
+:10F85000CE51D1408824992454013AC20E9428FFF5
+:10F86000282F133059F1143028F4113081F0123060
+:10F8700000F507C0153081F1153030F1163071F701
+:10F880003DC08B3159F711E05BE1D52EE7CF8130D8
+:10F8900041F0C25EDE4F3881CE51D140831709F06E
+:10F8A00019C2D226C25EDE4F2883CE51D14012E06B
+:10F8B000D5CFF82EEE24D82613E0D0CF90E0E82A5A
+:10F8C000F92AD22614E0CACF8E3009F003C2D82616
+:10F8D00015E044245524C2CFE1E0F0E0EC0FFD1F19
+:10F8E000E40DF51D80830894411C511CD8264E144C
+:10F8F0005F0409F0B3CF720116E0B0CF8D1509F0A7
+:10F90000E9C1EAC1CC2447C08D81803311F090E079
+:10F910000AC08F81882311F49EE105C0813011F067
+:10F9200095E001C097E91A821B828D818C838E81BC
+:10F930008D839E831F8247E0E42EF12C88C11A82BA
+:10F9400068E06B8383E58C8394E59D83EBE4EE8331
+:10F9500085E38F8380E3888789878FE58A8782E3C1
+:10F960008B873BE0E32EF12C72C18A81813941F013
+:10F97000823941F0803911F48FE005C080E003C086
+:10F9800082E001C08AE01A828B8323E0E22EF12C10
+:10F990005EC1CC24C3941A8292E0E92EF12C58C1A6
+:10F9A0008D81882311F48EE128C0813011F085E02B
+:10F9B00024C087E922C01A8229E0E1E0F0E0209328
+:10F9C000570084911BC08B81803589F48C818830ED
+:10F9D00039F439E0E2E0F0E03093570084910DC053
+:10F9E00069E0E0E0F0E060935700849106C099E0A0
+:10F9F000E3E0F0E09093570084911A828B831C829D
+:10FA000084E0E82EF12C23C18A8190E0A0E0B0E0F0
+:10FA1000B82EAA24992488248B8190E0A0E0B0E03D
+:10FA2000DC0199278827882A992AAA2ABB2A8D814E
+:10FA300090E0A0E0B0E0882A992AAA2ABB2A8C810B
+:10FA400090E0A0E0B0E0BA2FA92F982F8827882A4D
+:10FA5000992AAA2ABB2A88C0EA81C05EDE4FE883C1
+:10FA6000C052D140C15EDE4F1882CF51D1408B8150
+:10FA7000A82FB0E0C15EDE4F28813981CF51D1403F
+:10FA8000A22BB32B933109F042C075016401CC0C59
+:10FA9000DD1CEE1CFF1C33E0F601E0925B003093AE
+:10FAA0005700E89507B600FCFDCF8E01055F1F4F9C
+:10FAB000F801808161810E5F1F4FA5019401220F23
+:10FAC000331F441F551F362E222490E0822993298C
+:10FAD00061E00C01F90140935B0060935700E895E9
+:10FAE00011240894811C911CA11CB11C129701F7D0
+:10FAF00085E0F601E0925B0080935700E89507B639
+:10FB000000FCFDCF81E180935700E8952DC0FE01F8
+:10FB10003B9620E030E040E050E011977D0100E0AE
+:10FB200010E00894E11CF11C011D111D6081F99980
+:10FB3000FECF1FBAC901880D991D92BD81BD60BD60
+:10FB40000FB6F894FA9AF99A0FBE2F5F3F4F4F4FB6
+:10FB50005F4F2E153F054007510711F03196E6CF54
+:10FB6000820E931EA41EB51E1A826EC09A81CE5DAF
+:10FB7000DE4F9883C252D140CF5DDE4F1882C15212
+:10FB8000D1408B81C82EDD24CF5DDE4FE881F98125
+:10FB9000C152D140CE2ADF2A1A8289818431E1F410
+:10FBA0009601BE016D5F7F4FD501C401880F991F7B
+:10FBB000AA1FBB1FABBFFC0187919691FB018083FD
+:10FBC00091836E5F7F4F0894811C911CA11CB11C16
+:10FBD0002250304049F72EC0BE016D5F7F4F20E0BC
+:10FBE00030E040E050E00894C108D108760100E020
+:10FBF00010E00894C11CD11C0894E11CF11C011DEB
+:10FC0000111DF999FECFC901880D991D92BD81BDC5
+:10FC1000F89A80B5FB018193BF012F5F3F4F4F4F93
+:10FC20005F4F2E153F054007510759F7820E931E6F
+:10FC3000A41EB51E23E0E22EF12CEC0CFD1CFB01F2
+:10FC4000108205C080EC8A8392E0E92EF12CCC244E
+:10FC50008BE10E94C7FEC25EDE4F8881CE51D1404B
+:10FC60000E94C7FE8F2D0E94C7FE8E2D0E94C7FEE8
+:10FC70008EE00E94C7FE85E1D82EC25EDE4FF8817D
+:10FC8000CE51D140DF26DE24DF243E010894611CE2
+:10FC9000711C0AC0F30111913F01812F0E94C7FE20
+:10FCA000D1260894E108F108E114F10499F78D2DAB
+:10FCB0000E94C7FECC2009F044C0C25EDE4FF8812E
+:10FCC000CE51D140FF5FC25EDE4FF883CE51D140AE
+:10FCD000EE24FF2410E0C2CD9981933109F4BCCE0B
+:10FCE0009431B0F4933009F440CE943038F491302C
+:10FCF00009F425CE923009F0A5CF04CE903109F455
+:10FD000001CE913109F445CE963009F09BCF7CCEDF
+:10FD1000983109F458CE993150F4953109F49CCEBC
+:10FD2000953108F423CF963109F08CCF1FCF9B314A
+:10FD300009F436CE9D3109F4E7CD9A3109F082CF2E
+:10FD40003ACECE5DDE4F0FB6F894DEBF0FBECDBF0C
+:10FD5000CF91DF911F910F91FF90EF90DF90CF90A7
+:10FD6000BF90AF909F908F907F906F905F904F90DB
+:10FD70003F902F9008958091C00087FFFCCF089599
+:10FD80008091C00087FFFCCF8091C6000895982F16
+:10FD90008091C00085FFFCCF9093C60008959B0121
+:10FDA000AC0197FF11C08091C00082608093C000B9
+:10FDB00050954095309521953F4F4F4F5F4F60E0F4
+:10FDC00074E284EF90E009C08091C0008D7F809341
+:10FDD000C00060E072E18AE790E00E9447FF2C5F7C
+:10FDE0003F4F4F4F5F4F83E0569547953795279587
+:10FDF0008A95D1F7215030403093C5002093C4003C
+:10FE0000089518B817B81F921F921F920895FFCF38
+:10FE100084B714BE90E083709070892B39F418B8C1
+:10FE200017B81F921F921F920895FFCF88E1809309
+:10FE3000C10060E07EE38EEF9FEF0E94CFFE0E9444
+:10FE400007FC18B817B81F921F921F920895FFCF92
+:10FE500020E030E040E050E013C02F5F3F4F4F4FB5
+:10FE60005F4F21308AE6380788E1480780E058076D
+:10FE700039F418B817B81F921F921F920895FFCF38
+:10FE80008091C00087FFE9CF0E94C0FE0895A1E2E3
+:10FE90001A2EAA1BBB1BFD010DC0AA1FBB1FEE1F04
+:10FEA000FF1FA217B307E407F50720F0A21BB30B4F
+:10FEB000E40BF50B661F771F881F991F1A9469F7CB
+:10FEC00060957095809590959B01AC01BD01CF0127
+:02FED000089593
+:040000031000F800F1
+:00000001FF
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/bootloaders/Gen7/bootloader-644-16MHz.hex b/ArduinoAddons/Arduino_0.xx/Gen7/bootloaders/Gen7/bootloader-644-16MHz.hex
new file mode 100644
index 0000000..5809869
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/bootloaders/Gen7/bootloader-644-16MHz.hex
@@ -0,0 +1,75 @@
+:10F800008FEF90E19EBF8DBF11241FBE5A9A00C09A
+:10F81000CDB7DEB7CD51D140DEBFCDBF1092C50010
+:10F8200088E08093C40088E18093C100EE24FF2427
+:10F8300020E0552400E010E039E0432E9BE0292E23
+:10F84000312C2C0E3D1ECFC14150504060407040C5
+:10F8500011F43FE206C08091C00087FFF5CF3091E0
+:10F86000C600933021F1943028F4913099F0923011
+:10F87000C8F407C0953049F1953000F19630D1F5C4
+:10F8800035C03B3119F491E02BE134C03F3291F5A2
+:10F890003983BBC1313011F0351559F52327532E6B
+:10F8A00092E028C0B32FA0E0232793E023C0832F4A
+:10F8B00090E0A82BB92B232794E01CC03E30C9F45C
+:10F8C000232795E0EE24FF2415C0E1E0F0E0EC0FE3
+:10F8D000FD1FEE0DFF1D30830894E11CF11C232752
+:10F8E000EA16FB0639F4D70196E004C0321709F492
+:10F8F0008CC190E044E755E962E470E0ACCF90E061
+:10F9000044C08D81803311F090E00AC08F8188233C
+:10F9100011F49EE105C0813011F099E001C096E933
+:10F920001A821B828D818C838E818D839E831F82A0
+:10F9300047E050E0F4C01A8288E08B8381E48C8336
+:10F9400086E58D8382E58E8389E48F8383E58887CE
+:10F9500080E589878FE58A8782E38B874BE050E0DB
+:10F96000DEC08A81813941F0823941F0803911F459
+:10F970008FE005C080E003C082E001C08AE01A8207
+:10F980008B8343E050E0CBC091E01A8242E050E02C
+:10F99000C7C08D81882311F48EE124C0813011F01D
+:10F9A00089E020C086E91EC01A82E1E0F0E04092C2
+:10F9B0005700849118C08B81803579F48C81883010
+:10F9C00031F4E2E0F0E04092570084910BC0E0E0B7
+:10F9D000F0E040925700849105C0E3E0F0E04092EF
+:10F9E000570084911A828B831C8244E050E097C0B8
+:10F9F000BC80AA248D81082F10E00A291B29000F42
+:10FA0000111F1A828AC09A8088248B81682F70E027
+:10FA100068297929933109F033C0F7EF0F3F1F07A9
+:10FA200010F0A8013FC023E0F80120935700E895AB
+:10FA300007B600FCFDCFA801D1018C9111962C9145
+:10FA400011971296D22ECC2490E08C299D2921E08A
+:10FA5000FA010C0120935700E89511244E5F5F4F87
+:10FA60006250704051F725E0F80120935700E89567
+:10FA700007B600FCFDCF81E180935700E89512C0E6
+:10FA8000A801FB01D10141BD52BD4F5F5F4F8D9178
+:10FA900080BDFA9AF99AF999FECF3197A1F7A8019A
+:10FAA000460F571F1A828A0138C07A8066248B81DC
+:10FAB000A82FB0E0A629B7291A828981843191F450
+:10FAC000BD019E012D5F3F4FF80185919491F90191
+:10FAD000808391832E5F3F4F0E5F1F4F62507040B7
+:10FAE00099F713C0A801BD019E012D5F3F4F41BD95
+:10FAF00052BD4F5F5F4FF89A80B5F90181939F0126
+:10FB000061507040A1F70A0F1B1FAD014D5F5F4FA1
+:10FB1000F901108204C080EC8A8342E050E090E05A
+:10FB2000FBE1F093C6008091C00086FFFCCF80917E
+:10FB3000C00080648093C0005092C6008091C000D5
+:10FB400086FFFCCF8091C00080648093C000652F49
+:10FB50005093C6008091C00086FFFCCF8091C0000A
+:10FB600080648093C000342F4093C6008091C00011
+:10FB700086FFFCCF8091C00080648093C0008EE03F
+:10FB80008093C6008091C00086FFFCCF8091C000AA
+:10FB900080648093C00025E1252523272627FE01C8
+:10FBA000319610C030813093C6008091C00086FF2E
+:10FBB000FCCF31968091C00080648093C0002327E1
+:10FBC000415050404115510569F72093C60080917E
+:10FBD000C00086FFFCCF8091C00080648093C0008D
+:10FBE000992349F4539444E755E962E470E090E0C6
+:10FBF000A0E0B0E030CE5A9881E180935700E895BC
+:10FC000011241F921F920895FFCF9981933109F417
+:10FC1000FACE9431C8F4963009F4EACE973050F415
+:10FC2000923009F46CCE933009F49BCE913009F0F8
+:10FC300072CF81CE913109F4A7CE923108F0E1CE96
+:10FC4000903109F068CF5BCE983109F4B4CE993188
+:10FC500050F4953109F4D7CE953108F426CF96317A
+:10FC600009F059CF22CF9B3109F493CE9C3120F477
+:10FC70009A3109F050CF98CE9D3109F442CE9F328F
+:06FC800009F049CFB8CFE6
+:040000030000F80001
+:00000001FF
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/bootloaders/Gen7/bootloader-644-20MHz.hex b/ArduinoAddons/Arduino_0.xx/Gen7/bootloaders/Gen7/bootloader-644-20MHz.hex
new file mode 100644
index 0000000..d216c65
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/bootloaders/Gen7/bootloader-644-20MHz.hex
@@ -0,0 +1,75 @@
+:10F800008FEF90E19EBF8DBF11241FBE5A9A00C09A
+:10F81000CDB7DEB7CD51D140DEBFCDBF1092C50010
+:10F820008AE08093C40088E18093C100EE24FF2425
+:10F8300020E0552400E010E039E0432E9BE0292E23
+:10F84000312C2C0E3D1ECFC14150504060407040C5
+:10F8500011F43FE206C08091C00087FFF5CF3091E0
+:10F86000C600933021F1943028F4913099F0923011
+:10F87000C8F407C0953049F1953000F19630D1F5C4
+:10F8800035C03B3119F491E02BE134C03F3291F5A2
+:10F890003983BBC1313011F0351559F52327532E6B
+:10F8A00092E028C0B32FA0E0232793E023C0832F4A
+:10F8B00090E0A82BB92B232794E01CC03E30C9F45C
+:10F8C000232795E0EE24FF2415C0E1E0F0E0EC0FE3
+:10F8D000FD1FEE0DFF1D30830894E11CF11C232752
+:10F8E000EA16FB0639F4D70196E004C0321709F492
+:10F8F0008CC190E041ED5AE363E570E0ACCF90E05D
+:10F9000044C08D81803311F090E00AC08F8188233C
+:10F9100011F49EE105C0813011F099E001C096E933
+:10F920001A821B828D818C838E818D839E831F82A0
+:10F9300047E050E0F4C01A8288E08B8381E48C8336
+:10F9400086E58D8382E58E8389E48F8383E58887CE
+:10F9500080E589878FE58A8782E38B874BE050E0DB
+:10F96000DEC08A81813941F0823941F0803911F459
+:10F970008FE005C080E003C082E001C08AE01A8207
+:10F980008B8343E050E0CBC091E01A8242E050E02C
+:10F99000C7C08D81882311F48EE124C0813011F01D
+:10F9A00089E020C086E91EC01A82E1E0F0E04092C2
+:10F9B0005700849118C08B81803579F48C81883010
+:10F9C00031F4E2E0F0E04092570084910BC0E0E0B7
+:10F9D000F0E040925700849105C0E3E0F0E04092EF
+:10F9E000570084911A828B831C8244E050E097C0B8
+:10F9F000BC80AA248D81082F10E00A291B29000F42
+:10FA0000111F1A828AC09A8088248B81682F70E027
+:10FA100068297929933109F033C0F7EF0F3F1F07A9
+:10FA200010F0A8013FC023E0F80120935700E895AB
+:10FA300007B600FCFDCFA801D1018C9111962C9145
+:10FA400011971296D22ECC2490E08C299D2921E08A
+:10FA5000FA010C0120935700E89511244E5F5F4F87
+:10FA60006250704051F725E0F80120935700E89567
+:10FA700007B600FCFDCF81E180935700E89512C0E6
+:10FA8000A801FB01D10141BD52BD4F5F5F4F8D9178
+:10FA900080BDFA9AF99AF999FECF3197A1F7A8019A
+:10FAA000460F571F1A828A0138C07A8066248B81DC
+:10FAB000A82FB0E0A629B7291A828981843191F450
+:10FAC000BD019E012D5F3F4FF80185919491F90191
+:10FAD000808391832E5F3F4F0E5F1F4F62507040B7
+:10FAE00099F713C0A801BD019E012D5F3F4F41BD95
+:10FAF00052BD4F5F5F4FF89A80B5F90181939F0126
+:10FB000061507040A1F70A0F1B1FAD014D5F5F4FA1
+:10FB1000F901108204C080EC8A8342E050E090E05A
+:10FB2000FBE1F093C6008091C00086FFFCCF80917E
+:10FB3000C00080648093C0005092C6008091C000D5
+:10FB400086FFFCCF8091C00080648093C000652F49
+:10FB50005093C6008091C00086FFFCCF8091C0000A
+:10FB600080648093C000342F4093C6008091C00011
+:10FB700086FFFCCF8091C00080648093C0008EE03F
+:10FB80008093C6008091C00086FFFCCF8091C000AA
+:10FB900080648093C00025E1252523272627FE01C8
+:10FBA000319610C030813093C6008091C00086FF2E
+:10FBB000FCCF31968091C00080648093C0002327E1
+:10FBC000415050404115510569F72093C60080917E
+:10FBD000C00086FFFCCF8091C00080648093C0008D
+:10FBE000992349F4539441ED5AE363E570E090E0C2
+:10FBF000A0E0B0E030CE5A9881E180935700E895BC
+:10FC000011241F921F920895FFCF9981933109F417
+:10FC1000FACE9431C8F4963009F4EACE973050F415
+:10FC2000923009F46CCE933009F49BCE913009F0F8
+:10FC300072CF81CE913109F4A7CE923108F0E1CE96
+:10FC4000903109F068CF5BCE983109F4B4CE993188
+:10FC500050F4953109F4D7CE953108F426CF96317A
+:10FC600009F059CF22CF9B3109F493CE9C3120F477
+:10FC70009A3109F050CF98CE9D3109F442CE9F328F
+:06FC800009F049CFB8CFE6
+:040000030000F80001
+:00000001FF
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/bootloaders/Gen7/bootloader-644P-16MHz.hex b/ArduinoAddons/Arduino_0.xx/Gen7/bootloaders/Gen7/bootloader-644P-16MHz.hex
new file mode 100644
index 0000000..a9105a2
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/bootloaders/Gen7/bootloader-644P-16MHz.hex
@@ -0,0 +1,75 @@
+:10F800008FEF90E19EBF8DBF11241FBE5A9A00C09A
+:10F81000CDB7DEB7CD51D140DEBFCDBF1092C50010
+:10F8200088E08093C40088E18093C100EE24FF2427
+:10F8300020E0552400E010E039E0432E93E0292E2B
+:10F84000312C2C0E3D1ECDC14150504060407040C7
+:10F8500011F43FE206C08091C00087FFF5CF3091E0
+:10F86000C600933021F1943028F4913099F0923011
+:10F87000C8F407C0953049F1953000F19630D1F5C4
+:10F8800035C03B3119F491E02BE134C03F3291F5A2
+:10F890003983B9C1313011F0351559F52327532E6D
+:10F8A00092E028C0B32FA0E0232793E023C0832F4A
+:10F8B00090E0A82BB92B232794E01CC03E30C9F45C
+:10F8C000232795E0EE24FF2415C0E1E0F0E0EC0FE3
+:10F8D000FD1FEE0DFF1D30830894E11CF11C232752
+:10F8E000EA16FB0639F4D70196E004C0321709F492
+:10F8F0008AC190E044E755E962E470E0ACCF90E063
+:10F9000044C08D81803311F090E00AC08F8188233C
+:10F9100011F49EE105C0813011F09AE001C096E932
+:10F920001A821B828D818C838E818D839E831F82A0
+:10F9300047E050E0F2C01A8288E08B8381E48C8338
+:10F9400086E58D8382E58E8389E48F8383E58887CE
+:10F9500080E589878FE58A8782E38B874BE050E0DB
+:10F96000DCC08A81813941F0823941F0803911F45B
+:10F970008FE005C080E003C082E001C08AE01A8207
+:10F980008B8343E050E0C9C091E01A8242E050E02E
+:10F99000C5C08D81882311F48EE124C0813011F01F
+:10F9A0008AE020C086E91EC01A82E1E0F0E04092C1
+:10F9B0005700849118C08B81803579F48C81883010
+:10F9C00031F4E2E0F0E04092570084910BC0E0E0B7
+:10F9D000F0E040925700849105C0E3E0F0E04092EF
+:10F9E000570084911A828B831C8244E050E095C0BA
+:10F9F000BC80AA248D81082F10E00A291B29000F42
+:10FA0000111F1A8288C09A8088248B81682F70E029
+:10FA100068297929933109F034C0F7EF0F3F1F07A8
+:10FA200010F0A80141C023E0F80120935700E895A9
+:10FA300007B600FCFDCFA801DE011B968C91119644
+:10FA40002C9111971296D22ECC2490E08C299D29CE
+:10FA500021E0FA010C0120935700E89511244E5F34
+:10FA60005F4F6250704051F725E0F8012093570036
+:10FA7000E89507B600FCFDCF81E180935700E8953B
+:10FA800013C0A801FB01DE011B9641BD52BD4F5FB3
+:10FA90005F4F8D9180BDFA9AF99AF999FECF31970F
+:10FAA000A1F7A801460F571F1A828A0134C07A8035
+:10FAB00066248B81A82FB0E0A629B7291A828981F4
+:10FAC000843181F4BD019101F80185919491F9018E
+:10FAD000808391832E5F3F4F0E5F1F4F62507040B7
+:10FAE00099F711C0A801BD01910141BD52BD4F5F01
+:10FAF0005F4FF89A80B5F90181939F016150704082
+:10FB0000A1F70A0F1B1FAD014D5F5F4FF901108276
+:10FB100004C080EC8A8342E050E090E0FBE1F09387
+:10FB2000C6008091C00086FFFCCF8091C000806439
+:10FB30008093C0005092C6008091C00086FFFCCF29
+:10FB40008091C00080648093C000652F5093C600F0
+:10FB50008091C00086FFFCCF8091C00080648093BC
+:10FB6000C000342F4093C6008091C00086FFFCCFB8
+:10FB70008091C00080648093C0008EE08093C600B6
+:10FB80008091C00086FFFCCF8091C000806480938C
+:10FB9000C00025E1252523272627FE01319610C028
+:10FBA00030813093C6008091C00086FFFCCF319633
+:10FBB0008091C00080648093C00023274150504052
+:10FBC0004115510569F72093C6008091C00086FF5A
+:10FBD000FCCF8091C00080648093C000992349F4D9
+:10FBE000539444E755E962E470E090E0A0E0B0E0AF
+:10FBF00032CE5A9881E180935700E89511241F92E4
+:10FC00001F920895FFCF9981933109F4FCCE94316E
+:10FC1000C8F4963009F4ECCE973050F4923009F4E1
+:10FC20006ECE933009F49DCE913009F072CF83CE21
+:10FC3000913109F4A9CE923108F0E3CE903109F068
+:10FC400068CF5DCE983109F4B6CE993150F4953134
+:10FC500009F4D9CE953108F42ACF963109F059CF5D
+:10FC600026CF9B3109F495CE9C3120F49A3109F0CE
+:10FC700050CF9ACE9D3109F444CE9F3209F049CF3E
+:02FC8000B8CFFB
+:040000030000F80001
+:00000001FF
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/bootloaders/Gen7/bootloader-644P-20MHz.hex b/ArduinoAddons/Arduino_0.xx/Gen7/bootloaders/Gen7/bootloader-644P-20MHz.hex
new file mode 100644
index 0000000..4ee0c6b
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/bootloaders/Gen7/bootloader-644P-20MHz.hex
@@ -0,0 +1,75 @@
+:10F800008FEF90E19EBF8DBF11241FBE5A9A00C09A
+:10F81000CDB7DEB7CD51D140DEBFCDBF1092C50010
+:10F820008AE08093C40088E18093C100EE24FF2425
+:10F8300020E0552400E010E039E0432E93E0292E2B
+:10F84000312C2C0E3D1ECDC14150504060407040C7
+:10F8500011F43FE206C08091C00087FFF5CF3091E0
+:10F86000C600933021F1943028F4913099F0923011
+:10F87000C8F407C0953049F1953000F19630D1F5C4
+:10F8800035C03B3119F491E02BE134C03F3291F5A2
+:10F890003983B9C1313011F0351559F52327532E6D
+:10F8A00092E028C0B32FA0E0232793E023C0832F4A
+:10F8B00090E0A82BB92B232794E01CC03E30C9F45C
+:10F8C000232795E0EE24FF2415C0E1E0F0E0EC0FE3
+:10F8D000FD1FEE0DFF1D30830894E11CF11C232752
+:10F8E000EA16FB0639F4D70196E004C0321709F492
+:10F8F0008AC190E041ED5AE363E570E0ACCF90E05F
+:10F9000044C08D81803311F090E00AC08F8188233C
+:10F9100011F49EE105C0813011F09AE001C096E932
+:10F920001A821B828D818C838E818D839E831F82A0
+:10F9300047E050E0F2C01A8288E08B8381E48C8338
+:10F9400086E58D8382E58E8389E48F8383E58887CE
+:10F9500080E589878FE58A8782E38B874BE050E0DB
+:10F96000DCC08A81813941F0823941F0803911F45B
+:10F970008FE005C080E003C082E001C08AE01A8207
+:10F980008B8343E050E0C9C091E01A8242E050E02E
+:10F99000C5C08D81882311F48EE124C0813011F01F
+:10F9A0008AE020C086E91EC01A82E1E0F0E04092C1
+:10F9B0005700849118C08B81803579F48C81883010
+:10F9C00031F4E2E0F0E04092570084910BC0E0E0B7
+:10F9D000F0E040925700849105C0E3E0F0E04092EF
+:10F9E000570084911A828B831C8244E050E095C0BA
+:10F9F000BC80AA248D81082F10E00A291B29000F42
+:10FA0000111F1A8288C09A8088248B81682F70E029
+:10FA100068297929933109F034C0F7EF0F3F1F07A8
+:10FA200010F0A80141C023E0F80120935700E895A9
+:10FA300007B600FCFDCFA801DE011B968C91119644
+:10FA40002C9111971296D22ECC2490E08C299D29CE
+:10FA500021E0FA010C0120935700E89511244E5F34
+:10FA60005F4F6250704051F725E0F8012093570036
+:10FA7000E89507B600FCFDCF81E180935700E8953B
+:10FA800013C0A801FB01DE011B9641BD52BD4F5FB3
+:10FA90005F4F8D9180BDFA9AF99AF999FECF31970F
+:10FAA000A1F7A801460F571F1A828A0134C07A8035
+:10FAB00066248B81A82FB0E0A629B7291A828981F4
+:10FAC000843181F4BD019101F80185919491F9018E
+:10FAD000808391832E5F3F4F0E5F1F4F62507040B7
+:10FAE00099F711C0A801BD01910141BD52BD4F5F01
+:10FAF0005F4FF89A80B5F90181939F016150704082
+:10FB0000A1F70A0F1B1FAD014D5F5F4FF901108276
+:10FB100004C080EC8A8342E050E090E0FBE1F09387
+:10FB2000C6008091C00086FFFCCF8091C000806439
+:10FB30008093C0005092C6008091C00086FFFCCF29
+:10FB40008091C00080648093C000652F5093C600F0
+:10FB50008091C00086FFFCCF8091C00080648093BC
+:10FB6000C000342F4093C6008091C00086FFFCCFB8
+:10FB70008091C00080648093C0008EE08093C600B6
+:10FB80008091C00086FFFCCF8091C000806480938C
+:10FB9000C00025E1252523272627FE01319610C028
+:10FBA00030813093C6008091C00086FFFCCF319633
+:10FBB0008091C00080648093C00023274150504052
+:10FBC0004115510569F72093C6008091C00086FF5A
+:10FBD000FCCF8091C00080648093C000992349F4D9
+:10FBE000539441ED5AE363E570E090E0A0E0B0E0AB
+:10FBF00032CE5A9881E180935700E89511241F92E4
+:10FC00001F920895FFCF9981933109F4FCCE94316E
+:10FC1000C8F4963009F4ECCE973050F4923009F4E1
+:10FC20006ECE933009F49DCE913009F072CF83CE21
+:10FC3000913109F4A9CE923108F0E3CE903109F068
+:10FC400068CF5DCE983109F4B6CE993150F4953134
+:10FC500009F4D9CE953108F42ACF963109F059CF5D
+:10FC600026CF9B3109F495CE9C3120F49A3109F0CE
+:10FC700050CF9ACE9D3109F444CE9F3209F049CF3E
+:02FC8000B8CFFB
+:040000030000F80001
+:00000001FF
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/HardwareSerial.cpp b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/HardwareSerial.cpp
new file mode 100644
index 0000000..8b1fcc6
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/HardwareSerial.cpp
@@ -0,0 +1,239 @@
+/*
+  HardwareSerial.cpp - Hardware serial library for Wiring
+  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+  
+  Modified 23 November 2006 by David A. Mellis
+*/
+
+#include <stdio.h>
+#include <string.h>
+#include <inttypes.h>
+#include "wiring.h"
+#include "wiring_private.h"
+
+#include "HardwareSerial.h"
+
+// Define constants and variables for buffering incoming serial data.  We're
+// using a ring buffer (I think), in which rx_buffer_head is the index of the
+// location to which to write the next incoming character and rx_buffer_tail
+// is the index of the location from which to read.
+#define RX_BUFFER_SIZE 128
+
+struct ring_buffer {
+  unsigned char buffer[RX_BUFFER_SIZE];
+  int head;
+  int tail;
+};
+
+ring_buffer rx_buffer = { { 0 }, 0, 0 };
+
+#ifdef UDR1
+ring_buffer rx_buffer1 = { { 0 }, 0, 0 };
+#endif
+
+#ifdef UDR2
+ring_buffer rx_buffer2 = { { 0 }, 0, 0 };
+#endif
+#ifdef UDR3
+ring_buffer rx_buffer3 = { { 0 }, 0, 0 };
+#endif
+
+inline void store_char(unsigned char c, ring_buffer *rx_buffer)
+{
+  int i = (rx_buffer->head + 1) % RX_BUFFER_SIZE;
+
+  // if we should be storing the received character into the location
+  // just before the tail (meaning that the head would advance to the
+  // current location of the tail), we're about to overflow the buffer
+  // and so we don't write the character or advance the head.
+  if (i != rx_buffer->tail) {
+    rx_buffer->buffer[rx_buffer->head] = c;
+    rx_buffer->head = i;
+  }
+}
+
+ISR(USART0_RX_vect)
+{
+  unsigned char c = UDR0;
+  store_char(c, &rx_buffer);
+}
+
+#ifdef UDR1
+ISR(USART1_RX_vect)
+{
+  unsigned char c = UDR1;
+  store_char(c, &rx_buffer1);
+}
+
+#ifdef UDR2
+ISR(USART2_RX_vect)
+{
+  unsigned char c = UDR2;
+  store_char(c, &rx_buffer2);
+}
+
+#ifdef UDR2
+ISR(USART3_RX_vect)
+{
+  unsigned char c = UDR3;
+  store_char(c, &rx_buffer3);
+}
+#endif
+#endif
+
+#else
+
+#if defined(__AVR_ATmega8__)
+SIGNAL(SIG_UART_RECV)
+#else
+SIGNAL(USART_RX_vect)
+#endif
+{
+#if defined(__AVR_ATmega8__)
+  unsigned char c = UDR;
+#else
+  unsigned char c = UDR0;
+#endif
+  store_char(c, &rx_buffer);
+}
+
+#endif
+
+// Constructors ////////////////////////////////////////////////////////////////
+
+HardwareSerial::HardwareSerial(ring_buffer *rx_buffer,
+  volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
+  volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
+  volatile uint8_t *udr,
+  uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udre, uint8_t u2x)
+{
+  _rx_buffer = rx_buffer;
+  _ubrrh = ubrrh;
+  _ubrrl = ubrrl;
+  _ucsra = ucsra;
+  _ucsrb = ucsrb;
+  _udr = udr;
+  _rxen = rxen;
+  _txen = txen;
+  _rxcie = rxcie;
+  _udre = udre;
+  _u2x = u2x;
+}
+
+// Public Methods //////////////////////////////////////////////////////////////
+
+void HardwareSerial::begin(long baud)
+{
+  uint16_t baud_setting;
+  bool use_u2x;
+
+  // U2X mode is needed for baud rates higher than (CPU Hz / 16)
+  if (baud > F_CPU / 16) {
+    use_u2x = true;
+  } else {
+    // figure out if U2X mode would allow for a better connection
+    
+    // calculate the percent difference between the baud-rate specified and
+    // the real baud rate for both U2X and non-U2X mode (0-255 error percent)
+    uint8_t nonu2x_baud_error = abs((int)(255-((F_CPU/(16*(((F_CPU/8/baud-1)/2)+1))*255)/baud)));
+    uint8_t u2x_baud_error = abs((int)(255-((F_CPU/(8*(((F_CPU/4/baud-1)/2)+1))*255)/baud)));
+    
+    // prefer non-U2X mode because it handles clock skew better
+    use_u2x = (nonu2x_baud_error > u2x_baud_error);
+  }
+  
+  if (use_u2x) {
+    *_ucsra = 1 << _u2x;
+    baud_setting = (F_CPU / 4 / baud - 1) / 2;
+  } else {
+    *_ucsra = 0;
+    baud_setting = (F_CPU / 8 / baud - 1) / 2;
+  }
+
+  // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)
+  *_ubrrh = baud_setting >> 8;
+  *_ubrrl = baud_setting;
+
+  sbi(*_ucsrb, _rxen);
+  sbi(*_ucsrb, _txen);
+  sbi(*_ucsrb, _rxcie);
+}
+
+void HardwareSerial::end()
+{
+  cbi(*_ucsrb, _rxen);
+  cbi(*_ucsrb, _txen);
+  cbi(*_ucsrb, _rxcie);  
+}
+
+uint8_t HardwareSerial::available(void)
+{
+  return (RX_BUFFER_SIZE + _rx_buffer->head - _rx_buffer->tail) % RX_BUFFER_SIZE;
+}
+
+int HardwareSerial::read(void)
+{
+  // if the head isn't ahead of the tail, we don't have any characters
+  if (_rx_buffer->head == _rx_buffer->tail) {
+    return -1;
+  } else {
+    unsigned char c = _rx_buffer->buffer[_rx_buffer->tail];
+    _rx_buffer->tail = (_rx_buffer->tail + 1) % RX_BUFFER_SIZE;
+    return c;
+  }
+}
+
+void HardwareSerial::flush()
+{
+  // don't reverse this or there may be problems if the RX interrupt
+  // occurs after reading the value of rx_buffer_head but before writing
+  // the value to rx_buffer_tail; the previous value of rx_buffer_head
+  // may be written to rx_buffer_tail, making it appear as if the buffer
+  // don't reverse this or there may be problems if the RX interrupt
+  // occurs after reading the value of rx_buffer_head but before writing
+  // the value to rx_buffer_tail; the previous value of rx_buffer_head
+  // may be written to rx_buffer_tail, making it appear as if the buffer
+  // were full, not empty.
+  _rx_buffer->head = _rx_buffer->tail;
+}
+
+void HardwareSerial::write(uint8_t c)
+{
+  while (!((*_ucsra) & (1 << _udre)))
+    ;
+
+  *_udr = c;
+}
+
+// Preinstantiate Objects //////////////////////////////////////////////////////
+
+#if defined(__AVR_ATmega8__)
+HardwareSerial Serial(&rx_buffer, &UBRRH, &UBRRL, &UCSRA, &UCSRB, &UDR, RXEN, TXEN, RXCIE, UDRE, U2X);
+#else
+HardwareSerial Serial(&rx_buffer, &UBRR0H, &UBRR0L, &UCSR0A, &UCSR0B, &UDR0, RXEN0, TXEN0, RXCIE0, UDRE0, U2X0);
+#endif
+
+#ifdef UDR1
+HardwareSerial Serial1(&rx_buffer1, &UBRR1H, &UBRR1L, &UCSR1A, &UCSR1B, &UDR1, RXEN1, TXEN1, RXCIE1, UDRE1, U2X1);
+#endif
+
+#ifdef UDR2
+HardwareSerial Serial2(&rx_buffer2, &UBRR2H, &UBRR2L, &UCSR2A, &UCSR2B, &UDR2, RXEN2, TXEN2, RXCIE2, UDRE2, U2X2);
+#endif
+#ifdef UDR3
+HardwareSerial Serial3(&rx_buffer3, &UBRR3H, &UBRR3L, &UCSR3A, &UCSR3B, &UDR3, RXEN3, TXEN3, RXCIE3, UDRE3, U2X3);
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/HardwareSerial.h b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/HardwareSerial.h
new file mode 100644
index 0000000..f609f73
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/HardwareSerial.h
@@ -0,0 +1,69 @@
+/*
+  HardwareSerial.h - Hardware serial library for Wiring
+  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef HardwareSerial_h
+#define HardwareSerial_h
+
+#include <inttypes.h>
+
+#include "Print.h"
+
+struct ring_buffer;
+
+class HardwareSerial : public Print
+{
+  private:
+    ring_buffer *_rx_buffer;
+    volatile uint8_t *_ubrrh;
+    volatile uint8_t *_ubrrl;
+    volatile uint8_t *_ucsra;
+    volatile uint8_t *_ucsrb;
+    volatile uint8_t *_udr;
+    uint8_t _rxen;
+    uint8_t _txen;
+    uint8_t _rxcie;
+    uint8_t _udre;
+    uint8_t _u2x;
+  public:
+    HardwareSerial(ring_buffer *rx_buffer,
+      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
+      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
+      volatile uint8_t *udr,
+      uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udre, uint8_t u2x);
+    void begin(long);
+    void end();
+    uint8_t available(void);
+    int read(void);
+    void flush(void);
+    virtual void write(uint8_t);
+    using Print::write; // pull in write(str) and write(buf, size) from Print
+};
+
+extern HardwareSerial Serial;
+
+#if defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1280__)
+extern HardwareSerial Serial1;
+#endif
+
+#if defined(__AVR_ATmega1280__)
+extern HardwareSerial Serial2;
+extern HardwareSerial Serial3;
+#endif
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/Makefile b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/Makefile
new file mode 100644
index 0000000..571687d
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/Makefile
@@ -0,0 +1,243 @@
+# Arduino 0011 Makefile
+# Arduino adaptation by mellis, eighthave, oli.keller
+#
+# This makefile allows you to build sketches from the command line
+# without the Arduino environment (or Java).
+#
+# Detailed instructions for using the makefile:
+#
+#  1. Copy this file into the folder with your sketch. There should be a
+#     file with the same name as the folder and with the extension .pde
+#     (e.g. foo.pde in the foo/ folder).
+#
+#  2. Modify the line containg "INSTALL_DIR" to point to the directory that
+#     contains the Arduino installation (for example, under Mac OS X, this
+#     might be /Applications/arduino-0012).
+#
+#  3. Modify the line containing "PORT" to refer to the filename
+#     representing the USB or serial connection to your Arduino board
+#     (e.g. PORT = /dev/tty.USB0).  If the exact name of this file
+#     changes, you can use * as a wildcard (e.g. PORT = /dev/tty.usb*).
+#
+#  4. Set the line containing "MCU" to match your board's processor. 
+#     Older one's are atmega8 based, newer ones like Arduino Mini, Bluetooth
+#     or Diecimila have the atmega168.  If you're using a LilyPad Arduino,
+#     change F_CPU to 8000000.
+#
+#  5. At the command line, change to the directory containing your
+#     program's file and the makefile.
+#
+#  6. Type "make" and press enter to compile/verify your program.
+#
+#  7. Type "make upload", reset your Arduino board, and press enter to
+#     upload your program to the Arduino board.
+#
+# $Id$
+
+TARGET = $(notdir $(CURDIR))
+INSTALL_DIR = /Users/dmellis/Source/arduino/trunk/build/macosx/build/work
+PORT = /dev/tty.usb*
+UPLOAD_RATE = 19200
+AVRDUDE_PROGRAMMER = stk500v1
+MCU = atmega168
+F_CPU = 16000000
+
+############################################################################
+# Below here nothing should be changed...
+
+ARDUINO = $(INSTALL_DIR)/hardware/cores/arduino
+AVR_TOOLS_PATH = $(INSTALL_DIR)/hardware/tools/avr/bin
+SRC =  $(ARDUINO)/pins_arduino.c $(ARDUINO)/wiring.c \
+$(ARDUINO)/wiring_analog.c $(ARDUINO)/wiring_digital.c \
+$(ARDUINO)/wiring_pulse.c $(ARDUINO)/wiring_serial.c \
+$(ARDUINO)/wiring_shift.c $(ARDUINO)/WInterrupts.c
+CXXSRC = $(ARDUINO)/HardwareSerial.cpp $(ARDUINO)/WMath.cpp
+FORMAT = ihex
+
+
+# Name of this Makefile (used for "make depend").
+MAKEFILE = Makefile
+
+# Debugging format.
+# Native formats for AVR-GCC's -g are stabs [default], or dwarf-2.
+# AVR (extended) COFF requires stabs, plus an avr-objcopy run.
+DEBUG = stabs
+
+OPT = s
+
+# Place -D or -U options here
+CDEFS = -DF_CPU=$(F_CPU)
+CXXDEFS = -DF_CPU=$(F_CPU)
+
+# Place -I options here
+CINCS = -I$(ARDUINO)
+CXXINCS = -I$(ARDUINO)
+
+# Compiler flag to set the C Standard level.
+# c89   - "ANSI" C
+# gnu89 - c89 plus GCC extensions
+# c99   - ISO C99 standard (not yet fully implemented)
+# gnu99 - c99 plus GCC extensions
+CSTANDARD = -std=gnu99
+CDEBUG = -g$(DEBUG)
+CWARN = -Wall -Wstrict-prototypes
+CTUNING = -funsigned-char -funsigned-bitfields -fpack-struct -fshort-enums
+#CEXTRA = -Wa,-adhlns=$(<:.c=.lst)
+
+CFLAGS = $(CDEBUG) $(CDEFS) $(CINCS) -O$(OPT) $(CWARN) $(CSTANDARD) $(CEXTRA)
+CXXFLAGS = $(CDEFS) $(CINCS) -O$(OPT)
+#ASFLAGS = -Wa,-adhlns=$(<:.S=.lst),-gstabs 
+LDFLAGS = -lm
+
+
+# Programming support using avrdude. Settings and variables.
+AVRDUDE_PORT = $(PORT)
+AVRDUDE_WRITE_FLASH = -U flash:w:applet/$(TARGET).hex
+AVRDUDE_FLAGS = -V -F -C $(INSTALL_DIR)/hardware/tools/avr/etc/avrdude.conf \
+-p $(MCU) -P $(AVRDUDE_PORT) -c $(AVRDUDE_PROGRAMMER) \
+-b $(UPLOAD_RATE)
+
+# Program settings
+CC = $(AVR_TOOLS_PATH)/avr-gcc
+CXX = $(AVR_TOOLS_PATH)/avr-g++
+OBJCOPY = $(AVR_TOOLS_PATH)/avr-objcopy
+OBJDUMP = $(AVR_TOOLS_PATH)/avr-objdump
+AR  = $(AVR_TOOLS_PATH)/avr-ar
+SIZE = $(AVR_TOOLS_PATH)/avr-size
+NM = $(AVR_TOOLS_PATH)/avr-nm
+AVRDUDE = $(AVR_TOOLS_PATH)/avrdude
+REMOVE = rm -f
+MV = mv -f
+
+# Define all object files.
+OBJ = $(SRC:.c=.o) $(CXXSRC:.cpp=.o) $(ASRC:.S=.o) 
+
+# Define all listing files.
+LST = $(ASRC:.S=.lst) $(CXXSRC:.cpp=.lst) $(SRC:.c=.lst)
+
+# Combine all necessary flags and optional flags.
+# Add target processor to flags.
+ALL_CFLAGS = -mmcu=$(MCU) -I. $(CFLAGS)
+ALL_CXXFLAGS = -mmcu=$(MCU) -I. $(CXXFLAGS)
+ALL_ASFLAGS = -mmcu=$(MCU) -I. -x assembler-with-cpp $(ASFLAGS)
+
+
+# Default target.
+all: applet_files build sizeafter
+
+build: elf hex 
+
+applet_files: $(TARGET).pde
+	# Here is the "preprocessing".
+	# It creates a .cpp file based with the same name as the .pde file.
+	# On top of the new .cpp file comes the WProgram.h header.
+	# At the end there is a generic main() function attached.
+	# Then the .cpp file will be compiled. Errors during compile will
+	# refer to this new, automatically generated, file. 
+	# Not the original .pde file you actually edit...
+	test -d applet || mkdir applet
+	echo '#include "WProgram.h"' > applet/$(TARGET).cpp
+	cat $(TARGET).pde >> applet/$(TARGET).cpp
+	cat $(ARDUINO)/main.cxx >> applet/$(TARGET).cpp
+
+elf: applet/$(TARGET).elf
+hex: applet/$(TARGET).hex
+eep: applet/$(TARGET).eep
+lss: applet/$(TARGET).lss 
+sym: applet/$(TARGET).sym
+
+# Program the device.  
+upload: applet/$(TARGET).hex
+	$(AVRDUDE) $(AVRDUDE_FLAGS) $(AVRDUDE_WRITE_FLASH)
+
+
+	# Display size of file.
+HEXSIZE = $(SIZE) --target=$(FORMAT) applet/$(TARGET).hex
+ELFSIZE = $(SIZE)  applet/$(TARGET).elf
+sizebefore:
+	@if [ -f applet/$(TARGET).elf ]; then echo; echo $(MSG_SIZE_BEFORE); $(HEXSIZE); echo; fi
+
+sizeafter:
+	@if [ -f applet/$(TARGET).elf ]; then echo; echo $(MSG_SIZE_AFTER); $(HEXSIZE); echo; fi
+
+
+# Convert ELF to COFF for use in debugging / simulating in AVR Studio or VMLAB.
+COFFCONVERT=$(OBJCOPY) --debugging \
+--change-section-address .data-0x800000 \
+--change-section-address .bss-0x800000 \
+--change-section-address .noinit-0x800000 \
+--change-section-address .eeprom-0x810000 
+
+
+coff: applet/$(TARGET).elf
+	$(COFFCONVERT) -O coff-avr applet/$(TARGET).elf $(TARGET).cof
+
+
+extcoff: $(TARGET).elf
+	$(COFFCONVERT) -O coff-ext-avr applet/$(TARGET).elf $(TARGET).cof
+
+
+.SUFFIXES: .elf .hex .eep .lss .sym
+
+.elf.hex:
+	$(OBJCOPY) -O $(FORMAT) -R .eeprom $< $@
+
+.elf.eep:
+	-$(OBJCOPY) -j .eeprom --set-section-flags=.eeprom="alloc,load" \
+	--change-section-lma .eeprom=0 -O $(FORMAT) $< $@
+
+# Create extended listing file from ELF output file.
+.elf.lss:
+	$(OBJDUMP) -h -S $< > $@
+
+# Create a symbol table from ELF output file.
+.elf.sym:
+	$(NM) -n $< > $@
+
+	# Link: create ELF output file from library.
+applet/$(TARGET).elf: $(TARGET).pde applet/core.a 
+	$(CC) $(ALL_CFLAGS) -o $@ applet/$(TARGET).cpp -L. applet/core.a $(LDFLAGS)
+
+applet/core.a: $(OBJ)
+	@for i in $(OBJ); do echo $(AR) rcs applet/core.a $$i; $(AR) rcs applet/core.a $$i; done
+
+
+
+# Compile: create object files from C++ source files.
+.cpp.o:
+	$(CXX) -c $(ALL_CXXFLAGS) $< -o $@ 
+
+# Compile: create object files from C source files.
+.c.o:
+	$(CC) -c $(ALL_CFLAGS) $< -o $@ 
+
+
+# Compile: create assembler files from C source files.
+.c.s:
+	$(CC) -S $(ALL_CFLAGS) $< -o $@
+
+
+# Assemble: create object files from assembler source files.
+.S.o:
+	$(CC) -c $(ALL_ASFLAGS) $< -o $@
+
+
+
+# Target: clean project.
+clean:
+	$(REMOVE) applet/$(TARGET).hex applet/$(TARGET).eep applet/$(TARGET).cof applet/$(TARGET).elf \
+	applet/$(TARGET).map applet/$(TARGET).sym applet/$(TARGET).lss applet/core.a \
+	$(OBJ) $(LST) $(SRC:.c=.s) $(SRC:.c=.d) $(CXXSRC:.cpp=.s) $(CXXSRC:.cpp=.d)
+
+depend:
+	if grep '^# DO NOT DELETE' $(MAKEFILE) >/dev/null; \
+	then \
+		sed -e '/^# DO NOT DELETE/,$$d' $(MAKEFILE) > \
+			$(MAKEFILE).$$$$ && \
+		$(MV) $(MAKEFILE).$$$$ $(MAKEFILE); \
+	fi
+	echo '# DO NOT DELETE THIS LINE -- make depend depends on it.' \
+		>> $(MAKEFILE); \
+	$(CC) -M -mmcu=$(MCU) $(CDEFS) $(CINCS) $(SRC) $(ASRC) >> $(MAKEFILE)
+
+.PHONY:	all build elf hex eep lss sym program coff extcoff clean depend applet_files sizebefore sizeafter
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/Print.cpp b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/Print.cpp
new file mode 100644
index 0000000..d4833da
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/Print.cpp
@@ -0,0 +1,203 @@
+/*
+ Print.cpp - Base class that provides print() and println()
+ Copyright (c) 2008 David A. Mellis.  All right reserved.
+ 
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Lesser General Public
+ License as published by the Free Software Foundation; either
+ version 2.1 of the License, or (at your option) any later version.
+ 
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Lesser General Public License for more details.
+ 
+ You should have received a copy of the GNU Lesser General Public
+ License along with this library; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ 
+ Modified 23 November 2006 by David A. Mellis
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <inttypes.h>
+#include <math.h>
+#include "wiring.h"
+
+#include "Print.h"
+
+// Public Methods //////////////////////////////////////////////////////////////
+
+void Print::print(uint8_t b)
+{
+  this->write(b);
+}
+
+void Print::print(char c)
+{
+  print((byte) c);
+}
+
+void Print::print(const char c[])
+{
+  while (*c)
+    print(*c++);
+}
+
+void Print::print(int n)
+{
+  print((long) n);
+}
+
+void Print::print(unsigned int n)
+{
+  print((unsigned long) n);
+}
+
+void Print::print(long n)
+{
+  if (n < 0) {
+    print('-');
+    n = -n;
+  }
+  printNumber(n, 10);
+}
+
+void Print::print(unsigned long n)
+{
+  printNumber(n, 10);
+}
+
+void Print::print(long n, int base)
+{
+  if (base == 0)
+    print((char) n);
+  else if (base == 10)
+    print(n);
+  else
+    printNumber(n, base);
+}
+
+void Print::print(double n)
+{
+  printFloat(n, 2);
+}
+
+void Print::println(void)
+{
+  print('\r');
+  print('\n');  
+}
+
+void Print::println(char c)
+{
+  print(c);
+  println();  
+}
+
+void Print::println(const char c[])
+{
+  print(c);
+  println();
+}
+
+void Print::println(uint8_t b)
+{
+  print(b);
+  println();
+}
+
+void Print::println(int n)
+{
+  print(n);
+  println();
+}
+
+void Print::println(unsigned int n)
+{
+  print(n);
+  println();
+}
+
+void Print::println(long n)
+{
+  print(n);
+  println();  
+}
+
+void Print::println(unsigned long n)
+{
+  print(n);
+  println();  
+}
+
+void Print::println(long n, int base)
+{
+  print(n, base);
+  println();
+}
+
+void Print::println(double n)
+{
+  print(n);
+  println();
+}
+
+// Private Methods /////////////////////////////////////////////////////////////
+
+void Print::printNumber(unsigned long n, uint8_t base)
+{
+  unsigned char buf[8 * sizeof(long)]; // Assumes 8-bit chars. 
+  unsigned long i = 0;
+
+  if (n == 0) {
+    print('0');
+    return;
+  } 
+
+  while (n > 0) {
+    buf[i++] = n % base;
+    n /= base;
+  }
+
+  for (; i > 0; i--)
+    print((char) (buf[i - 1] < 10 ?
+      '0' + buf[i - 1] :
+      'A' + buf[i - 1] - 10));
+}
+
+void Print::printFloat(double number, uint8_t digits) 
+{ 
+  // Handle negative numbers
+  if (number < 0.0)
+  {
+     print('-');
+     number = -number;
+  }
+
+  // Round correctly so that print(1.999, 2) prints as "2.00"
+  double rounding = 0.5;
+  for (uint8_t i=0; i<digits; ++i)
+    rounding /= 10.0;
+  
+  number += rounding;
+
+  // Extract the integer part of the number and print it
+  unsigned long int_part = (unsigned long)number;
+  double remainder = number - (double)int_part;
+  print(int_part);
+
+  // Print the decimal point, but only if there are digits beyond
+  if (digits > 0)
+    print("."); 
+
+  // Extract digits from the remainder one at a time
+  while (digits-- > 0)
+  {
+    remainder *= 10.0;
+    int toPrint = int(remainder);
+    print(toPrint);
+    remainder -= toPrint; 
+  } 
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/Print.h b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/Print.h
new file mode 100644
index 0000000..c95a0dc
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/Print.h
@@ -0,0 +1,59 @@
+/*
+  Print.h - Base class that provides print() and println()
+  Copyright (c) 2008 David A. Mellis.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef Print_h
+#define Print_h
+
+#include <inttypes.h>
+
+#define DEC 10
+#define HEX 16
+#define OCT 8
+#define BIN 2
+#define BYTE 0
+
+class Print
+{
+  private:
+    void printNumber(unsigned long, uint8_t);
+    void printFloat(double, uint8_t);
+  public:
+    virtual void write(uint8_t);
+    void print(char);
+    void print(const char[]);
+    void print(uint8_t);
+    void print(int);
+    void print(unsigned int);
+    void print(long);
+    void print(unsigned long);
+    void print(long, int);
+    void print(double);
+    void println(void);
+    void println(char);
+    void println(const char[]);
+    void println(uint8_t);
+    void println(int);
+    void println(unsigned int);
+    void println(long);
+    void println(unsigned long);
+    void println(long, int);
+    void println(double);
+};
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/Tone.cpp b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/Tone.cpp
new file mode 100644
index 0000000..827fe49
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/Tone.cpp
@@ -0,0 +1,515 @@
+/* Tone.cpp
+
+  A Tone Generator Library
+
+  Written by Brett Hagman
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+Version Modified By Date     Comments
+------- ----------- -------- --------
+0001    B Hagman    09/08/02 Initial coding
+0002    B Hagman    09/08/18 Multiple pins
+0003    B Hagman    09/08/18 Moved initialization from constructor to begin()
+0004    B Hagman    09/09/26 Fixed problems with ATmega8
+0005    B Hagman    09/11/23 Scanned prescalars for best fit on 8 bit timers
+                    09/11/25 Changed pin toggle method to XOR
+                    09/11/25 Fixed timer0 from being excluded
+0006    D Mellis    09/12/29 Replaced objects with functions
+
+*************************************************/
+
+#include <avr/interrupt.h>
+#include <avr/pgmspace.h>
+#include <wiring.h>
+#include <pins_arduino.h>
+
+#if defined(__AVR_ATmega8__)
+#define TCCR2A TCCR2
+#define TCCR2B TCCR2
+#define COM2A1 COM21
+#define COM2A0 COM20
+#define OCR2A OCR2
+#define TIMSK2 TIMSK
+#define OCIE2A OCIE2
+#define TIMER2_COMPA_vect TIMER2_COMP_vect
+#define TIMSK1 TIMSK
+#endif
+
+// timerx_toggle_count:
+//  > 0 - duration specified
+//  = 0 - stopped
+//  < 0 - infinitely (until stop() method called, or new play() called)
+
+#if !defined(__AVR_ATmega8__)
+volatile long timer0_toggle_count;
+volatile uint8_t *timer0_pin_port;
+volatile uint8_t timer0_pin_mask;
+#endif
+
+volatile long timer1_toggle_count;
+volatile uint8_t *timer1_pin_port;
+volatile uint8_t timer1_pin_mask;
+volatile long timer2_toggle_count;
+volatile uint8_t *timer2_pin_port;
+volatile uint8_t timer2_pin_mask;
+
+#if defined(__AVR_ATmega1280__)
+volatile long timer3_toggle_count;
+volatile uint8_t *timer3_pin_port;
+volatile uint8_t timer3_pin_mask;
+volatile long timer4_toggle_count;
+volatile uint8_t *timer4_pin_port;
+volatile uint8_t timer4_pin_mask;
+volatile long timer5_toggle_count;
+volatile uint8_t *timer5_pin_port;
+volatile uint8_t timer5_pin_mask;
+#endif
+
+
+#if defined(__AVR_ATmega1280__)
+
+#define AVAILABLE_TONE_PINS 1
+
+const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 3, 4, 5, 1, 0 */ };
+static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255, 255, 255, 255, 255 */ };
+
+#elif defined(__AVR_ATmega8__)
+
+#define AVAILABLE_TONE_PINS 1
+
+const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 1 */ };
+static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255 */ };
+
+#else
+
+#define AVAILABLE_TONE_PINS 1
+
+// Leave timer 0 to last.
+const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 1, 0 */ };
+static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255, 255 */ };
+
+#endif
+
+
+
+static int8_t toneBegin(uint8_t _pin)
+{
+  int8_t _timer = -1;
+
+  // if we're already using the pin, the timer should be configured.  
+  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
+    if (tone_pins[i] == _pin) {
+      return pgm_read_byte(tone_pin_to_timer_PGM + i);
+    }
+  }
+  
+  // search for an unused timer.
+  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
+    if (tone_pins[i] == 255) {
+      tone_pins[i] = _pin;
+      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
+      break;
+    }
+  }
+  
+  if (_timer != -1)
+  {
+    // Set timer specific stuff
+    // All timers in CTC mode
+    // 8 bit timers will require changing prescalar values,
+    // whereas 16 bit timers are set to either ck/1 or ck/64 prescalar
+    switch (_timer)
+    {
+#if !defined(__AVR_ATmega8__)
+      case 0:
+        // 8 bit timer
+        TCCR0A = 0;
+        TCCR0B = 0;
+        bitWrite(TCCR0A, WGM01, 1);
+        bitWrite(TCCR0B, CS00, 1);
+        timer0_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer0_pin_mask = digitalPinToBitMask(_pin);
+        break;
+#endif
+
+      case 1:
+        // 16 bit timer
+        TCCR1A = 0;
+        TCCR1B = 0;
+        bitWrite(TCCR1B, WGM12, 1);
+        bitWrite(TCCR1B, CS10, 1);
+        timer1_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer1_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      case 2:
+        // 8 bit timer
+        TCCR2A = 0;
+        TCCR2B = 0;
+        bitWrite(TCCR2A, WGM21, 1);
+        bitWrite(TCCR2B, CS20, 1);
+        timer2_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer2_pin_mask = digitalPinToBitMask(_pin);
+        break;
+
+#if defined(__AVR_ATmega1280__)
+      case 3:
+        // 16 bit timer
+        TCCR3A = 0;
+        TCCR3B = 0;
+        bitWrite(TCCR3B, WGM32, 1);
+        bitWrite(TCCR3B, CS30, 1);
+        timer3_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer3_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      case 4:
+        // 16 bit timer
+        TCCR4A = 0;
+        TCCR4B = 0;
+        bitWrite(TCCR4B, WGM42, 1);
+        bitWrite(TCCR4B, CS40, 1);
+        timer4_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer4_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      case 5:
+        // 16 bit timer
+        TCCR5A = 0;
+        TCCR5B = 0;
+        bitWrite(TCCR5B, WGM52, 1);
+        bitWrite(TCCR5B, CS50, 1);
+        timer5_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer5_pin_mask = digitalPinToBitMask(_pin);
+        break;
+#endif
+    }
+  }
+
+  return _timer;
+}
+
+
+
+// frequency (in hertz) and duration (in milliseconds).
+
+void tone(uint8_t _pin, unsigned int frequency, unsigned long duration)
+{
+  uint8_t prescalarbits = 0b001;
+  long toggle_count = 0;
+  uint32_t ocr = 0;
+  int8_t _timer;
+
+  _timer = toneBegin(_pin);
+
+  if (_timer >= 0)
+  {
+    // Set the pinMode as OUTPUT
+    pinMode(_pin, OUTPUT);
+    
+    // if we are using an 8 bit timer, scan through prescalars to find the best fit
+    if (_timer == 0 || _timer == 2)
+    {
+      ocr = F_CPU / frequency / 2 - 1;
+      prescalarbits = 0b001;  // ck/1: same for both timers
+      if (ocr > 255)
+      {
+        ocr = F_CPU / frequency / 2 / 8 - 1;
+        prescalarbits = 0b010;  // ck/8: same for both timers
+
+        if (_timer == 2 && ocr > 255)
+        {
+          ocr = F_CPU / frequency / 2 / 32 - 1;
+          prescalarbits = 0b011;
+        }
+
+        if (ocr > 255)
+        {
+          ocr = F_CPU / frequency / 2 / 64 - 1;
+          prescalarbits = _timer == 0 ? 0b011 : 0b100;
+
+          if (_timer == 2 && ocr > 255)
+          {
+            ocr = F_CPU / frequency / 2 / 128 - 1;
+            prescalarbits = 0b101;
+          }
+
+          if (ocr > 255)
+          {
+            ocr = F_CPU / frequency / 2 / 256 - 1;
+            prescalarbits = _timer == 0 ? 0b100 : 0b110;
+            if (ocr > 255)
+            {
+              // can't do any better than /1024
+              ocr = F_CPU / frequency / 2 / 1024 - 1;
+              prescalarbits = _timer == 0 ? 0b101 : 0b111;
+            }
+          }
+        }
+      }
+
+#if !defined(__AVR_ATmega8__)
+      if (_timer == 0)
+        TCCR0B = prescalarbits;
+      else
+#endif
+        TCCR2B = prescalarbits;
+    }
+    else
+    {
+      // two choices for the 16 bit timers: ck/1 or ck/64
+      ocr = F_CPU / frequency / 2 - 1;
+
+      prescalarbits = 0b001;
+      if (ocr > 0xffff)
+      {
+        ocr = F_CPU / frequency / 2 / 64 - 1;
+        prescalarbits = 0b011;
+      }
+
+      if (_timer == 1)
+        TCCR1B = (TCCR1B & 0b11111000) | prescalarbits;
+#if defined(__AVR_ATmega1280__)
+      else if (_timer == 3)
+        TCCR3B = (TCCR3B & 0b11111000) | prescalarbits;
+      else if (_timer == 4)
+        TCCR4B = (TCCR4B & 0b11111000) | prescalarbits;
+      else if (_timer == 5)
+        TCCR5B = (TCCR5B & 0b11111000) | prescalarbits;
+#endif
+
+    }
+    
+
+    // Calculate the toggle count
+    if (duration > 0)
+    {
+      toggle_count = 2 * frequency * duration / 1000;
+    }
+    else
+    {
+      toggle_count = -1;
+    }
+
+    // Set the OCR for the given timer,
+    // set the toggle count,
+    // then turn on the interrupts
+    switch (_timer)
+    {
+
+#if !defined(__AVR_ATmega8__)
+      case 0:
+        OCR0A = ocr;
+        timer0_toggle_count = toggle_count;
+        bitWrite(TIMSK0, OCIE0A, 1);
+        break;
+#endif
+
+      case 1:
+        OCR1A = ocr;
+        timer1_toggle_count = toggle_count;
+        bitWrite(TIMSK1, OCIE1A, 1);
+        break;
+      case 2:
+        OCR2A = ocr;
+        timer2_toggle_count = toggle_count;
+        bitWrite(TIMSK2, OCIE2A, 1);
+        break;
+
+#if defined(__AVR_ATmega1280__)
+      case 3:
+        OCR3A = ocr;
+        timer3_toggle_count = toggle_count;
+        bitWrite(TIMSK3, OCIE3A, 1);
+        break;
+      case 4:
+        OCR4A = ocr;
+        timer4_toggle_count = toggle_count;
+        bitWrite(TIMSK4, OCIE4A, 1);
+        break;
+      case 5:
+        OCR5A = ocr;
+        timer5_toggle_count = toggle_count;
+        bitWrite(TIMSK5, OCIE5A, 1);
+        break;
+#endif
+
+    }
+  }
+}
+
+
+void noTone(uint8_t _pin)
+{
+  int8_t _timer = -1;
+  
+  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
+    if (tone_pins[i] == _pin) {
+      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
+      tone_pins[i] = 255;
+    }
+  }
+  
+  switch (_timer)
+  {
+#if defined(__AVR_ATmega8__)
+    case 1:
+      bitWrite(TIMSK1, OCIE1A, 0);
+      break;
+    case 2:
+      bitWrite(TIMSK2, OCIE2A, 0);
+      break;
+
+#else
+    case 0:
+      TIMSK0 = 0;
+      break;
+    case 1:
+      TIMSK1 = 0;
+      break;
+    case 2:
+      TIMSK2 = 0;
+      break;
+#endif
+
+#if defined(__AVR_ATmega1280__)
+    case 3:
+      TIMSK3 = 0;
+      break;
+    case 4:
+      TIMSK4 = 0;
+      break;
+    case 5:
+      TIMSK5 = 0;
+      break;
+#endif
+  }
+
+  digitalWrite(_pin, 0);
+}
+
+#if 0
+#if !defined(__AVR_ATmega8__)
+ISR(TIMER0_COMPA_vect)
+{
+  if (timer0_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer0_pin_port ^= timer0_pin_mask;
+
+    if (timer0_toggle_count > 0)
+      timer0_toggle_count--;
+  }
+  else
+  {
+    TIMSK0 = 0;   // disable the interrupt
+    *timer0_pin_port &= ~(timer0_pin_mask);  // keep pin low after stop
+  }
+}
+#endif
+
+
+ISR(TIMER1_COMPA_vect)
+{
+  if (timer1_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer1_pin_port ^= timer1_pin_mask;
+
+    if (timer1_toggle_count > 0)
+      timer1_toggle_count--;
+  }
+  else
+  {
+    TIMSK1 = 0;   // disable the interrupt
+    *timer1_pin_port &= ~(timer1_pin_mask);  // keep pin low after stop
+  }
+}
+#endif
+
+
+ISR(TIMER2_COMPA_vect)
+{
+
+  if (timer2_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer2_pin_port ^= timer2_pin_mask;
+
+    if (timer2_toggle_count > 0)
+      timer2_toggle_count--;
+  }
+  else
+  {
+    TIMSK2 = 0;   // disable the interrupt
+    *timer2_pin_port &= ~(timer2_pin_mask);  // keep pin low after stop
+  }
+}
+
+
+
+//#if defined(__AVR_ATmega1280__)
+#if 0
+
+ISR(TIMER3_COMPA_vect)
+{
+  if (timer3_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer3_pin_port ^= timer3_pin_mask;
+
+    if (timer3_toggle_count > 0)
+      timer3_toggle_count--;
+  }
+  else
+  {
+    TIMSK3 = 0;   // disable the interrupt
+    *timer3_pin_port &= ~(timer3_pin_mask);  // keep pin low after stop
+  }
+}
+
+ISR(TIMER4_COMPA_vect)
+{
+  if (timer4_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer4_pin_port ^= timer4_pin_mask;
+
+    if (timer4_toggle_count > 0)
+      timer4_toggle_count--;
+  }
+  else
+  {
+    TIMSK4 = 0;   // disable the interrupt
+    *timer4_pin_port &= ~(timer4_pin_mask);  // keep pin low after stop
+  }
+}
+
+ISR(TIMER5_COMPA_vect)
+{
+  if (timer5_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer5_pin_port ^= timer5_pin_mask;
+
+    if (timer5_toggle_count > 0)
+      timer5_toggle_count--;
+  }
+  else
+  {
+    TIMSK5 = 0;   // disable the interrupt
+    *timer5_pin_port &= ~(timer5_pin_mask);  // keep pin low after stop
+  }
+}
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WCharacter.h b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WCharacter.h
new file mode 100644
index 0000000..79733b5
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WCharacter.h
@@ -0,0 +1,168 @@
+/*
+ WCharacter.h - Character utility functions for Wiring & Arduino
+ Copyright (c) 2010 Hernando Barragan.  All right reserved.
+ 
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Lesser General Public
+ License as published by the Free Software Foundation; either
+ version 2.1 of the License, or (at your option) any later version.
+ 
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Lesser General Public License for more details.
+ 
+ You should have received a copy of the GNU Lesser General Public
+ License along with this library; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef Character_h
+#define Character_h
+
+#include <ctype.h>
+
+// WCharacter.h prototypes
+inline boolean isAlphaNumeric(int c) __attribute__((always_inline));
+inline boolean isAlpha(int c) __attribute__((always_inline));
+inline boolean isAscii(int c) __attribute__((always_inline));
+inline boolean isWhitespace(int c) __attribute__((always_inline));
+inline boolean isControl(int c) __attribute__((always_inline));
+inline boolean isDigit(int c) __attribute__((always_inline));
+inline boolean isGraph(int c) __attribute__((always_inline));
+inline boolean isLowerCase(int c) __attribute__((always_inline));
+inline boolean isPrintable(int c) __attribute__((always_inline));
+inline boolean isPunct(int c) __attribute__((always_inline));
+inline boolean isSpace(int c) __attribute__((always_inline));
+inline boolean isUpperCase(int c) __attribute__((always_inline));
+inline boolean isHexadecimalDigit(int c) __attribute__((always_inline));
+inline int toAscii(int c) __attribute__((always_inline));
+inline int toLowerCase(int c) __attribute__((always_inline));
+inline int toUpperCase(int c)__attribute__((always_inline));
+
+
+// Checks for an alphanumeric character. 
+// It is equivalent to (isalpha(c) || isdigit(c)).
+inline boolean isAlphaNumeric(int c) 
+{
+  return ( isalnum(c) == 0 ? false : true);
+}
+
+
+// Checks for an alphabetic character. 
+// It is equivalent to (isupper(c) || islower(c)).
+inline boolean isAlpha(int c)
+{
+  return ( isalpha(c) == 0 ? false : true);
+}
+
+
+// Checks whether c is a 7-bit unsigned char value 
+// that fits into the ASCII character set.
+inline boolean isAscii(int c)
+{
+  return ( isascii (c) == 0 ? false : true);
+}
+
+
+// Checks for a blank character, that is, a space or a tab.
+inline boolean isWhitespace(int c)
+{
+  return ( isblank (c) == 0 ? false : true);
+}
+
+
+// Checks for a control character.
+inline boolean isControl(int c)
+{
+  return ( iscntrl (c) == 0 ? false : true);
+}
+
+
+// Checks for a digit (0 through 9).
+inline boolean isDigit(int c)
+{
+  return ( isdigit (c) == 0 ? false : true);
+}
+
+
+// Checks for any printable character except space.
+inline boolean isGraph(int c)
+{
+  return ( isgraph (c) == 0 ? false : true);
+}
+
+
+// Checks for a lower-case character.
+inline boolean isLowerCase(int c)
+{
+  return (islower (c) == 0 ? false : true);
+}
+
+
+// Checks for any printable character including space.
+inline boolean isPrintable(int c)
+{
+  return ( isprint (c) == 0 ? false : true);
+}
+
+
+// Checks for any printable character which is not a space 
+// or an alphanumeric character.
+inline boolean isPunct(int c)
+{
+  return ( ispunct (c) == 0 ? false : true);
+}
+
+
+// Checks for white-space characters. For the avr-libc library, 
+// these are: space, formfeed ('\f'), newline ('\n'), carriage 
+// return ('\r'), horizontal tab ('\t'), and vertical tab ('\v').
+inline boolean isSpace(int c)
+{
+  return ( isspace (c) == 0 ? false : true);
+}
+
+
+// Checks for an uppercase letter.
+inline boolean isUpperCase(int c)
+{
+  return ( isupper (c) == 0 ? false : true);
+}
+
+
+// Checks for a hexadecimal digits, i.e. one of 0 1 2 3 4 5 6 7 
+// 8 9 a b c d e f A B C D E F.
+inline boolean isHexadecimalDigit(int c)
+{
+  return ( isxdigit (c) == 0 ? false : true);
+}
+
+
+// Converts c to a 7-bit unsigned char value that fits into the 
+// ASCII character set, by clearing the high-order bits.
+inline int toAscii(int c)
+{
+  return toascii (c);
+}
+
+
+// Warning:
+// Many people will be unhappy if you use this function. 
+// This function will convert accented letters into random 
+// characters.
+
+// Converts the letter c to lower case, if possible.
+inline int toLowerCase(int c)
+{
+  return tolower (c);
+}
+
+
+// Converts the letter c to upper case, if possible.
+inline int toUpperCase(int c)
+{
+  return toupper (c);
+}
+
+#endif
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WConstants.h b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WConstants.h
new file mode 100644
index 0000000..3e19ac4
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WConstants.h
@@ -0,0 +1 @@
+#include "wiring.h"
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WInterrupts.c b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WInterrupts.c
new file mode 100644
index 0000000..6f3f0b1
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WInterrupts.c
@@ -0,0 +1,87 @@
+/* -*- mode: jde; c-basic-offset: 2; indent-tabs-mode: nil -*- */
+
+/*
+  Part of the Wiring project - http://wiring.uniandes.edu.co
+
+  Copyright (c) 2004-05 Hernando Barragan
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+  
+  Modified 24 November 2006 by David A. Mellis
+*/
+
+#include <inttypes.h>
+#include <avr/io.h>
+#include <avr/interrupt.h>
+#include <avr/pgmspace.h>
+#include <stdio.h>
+
+#include "WConstants.h"
+#include "wiring_private.h"
+
+volatile static voidFuncPtr intFunc[EXTERNAL_NUM_INTERRUPTS];
+// volatile static voidFuncPtr twiIntFunc;
+
+void attachInterrupt(uint8_t interruptNum, void (*userFunc)(void), int mode)
+{
+	if(interruptNum < EXTERNAL_NUM_INTERRUPTS)
+	{
+		intFunc[interruptNum] = userFunc;
+
+		//clear the config for the change settings
+		EICRA &= ~(B00000011 << (interruptNum * 2));
+
+		//set our mode.
+		EICRA |= (mode << (interruptNum * 2));
+
+		// Enable the interrupt.
+		EIMSK |= (1 << interruptNum);
+	}
+}
+
+void detachInterrupt(uint8_t interruptNum)
+{
+	if(interruptNum < EXTERNAL_NUM_INTERRUPTS)
+	{
+		// Disable the interrupt.
+		EIMSK &= ~(1 << interruptNum);
+
+		intFunc[interruptNum] = 0;
+	}
+}
+
+ISR(INT0_vect) {
+  if(intFunc[EXTERNAL_INT_0])
+    intFunc[EXTERNAL_INT_0]();
+}
+
+ISR(INT1_vect) {
+  if(intFunc[EXTERNAL_INT_1])
+    intFunc[EXTERNAL_INT_1]();
+}
+
+ISR(INT2_vect) {
+  if(intFunc[EXTERNAL_INT_2])
+    intFunc[EXTERNAL_INT_2]();
+}
+
+/*
+SIGNAL(SIG_2WIRE_SERIAL) {
+  if(twiIntFunc)
+    twiIntFunc();
+}
+*/
+
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WMath.cpp b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WMath.cpp
new file mode 100644
index 0000000..7a230f5
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WMath.cpp
@@ -0,0 +1,60 @@
+/* -*- mode: jde; c-basic-offset: 2; indent-tabs-mode: nil -*- */
+
+/*
+  Part of the Wiring project - http://wiring.org.co
+  Copyright (c) 2004-06 Hernando Barragan
+  Modified 13 August 2006, David A. Mellis for Arduino - http://www.arduino.cc/
+  
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+  
+  $Id$
+*/
+
+extern "C" {
+  #include "stdlib.h"
+}
+
+void randomSeed(unsigned int seed)
+{
+  if (seed != 0){
+    srandom(seed);
+  }
+}
+
+long random(long howbig)
+{
+  if (howbig == 0) {
+    return 0;
+  }
+  return random() % howbig;
+}
+
+long random(long howsmall, long howbig)
+{
+  if (howsmall >= howbig) {
+    return howsmall;
+  }
+  long diff = howbig - howsmall;
+  return random(diff) + howsmall;
+}
+
+long map(long x, long in_min, long in_max, long out_min, long out_max)
+{
+  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
+}
+
+unsigned int makeWord(unsigned int w) { return w; }
+unsigned int makeWord(unsigned char h, unsigned char l) { return (h << 8) | l; }
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WProgram.h b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WProgram.h
new file mode 100644
index 0000000..2c7ed16
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WProgram.h
@@ -0,0 +1,34 @@
+#ifndef WProgram_h
+#define WProgram_h
+
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+
+#include <avr/interrupt.h>
+
+#include "wiring.h"
+
+#ifdef __cplusplus
+#include "WCharacter.h"
+#include "WString.h"
+#include "HardwareSerial.h"
+
+uint16_t makeWord(uint16_t w);
+uint16_t makeWord(byte h, byte l);
+
+#define word(...) makeWord(__VA_ARGS__)
+
+unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout = 1000000L);
+
+void tone(uint8_t _pin, unsigned int frequency, unsigned long duration = 0);
+void noTone(uint8_t _pin);
+
+// WMath prototypes
+long random(long);
+long random(long, long);
+void randomSeed(unsigned int);
+long map(long, long, long, long, long);
+#endif
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WString.cpp b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WString.cpp
new file mode 100644
index 0000000..db5a441
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WString.cpp
@@ -0,0 +1,443 @@
+/*
+  WString.cpp - String library for Wiring & Arduino
+  Copyright (c) 2009-10 Hernando Barragan.  All rights reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include <stdlib.h>
+#include "WProgram.h"
+#include "WString.h"
+
+
+String::String( const char *value )
+{
+  if ( value == NULL )
+    value = "";
+  getBuffer( _length = strlen( value ) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, value );
+}
+
+String::String( const String &value )
+{
+  getBuffer( _length = value._length );
+  if ( _buffer != NULL )
+    strcpy( _buffer, value._buffer );
+}
+
+String::String( const char value )
+{
+  _length = 1;
+  getBuffer(1);
+  if ( _buffer != NULL ) {
+    _buffer[0] = value;
+    _buffer[1] = 0;
+  }
+}
+
+String::String( const unsigned char value )
+{
+  _length = 1;
+  getBuffer(1);
+  if ( _buffer != NULL) {
+    _buffer[0] = value;
+    _buffer[1] = 0;
+  }
+}
+
+String::String( const int value, const int base )
+{
+  char buf[33];   
+  itoa((signed long)value, buf, base);
+  getBuffer( _length = strlen(buf) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, buf );
+}
+
+String::String( const unsigned int value, const int base )
+{
+  char buf[33];   
+  ultoa((unsigned long)value, buf, base);
+  getBuffer( _length = strlen(buf) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, buf );
+}
+
+String::String( const long value, const int base )
+{
+  char buf[33];   
+  ltoa(value, buf, base);
+  getBuffer( _length = strlen(buf) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, buf );
+}
+
+String::String( const unsigned long value, const int base )
+{
+  char buf[33];   
+  ultoa(value, buf, 10);
+  getBuffer( _length = strlen(buf) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, buf );
+}
+
+char String::charAt( unsigned int loc ) const
+{
+  return operator[]( loc );
+}
+
+void String::setCharAt( unsigned int loc, const char aChar ) 
+{
+  if(_buffer == NULL) return;
+  if(_length > loc) {
+    _buffer[loc] = aChar;
+  }
+}
+
+int String::compareTo( const String &s2 ) const
+{
+  return strcmp( _buffer, s2._buffer );
+}
+
+const String & String::concat( const String &s2 )
+{
+  return (*this) += s2;
+}
+
+const String & String::operator=( const String &rhs )
+{
+  if ( this == &rhs )
+    return *this;
+
+  if ( rhs._length > _length )
+  {
+    free(_buffer);
+    getBuffer( rhs._length );
+  }
+  
+  if ( _buffer != NULL ) {
+    _length = rhs._length;
+    strcpy( _buffer, rhs._buffer );
+  }
+  return *this;
+}
+
+//const String & String::operator+=( const char aChar )
+//{
+//  if ( _length == _capacity )
+//    doubleBuffer();
+//
+//  _buffer[ _length++ ] = aChar;
+//  _buffer[ _length ] = '\0';
+//  return *this;
+//}
+
+const String & String::operator+=( const String &other )
+{
+  _length += other._length;
+  if ( _length > _capacity )
+  {
+    char *temp = (char *)realloc(_buffer, _length + 1);
+    if ( temp != NULL ) {
+      _buffer = temp;
+      _capacity = _length;
+    } else {
+      _length -= other._length;
+      return *this;
+    }
+  }
+  strcat( _buffer, other._buffer );
+  return *this;
+}
+
+
+int String::operator==( const String &rhs ) const
+{
+  return ( _length == rhs._length && strcmp( _buffer, rhs._buffer ) == 0 );
+}
+
+int String::operator!=( const String &rhs ) const
+{
+  return ( _length != rhs.length() || strcmp( _buffer, rhs._buffer ) != 0 );
+}
+
+int String::operator<( const String &rhs ) const
+{
+  return strcmp( _buffer, rhs._buffer ) < 0;
+}
+
+int String::operator>( const String &rhs ) const
+{
+  return strcmp( _buffer, rhs._buffer ) > 0;
+}
+
+int String::operator<=( const String &rhs ) const
+{
+  return strcmp( _buffer, rhs._buffer ) <= 0;
+}
+
+int String::operator>=( const String & rhs ) const
+{
+  return strcmp( _buffer, rhs._buffer ) >= 0;
+}
+
+char & String::operator[]( unsigned int index )
+{
+  static char dummy_writable_char;
+  if (index >= _length || !_buffer) {
+    dummy_writable_char = 0;
+    return dummy_writable_char;
+  }
+  return _buffer[ index ];
+}
+
+char String::operator[]( unsigned int index ) const
+{
+  // need to check for valid index, to do later
+  return _buffer[ index ];
+}
+
+boolean String::endsWith( const String &s2 ) const
+{
+  if ( _length < s2._length )
+    return 0;
+
+  return strcmp( &_buffer[ _length - s2._length], s2._buffer ) == 0;
+}
+
+boolean String::equals( const String &s2 ) const
+{
+  return ( _length == s2._length && strcmp( _buffer,s2._buffer ) == 0 );
+}
+
+boolean String::equalsIgnoreCase( const String &s2 ) const
+{
+  if ( this == &s2 )
+    return true; //1;
+  else if ( _length != s2._length )
+    return false; //0;
+
+  return strcmp(toLowerCase()._buffer, s2.toLowerCase()._buffer) == 0;
+}
+
+String String::replace( char findChar, char replaceChar )
+{
+  if ( _buffer == NULL ) return *this;
+  String theReturn = _buffer;
+  char* temp = theReturn._buffer;
+  while( (temp = strchr( temp, findChar )) != 0 )
+    *temp = replaceChar;
+
+  return theReturn;
+}
+
+String String::replace( const String& match, const String& replace )
+{
+  if ( _buffer == NULL ) return *this;
+  String temp = _buffer, newString;
+
+  int loc;
+  while ( (loc = temp.indexOf( match )) != -1 )
+  {
+    newString += temp.substring( 0, loc );
+    newString += replace;
+    temp = temp.substring( loc + match._length );
+  }
+  newString += temp;  
+  return newString;
+}
+
+int String::indexOf( char temp ) const
+{
+  return indexOf( temp, 0 );
+}
+
+int String::indexOf( char ch, unsigned int fromIndex ) const
+{
+  if ( fromIndex >= _length )
+    return -1;
+
+  const char* temp = strchr( &_buffer[fromIndex], ch );
+  if ( temp == NULL )
+    return -1;
+
+  return temp - _buffer;
+}
+
+int String::indexOf( const String &s2 ) const
+{
+  return indexOf( s2, 0 );
+}
+
+int String::indexOf( const String &s2, unsigned int fromIndex ) const
+{
+  if ( fromIndex >= _length )
+    return -1;
+
+  const char *theFind = strstr( &_buffer[ fromIndex ], s2._buffer );
+
+  if ( theFind == NULL )
+    return -1;
+
+  return theFind - _buffer; // pointer subtraction
+}
+
+int String::lastIndexOf( char theChar ) const
+{
+  return lastIndexOf( theChar, _length - 1 );
+}
+
+int String::lastIndexOf( char ch, unsigned int fromIndex ) const
+{
+  if ( fromIndex >= _length )
+    return -1;
+
+  char tempchar = _buffer[fromIndex + 1];
+  _buffer[fromIndex + 1] = '\0';
+  char* temp = strrchr( _buffer, ch );
+  _buffer[fromIndex + 1] = tempchar;
+
+  if ( temp == NULL )
+    return -1;
+
+  return temp - _buffer;
+}
+
+int String::lastIndexOf( const String &s2 ) const
+{
+  return lastIndexOf( s2, _length - s2._length );
+}
+
+int String::lastIndexOf( const String &s2, unsigned int fromIndex ) const
+{
+  // check for empty strings
+  if ( s2._length == 0 || s2._length - 1 > fromIndex || fromIndex >= _length )
+    return -1;
+
+  // matching first character
+  char temp = s2[ 0 ];
+
+  for ( int i = fromIndex; i >= 0; i-- )
+  {
+    if ( _buffer[ i ] == temp && (*this).substring( i, i + s2._length ).equals( s2 ) )
+    return i;
+  }
+  return -1;
+}
+
+boolean String::startsWith( const String &s2 ) const
+{
+  if ( _length < s2._length )
+    return 0;
+
+  return startsWith( s2, 0 );
+}
+
+boolean String::startsWith( const String &s2, unsigned int offset ) const
+{
+  if ( offset > _length - s2._length )
+    return 0;
+
+  return strncmp( &_buffer[offset], s2._buffer, s2._length ) == 0;
+}
+
+String String::substring( unsigned int left ) const
+{
+  return substring( left, _length );
+}
+
+String String::substring( unsigned int left, unsigned int right ) const
+{
+  if ( left > right )
+  {
+    int temp = right;
+    right = left;
+    left = temp;
+  }
+
+  if ( right > _length )
+  {
+    right = _length;
+  } 
+
+  char temp = _buffer[ right ];  // save the replaced character
+  _buffer[ right ] = '\0';	
+  String outPut = ( _buffer + left );  // pointer arithmetic
+  _buffer[ right ] = temp;  //restore character
+  return outPut;
+}
+
+String String::toLowerCase() const
+{
+  String temp = _buffer;
+
+  for ( unsigned int i = 0; i < _length; i++ )
+    temp._buffer[ i ] = (char)tolower( temp._buffer[ i ] );
+  return temp;
+}
+
+String String::toUpperCase() const
+{
+  String temp = _buffer;
+
+  for ( unsigned int i = 0; i < _length; i++ )
+    temp._buffer[ i ] = (char)toupper( temp._buffer[ i ] );
+  return temp;
+}
+
+String String::trim() const
+{
+  if ( _buffer == NULL ) return *this;
+  String temp = _buffer;
+  unsigned int i,j;
+
+  for ( i = 0; i < _length; i++ )
+  {
+    if ( !isspace(_buffer[i]) )
+      break;
+  }
+
+  for ( j = temp._length - 1; j > i; j-- )
+  {
+    if ( !isspace(_buffer[j]) )
+      break;
+  }
+
+  return temp.substring( i, j + 1);
+}
+
+void String::getBytes(unsigned char *buf, unsigned int bufsize)
+{
+  if (!bufsize || !buf) return;
+  unsigned int len = bufsize - 1;
+  if (len > _length) len = _length;
+  strncpy((char *)buf, _buffer, len);
+  buf[len] = 0;
+}
+
+void String::toCharArray(char *buf, unsigned int bufsize)
+{
+  if (!bufsize || !buf) return;
+  unsigned int len = bufsize - 1;
+  if (len > _length) len = _length;
+  strncpy(buf, _buffer, len);
+  buf[len] = 0;
+}
+
+
+long String::toInt() {
+  return atol(_buffer);
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WString.h b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WString.h
new file mode 100644
index 0000000..cadddb9
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WString.h
@@ -0,0 +1,112 @@
+/*
+  WString.h - String library for Wiring & Arduino
+  Copyright (c) 2009-10 Hernando Barragan.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef String_h
+#define String_h
+
+//#include "WProgram.h"
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+
+class String
+{
+  public:
+    // constructors
+    String( const char *value = "" );
+    String( const String &value );
+    String( const char );
+    String( const unsigned char );
+    String( const int, const int base=10);
+    String( const unsigned int, const int base=10 );
+    String( const long, const int base=10 );
+    String( const unsigned long, const int base=10 );
+    ~String() { free(_buffer); _length = _capacity = 0;}     //added _length = _capacity = 0;
+
+    // operators
+    const String & operator = ( const String &rhs );
+    const String & operator +=( const String &rhs );
+    //const String & operator +=( const char );
+    int operator ==( const String &rhs ) const;
+    int	operator !=( const String &rhs ) const;
+    int	operator < ( const String &rhs ) const;
+    int	operator > ( const String &rhs ) const;
+    int	operator <=( const String &rhs ) const;
+    int	operator >=( const String &rhs ) const;
+    char operator []( unsigned int index ) const;
+    char& operator []( unsigned int index );
+    //operator const char *() const { return _buffer; }
+    
+    // general methods
+    char charAt( unsigned int index ) const;
+    int	compareTo( const String &anotherString ) const;
+    unsigned char endsWith( const String &suffix ) const;
+    unsigned char equals( const String &anObject ) const;
+    unsigned char equalsIgnoreCase( const String &anotherString ) const;
+    int	indexOf( char ch ) const;
+    int	indexOf( char ch, unsigned int fromIndex ) const;
+    int	indexOf( const String &str ) const;
+    int	indexOf( const String &str, unsigned int fromIndex ) const;
+    int	lastIndexOf( char ch ) const;
+    int	lastIndexOf( char ch, unsigned int fromIndex ) const;
+    int	lastIndexOf( const String &str ) const;
+    int	lastIndexOf( const String &str, unsigned int fromIndex ) const;
+    const unsigned int length( ) const { return _length; }
+    void setCharAt(unsigned int index, const char ch);
+    unsigned char startsWith( const String &prefix ) const;
+    unsigned char startsWith( const String &prefix, unsigned int toffset ) const;
+    String substring( unsigned int beginIndex ) const;
+    String substring( unsigned int beginIndex, unsigned int endIndex ) const;
+    String toLowerCase( ) const;
+    String toUpperCase( ) const;
+    String trim( ) const;
+    void getBytes(unsigned char *buf, unsigned int bufsize);
+    void toCharArray(char *buf, unsigned int bufsize);
+    long toInt( );
+    const String& concat( const String &str );
+    String replace( char oldChar, char newChar );
+    String replace( const String& match, const String& replace );
+    friend String operator + ( String lhs, const String &rhs );
+
+  protected:
+    char *_buffer;	     // the actual char array
+    unsigned int _capacity;  // the array length minus one (for the '\0')
+    unsigned int _length;    // the String length (not counting the '\0')
+
+    void getBuffer(unsigned int maxStrLen);
+
+  private:
+
+};
+
+// allocate buffer space
+inline void String::getBuffer(unsigned int maxStrLen)
+{
+  _capacity = maxStrLen;
+  _buffer = (char *) malloc(_capacity + 1);
+  if (_buffer == NULL) _length = _capacity = 0;
+}
+
+inline String operator+( String lhs, const String &rhs )
+{
+  return lhs += rhs;
+}
+
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/binary.h b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/binary.h
new file mode 100644
index 0000000..af14980
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/binary.h
@@ -0,0 +1,515 @@
+#ifndef Binary_h
+#define Binary_h
+
+#define B0 0
+#define B00 0
+#define B000 0
+#define B0000 0
+#define B00000 0
+#define B000000 0
+#define B0000000 0
+#define B00000000 0
+#define B1 1
+#define B01 1
+#define B001 1
+#define B0001 1
+#define B00001 1
+#define B000001 1
+#define B0000001 1
+#define B00000001 1
+#define B10 2
+#define B010 2
+#define B0010 2
+#define B00010 2
+#define B000010 2
+#define B0000010 2
+#define B00000010 2
+#define B11 3
+#define B011 3
+#define B0011 3
+#define B00011 3
+#define B000011 3
+#define B0000011 3
+#define B00000011 3
+#define B100 4
+#define B0100 4
+#define B00100 4
+#define B000100 4
+#define B0000100 4
+#define B00000100 4
+#define B101 5
+#define B0101 5
+#define B00101 5
+#define B000101 5
+#define B0000101 5
+#define B00000101 5
+#define B110 6
+#define B0110 6
+#define B00110 6
+#define B000110 6
+#define B0000110 6
+#define B00000110 6
+#define B111 7
+#define B0111 7
+#define B00111 7
+#define B000111 7
+#define B0000111 7
+#define B00000111 7
+#define B1000 8
+#define B01000 8
+#define B001000 8
+#define B0001000 8
+#define B00001000 8
+#define B1001 9
+#define B01001 9
+#define B001001 9
+#define B0001001 9
+#define B00001001 9
+#define B1010 10
+#define B01010 10
+#define B001010 10
+#define B0001010 10
+#define B00001010 10
+#define B1011 11
+#define B01011 11
+#define B001011 11
+#define B0001011 11
+#define B00001011 11
+#define B1100 12
+#define B01100 12
+#define B001100 12
+#define B0001100 12
+#define B00001100 12
+#define B1101 13
+#define B01101 13
+#define B001101 13
+#define B0001101 13
+#define B00001101 13
+#define B1110 14
+#define B01110 14
+#define B001110 14
+#define B0001110 14
+#define B00001110 14
+#define B1111 15
+#define B01111 15
+#define B001111 15
+#define B0001111 15
+#define B00001111 15
+#define B10000 16
+#define B010000 16
+#define B0010000 16
+#define B00010000 16
+#define B10001 17
+#define B010001 17
+#define B0010001 17
+#define B00010001 17
+#define B10010 18
+#define B010010 18
+#define B0010010 18
+#define B00010010 18
+#define B10011 19
+#define B010011 19
+#define B0010011 19
+#define B00010011 19
+#define B10100 20
+#define B010100 20
+#define B0010100 20
+#define B00010100 20
+#define B10101 21
+#define B010101 21
+#define B0010101 21
+#define B00010101 21
+#define B10110 22
+#define B010110 22
+#define B0010110 22
+#define B00010110 22
+#define B10111 23
+#define B010111 23
+#define B0010111 23
+#define B00010111 23
+#define B11000 24
+#define B011000 24
+#define B0011000 24
+#define B00011000 24
+#define B11001 25
+#define B011001 25
+#define B0011001 25
+#define B00011001 25
+#define B11010 26
+#define B011010 26
+#define B0011010 26
+#define B00011010 26
+#define B11011 27
+#define B011011 27
+#define B0011011 27
+#define B00011011 27
+#define B11100 28
+#define B011100 28
+#define B0011100 28
+#define B00011100 28
+#define B11101 29
+#define B011101 29
+#define B0011101 29
+#define B00011101 29
+#define B11110 30
+#define B011110 30
+#define B0011110 30
+#define B00011110 30
+#define B11111 31
+#define B011111 31
+#define B0011111 31
+#define B00011111 31
+#define B100000 32
+#define B0100000 32
+#define B00100000 32
+#define B100001 33
+#define B0100001 33
+#define B00100001 33
+#define B100010 34
+#define B0100010 34
+#define B00100010 34
+#define B100011 35
+#define B0100011 35
+#define B00100011 35
+#define B100100 36
+#define B0100100 36
+#define B00100100 36
+#define B100101 37
+#define B0100101 37
+#define B00100101 37
+#define B100110 38
+#define B0100110 38
+#define B00100110 38
+#define B100111 39
+#define B0100111 39
+#define B00100111 39
+#define B101000 40
+#define B0101000 40
+#define B00101000 40
+#define B101001 41
+#define B0101001 41
+#define B00101001 41
+#define B101010 42
+#define B0101010 42
+#define B00101010 42
+#define B101011 43
+#define B0101011 43
+#define B00101011 43
+#define B101100 44
+#define B0101100 44
+#define B00101100 44
+#define B101101 45
+#define B0101101 45
+#define B00101101 45
+#define B101110 46
+#define B0101110 46
+#define B00101110 46
+#define B101111 47
+#define B0101111 47
+#define B00101111 47
+#define B110000 48
+#define B0110000 48
+#define B00110000 48
+#define B110001 49
+#define B0110001 49
+#define B00110001 49
+#define B110010 50
+#define B0110010 50
+#define B00110010 50
+#define B110011 51
+#define B0110011 51
+#define B00110011 51
+#define B110100 52
+#define B0110100 52
+#define B00110100 52
+#define B110101 53
+#define B0110101 53
+#define B00110101 53
+#define B110110 54
+#define B0110110 54
+#define B00110110 54
+#define B110111 55
+#define B0110111 55
+#define B00110111 55
+#define B111000 56
+#define B0111000 56
+#define B00111000 56
+#define B111001 57
+#define B0111001 57
+#define B00111001 57
+#define B111010 58
+#define B0111010 58
+#define B00111010 58
+#define B111011 59
+#define B0111011 59
+#define B00111011 59
+#define B111100 60
+#define B0111100 60
+#define B00111100 60
+#define B111101 61
+#define B0111101 61
+#define B00111101 61
+#define B111110 62
+#define B0111110 62
+#define B00111110 62
+#define B111111 63
+#define B0111111 63
+#define B00111111 63
+#define B1000000 64
+#define B01000000 64
+#define B1000001 65
+#define B01000001 65
+#define B1000010 66
+#define B01000010 66
+#define B1000011 67
+#define B01000011 67
+#define B1000100 68
+#define B01000100 68
+#define B1000101 69
+#define B01000101 69
+#define B1000110 70
+#define B01000110 70
+#define B1000111 71
+#define B01000111 71
+#define B1001000 72
+#define B01001000 72
+#define B1001001 73
+#define B01001001 73
+#define B1001010 74
+#define B01001010 74
+#define B1001011 75
+#define B01001011 75
+#define B1001100 76
+#define B01001100 76
+#define B1001101 77
+#define B01001101 77
+#define B1001110 78
+#define B01001110 78
+#define B1001111 79
+#define B01001111 79
+#define B1010000 80
+#define B01010000 80
+#define B1010001 81
+#define B01010001 81
+#define B1010010 82
+#define B01010010 82
+#define B1010011 83
+#define B01010011 83
+#define B1010100 84
+#define B01010100 84
+#define B1010101 85
+#define B01010101 85
+#define B1010110 86
+#define B01010110 86
+#define B1010111 87
+#define B01010111 87
+#define B1011000 88
+#define B01011000 88
+#define B1011001 89
+#define B01011001 89
+#define B1011010 90
+#define B01011010 90
+#define B1011011 91
+#define B01011011 91
+#define B1011100 92
+#define B01011100 92
+#define B1011101 93
+#define B01011101 93
+#define B1011110 94
+#define B01011110 94
+#define B1011111 95
+#define B01011111 95
+#define B1100000 96
+#define B01100000 96
+#define B1100001 97
+#define B01100001 97
+#define B1100010 98
+#define B01100010 98
+#define B1100011 99
+#define B01100011 99
+#define B1100100 100
+#define B01100100 100
+#define B1100101 101
+#define B01100101 101
+#define B1100110 102
+#define B01100110 102
+#define B1100111 103
+#define B01100111 103
+#define B1101000 104
+#define B01101000 104
+#define B1101001 105
+#define B01101001 105
+#define B1101010 106
+#define B01101010 106
+#define B1101011 107
+#define B01101011 107
+#define B1101100 108
+#define B01101100 108
+#define B1101101 109
+#define B01101101 109
+#define B1101110 110
+#define B01101110 110
+#define B1101111 111
+#define B01101111 111
+#define B1110000 112
+#define B01110000 112
+#define B1110001 113
+#define B01110001 113
+#define B1110010 114
+#define B01110010 114
+#define B1110011 115
+#define B01110011 115
+#define B1110100 116
+#define B01110100 116
+#define B1110101 117
+#define B01110101 117
+#define B1110110 118
+#define B01110110 118
+#define B1110111 119
+#define B01110111 119
+#define B1111000 120
+#define B01111000 120
+#define B1111001 121
+#define B01111001 121
+#define B1111010 122
+#define B01111010 122
+#define B1111011 123
+#define B01111011 123
+#define B1111100 124
+#define B01111100 124
+#define B1111101 125
+#define B01111101 125
+#define B1111110 126
+#define B01111110 126
+#define B1111111 127
+#define B01111111 127
+#define B10000000 128
+#define B10000001 129
+#define B10000010 130
+#define B10000011 131
+#define B10000100 132
+#define B10000101 133
+#define B10000110 134
+#define B10000111 135
+#define B10001000 136
+#define B10001001 137
+#define B10001010 138
+#define B10001011 139
+#define B10001100 140
+#define B10001101 141
+#define B10001110 142
+#define B10001111 143
+#define B10010000 144
+#define B10010001 145
+#define B10010010 146
+#define B10010011 147
+#define B10010100 148
+#define B10010101 149
+#define B10010110 150
+#define B10010111 151
+#define B10011000 152
+#define B10011001 153
+#define B10011010 154
+#define B10011011 155
+#define B10011100 156
+#define B10011101 157
+#define B10011110 158
+#define B10011111 159
+#define B10100000 160
+#define B10100001 161
+#define B10100010 162
+#define B10100011 163
+#define B10100100 164
+#define B10100101 165
+#define B10100110 166
+#define B10100111 167
+#define B10101000 168
+#define B10101001 169
+#define B10101010 170
+#define B10101011 171
+#define B10101100 172
+#define B10101101 173
+#define B10101110 174
+#define B10101111 175
+#define B10110000 176
+#define B10110001 177
+#define B10110010 178
+#define B10110011 179
+#define B10110100 180
+#define B10110101 181
+#define B10110110 182
+#define B10110111 183
+#define B10111000 184
+#define B10111001 185
+#define B10111010 186
+#define B10111011 187
+#define B10111100 188
+#define B10111101 189
+#define B10111110 190
+#define B10111111 191
+#define B11000000 192
+#define B11000001 193
+#define B11000010 194
+#define B11000011 195
+#define B11000100 196
+#define B11000101 197
+#define B11000110 198
+#define B11000111 199
+#define B11001000 200
+#define B11001001 201
+#define B11001010 202
+#define B11001011 203
+#define B11001100 204
+#define B11001101 205
+#define B11001110 206
+#define B11001111 207
+#define B11010000 208
+#define B11010001 209
+#define B11010010 210
+#define B11010011 211
+#define B11010100 212
+#define B11010101 213
+#define B11010110 214
+#define B11010111 215
+#define B11011000 216
+#define B11011001 217
+#define B11011010 218
+#define B11011011 219
+#define B11011100 220
+#define B11011101 221
+#define B11011110 222
+#define B11011111 223
+#define B11100000 224
+#define B11100001 225
+#define B11100010 226
+#define B11100011 227
+#define B11100100 228
+#define B11100101 229
+#define B11100110 230
+#define B11100111 231
+#define B11101000 232
+#define B11101001 233
+#define B11101010 234
+#define B11101011 235
+#define B11101100 236
+#define B11101101 237
+#define B11101110 238
+#define B11101111 239
+#define B11110000 240
+#define B11110001 241
+#define B11110010 242
+#define B11110011 243
+#define B11110100 244
+#define B11110101 245
+#define B11110110 246
+#define B11110111 247
+#define B11111000 248
+#define B11111001 249
+#define B11111010 250
+#define B11111011 251
+#define B11111100 252
+#define B11111101 253
+#define B11111110 254
+#define B11111111 255
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/main.cpp b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/main.cpp
new file mode 100644
index 0000000..cc6e81d
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/main.cpp
@@ -0,0 +1,14 @@
+#include <WProgram.h>
+
+int main(void)
+{
+	init();
+
+	setup();
+    
+	for (;;)
+		loop();
+        
+	return 0;
+}
+
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/main.cxx b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/main.cxx
new file mode 100644
index 0000000..52351e4
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/main.cxx
@@ -0,0 +1,12 @@
+int main(void)
+{
+	init();
+
+	setup();
+    
+	for (;;)
+		loop();
+        
+	return 0;
+}
+
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/pins_arduino.c b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/pins_arduino.c
new file mode 100644
index 0000000..c67ab73
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/pins_arduino.c
@@ -0,0 +1,200 @@
+/*
+  pins_arduino.c - pin definitions for the Arduino board
+  Part of Arduino / Wiring Lite
+
+  Copyright (c) 2005 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: pins_arduino.c 254 2007-04-20 23:17:38Z mellis $
+*/
+
+#include <avr/io.h>
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+// On the Sanguino board, digital pins are also used
+// for the analog output (software PWM).  Analog input
+// pins are a separate set.
+
+// ATMEL ATMEGA644P / SANGUINO
+//
+//                   +---\/---+
+//  INT0 (D 0) PB0  1|        |40  PA0 (AI 0 / D31)
+//  INT1 (D 1) PB1  2|        |39  PA1 (AI 1 / D30)
+//  INT2 (D 2) PB2  3|        |38  PA2 (AI 2 / D29)
+//   PWM (D 3) PB3  4|        |37  PA3 (AI 3 / D28)
+//   PWM (D 4) PB4  5|        |36  PA4 (AI 4 / D27)
+//  MOSI (D 5) PB5  6|        |35  PA5 (AI 5 / D26)
+//  MISO (D 6) PB6  7|        |34  PA6 (AI 6 / D25)
+//   SCK (D 7) PB7  8|        |33  PA7 (AI 7 / D24)
+//             RST  9|        |32  AREF
+//             VCC 10|        |31  GND 
+//             GND 11|        |30  AVCC
+//           XTAL2 12|        |29  PC7 (D 23)
+//           XTAL1 13|        |28  PC6 (D 22)
+//  RX0 (D 8)  PD0 14|        |27  PC5 (D 21) TDI
+//  TX0 (D 9)  PD1 15|        |26  PC4 (D 20) TDO
+//  RX1 (D 10) PD2 16|        |25  PC3 (D 19) TMS
+//  TX1 (D 11) PD3 17|        |24  PC2 (D 18) TCK
+//  PWM (D 12) PD4 18|        |23  PC1 (D 17) SDA
+//  PWM (D 13) PD5 19|        |22  PC0 (D 16) SCL
+//  PWM (D 14) PD6 20|        |21  PD7 (D 15) PWM
+//                   +--------+
+//
+
+#define PA 1
+#define PB 2
+#define PC 3
+#define PD 4
+
+// these arrays map port names (e.g. port B) to the
+// appropriate addresses for various functions (e.g. reading
+// and writing)
+const uint8_t PROGMEM port_to_mode_PGM[] =
+{
+	NOT_A_PORT,
+        (uint8_t) &DDRA,
+	(uint8_t) &DDRB,
+	(uint8_t) &DDRC,
+	(uint8_t) &DDRD,
+};
+
+const uint8_t PROGMEM port_to_output_PGM[] =
+{
+	NOT_A_PORT,
+	(uint8_t) &PORTA,
+	(uint8_t) &PORTB,
+	(uint8_t) &PORTC,
+	(uint8_t) &PORTD,
+};
+
+const uint8_t PROGMEM port_to_input_PGM[] =
+{
+	NOT_A_PORT,
+	(uint8_t) &PINA,
+	(uint8_t) &PINB,
+	(uint8_t) &PINC,
+	(uint8_t) &PIND,
+};
+
+const uint8_t PROGMEM digital_pin_to_port_PGM[] =
+{
+	PB, /* 0 */
+	PB,
+	PB,
+	PB,
+	PB,
+	PB,
+	PB,
+	PB,
+	PD, /* 8 */
+	PD,
+	PD,
+	PD,
+	PD,
+	PD,
+	PD,
+	PD,
+	PC, /* 16 */
+	PC,
+	PC,
+	PC,
+	PC,
+	PC,
+   	PC,
+	PC,
+	PA, /* 24 */
+	PA,
+	PA,
+	PA,
+	PA,
+	PA,
+	PA,
+	PA  /* 31 */
+};
+
+const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[] =
+{
+	_BV(0), /* 0, port B */
+	_BV(1),
+	_BV(2),
+	_BV(3),
+	_BV(4),
+	_BV(5),
+	_BV(6),
+	_BV(7),
+	_BV(0), /* 8, port D */
+	_BV(1),
+	_BV(2),
+	_BV(3),
+	_BV(4),
+	_BV(5),
+	_BV(6),
+	_BV(7),
+	_BV(0), /* 16, port C */
+	_BV(1),
+	_BV(2),
+	_BV(3),
+	_BV(4),
+	_BV(5),
+	_BV(6),
+	_BV(7),
+	_BV(7), /* 24, port A */
+	_BV(6),
+	_BV(5),
+	_BV(4),
+	_BV(3),
+	_BV(2),
+	_BV(1),
+	_BV(0)
+};
+
+const uint8_t PROGMEM digital_pin_to_timer_PGM[] =
+{
+	NOT_ON_TIMER, 	/* 0  - PB0 */
+	NOT_ON_TIMER, 	/* 1  - PB1 */
+	NOT_ON_TIMER, 	/* 2  - PB2 */
+	TIMER0A,     	/* 3  - PB3 */
+	TIMER0B, 		/* 4  - PB4 */
+	NOT_ON_TIMER, 	/* 5  - PB5 */
+	NOT_ON_TIMER, 	/* 6  - PB6 */
+	NOT_ON_TIMER,	/* 7  - PB7 */
+	NOT_ON_TIMER, 	/* 8  - PD0 */
+	NOT_ON_TIMER, 	/* 9  - PD1 */
+	NOT_ON_TIMER, 	/* 10 - PD2 */
+	NOT_ON_TIMER, 	/* 11 - PD3 */
+	TIMER1B,     	/* 12 - PD4 */
+	TIMER1A,     	/* 13 - PD5 */
+	TIMER2B,     	/* 14 - PD6 */
+	TIMER2A,     	/* 15 - PD7 */
+	NOT_ON_TIMER, 	/* 16 - PC0 */
+	NOT_ON_TIMER,   /* 17 - PC1 */
+	NOT_ON_TIMER,   /* 18 - PC2 */
+	NOT_ON_TIMER,   /* 19 - PC3 */
+	NOT_ON_TIMER,   /* 20 - PC4 */
+	NOT_ON_TIMER,   /* 21 - PC5 */
+	NOT_ON_TIMER,   /* 22 - PC6 */
+	NOT_ON_TIMER,   /* 23 - PC7 */
+	NOT_ON_TIMER,   /* 24 - PA0 */
+	NOT_ON_TIMER,   /* 25 - PA1 */
+	NOT_ON_TIMER,   /* 26 - PA2 */
+	NOT_ON_TIMER,   /* 27 - PA3 */
+	NOT_ON_TIMER,   /* 28 - PA4 */
+	NOT_ON_TIMER,   /* 29 - PA5 */
+	NOT_ON_TIMER,   /* 30 - PA6 */
+	NOT_ON_TIMER   /* 31 - PA7 */
+};
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/pins_arduino.h b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/pins_arduino.h
new file mode 100644
index 0000000..e0b7add
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/pins_arduino.h
@@ -0,0 +1,65 @@
+/*
+  pins_arduino.h - Pin definition functions for Arduino
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2007 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.h 249 2007-02-03 16:52:51Z mellis $
+*/
+
+#ifndef Pins_Arduino_h
+#define Pins_Arduino_h
+
+#include <avr/pgmspace.h>
+
+#define NOT_A_PIN 0
+#define NOT_A_PORT 0
+
+#define NOT_ON_TIMER 0
+#define TIMER0A 1
+#define TIMER0B 2
+#define TIMER1A 3
+#define TIMER1B 4
+#define TIMER2  5
+#define TIMER2A 6
+#define TIMER2B 7
+
+extern const uint8_t PROGMEM port_to_mode_PGM[];
+extern const uint8_t PROGMEM port_to_input_PGM[];
+extern const uint8_t PROGMEM port_to_output_PGM[];
+
+extern const uint8_t PROGMEM digital_pin_to_port_PGM[];
+extern const uint8_t PROGMEM digital_pin_to_bit_PGM[];
+extern const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[];
+
+extern const uint8_t PROGMEM digital_pin_to_timer_PGM[];
+
+// Get the bit location within the hardware port of the given virtual pin.
+// This comes from the pins_*.c file for the active board configuration.
+// 
+// These perform slightly better as macros compared to inline functions
+//
+#define digitalPinToPort(P) ( pgm_read_byte( digital_pin_to_port_PGM + (P) ) )
+#define digitalPinToBitMask(P) ( pgm_read_byte( digital_pin_to_bit_mask_PGM + (P) ) )
+#define digitalPinToTimer(P) ( pgm_read_byte( digital_pin_to_timer_PGM + (P) ) )
+#define analogInPinToBit(P) (P)
+#define portOutputRegister(P) ( (volatile uint8_t *)( pgm_read_byte( port_to_output_PGM + (P))) )
+#define portInputRegister(P) ( (volatile uint8_t *)( pgm_read_byte( port_to_input_PGM + (P))) )
+#define portModeRegister(P) ( (volatile uint8_t *)( pgm_read_byte( port_to_mode_PGM + (P))) )
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring.c b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring.c
new file mode 100644
index 0000000..1a102ae
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring.c
@@ -0,0 +1,203 @@
+/*
+  wiring.c - Partial implementation of the Wiring API for the ATmega8.
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.c 388 2008-03-08 22:05:23Z mellis $
+*/
+
+#include "wiring_private.h"
+
+volatile unsigned long timer0_overflow_count = 0;
+volatile unsigned long timer0_clock_cycles = 0;
+volatile unsigned long timer0_millis = 0;
+
+SIGNAL(TIMER0_OVF_vect)
+{
+	timer0_overflow_count++;
+	// timer 0 prescale factor is 64 and the timer overflows at 256
+	timer0_clock_cycles += 64UL * 256UL;
+	while (timer0_clock_cycles > clockCyclesPerMicrosecond() * 1000UL) {
+		timer0_clock_cycles -= clockCyclesPerMicrosecond() * 1000UL;
+		timer0_millis++;
+	}
+}
+
+unsigned long millis()
+{
+	unsigned long m;
+	uint8_t oldSREG = SREG;
+	
+	// disable interrupts while we read timer0_millis or we might get an
+	// inconsistent value (e.g. in the middle of the timer0_millis++)
+	cli();
+	m = timer0_millis;
+	SREG = oldSREG;
+	
+	return m;
+}
+
+unsigned long micros() {
+	unsigned long m, t;
+	uint8_t oldSREG = SREG;
+	
+	cli();	
+	t = TCNT0;
+  
+#ifdef TIFR0
+	if ((TIFR0 & _BV(TOV0)) && (t == 0))
+		t = 256;
+#else
+	if ((TIFR & _BV(TOV0)) && (t == 0))
+		t = 256;
+#endif
+
+	m = timer0_overflow_count;
+	SREG = oldSREG;
+	
+	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
+}
+
+void delay(unsigned long ms)
+{
+	unsigned long start = millis();
+	
+	while (millis() - start <= ms)
+		;
+}
+
+/* Delay for the given number of microseconds.  Assumes a 8 or 16 MHz clock. 
+ * Disables interrupts, which will disrupt the millis() function if used
+ * too frequently. */
+void delayMicroseconds(unsigned int us)
+{
+	uint8_t oldSREG;
+
+	// calling avrlib's delay_us() function with low values (e.g. 1 or
+	// 2 microseconds) gives delays longer than desired.
+	//delay_us(us);
+
+#if F_CPU >= 16000000L
+	// for the 16 MHz clock on most Arduino boards
+
+	// for a one-microsecond delay, simply return.  the overhead
+	// of the function call yields a delay of approximately 1 1/8 us.
+	if (--us == 0)
+		return;
+
+	// the following loop takes a quarter of a microsecond (4 cycles)
+	// per iteration, so execute it four times for each microsecond of
+	// delay requested.
+	us <<= 2;
+
+	// account for the time taken in the preceeding commands.
+	us -= 2;
+#else
+	// for the 8 MHz internal clock on the ATmega168
+
+	// for a one- or two-microsecond delay, simply return.  the overhead of
+	// the function calls takes more than two microseconds.  can't just
+	// subtract two, since us is unsigned; we'd overflow.
+	if (--us == 0)
+		return;
+	if (--us == 0)
+		return;
+
+	// the following loop takes half of a microsecond (4 cycles)
+	// per iteration, so execute it twice for each microsecond of
+	// delay requested.
+	us <<= 1;
+
+	// partially compensate for the time taken by the preceeding commands.
+	// we can't subtract any more than this or we'd overflow w/ small delays.
+	us--;
+#endif
+
+	// disable interrupts, otherwise the timer 0 overflow interrupt that
+	// tracks milliseconds will make us delay longer than we want.
+	oldSREG = SREG;
+	cli();
+
+	// busy wait
+	__asm__ __volatile__ (
+		"1: sbiw %0,1" "\n\t" // 2 cycles
+		"brne 1b" : "=w" (us) : "0" (us) // 2 cycles
+	);
+
+	// reenable interrupts.
+	SREG = oldSREG;
+}
+
+void init()
+{
+	// this needs to be called before setup() or some functions won't
+	// work there
+	sei();
+	
+	// on the ATmega168, timer 0 is also used for fast hardware pwm
+	// (using phase-correct PWM would mean that timer 0 overflowed half as often
+	// resulting in different millis() behavior on the ATmega8 and ATmega168)
+	sbi(TCCR0A, WGM01);
+	sbi(TCCR0A, WGM00);
+
+	// set timer 0 prescale factor to 64
+	sbi(TCCR0B, CS01);
+	sbi(TCCR0B, CS00);
+
+	// enable timer 0 overflow interrupt
+	sbi(TIMSK0, TOIE0);
+
+	// timers 1 and 2 are used for phase-correct hardware pwm
+	// this is better for motors as it ensures an even waveform
+	// note, however, that fast pwm mode can achieve a frequency of up
+	// 8 MHz (with a 16 MHz clock) at 50% duty cycle
+
+	// set timer 1 prescale factor to 64
+	sbi(TCCR1B, CS11);
+	sbi(TCCR1B, CS10);
+
+	// put timer 1 in 8-bit phase correct pwm mode
+	sbi(TCCR1A, WGM10);
+
+	// set timer 2 prescale factor to 64
+	sbi(TCCR2B, CS22);
+
+	// configure timer 2 for phase correct pwm (8-bit)
+	sbi(TCCR2A, WGM20);
+
+	// set a2d prescale factor to 128
+	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.
+	// XXX: this will not work properly for other clock speeds, and
+	// this code should use F_CPU to determine the prescale factor.
+	sbi(ADCSRA, ADPS2);
+	sbi(ADCSRA, ADPS1);
+	sbi(ADCSRA, ADPS0);
+
+	// enable a2d conversions
+	sbi(ADCSRA, ADEN);
+
+	// the bootloader connects pins 0 and 1 to the USART; disconnect them
+	// here so they can be used as normal digital i/o; they will be
+	// reconnected in Serial.begin()
+	UCSR0B = 0;
+	#if defined(__AVR_ATmega644P__)
+	//TODO: test to see if disabling this helps?
+	//UCSR1B = 0;
+	#endif
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring.h b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring.h
new file mode 100644
index 0000000..48ff04a
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring.h
@@ -0,0 +1,135 @@
+/*
+  wiring.h - Partial implementation of the Wiring API for the ATmega8.
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.h 387 2008-03-08 21:30:00Z mellis $
+*/
+
+#ifndef Wiring_h
+#define Wiring_h
+
+#include <avr/io.h>
+#include "binary.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+#define HIGH 0x1
+#define LOW  0x0
+
+#define INPUT 0x0
+#define OUTPUT 0x1
+
+#define true 0x1
+#define false 0x0
+
+#define PI 3.14159265
+#define HALF_PI 1.57079
+#define TWO_PI 6.283185
+#define DEG_TO_RAD 0.01745329
+#define RAD_TO_DEG 57.2957786
+
+#define SERIAL  0x0
+#define DISPLAY 0x1
+
+#define LSBFIRST 0
+#define MSBFIRST 1
+
+#define CHANGE 1
+#define FALLING 2
+#define RISING 3
+
+#define INTERNAL 3
+#define DEFAULT 1
+#define EXTERNAL 0
+
+// undefine stdlib's abs if encountered
+#ifdef abs
+#undef abs
+#endif
+
+#define min(a,b) ((a)<(b)?(a):(b))
+#define max(a,b) ((a)>(b)?(a):(b))
+#define abs(x) ((x)>0?(x):-(x))
+#define constrain(amt,low,high) ((amt)<(low)?(low):((amt)>(high)?(high):(amt)))
+#if __AVR_LIBC_VERSION__ < 10701UL
+#define round(x)     ((x)>=0?(long)((x)+0.5):(long)((x)-0.5))
+#endif
+#define radians(deg) ((deg)*DEG_TO_RAD)
+#define degrees(rad) ((rad)*RAD_TO_DEG)
+#define sq(x) ((x)*(x))
+
+#define interrupts() sei()
+#define noInterrupts() cli()
+
+#define clockCyclesPerMicrosecond() ( F_CPU / 1000000L )
+#define clockCyclesToMicroseconds(a) ( (a) / clockCyclesPerMicrosecond() )
+#define microsecondsToClockCycles(a) ( (a) * clockCyclesPerMicrosecond() )
+
+#define lowByte(w) ((w) & 0xff)
+#define highByte(w) ((w) >> 8)
+
+#define bitRead(value, bit) (((value) >> (bit)) & 0x01)
+#define bitSet(value, bit) ((value) |= (1UL << (bit)))
+#define bitClear(value, bit) ((value) &= ~(1UL << (bit)))
+#define bitWrite(value, bit, bitvalue) (bitvalue ? bitSet(value, bit) : bitClear(value, bit))
+
+typedef unsigned int word;
+
+#define bit(b) (1 << (b))
+
+typedef uint8_t boolean;
+typedef uint8_t byte;
+
+void init(void);
+
+void pinMode(uint8_t, uint8_t);
+void digitalWrite(uint8_t, uint8_t);
+int digitalRead(uint8_t);
+int analogRead(uint8_t);
+void analogReference(uint8_t mode);
+void analogWrite(uint8_t, int);
+
+void beginSerial(uint8_t, long);
+void serialWrite(uint8_t, unsigned char);
+int serialAvailable(uint8_t);
+int serialRead(uint8_t);
+void serialFlush(uint8_t);
+
+unsigned long millis(void);
+unsigned long micros(void);
+void delay(unsigned long);
+void delayMicroseconds(unsigned int us);
+unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout);
+
+void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, byte val);
+
+void attachInterrupt(uint8_t, void (*)(void), int mode);
+void detachInterrupt(uint8_t);
+
+void setup(void);
+void loop(void);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_analog.c b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_analog.c
new file mode 100644
index 0000000..b98bb1a
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_analog.c
@@ -0,0 +1,116 @@
+/*
+  wiring_analog.c - analog input and output
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+uint8_t analog_reference = DEFAULT;
+
+void analogReference(uint8_t mode)
+{
+	// can't actually set the register here because the default setting
+	// will connect AVCC and the AREF pin, which would cause a short if
+	// there's something connected to AREF.
+	analog_reference = mode;
+}
+
+int analogRead(uint8_t pin)
+{
+	uint8_t low, high, ch = analogInPinToBit(pin);
+
+	// set the analog reference (high two bits of ADMUX) and select the
+	// channel (low 4 bits).  this also sets ADLAR (left-adjust result)
+	// to 0 (the default).
+	// the final AND is to clear the pos/neg reference bits
+	ADMUX = ((analog_reference << 6) | (pin & 0x0f)) & B11000111;
+
+	// without a delay, we seem to read from the wrong channel
+	//delay(1);
+
+	// start the conversion
+	sbi(ADCSRA, ADSC);
+
+	// ADSC is cleared when the conversion finishes
+	while (bit_is_set(ADCSRA, ADSC));
+
+	// we have to read ADCL first; doing so locks both ADCL
+	// and ADCH until ADCH is read.  reading ADCL second would
+	// cause the results of each conversion to be discarded,
+	// as ADCL and ADCH would be locked when it completed.
+	low = ADCL;
+	high = ADCH;
+
+	// combine the two bytes
+	return (high << 8) | low;
+}
+
+// Right now, PWM output only works on the pins with
+// hardware support.  These are defined in the appropriate
+// pins_*.c file.  For the rest of the pins, we default
+// to digital output.
+void analogWrite(uint8_t pin, int val)
+{
+	// We need to make sure the PWM output is enabled for those pins
+	// that support it, as we turn it off when digitally reading or
+	// writing with them.  Also, make sure the pin is in output mode
+	// for consistenty with Wiring, which doesn't require a pinMode
+	// call for the analog output pins.
+	pinMode(pin, OUTPUT);
+	
+	if (digitalPinToTimer(pin) == TIMER1A) {
+		// connect pwm to pin on timer 1, channel A
+		sbi(TCCR1A, COM1A1);
+		// set pwm duty
+		OCR1A = val;
+	} else if (digitalPinToTimer(pin) == TIMER1B) {
+		// connect pwm to pin on timer 1, channel B
+		sbi(TCCR1A, COM1B1);
+		// set pwm duty
+		OCR1B = val;
+	} else if (digitalPinToTimer(pin) == TIMER0A) {
+		// connect pwm to pin on timer 0, channel A
+		sbi(TCCR0A, COM0A1);
+		// set pwm duty
+		OCR0A = val;	
+	} else if (digitalPinToTimer(pin) == TIMER0B) {
+		// connect pwm to pin on timer 0, channel B
+		sbi(TCCR0A, COM0B1);
+		// set pwm duty
+		OCR0B = val;
+	} else if (digitalPinToTimer(pin) == TIMER2A) {
+		// connect pwm to pin on timer 2, channel A
+		sbi(TCCR2A, COM2A1);
+		// set pwm duty
+		OCR2A = val;	
+	} else if (digitalPinToTimer(pin) == TIMER2B) {
+		// connect pwm to pin on timer 2, channel B
+		sbi(TCCR2A, COM2B1);
+		// set pwm duty
+		OCR2B = val;
+	} else if (val < 128)
+	//fail semi-intelligently
+		digitalWrite(pin, LOW);
+	else
+		digitalWrite(pin, HIGH);
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_digital.c b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_digital.c
new file mode 100644
index 0000000..3d4b4eb
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_digital.c
@@ -0,0 +1,95 @@
+/*
+  wiring_digital.c - digital input and output functions
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+void pinMode(uint8_t pin, uint8_t mode)
+{
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+	volatile uint8_t *reg;
+
+	if (port == NOT_A_PIN) return;
+
+	// JWS: can I let the optimizer do this?
+	reg = portModeRegister(port);
+
+	if (mode == INPUT) *reg &= ~bit;
+	else *reg |= bit;
+}
+
+// Forcing this inline keeps the callers from having to push their own stuff
+// on the stack. It is a good performance win and only takes 1 more byte per
+// user than calling. (It will take more bytes on the 168.)
+//
+// But shouldn't this be moved into pinMode? Seems silly to check and do on
+// each digitalread or write.
+//
+static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
+static inline void turnOffPWM(uint8_t timer)
+{
+	if (timer == TIMER0A) cbi(TCCR0A, COM0A1);
+	if (timer == TIMER0B) cbi(TCCR0A, COM0B1);
+	if (timer == TIMER1A) cbi(TCCR1A, COM1A1);
+	if (timer == TIMER1B) cbi(TCCR1A, COM1B1);
+	if (timer == TIMER2A) cbi(TCCR2A, COM2A1);
+	if (timer == TIMER2B) cbi(TCCR2A, COM2B1);
+}
+
+void digitalWrite(uint8_t pin, uint8_t val)
+{
+	uint8_t timer = digitalPinToTimer(pin);
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+	volatile uint8_t *out;
+
+	if (port == NOT_A_PIN) return;
+
+	// If the pin that support PWM output, we need to turn it off
+	// before doing a digital write.
+	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
+
+	out = portOutputRegister(port);
+
+	if (val == LOW) *out &= ~bit;
+	else *out |= bit;
+}
+
+int digitalRead(uint8_t pin)
+{
+	uint8_t timer = digitalPinToTimer(pin);
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+
+	if (port == NOT_A_PIN) return LOW;
+
+	// If the pin that support PWM output, we need to turn it off
+	// before getting a digital reading.
+	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
+
+	if (*portInputRegister(port) & bit) return HIGH;
+	
+	return LOW;
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_private.h b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_private.h
new file mode 100644
index 0000000..14394a0
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_private.h
@@ -0,0 +1,60 @@
+/*
+  wiring_private.h - Internal header file.
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.h 239 2007-01-12 17:58:39Z mellis $
+*/
+
+#ifndef WiringPrivate_h
+#define WiringPrivate_h
+
+#include <avr/io.h>
+#include <avr/interrupt.h>
+#include <avr/signal.h>
+#include <avr/delay.h>
+#include <stdio.h>
+#include <stdarg.h>
+
+#include "wiring.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+#ifndef cbi
+#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
+#endif
+#ifndef sbi
+#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
+#endif
+
+#define EXTERNAL_INT_0 0
+#define EXTERNAL_INT_1 1
+#define EXTERNAL_INT_2 2
+
+#define EXTERNAL_NUM_INTERRUPTS 3
+
+typedef void (*voidFuncPtr)(void);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_pulse.c b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_pulse.c
new file mode 100644
index 0000000..8f232f1
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_pulse.c
@@ -0,0 +1,66 @@
+/*
+  wiring_pulse.c - pulseIn() function
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+/* Measures the length (in microseconds) of a pulse on the pin; state is HIGH
+ * or LOW, the type of pulse to measure.  Works on pulses from 2-3 microseconds
+ * to 3 minutes in length, but must be called at least a few dozen microseconds
+ * before the start of the pulse. */
+unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout)
+{
+	// cache the port and bit of the pin in order to speed up the
+	// pulse width measuring loop and achieve finer resolution.  calling
+	// digitalRead() instead yields much coarser resolution.
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+	uint8_t stateMask = (state ? bit : 0);
+	unsigned long width = 0; // keep initialization out of time critical area
+	
+	// convert the timeout from microseconds to a number of times through
+	// the initial loop; it takes 16 clock cycles per iteration.
+	unsigned long numloops = 0;
+	unsigned long maxloops = microsecondsToClockCycles(timeout) / 16;
+	
+	// wait for any previous pulse to end
+	while ((*portInputRegister(port) & bit) == stateMask)
+		if (numloops++ == maxloops)
+			return 0;
+	
+	// wait for the pulse to start
+	while ((*portInputRegister(port) & bit) != stateMask)
+		if (numloops++ == maxloops)
+			return 0;
+	
+	// wait for the pulse to stop
+	while ((*portInputRegister(port) & bit) == stateMask)
+		width++;
+
+	// convert the reading to microseconds. The loop has been determined
+	// to be 10 clock cycles long and have about 16 clocks between the edge
+	// and the start of the loop. There will be some error introduced by
+	// the interrupt handlers.
+	return clockCyclesToMicroseconds(width * 10 + 16); 
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_serial.c b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_serial.c
new file mode 100644
index 0000000..a3314fa
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_serial.c
@@ -0,0 +1,138 @@
+/*
+  wiring_serial.c - serial functions.
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+  Modified 29 January 2009, Marius Kintel for Sanguino - http://www.sanguino.cc/
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+
+#include "wiring_private.h"
+
+// Define constants and variables for buffering incoming serial data.  We're
+// using a ring buffer (I think), in which rx_buffer_head is the index of the
+// location to which to write the next incoming character and rx_buffer_tail
+// is the index of the location from which to read.
+#define RX_BUFFER_SIZE 128
+
+#if defined(__AVR_ATmega644P__)
+unsigned char rx_buffer[2][RX_BUFFER_SIZE];
+int rx_buffer_head[2] = {0, 0};
+int rx_buffer_tail[2] = {0, 0};
+#else
+unsigned char rx_buffer[1][RX_BUFFER_SIZE];
+int rx_buffer_head[1] = {0};
+int rx_buffer_tail[1] = {0};
+#endif
+
+
+#define BEGIN_SERIAL(uart_, baud_) \
+{ \
+    UBRR##uart_##H = ((F_CPU / 16 + baud / 2) / baud - 1) >> 8; \
+    UBRR##uart_##L = ((F_CPU / 16 + baud / 2) / baud - 1); \
+    \
+    /* reset config for UART */ \
+    UCSR##uart_##A = 0; \
+    UCSR##uart_##B = 0; \
+    UCSR##uart_##C = 0; \
+    \
+    /* enable rx and tx */ \
+    sbi(UCSR##uart_##B, RXEN##uart_);\
+    sbi(UCSR##uart_##B, TXEN##uart_);\
+    \
+    /* enable interrupt on complete reception of a byte */ \
+    sbi(UCSR##uart_##B, RXCIE##uart_); \
+    UCSR##uart_##C = _BV(UCSZ##uart_##1)|_BV(UCSZ##uart_##0); \
+    /* defaults to 8-bit, no parity, 1 stop bit */ \
+}
+
+void beginSerial(uint8_t uart, long baud)
+{
+  if (uart == 0) BEGIN_SERIAL(0, baud)
+#if defined(__AVR_ATmega644P__)
+  else BEGIN_SERIAL(1, baud)
+#endif
+}
+
+#define SERIAL_WRITE(uart_, c_) \
+    while (!(UCSR##uart_##A & (1 << UDRE##uart_))) \
+      ; \
+    UDR##uart_ = c
+
+void serialWrite(uint8_t uart, unsigned char c)
+{
+  if (uart == 0) {
+    SERIAL_WRITE(0, c);
+  }
+#if defined(__AVR_ATmega644P__)
+  else {
+    SERIAL_WRITE(1, c);
+  }
+#endif
+}
+
+int serialAvailable(uint8_t uart)
+{
+  return (RX_BUFFER_SIZE + rx_buffer_head[uart] - rx_buffer_tail[uart]) % RX_BUFFER_SIZE;
+}
+
+int serialRead(uint8_t uart)
+{
+  // if the head isn't ahead of the tail, we don't have any characters
+  if (rx_buffer_head[uart] == rx_buffer_tail[uart]) {
+    return -1;
+  } else {
+    unsigned char c = rx_buffer[uart][rx_buffer_tail[uart]];
+    rx_buffer_tail[uart] = (rx_buffer_tail[uart] + 1) % RX_BUFFER_SIZE;
+    return c;
+  }
+}
+
+void serialFlush(uint8_t uart)
+{
+  // don't reverse this or there may be problems if the RX interrupt
+  // occurs after reading the value of rx_buffer_head but before writing
+  // the value to rx_buffer_tail; the previous value of rx_buffer_head
+  // may be written to rx_buffer_tail, making it appear as if the buffer
+  // were full, not empty.
+  rx_buffer_head[uart] = rx_buffer_tail[uart];
+}
+
+#define UART_ISR(uart_) \
+ISR(USART##uart_##_RX_vect) \
+{ \
+  unsigned char c = UDR##uart_; \
+  \
+  int i = (rx_buffer_head[uart_] + 1) % RX_BUFFER_SIZE; \
+  \  
+  /* if we should be storing the received character into the location \
+     just before the tail (meaning that the head would advance to the \
+     current location of the tail), we're about to overflow the buffer \
+     and so we don't write the character or advance the head. */ \
+  if (i != rx_buffer_tail[uart_]) { \
+    rx_buffer[uart_][rx_buffer_head[uart_]] = c; \
+    rx_buffer_head[uart_] = i; \
+  } \
+}
+
+UART_ISR(0)
+#if defined(__AVR_ATmega644P__) 
+UART_ISR(1)
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_shift.c b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_shift.c
new file mode 100644
index 0000000..956f864
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_shift.c
@@ -0,0 +1,40 @@
+/*
+  wiring_shift.c - shiftOut() function
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+
+void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, byte val)
+{
+	int i;
+
+	for (i = 0; i < 8; i++)  {
+		if (bitOrder == LSBFIRST)
+			digitalWrite(dataPin, !!(val & (1 << i)));
+		else	
+			digitalWrite(dataPin, !!(val & (1 << (7 - i))));
+			
+		digitalWrite(clockPin, HIGH);
+		digitalWrite(clockPin, LOW);		
+	}
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/boards.txt b/ArduinoAddons/Arduino_0.xx/Sanguino/boards.txt
new file mode 100644
index 0000000..4f71b8a
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/boards.txt
@@ -0,0 +1,16 @@
+##############################################################
+
+sanguino.name=Sanguino
+sanguino.upload.protocol=stk500
+sanguino.upload.maximum_size=63488
+sanguino.upload.speed=38400
+sanguino.bootloader.low_fuses=0xFF
+sanguino.bootloader.high_fuses=0xDC
+sanguino.bootloader.extended_fuses=0xFD
+sanguino.bootloader.path=atmega644p
+sanguino.bootloader.file=ATmegaBOOT_644P.hex
+sanguino.bootloader.unlock_bits=0x3F
+sanguino.bootloader.lock_bits=0x0F
+sanguino.build.mcu=atmega644p
+sanguino.build.f_cpu=16000000L
+sanguino.build.core=arduino
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/ATmegaBOOT.c b/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/ATmegaBOOT.c
new file mode 100644
index 0000000..1711014
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/ATmegaBOOT.c
@@ -0,0 +1,713 @@
+/**********************************************************/
+/* Serial Bootloader for Atmel megaAVR Controllers        */
+/*                                                        */
+/* tested with ATmega644 and ATmega644P                   */
+/* should work with other mega's, see code for details    */
+/*                                                        */
+/* ATmegaBOOT.c                                           */
+/*                                                        */
+/* 20090131: Added 324P support from Alex Leone           */
+/*           Marius Kintel                                */
+/* 20080915: applied ADABoot mods for Sanguino 644P       */
+/*           Brian Riley                                  */
+/* 20080711: hacked for Sanguino by Zach Smith            */
+/*           and Justin Day                               */
+/* 20070626: hacked for Arduino Diecimila (which auto-    */
+/*           resets when a USB connection is made to it)  */
+/*           by D. Mellis                                 */
+/* 20060802: hacked for Arduino by D. Cuartielles         */
+/*           based on a previous hack by D. Mellis        */
+/*           and D. Cuartielles                           */
+/*                                                        */
+/* Monitor and debug functions were added to the original */
+/* code by Dr. Erik Lins, chip45.com. (See below)         */
+/*                                                        */
+/* Thanks to Karl Pitrich for fixing a bootloader pin     */
+/* problem and more informative LED blinking!             */
+/*                                                        */
+/* For the latest version see:                            */
+/* http://www.chip45.com/                                 */
+/*                                                        */
+/* ------------------------------------------------------ */
+/*                                                        */
+/* based on stk500boot.c                                  */
+/* Copyright (c) 2003, Jason P. Kyle                      */
+/* All rights reserved.                                   */
+/* see avr1.org for original file and information         */
+/*                                                        */
+/* This program is free software; you can redistribute it */
+/* and/or modify it under the terms of the GNU General    */
+/* Public License as published by the Free Software       */
+/* Foundation; either version 2 of the License, or        */
+/* (at your option) any later version.                    */
+/*                                                        */
+/* This program is distributed in the hope that it will   */
+/* be useful, but WITHOUT ANY WARRANTY; without even the  */
+/* implied warranty of MERCHANTABILITY or FITNESS FOR A   */
+/* PARTICULAR PURPOSE.  See the GNU General Public        */
+/* License for more details.                              */
+/*                                                        */
+/* You should have received a copy of the GNU General     */
+/* Public License along with this program; if not, write  */
+/* to the Free Software Foundation, Inc.,                 */
+/* 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA */
+/*                                                        */
+/* Licence can be viewed at                               */
+/* http://www.fsf.org/licenses/gpl.txt                    */
+/*                                                        */
+/* Target = Atmel AVR m128,m64,m32,m16,m8,m162,m163,m169, */
+/* m8515,m8535. ATmega161 has a very small boot block so  */
+/* isn't supported.                                       */
+/*                                                        */
+/* Tested with m168                                       */
+/**********************************************************/
+
+/* $Id$ */
+
+
+/* some includes */
+#include <inttypes.h>
+#include <avr/io.h>
+#include <avr/pgmspace.h>
+#include <avr/interrupt.h>
+#include <avr/wdt.h>
+#include <avr/boot.h>
+
+#ifdef ADABOOT
+    #define NUM_LED_FLASHES 3
+    #define ADABOOT_VER	1
+#endif
+
+
+/* 20070707: hacked by David A. Mellis - after this many errors give up and launch application */
+#define MAX_ERROR_COUNT 5
+
+/* set the UART baud rate */
+/* 20080711: hack by Zach Hoeken */
+#define BAUD_RATE   38400
+
+/* SW_MAJOR and MINOR needs to be updated from time to time to avoid warning message from AVR Studio */
+/* never allow AVR Studio to do an update !!!! */
+#define HW_VER	 0x02
+#define SW_MAJOR 0x01
+#define SW_MINOR 0x10
+
+/* onboard LED is used to indicate, that the bootloader was entered (3x flashing) */
+/* if monitor functions are included, LED goes on after monitor was entered */
+#define LED_DDR  DDRB
+#define LED_PORT PORTB
+#define LED_PIN  PINB
+#define LED      PINB0
+
+/* define various device id's */
+/* manufacturer byte is always the same */
+#define SIG1	0x1E	// Yep, Atmel is the only manufacturer of AVR micros.  Single source :(
+#if defined(__AVR_ATmega644P__)
+#define SIG2	0x96
+#define SIG3	0x0A
+#elif defined(__AVR_ATmega644__)
+#define SIG2	0x96
+#define SIG3	0x09
+#elif defined(__AVR_ATmega324P__)
+#define SIG2	0x95
+#define SIG3	0x08
+#endif
+#define PAGE_SIZE		0x080U   //128 words
+#define PAGE_SIZE_BYTES	0x100U   //256 bytes
+
+/* function prototypes */
+void putch(char);
+char getch(void);
+void getNch(uint8_t);
+void byte_response(uint8_t);
+void nothing_response(void);
+char gethex(void);
+void puthex(char);
+void flash_led(uint8_t);
+
+/* some variables */
+union address_union
+{
+    uint16_t word;
+    uint8_t  byte[2];
+} address;
+
+union length_union
+{
+    uint16_t word;
+    uint8_t  byte[2];
+} length;
+
+struct flags_struct
+{
+    unsigned eeprom : 1;
+    unsigned rampz  : 1;
+} flags;
+
+uint8_t buff[256];
+
+uint8_t error_count = 0;
+uint8_t sreg;
+
+void (*app_start)(void) = 0x0000;
+
+/* main program starts here */
+int main(void)
+{
+    uint8_t ch,ch2;
+    uint16_t w;
+	uint16_t i;
+	
+    asm volatile("nop\n\t");
+
+#ifdef ADABOOT		// BBR/LF 10/8/2007 & 9/13/2008
+    ch = MCUSR;
+    MCUSR = 0;
+
+    WDTCSR |= _BV(WDCE) | _BV(WDE);
+    WDTCSR = 0;
+
+    // Check if the WDT was used to reset, in which case we dont bootload and skip straight to the code. woot.
+    if (! (ch &  _BV(EXTRF))) // if its a not an external reset...
+      app_start();  // skip bootloader
+#endif
+
+
+	//initialize our serial port.
+    UBRR0L = (uint8_t)(F_CPU/(BAUD_RATE*16L)-1);
+    UBRR0H = (F_CPU/(BAUD_RATE*16L)-1) >> 8;
+    UCSR0B = (1<<RXEN0) | (1<<TXEN0);
+    UCSR0C = (1<<UCSZ00) | (1<<UCSZ01);
+
+    /* Enable internal pull-up resistor on pin D0 (RX), in order
+    to supress line noise that prevents the bootloader from
+    timing out (DAM: 20070509) */
+    DDRD &= ~_BV(PIND0);
+    PORTD |= _BV(PIND0);
+
+    /* set LED pin as output */
+    LED_DDR |= _BV(LED);
+
+	    /* flash onboard LED to signal entering of bootloader                   */
+	    /* ADABOOT will do two series of flashes. first 4 - signifying ADABOOT  */
+	    /* then a pause and another flash series signifying ADABOOT sub-version */
+
+
+	flash_led(NUM_LED_FLASHES);
+
+	#ifdef	ADABOOT
+		flash_led(ADABOOT_VER);		// BBR 9/13/2008
+	#endif 
+
+    /* forever loop */
+    for (;;)
+	{
+		/* get character from UART */
+		ch = getch();
+
+		/* A bunch of if...else if... gives smaller code than switch...case ! */
+
+		/* Hello is anyone home ? */ 
+		if(ch=='0')
+		    nothing_response();
+
+
+		/* Request programmer ID */
+		/* Not using PROGMEM string due to boot block in m128 being beyond 64kB boundry  */
+		/* Would need to selectively manipulate RAMPZ, and it's only 9 characters anyway so who cares.  */
+		else if(ch=='1')
+		{
+		    if (getch() == ' ')
+			{
+				putch(0x14);
+				putch('A');
+				putch('V');
+				putch('R');
+				putch(' ');
+				putch('I');
+				putch('S');
+				putch('P');
+				putch(0x10);
+		    }
+			else
+			{
+				if (++error_count == MAX_ERROR_COUNT)
+				    app_start();
+		    }
+		}
+
+
+		/* AVR ISP/STK500 board commands  DON'T CARE so default nothing_response */
+		else if(ch=='@')
+		{
+		    ch2 = getch();
+		    if (ch2 > 0x85)
+				getch();
+		    nothing_response();
+		}
+
+
+		/* AVR ISP/STK500 board requests */
+		else if(ch=='A')
+		{
+		    ch2 = getch();
+		    if(ch2 == 0x80)
+				byte_response(HW_VER);		// Hardware version
+		    else if(ch2==0x81)
+				byte_response(SW_MAJOR);	// Software major version
+		    else if(ch2==0x82)
+				byte_response(SW_MINOR);	// Software minor version
+		    else if(ch2==0x98)
+				byte_response(0x03);		// Unknown but seems to be required by avr studio 3.56
+		    else
+				byte_response(0x00);		// Covers various unnecessary responses we don't care about
+		}
+
+
+		/* Device Parameters  DON'T CARE, DEVICE IS FIXED  */
+		else if(ch=='B')
+		{
+		    getNch(20);
+		    nothing_response();
+		}
+
+
+		/* Parallel programming stuff  DON'T CARE  */
+		else if(ch=='E')
+		{
+		    getNch(5);
+		    nothing_response();
+		}
+
+
+		/* Enter programming mode  */
+		else if(ch=='P')
+		{
+		    nothing_response();
+		}
+
+
+		/* Leave programming mode  */
+		else if(ch=='Q')
+		{
+		    nothing_response();
+#ifdef ADABOOT		
+			// autoreset via watchdog (sneaky!) BBR/LF 9/13/2008
+	  		WDTCSR = _BV(WDE);
+	  		while (1); // 16 ms
+#endif		
+		}
+
+
+		/* Erase device, don't care as we will erase one page at a time anyway.  */
+		else if(ch=='R')
+		{
+		    nothing_response();
+		}
+
+
+		/* Set address, little endian. EEPROM in bytes, FLASH in words  */
+		/* Perhaps extra address bytes may be added in future to support > 128kB FLASH.  */
+		/* This might explain why little endian was used here, big endian used everywhere else.  */
+		else if(ch=='U')
+		{
+		    address.byte[0] = getch();
+		    address.byte[1] = getch();
+		    nothing_response();
+		}
+
+
+		/* Universal SPI programming command, disabled.  Would be used for fuses and lock bits.  */
+		else if(ch=='V')
+		{
+		    getNch(4);
+		    byte_response(0x00);
+		}
+
+
+		/* Write memory, length is big endian and is in bytes  */
+		else if(ch=='d')
+		{
+		    length.byte[1] = getch();
+		    length.byte[0] = getch();
+	
+		    flags.eeprom = 0;
+		    if (getch() == 'E')
+				flags.eeprom = 1;
+
+			for (i=0; i<PAGE_SIZE; i++)
+				buff[i] = 0;
+		
+		    for (w = 0; w < length.word; w++)
+			{
+				// Store data in buffer, can't keep up with serial data stream whilst programming pages
+				buff[w] = getch();
+		    }
+	
+		    if (getch() == ' ')
+			{
+				if (flags.eeprom)
+				{		                
+					//Write to EEPROM one byte at a time
+				    for(w=0;w<length.word;w++)
+					{
+						while(EECR & (1<<EEPE));
+					
+						EEAR = (uint16_t)(void *)address.word;
+						EEDR = buff[w];
+						EECR |= (1<<EEMPE);
+						EECR |= (1<<EEPE);
+
+						address.word++;
+				    }			
+				}
+				else
+				{
+					//address * 2 -> byte location
+				    address.word = address.word << 1;
+			    
+					//Even up an odd number of bytes
+					if ((length.byte[0] & 0x01))
+						length.word++;
+				
+					// HACKME: EEPE used to be EEWE
+				    //Wait for previous EEPROM writes to complete
+					//while(bit_is_set(EECR,EEPE));
+					while(EECR & (1<<EEPE));
+				
+				    asm volatile(
+						 "clr	r17		\n\t"	//page_word_count
+						 "lds	r30,address	\n\t"	//Address of FLASH location (in bytes)
+						 "lds	r31,address+1	\n\t"
+						 "ldi	r28,lo8(buff)	\n\t"	//Start of buffer array in RAM
+						 "ldi	r29,hi8(buff)	\n\t"
+						 "lds	r24,length	\n\t"	//Length of data to be written (in bytes)
+						 "lds	r25,length+1	\n\t"
+						 "length_loop:		\n\t"	//Main loop, repeat for number of words in block							 							 
+						 "cpi	r17,0x00	\n\t"	//If page_word_count=0 then erase page
+						 "brne	no_page_erase	\n\t"						 
+						 "wait_spm1:		\n\t"
+						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+						 "andi	r16,1           \n\t"
+						 "cpi	r16,1           \n\t"
+						 "breq	wait_spm1       \n\t"
+						 "ldi	r16,0x03	\n\t"	//Erase page pointed to by Z
+						 "sts	%0,r16		\n\t"
+						 "spm			\n\t"							 
+						 "wait_spm2:		\n\t"
+						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+						 "andi	r16,1           \n\t"
+						 "cpi	r16,1           \n\t"
+						 "breq	wait_spm2       \n\t"									 
+
+						 "ldi	r16,0x11	\n\t"	//Re-enable RWW section
+						 "sts	%0,r16		\n\t"						 			 
+						 "spm			\n\t"
+						 "no_page_erase:		\n\t"							 
+						 "ld	r0,Y+		\n\t"	//Write 2 bytes into page buffer
+						 "ld	r1,Y+		\n\t"							 
+							 
+						 "wait_spm3:		\n\t"
+						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+						 "andi	r16,1           \n\t"
+						 "cpi	r16,1           \n\t"
+						 "breq	wait_spm3       \n\t"
+						 "ldi	r16,0x01	\n\t"	//Load r0,r1 into FLASH page buffer
+						 "sts	%0,r16		\n\t"
+						 "spm			\n\t"
+							 
+						 "inc	r17		\n\t"	//page_word_count++
+						 "cpi r17,%1	        \n\t"
+						 "brlo	same_page	\n\t"	//Still same page in FLASH
+						 "write_page:		\n\t"
+						 "clr	r17		\n\t"	//New page, write current one first
+						 "wait_spm4:		\n\t"
+						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+						 "andi	r16,1           \n\t"
+						 "cpi	r16,1           \n\t"
+						 "breq	wait_spm4       \n\t"						 							 
+						 "ldi	r16,0x05	\n\t"	//Write page pointed to by Z
+						 "sts	%0,r16		\n\t"
+						 "spm			\n\t"
+						 "wait_spm5:		\n\t"
+						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+						 "andi	r16,1           \n\t"
+						 "cpi	r16,1           \n\t"
+						 "breq	wait_spm5       \n\t"									 
+						 "ldi	r16,0x11	\n\t"	//Re-enable RWW section
+						 "sts	%0,r16		\n\t"						 			 
+						 "spm			\n\t"					 		 
+						 "same_page:		\n\t"							 
+						 "adiw	r30,2		\n\t"	//Next word in FLASH
+						 "sbiw	r24,2		\n\t"	//length-2
+						 "breq	final_write	\n\t"	//Finished
+						 "rjmp	length_loop	\n\t"
+						 "final_write:		\n\t"
+						 "cpi	r17,0		\n\t"
+						 "breq	block_done	\n\t"
+						 "adiw	r24,2		\n\t"	//length+2, fool above check on length after short page write
+						 "rjmp	write_page	\n\t"
+						 "block_done:		\n\t"
+						 "clr	__zero_reg__	\n\t"	//restore zero register
+						 : "=m" (SPMCSR) : "M" (PAGE_SIZE) : "r0","r16","r17","r24","r25","r28","r29","r30","r31"
+
+						 );
+				}
+				putch(0x14);
+				putch(0x10);
+		    }
+			else
+			{
+				if (++error_count == MAX_ERROR_COUNT)
+				    app_start();
+		    }		
+		}
+    
+		/* Read memory block mode, length is big endian.  */
+		else if(ch=='t')
+		{
+			length.byte[1] = getch();
+			length.byte[0] = getch();
+
+			if (getch() == 'E')
+				flags.eeprom = 1;
+			else
+			{
+				flags.eeprom = 0;
+				address.word = address.word << 1;	        // address * 2 -> byte location
+			}
+
+			// Command terminator
+			if (getch() == ' ')
+			{
+				putch(0x14);
+				for (w=0; w<length.word; w++)
+				{
+					// Can handle odd and even lengths okay
+				    if (flags.eeprom) 
+					{
+						// Byte access EEPROM read
+						while(EECR & (1<<EEPE));
+						EEAR = (uint16_t)(void *)address.word;
+						EECR |= (1<<EERE);
+						putch(EEDR);
+
+						address.word++;
+				    }
+				    else
+					{
+						if (!flags.rampz)
+							putch(pgm_read_byte_near(address.word));
+
+						address.word++;
+				    }
+				}
+				putch(0x10);
+		    }
+		}
+
+
+		/* Get device signature bytes  */
+		else if(ch=='u')
+		{
+			if (getch() == ' ')
+			{
+				putch(0x14);
+				putch(SIG1);
+				putch(SIG2);
+				putch(SIG3);
+				putch(0x10);
+			}
+			else
+			{
+				if (++error_count == MAX_ERROR_COUNT)
+					app_start();
+			}
+		}
+
+
+		/* Read oscillator calibration byte */
+		else if(ch=='v')
+			byte_response(0x00);
+
+		else if (++error_count == MAX_ERROR_COUNT)
+		    app_start();
+
+	}
+    /* end of forever loop */
+}
+
+
+char gethex(void)
+{
+    char ah,al;
+
+    ah = getch();
+	putch(ah);
+    al = getch();
+	putch(al);
+    
+	if(ah >= 'a')
+		ah = ah - 'a' + 0x0a;
+	else if(ah >= '0')
+		ah -= '0';
+    if(al >= 'a')
+		al = al - 'a' + 0x0a;
+	else if(al >= '0')
+		al -= '0';
+
+    return (ah << 4) + al;
+}
+
+
+void puthex(char ch)
+{
+    char ah,al;
+
+    ah = (ch & 0xf0) >> 4;
+	if(ah >= 0x0a)
+		ah = ah - 0x0a + 'a';
+	else
+		ah += '0';
+
+    al = (ch & 0x0f);
+	if(al >= 0x0a)
+		al = al - 0x0a + 'a';
+	else
+		al += '0';
+
+    putch(ah);
+    putch(al);
+}
+
+
+void putch(char ch)
+{
+    while (!(UCSR0A & _BV(UDRE0)));
+    UDR0 = ch;
+}
+
+
+
+
+char getch(void)
+{
+    uint32_t count = 0;
+
+#ifdef ADABOOT
+	LED_PORT &= ~_BV(LED);          // toggle LED to show activity - BBR/LF 10/3/2007 & 9/13/2008
+#endif
+
+    while(!(UCSR0A & _BV(RXC0)))
+	{
+    	/* 20060803 DojoCorp:: Addon coming from the previous Bootloader*/               
+    	/* HACKME:: here is a good place to count times*/
+    	count++;
+    	if (count > MAX_TIME_COUNT)
+    		app_start();
+     }
+
+#ifdef ADABOOT
+	LED_PORT |= _BV(LED);          // toggle LED to show activity - BBR/LF 10/3/2007 & 9/13/2008
+#endif
+
+    return UDR0;
+}
+
+
+void getNch(uint8_t count)
+{
+    uint8_t i;
+    for(i=0;i<count;i++)
+	{
+		while(!(UCSR0A & _BV(RXC0)));
+		UDR0;
+    }
+}
+
+
+void byte_response(uint8_t val)
+{
+    if (getch() == ' ')
+	{
+		putch(0x14);
+		putch(val);
+		putch(0x10);
+    }
+	else
+	{
+		if (++error_count == MAX_ERROR_COUNT)
+		    app_start();
+    }
+}
+
+
+void nothing_response(void)
+{
+    if (getch() == ' ')
+	{
+		putch(0x14);
+		putch(0x10);
+    }
+	else
+	{
+		if (++error_count == MAX_ERROR_COUNT)
+		    app_start();
+    }
+}
+
+#ifdef ADABOOT
+
+void flash_led(uint8_t count)
+{
+    /* flash onboard LED count times to signal entering of bootloader */
+	/* l needs to be volatile or the delay loops below might get      */
+	/* optimized away if compiling with optimizations (DAM).          */
+	
+    volatile uint32_t l;
+
+    if (count == 0) {
+      count = ADABOOT;
+    }
+    
+
+	int8_t i;
+    for (i = 0; i < count; ++i) {
+		LED_PORT |= _BV(LED);					// LED on
+		for(l = 0; l < (F_CPU / 1000); ++l);		// delay NGvalue was 1000 for both loops - BBR
+		LED_PORT &= ~_BV(LED);					// LED off
+		for(l = 0; l < (F_CPU / 250); ++l);		// delay asymmteric for ADA BOOT BBR 
+	}
+
+	for(l = 0; l < (F_CPU / 100); ++l);		    // pause ADA BOOT BBR 
+		
+}
+
+#else
+
+void flash_led(uint8_t count)
+{
+    /* flash onboard LED three times to signal entering of bootloader */
+	/* l needs to be volatile or the delay loops below might get
+	optimized away if compiling with optimizations (DAM). */
+    volatile uint32_t l;
+
+    if (count == 0) {
+      count = 3;
+    }
+    
+	int8_t i;
+    for (i = 0; i < count; ++i) {
+		LED_PORT |= _BV(LED);
+		for(l = 0; l < (F_CPU / 1000); ++l);
+		LED_PORT &= ~_BV(LED);
+		for(l = 0; l < (F_CPU / 1000); ++l); 
+	}
+		
+}
+
+
+#endif
+
+
+/* end of file ATmegaBOOT.c */
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/ATmegaBOOT_324P.hex b/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/ATmegaBOOT_324P.hex
new file mode 100644
index 0000000..e67fe88
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/ATmegaBOOT_324P.hex
@@ -0,0 +1,121 @@
+:10F800000C943E7C0C945B7C0C945B7C0C945B7C39
+:10F810000C945B7C0C945B7C0C945B7C0C945B7C0C
+:10F820000C945B7C0C945B7C0C945B7C0C945B7CFC
+:10F830000C945B7C0C945B7C0C945B7C0C945B7CEC
+:10F840000C945B7C0C945B7C0C945B7C0C945B7CDC
+:10F850000C945B7C0C945B7C0C945B7C0C945B7CCC
+:10F860000C945B7C0C945B7C0C945B7C0C945B7CBC
+:10F870000C945B7C0C945B7C0C945B7C11241FBE11
+:10F88000CFEFD8E0DEBFCDBF11E0A0E0B1E0E6E60B
+:10F89000FFEF02C005900D92A030B107D9F712E03A
+:10F8A000A0E0B1E001C01D92A930B107E1F70E94CC
+:10F8B000537D0C94B27F0C94007CCF93DF93CDB733
+:10F8C000DEB724970FB6F894DEBF0FBECDBF8823F6
+:10F8D00009F481E020E0482F55274115510509F42E
+:10F8E0003DC0289A19821A821B821C820BC0898112
+:10F8F0009A81AB81BC810196A11DB11D89839A8338
+:10F90000AB83BC8389819A81AB81BC8180589E4343
+:10F91000A040B04060F3289819821A821B821C8292
+:10F920000BC089819A81AB81BC810196A11DB11D5B
+:10F9300089839A83AB83BC8389819A81AB81BC81A3
+:10F9400080509A4FA040B04060F32F5F822F9927DC
+:10F9500087FD9095841795070CF4C3CF19821A82FE
+:10F960001B821C8289819A81AB81BC818050914726
+:10F97000A240B040A0F489819A81AB81BC810196FC
+:10F98000A11DB11D89839A83AB83BC8389819A8130
+:10F99000AB81BC8180509147A240B04060F3249677
+:10F9A0000FB6F894DEBF0FBECDBFDF91CF910895A3
+:10F9B000EF92FF920F931F93EE24FF248701289864
+:10F9C0008091C00087FD17C00894E11CF11C011D47
+:10F9D000111D81E0E81689E0F8068DE3080780E054
+:10F9E000180770F3E0910001F091010109958091F1
+:10F9F000C00087FFE9CF289A8091C600992787FD2C
+:10FA000090951F910F91FF90EF900895982F8091FE
+:10FA1000C00085FFFCCF9093C60008950E94D87C5B
+:10FA2000803271F0809102018F5F809302018530F6
+:10FA300009F00895E0910001F09101010995089500
+:10FA400084E10E94067D80E10E94067D0895CF93A7
+:10FA5000C82F0E94D87C803241F0809102018F5FD4
+:10FA600080930201853081F40AC084E10E94067D02
+:10FA70008C2F0E94067D80E10E94067D05C0E091EA
+:10FA80000001F09101010995CF910895282F90E090
+:10FA900007C08091C0008823E4F78091C6009F5F73
+:10FAA0009217B8F30895CFEFD8E0DEBFCDBF0000C6
+:10FAB00094B714BE809160008861809360001092BA
+:10FAC000600091FF74C189E18093C4001092C50069
+:10FAD00088E18093C10086E08093C2005098589AD4
+:10FAE000209A83E00E945D7C81E00E945D7C0E9400
+:10FAF000D87C8033B9F18133C1F1803409F456C028
+:10FB0000813409F45CC0823409F46EC0853409F490
+:10FB100071C0803539F1813509F4F3C0823511F1B6
+:10FB2000853509F4D3C0863509F4CBC0843609F491
+:10FB300065C0843709F4EBC0853709F4D2C0863735
+:10FB400009F44AC0809102018F5F809302018530E1
+:10FB500071F6E0910001F091010109950E94D87CB5
+:10FB6000803349F60E940E7DC2CF0E94D87CC82FF8
+:10FB7000803241F784E10E94067D81E40E94067D87
+:10FB800086E50E94067D82E50E94067D8C2F0E94FC
+:10FB9000067D89E40E94067D83E50E94067D80E55E
+:10FBA0000E94067D80E10E94067DA1CF0E94D87C44
+:10FBB0008638C0F20E94D87C0E940E7D98CF0E94A9
+:10FBC000D87C803809F407C1813809F400C1823833
+:10FBD00009F4F9C0883921F080E00E94277D87CFA1
+:10FBE00083E00E94277D83CF84E10E94467D0E94AE
+:10FBF0000E7D7DCF85E00E94467DF9CF0E94D87CA6
+:10FC0000809306020E94D87C8093050280910802AE
+:10FC10008E7F809308020E94D87C853409F44BC003
+:10FC2000E5E0F1E0119281E0E438F807D9F3D0F390
+:10FC3000C0E0D0E0809105029091060218161906E6
+:10FC400078F405E011E00E94D87CF80181938F01DF
+:10FC500021968091050290910602C817D90798F362
+:10FC60000E94D87C803209F06DCF8091080280FF1D
+:10FC7000B6C0C0E0D0E02091050230910602121615
+:10FC80001306B8F4E0910301F0910401A5E0B1E09E
+:10FC9000F999FECFF2BDE1BD8D9180BDFA9AF99A36
+:10FCA00031962196C217D30798F3F0930401E0939D
+:10FCB000030184E175CF809108028160809308027E
+:10FCC000AFCF84E00E94467D80E087CF0E94D87C41
+:10FCD000809303010E94D87C809304010E940E7DD2
+:10FCE00006CF0E94D87C803209F02CCF84E10E949C
+:10FCF000067D8EE10E94067D85E90E94067D88E0F2
+:10FD00004FCF0E940E7D88E080936000FFCF0E945D
+:10FD1000D87C809306020E94D87C809305020E94C2
+:10FD2000D87C853409F449C0809108028E7F809385
+:10FD300008028091030190910401880F991F90930C
+:10FD40000401809303010E94D87C803209F0CFCE59
+:10FD500084E10E94067DC0E0D0E020910502309150
+:10FD600006021216130608F01DCFE0910301F09170
+:10FD700004018091080280FF96C0F999FECFF2BD80
+:10FD8000E1BDF89A80B50E94067DE0910301F091F3
+:10FD900004013196F0930401E093030120910502E0
+:10FDA000309106022196C217D30718F3FBCEE091DB
+:10FDB0000001F0910101099586CE809108028160D1
+:10FDC00080930802C0CF80E10E94277D90CE81E021
+:10FDD0000E94277D8CCE82E00E94277D88CE809174
+:10FDE000030190910401880F991F9093040180935F
+:10FDF00003018091050280FF09C080910502909166
+:10FE0000060201969093060280930502F999FECFAF
+:10FE10001127E0910301F0910401C5E0D1E0809148
+:10FE2000050290910602103091F400915700017084
+:10FE30000130D9F303E000935700E8950091570093
+:10FE400001700130D9F301E100935700E895099062
+:10FE500019900091570001700130D9F301E000932F
+:10FE60005700E8951395103898F011270091570026
+:10FE700001700130D9F305E000935700E895009137
+:10FE8000570001700130D9F301E100935700E89564
+:10FE90003296029709F0C7CF103011F00296E5CFE5
+:10FEA000112484E17DCE869580FF06C03196F093C3
+:10FEB0000401E093030176CF84910E94067D209196
+:10FEC000050230910602E0910301F0910401EECFAA
+:10FED0001F93CF930E94D87CC82F0E94067D0E945A
+:10FEE000D87C182F0E94067DC1362CF0C7551136DC
+:10FEF0003CF0175508C0C033D4F3C0531136CCF7CB
+:10FF000010330CF01053C295C07FC10F8C2F99276E
+:10FF100087FD9095CF911F910895CF93282F992712
+:10FF200087FD9095807F907095958795959587959D
+:10FF300095958795959587958A303CF0895AC22F7B
+:10FF4000CF70CA303CF0C95A06C0805DC22FCF7056
+:10FF5000CA30CCF7C05D0E94067D8C2F0E94067DC2
+:06FF6000CF910895FFCFD0
+:040000030000F80001
+:00000001FF
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644.hex b/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644.hex
new file mode 100644
index 0000000..d5557de
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644.hex
@@ -0,0 +1,120 @@
+:10F800000C94387C0C94557C0C94557C0C94557C51
+:10F810000C94557C0C94557C0C94557C0C94557C24
+:10F820000C94557C0C94557C0C94557C0C94557C14
+:10F830000C94557C0C94557C0C94557C0C94557C04
+:10F840000C94557C0C94557C0C94557C0C94557CF4
+:10F850000C94557C0C94557C0C94557C0C94557CE4
+:10F860000C94557C0C94557C0C94557C0C94557CD4
+:10F8700011241FBECFEFD0E1DEBFCDBF11E0A0E06D
+:10F88000B1E0EAE5FFEF02C005900D92A030B107AC
+:10F89000D9F712E0A0E0B1E001C01D92A930B10794
+:10F8A000E1F70E944D7D0C94AC7F0C94007CCF93CB
+:10F8B000DF93CDB7DEB724970FB6F894DEBF0FBE47
+:10F8C000CDBF882309F481E020E0482F552741155A
+:10F8D000510509F43DC0289A19821A821B821C82A4
+:10F8E0000BC089819A81AB81BC810196A11DB11D9C
+:10F8F00089839A83AB83BC8389819A81AB81BC81E4
+:10F9000080589E43A040B04060F3289819821A8224
+:10F910001B821C820BC089819A81AB81BC810196BC
+:10F92000A11DB11D89839A83AB83BC8389819A8190
+:10F93000AB81BC8180509A4FA040B04060F32F5FF4
+:10F94000822F992787FD9095841795070CF4C3CFD4
+:10F9500019821A821B821C8289819A81AB81BC81A7
+:10F9600080509147A240B040A0F489819A81AB8138
+:10F97000BC810196A11DB11D89839A83AB83BC8391
+:10F9800089819A81AB81BC8180509147A240B0406F
+:10F9900060F324960FB6F894DEBF0FBECDBFDF91A3
+:10F9A000CF910895EF92FF920F931F93EE24FF24BF
+:10F9B000870128988091C00087FD17C00894E11C3A
+:10F9C000F11C011D111D81E0E81689E0F8068DE3A8
+:10F9D000080780E0180770F3E0910001F091010141
+:10F9E00009958091C00087FFE9CF289A8091C600D1
+:10F9F000992787FD90951F910F91FF90EF900895A3
+:10FA0000982F8091C00085FFFCCF9093C600089589
+:10FA10000E94D27C803271F0809102018F5F8093CE
+:10FA20000201853009F00895E0910001F091010193
+:10FA30000995089584E10E94007D80E10E94007D87
+:10FA40000895CF93C82F0E94D27C803241F08091DC
+:10FA500002018F5F80930201853081F40AC084E146
+:10FA60000E94007D8C2F0E94007D80E10E94007D1D
+:10FA700005C0E0910001F09101010995CF91089531
+:10FA8000282F90E007C08091C0008823E4F7809180
+:10FA9000C6009F5F9217B8F30895CFEFD0E1DEBFA5
+:10FAA000CDBF000094B714BE809160008861809340
+:10FAB00060001092600091FF74C189E18093C400DE
+:10FAC0001092C50088E18093C10086E08093C20057
+:10FAD0005098589A209A83E00E94577C81E00E94B7
+:10FAE000577C0E94D27C8033B9F18133C1F18034DC
+:10FAF00009F456C0813409F45CC0823409F46EC044
+:10FB0000853409F471C0803539F1813509F4F3C0C9
+:10FB1000823511F1853509F4D3C0863509F4CBC09F
+:10FB2000843609F465C0843709F4EBC0853709F4DD
+:10FB3000D2C0863709F44AC0809102018F5F80935A
+:10FB40000201853071F6E0910001F0910101099503
+:10FB50000E94D27C803349F60E94087DC2CF0E9469
+:10FB6000D27CC82F803241F784E10E94007D81E47D
+:10FB70000E94007D86E50E94007D82E50E94007D56
+:10FB80008C2F0E94007D89E40E94007D83E50E9405
+:10FB9000007D80E50E94007D80E10E94007DA1CF74
+:10FBA0000E94D27C8638C0F20E94D27C0E94087DDE
+:10FBB00098CF0E94D27C803809F407C1813809F4BB
+:10FBC00000C1823809F4F9C0883921F080E00E9430
+:10FBD000217D87CF83E00E94217D83CF84E10E9435
+:10FBE000407D0E94087D7DCF85E00E94407DF9CF59
+:10FBF0000E94D27C809306020E94D27C80930502F0
+:10FC0000809108028E7F809308020E94D27C853406
+:10FC100009F44BC0E5E0F1E0119281E0E438F80727
+:10FC2000D9F3D0F3C0E0D0E08091050290910602B4
+:10FC30001816190678F405E011E00E94D27CF8014C
+:10FC400081938F0121968091050290910602C81739
+:10FC5000D90798F30E94D27C803209F06DCF809151
+:10FC6000080280FFB6C0C0E0D0E0209105023091CC
+:10FC7000060212161306B8F4E0910301F091040194
+:10FC8000A5E0B1E0F999FECFF2BDE1BD8D9180BD57
+:10FC9000FA9AF99A31962196C217D30798F3F093FE
+:10FCA0000401E093030184E175CF80910802816033
+:10FCB00080930802AFCF84E00E94407D80E087CF30
+:10FCC0000E94D27C809303010E94D27C8093040125
+:10FCD0000E94087D06CF0E94D27C803209F02CCF92
+:10FCE00084E10E94007D8EE10E94007D86E90E94F1
+:10FCF000007D89E04FCF0E94087D88E080936000FE
+:10FD0000FFCF0E94D27C809306020E94D27C809317
+:10FD100005020E94D27C853409F449C08091080212
+:10FD20008E7F809308028091030190910401880FD7
+:10FD3000991F90930401809303010E94D27C80322A
+:10FD400009F0CFCE84E10E94007DC0E0D0E0209198
+:10FD50000502309106021216130608F01DCFE0913D
+:10FD60000301F09104018091080280FF96C0F99987
+:10FD7000FECFF2BDE1BDF89A80B50E94007DE09112
+:10FD80000301F09104013196F0930401E093030123
+:10FD900020910502309106022196C217D30718F36D
+:10FDA000FBCEE0910001F0910101099586CE809192
+:10FDB0000802816080930802C0CF80E10E94217D0B
+:10FDC00090CE81E00E94217D8CCE82E00E94217D38
+:10FDD00088CE8091030190910401880F991F909320
+:10FDE0000401809303018091050280FF09C0809186
+:10FDF00005029091060201969093060280930502F7
+:10FE0000F999FECF1127E0910301F0910401C5E0BB
+:10FE1000D1E08091050290910602103091F400919A
+:10FE2000570001700130D9F303E000935700E895C3
+:10FE30000091570001700130D9F301E100935700A0
+:10FE4000E895099019900091570001700130D9F39D
+:10FE500001E000935700E8951395103898F01127AA
+:10FE60000091570001700130D9F305E0009357006D
+:10FE7000E8950091570001700130D9F301E100933A
+:10FE80005700E8953296029709F0C7CF103011F06D
+:10FE90000296E5CF112484E17DCE869580FF06C0D1
+:10FEA0003196F0930401E093030176CF84910E9490
+:10FEB000007D2091050230910602E0910301F0914E
+:10FEC0000401EECF1F93CF930E94D27CC82F0E94D3
+:10FED000007D0E94D27C182F0E94007DC1362CF03C
+:10FEE000C75511363CF0175508C0C033D4F3C05382
+:10FEF0001136CCF710330CF01053C295C07FC10FF0
+:10FF00008C2F992787FD9095CF911F910895CF93BE
+:10FF1000282F992787FD9095807F907095958795DC
+:10FF20009595879595958795959587958A303CF019
+:10FF3000895AC22FCF70CA303CF0C95A06C0805DC2
+:10FF4000C22FCF70CA30CCF7C05D0E94007D8C2FCD
+:0AFF50000E94007DCF910895FFCFBD
+:040000030000F80001
+:00000001FF
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644P.hex b/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644P.hex
new file mode 100644
index 0000000..99a6ae1
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644P.hex
@@ -0,0 +1,121 @@
+:10F800000C943E7C0C945B7C0C945B7C0C945B7C39
+:10F810000C945B7C0C945B7C0C945B7C0C945B7C0C
+:10F820000C945B7C0C945B7C0C945B7C0C945B7CFC
+:10F830000C945B7C0C945B7C0C945B7C0C945B7CEC
+:10F840000C945B7C0C945B7C0C945B7C0C945B7CDC
+:10F850000C945B7C0C945B7C0C945B7C0C945B7CCC
+:10F860000C945B7C0C945B7C0C945B7C0C945B7CBC
+:10F870000C945B7C0C945B7C0C945B7C11241FBE11
+:10F88000CFEFD0E1DEBFCDBF11E0A0E0B1E0E6E612
+:10F89000FFEF02C005900D92A030B107D9F712E03A
+:10F8A000A0E0B1E001C01D92A930B107E1F70E94CC
+:10F8B000537D0C94B27F0C94007CCF93DF93CDB733
+:10F8C000DEB724970FB6F894DEBF0FBECDBF8823F6
+:10F8D00009F481E020E0482F55274115510509F42E
+:10F8E0003DC0289A19821A821B821C820BC0898112
+:10F8F0009A81AB81BC810196A11DB11D89839A8338
+:10F90000AB83BC8389819A81AB81BC8180589E4343
+:10F91000A040B04060F3289819821A821B821C8292
+:10F920000BC089819A81AB81BC810196A11DB11D5B
+:10F9300089839A83AB83BC8389819A81AB81BC81A3
+:10F9400080509A4FA040B04060F32F5F822F9927DC
+:10F9500087FD9095841795070CF4C3CF19821A82FE
+:10F960001B821C8289819A81AB81BC818050914726
+:10F97000A240B040A0F489819A81AB81BC810196FC
+:10F98000A11DB11D89839A83AB83BC8389819A8130
+:10F99000AB81BC8180509147A240B04060F3249677
+:10F9A0000FB6F894DEBF0FBECDBFDF91CF910895A3
+:10F9B000EF92FF920F931F93EE24FF248701289864
+:10F9C0008091C00087FD17C00894E11CF11C011D47
+:10F9D000111D81E0E81689E0F8068DE3080780E054
+:10F9E000180770F3E0910001F091010109958091F1
+:10F9F000C00087FFE9CF289A8091C600992787FD2C
+:10FA000090951F910F91FF90EF900895982F8091FE
+:10FA1000C00085FFFCCF9093C60008950E94D87C5B
+:10FA2000803271F0809102018F5F809302018530F6
+:10FA300009F00895E0910001F09101010995089500
+:10FA400084E10E94067D80E10E94067D0895CF93A7
+:10FA5000C82F0E94D87C803241F0809102018F5FD4
+:10FA600080930201853081F40AC084E10E94067D02
+:10FA70008C2F0E94067D80E10E94067D05C0E091EA
+:10FA80000001F09101010995CF910895282F90E090
+:10FA900007C08091C0008823E4F78091C6009F5F73
+:10FAA0009217B8F30895CFEFD0E1DEBFCDBF0000CD
+:10FAB00094B714BE809160008861809360001092BA
+:10FAC000600091FF74C189E18093C4001092C50069
+:10FAD00088E18093C10086E08093C2005098589AD4
+:10FAE000209A83E00E945D7C81E00E945D7C0E9400
+:10FAF000D87C8033B9F18133C1F1803409F456C028
+:10FB0000813409F45CC0823409F46EC0853409F490
+:10FB100071C0803539F1813509F4F3C0823511F1B6
+:10FB2000853509F4D3C0863509F4CBC0843609F491
+:10FB300065C0843709F4EBC0853709F4D2C0863735
+:10FB400009F44AC0809102018F5F809302018530E1
+:10FB500071F6E0910001F091010109950E94D87CB5
+:10FB6000803349F60E940E7DC2CF0E94D87CC82FF8
+:10FB7000803241F784E10E94067D81E40E94067D87
+:10FB800086E50E94067D82E50E94067D8C2F0E94FC
+:10FB9000067D89E40E94067D83E50E94067D80E55E
+:10FBA0000E94067D80E10E94067DA1CF0E94D87C44
+:10FBB0008638C0F20E94D87C0E940E7D98CF0E94A9
+:10FBC000D87C803809F407C1813809F400C1823833
+:10FBD00009F4F9C0883921F080E00E94277D87CFA1
+:10FBE00083E00E94277D83CF84E10E94467D0E94AE
+:10FBF0000E7D7DCF85E00E94467DF9CF0E94D87CA6
+:10FC0000809306020E94D87C8093050280910802AE
+:10FC10008E7F809308020E94D87C853409F44BC003
+:10FC2000E5E0F1E0119281E0E438F807D9F3D0F390
+:10FC3000C0E0D0E0809105029091060218161906E6
+:10FC400078F405E011E00E94D87CF80181938F01DF
+:10FC500021968091050290910602C817D90798F362
+:10FC60000E94D87C803209F06DCF8091080280FF1D
+:10FC7000B6C0C0E0D0E02091050230910602121615
+:10FC80001306B8F4E0910301F0910401A5E0B1E09E
+:10FC9000F999FECFF2BDE1BD8D9180BDFA9AF99A36
+:10FCA00031962196C217D30798F3F0930401E0939D
+:10FCB000030184E175CF809108028160809308027E
+:10FCC000AFCF84E00E94467D80E087CF0E94D87C41
+:10FCD000809303010E94D87C809304010E940E7DD2
+:10FCE00006CF0E94D87C803209F02CCF84E10E949C
+:10FCF000067D8EE10E94067D86E90E94067D8AE0EF
+:10FD00004FCF0E940E7D88E080936000FFCF0E945D
+:10FD1000D87C809306020E94D87C809305020E94C2
+:10FD2000D87C853409F449C0809108028E7F809385
+:10FD300008028091030190910401880F991F90930C
+:10FD40000401809303010E94D87C803209F0CFCE59
+:10FD500084E10E94067DC0E0D0E020910502309150
+:10FD600006021216130608F01DCFE0910301F09170
+:10FD700004018091080280FF96C0F999FECFF2BD80
+:10FD8000E1BDF89A80B50E94067DE0910301F091F3
+:10FD900004013196F0930401E093030120910502E0
+:10FDA000309106022196C217D30718F3FBCEE091DB
+:10FDB0000001F0910101099586CE809108028160D1
+:10FDC00080930802C0CF80E10E94277D90CE81E021
+:10FDD0000E94277D8CCE82E00E94277D88CE809174
+:10FDE000030190910401880F991F9093040180935F
+:10FDF00003018091050280FF09C080910502909166
+:10FE0000060201969093060280930502F999FECFAF
+:10FE10001127E0910301F0910401C5E0D1E0809148
+:10FE2000050290910602103091F400915700017084
+:10FE30000130D9F303E000935700E8950091570093
+:10FE400001700130D9F301E100935700E895099062
+:10FE500019900091570001700130D9F301E000932F
+:10FE60005700E8951395103898F011270091570026
+:10FE700001700130D9F305E000935700E895009137
+:10FE8000570001700130D9F301E100935700E89564
+:10FE90003296029709F0C7CF103011F00296E5CFE5
+:10FEA000112484E17DCE869580FF06C03196F093C3
+:10FEB0000401E093030176CF84910E94067D209196
+:10FEC000050230910602E0910301F0910401EECFAA
+:10FED0001F93CF930E94D87CC82F0E94067D0E945A
+:10FEE000D87C182F0E94067DC1362CF0C7551136DC
+:10FEF0003CF0175508C0C033D4F3C0531136CCF7CB
+:10FF000010330CF01053C295C07FC10F8C2F99276E
+:10FF100087FD9095CF911F910895CF93282F992712
+:10FF200087FD9095807F907095958795959587959D
+:10FF300095958795959587958A303CF0895AC22F7B
+:10FF4000CF70CA303CF0C95A06C0805DC22FCF7056
+:10FF5000CA30CCF7C05D0E94067D8C2F0E94067DC2
+:06FF6000CF910895FFCFD0
+:040000030000F80001
+:00000001FF
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/Makefile b/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/Makefile
new file mode 100644
index 0000000..5714395
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/Makefile
@@ -0,0 +1,56 @@
+# Makefile for ATmegaBOOT
+# E.Lins, 18.7.2005
+# $Id$
+
+
+# program name should not be changed...
+PROGRAM    = ATmegaBOOT_644P
+
+# enter the target CPU frequency
+AVR_FREQ   = 16000000L
+
+MCU_TARGET = atmega644p
+LDSECTION  = --section-start=.text=0xF800
+
+OBJ        = $(PROGRAM).o
+OPTIMIZE   = -O2
+
+DEFS       = 
+LIBS       = 
+
+CC         = avr-gcc
+
+
+# Override is only needed by avr-lib build system.
+
+override CFLAGS        = -g -Wall $(OPTIMIZE) -mmcu=$(MCU_TARGET) -DF_CPU=$(AVR_FREQ) $(DEFS)
+override LDFLAGS       = -Wl,$(LDSECTION)
+#override LDFLAGS       = -Wl,-Map,$(PROGRAM).map,$(LDSECTION)
+
+OBJCOPY        = avr-objcopy
+OBJDUMP        = avr-objdump
+
+all: CFLAGS += '-DMAX_TIME_COUNT=8000000L>>1' -DADABOOT
+all: $(PROGRAM).hex
+
+$(PROGRAM).hex: $(PROGRAM).elf
+	$(OBJCOPY) -j .text -j .data -O ihex $< $@
+	
+$(PROGRAM).elf: $(OBJ)
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^ $(LIBS)
+	
+$(OBJ): ATmegaBOOT.c
+	avr-gcc $(CFLAGS) $(LDFLAGS) -c -g -O2 -Wall -mmcu=$(MCU_TARGET) ATmegaBOOT.c -o $(PROGRAM).o
+
+%.lst: %.elf
+	$(OBJDUMP) -h -S $< > $@
+
+%.srec: %.elf
+	$(OBJCOPY) -j .text -j .data -O srec $< $@
+
+%.bin: %.elf
+	$(OBJCOPY) -j .text -j .data -O binary $< $@
+
+clean:
+	rm -rf *.o *.elf *.lst *.map *.sym *.lss *.eep *.srec *.bin *.hex
+	
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/README.txt b/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/README.txt
new file mode 100644
index 0000000..8286007
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/README.txt
@@ -0,0 +1,3 @@
+Note: This bootloader support ATmega644, ATmega644P and ATmega324P.
+To build, set PROGRAM and MCU_TARGET in the Makefile according to your target device.
+
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/Copy of wiring.h b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/Copy of wiring.h
new file mode 100644
index 0000000..e29959b
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/Copy of wiring.h	
@@ -0,0 +1,135 @@
+/*
+  wiring.h - Partial implementation of the Wiring API for the ATmega8.
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id$
+*/
+
+#ifndef Wiring_h
+#define Wiring_h
+
+#include <avr/io.h>
+#include <stdlib.h>
+#include "binary.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+#define HIGH 0x1
+#define LOW  0x0
+
+#define INPUT 0x0
+#define OUTPUT 0x1
+
+#define true 0x1
+#define false 0x0
+
+#define PI 3.1415926535897932384626433832795
+#define HALF_PI 1.5707963267948966192313216916398
+#define TWO_PI 6.283185307179586476925286766559
+#define DEG_TO_RAD 0.017453292519943295769236907684886
+#define RAD_TO_DEG 57.295779513082320876798154814105
+
+#define SERIAL  0x0
+#define DISPLAY 0x1
+
+#define LSBFIRST 0
+#define MSBFIRST 1
+
+#define CHANGE 1
+#define FALLING 2
+#define RISING 3
+
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+#define INTERNAL1V1 2
+#define INTERNAL2V56 3
+#else
+#define INTERNAL 3
+#endif
+#define DEFAULT 1
+#define EXTERNAL 0
+
+// undefine stdlib's abs if encountered
+#ifdef abs
+#undef abs
+#endif
+
+#define min(a,b) ((a)<(b)?(a):(b))
+#define max(a,b) ((a)>(b)?(a):(b))
+#define abs(x) ((x)>0?(x):-(x))
+#define constrain(amt,low,high) ((amt)<(low)?(low):((amt)>(high)?(high):(amt)))
+#define round(x)     ((x)>=0?(long)((x)+0.5):(long)((x)-0.5))
+#define radians(deg) ((deg)*DEG_TO_RAD)
+#define degrees(rad) ((rad)*RAD_TO_DEG)
+#define sq(x) ((x)*(x))
+
+#define interrupts() sei()
+#define noInterrupts() cli()
+
+#define clockCyclesPerMicrosecond() ( F_CPU / 1000000L )
+#define clockCyclesToMicroseconds(a) ( ((a) * 1000L) / (F_CPU / 1000L) )
+#define microsecondsToClockCycles(a) ( ((a) * (F_CPU / 1000L)) / 1000L )
+
+#define lowByte(w) ((uint8_t) ((w) & 0xff))
+#define highByte(w) ((uint8_t) ((w) >> 8))
+
+#define bitRead(value, bit) (((value) >> (bit)) & 0x01)
+#define bitSet(value, bit) ((value) |= (1UL << (bit)))
+#define bitClear(value, bit) ((value) &= ~(1UL << (bit)))
+#define bitWrite(value, bit, bitvalue) (bitvalue ? bitSet(value, bit) : bitClear(value, bit))
+
+
+typedef unsigned int word;
+
+#define bit(b) (1UL << (b))
+
+typedef uint8_t boolean;
+typedef uint8_t byte;
+
+void init(void);
+
+void pinMode(uint8_t, uint8_t);
+void digitalWrite(uint8_t, uint8_t);
+int digitalRead(uint8_t);
+int analogRead(uint8_t);
+void analogReference(uint8_t mode);
+void analogWrite(uint8_t, int);
+
+unsigned long millis(void);
+unsigned long micros(void);
+void delay(unsigned long);
+void delayMicroseconds(unsigned int us);
+unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout);
+
+void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val);
+uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder);
+
+void attachInterrupt(uint8_t, void (*)(void), int mode);
+void detachInterrupt(uint8_t);
+
+void setup(void);
+void loop(void);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/HardwareSerial.cpp b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/HardwareSerial.cpp
new file mode 100644
index 0000000..d4931b4
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/HardwareSerial.cpp
@@ -0,0 +1,187 @@
+/*
+  HardwareSerial.cpp - Hardware serial library for Wiring
+  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+  
+  Modified 23 November 2006 by David A. Mellis
+  Modified 28 September 2010 by Mark Sproul
+*/
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <inttypes.h>
+#include "wiring.h"
+#include "wiring_private.h"
+
+// this next line disables the entire HardwareSerial.cpp, 
+// this is so I can support Attiny series and any other chip without a uart
+#if defined(UBRRH) || defined(UBRR0H) || defined(UBRR1H) || defined(UBRR2H) || defined(UBRR3H)
+
+#include "HardwareSerial.h"
+
+// Define constants and variables for buffering incoming serial data.  We're
+// using a ring buffer (I think), in which rx_buffer_head is the index of the
+// location to which to write the next incoming character and rx_buffer_tail
+// is the index of the location from which to read.
+#define RX_BUFFER_SIZE 128
+
+struct ring_buffer
+{
+  unsigned char buffer[RX_BUFFER_SIZE];
+  int head;
+  int tail;
+};
+
+ring_buffer rx_buffer  =  { { 0 }, 0, 0 };
+
+inline void store_char(unsigned char c, ring_buffer *rx_buffer)
+{
+  int i = (unsigned int)(rx_buffer->head + 1) & (RX_BUFFER_SIZE -1);
+
+  // if we should be storing the received character into the location
+  // just before the tail (meaning that the head would advance to the
+  // current location of the tail), we're about to overflow the buffer
+  // and so we don't write the character or advance the head.
+  if (i != rx_buffer->tail) {
+    rx_buffer->buffer[rx_buffer->head] = c;
+    rx_buffer->head = i;
+  }
+}
+
+// fixed by Mark Sproul this is on the 644/644p
+//SIGNAL(SIG_USART_RECV)
+SIGNAL(USART0_RX_vect)
+{
+  unsigned char c  =  UDR0;
+  store_char(c, &rx_buffer);
+}
+
+
+// Constructors ////////////////////////////////////////////////////////////////
+
+HardwareSerial::HardwareSerial(ring_buffer *rx_buffer,
+  volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
+  volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
+  volatile uint8_t *udr,
+  uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udre, uint8_t u2x)
+{
+  _rx_buffer = rx_buffer;
+  _ubrrh = ubrrh;
+  _ubrrl = ubrrl;
+  _ucsra = ucsra;
+  _ucsrb = ucsrb;
+  _udr = udr;
+  _rxen = rxen;
+  _txen = txen;
+  _rxcie = rxcie;
+  _udre = udre;
+  _u2x = u2x;
+}
+
+// Public Methods //////////////////////////////////////////////////////////////
+
+void HardwareSerial::begin(long baud)
+{
+  uint16_t baud_setting;
+  bool use_u2x = true;
+
+#if F_CPU == 16000000UL
+  // hardcoded exception for compatibility with the bootloader shipped
+  // with the Duemilanove and previous boards and the firmware on the 8U2
+  // on the Uno and Mega 2560.
+  if (baud == 57600) {
+    use_u2x = false;
+  }
+#endif
+  
+  if (use_u2x) {
+    *_ucsra = 1 << _u2x;
+    baud_setting = (F_CPU / 4 / baud - 1) / 2;
+  } else {
+    *_ucsra = 0;
+    baud_setting = (F_CPU / 8 / baud - 1) / 2;
+  }
+
+  // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)
+  *_ubrrh = baud_setting >> 8;
+  *_ubrrl = baud_setting;
+
+  sbi(*_ucsrb, _rxen);
+  sbi(*_ucsrb, _txen);
+  sbi(*_ucsrb, _rxcie);
+}
+
+void HardwareSerial::end()
+{
+  cbi(*_ucsrb, _rxen);
+  cbi(*_ucsrb, _txen);
+  cbi(*_ucsrb, _rxcie);  
+}
+
+int HardwareSerial::available(void)
+{
+  return (unsigned int)(RX_BUFFER_SIZE + _rx_buffer->head - _rx_buffer->tail) & (RX_BUFFER_SIZE-1);
+}
+
+int HardwareSerial::peek(void)
+{
+  if (_rx_buffer->head == _rx_buffer->tail) {
+    return -1;
+  } else {
+    return _rx_buffer->buffer[_rx_buffer->tail];
+  }
+}
+
+int HardwareSerial::read(void)
+{
+  // if the head isn't ahead of the tail, we don't have any characters
+  if (_rx_buffer->head == _rx_buffer->tail) {
+    return -1;
+  } else {
+    unsigned char c = _rx_buffer->buffer[_rx_buffer->tail];
+    _rx_buffer->tail = (unsigned int)(_rx_buffer->tail + 1) & (RX_BUFFER_SIZE-1);
+    return c;
+  }
+}
+
+void HardwareSerial::flush()
+{
+  // don't reverse this or there may be problems if the RX interrupt
+  // occurs after reading the value of rx_buffer_head but before writing
+  // the value to rx_buffer_tail; the previous value of rx_buffer_head
+  // may be written to rx_buffer_tail, making it appear as if the buffer
+  // don't reverse this or there may be problems if the RX interrupt
+  // occurs after reading the value of rx_buffer_head but before writing
+  // the value to rx_buffer_tail; the previous value of rx_buffer_head
+  // may be written to rx_buffer_tail, making it appear as if the buffer
+  // were full, not empty.
+  _rx_buffer->head = _rx_buffer->tail;
+}
+
+void HardwareSerial::write(uint8_t c)
+{
+  while (!((*_ucsra) & (1 << _udre)))
+    ;
+
+  *_udr = c;
+}
+
+// Preinstantiate Objects //////////////////////////////////////////////////////
+HardwareSerial Serial(&rx_buffer, &UBRR0H, &UBRR0L, &UCSR0A, &UCSR0B, &UDR0, RXEN0, TXEN0, RXCIE0, UDRE0, U2X0);
+
+#endif // whole file
+
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/HardwareSerial.h b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/HardwareSerial.h
new file mode 100644
index 0000000..3efa775
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/HardwareSerial.h
@@ -0,0 +1,76 @@
+/*
+  HardwareSerial.h - Hardware serial library for Wiring
+  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+  Modified 28 September 2010 by Mark Sproul
+*/
+
+#ifndef HardwareSerial_h
+#define HardwareSerial_h
+
+#include <inttypes.h>
+
+#include "Stream.h"
+
+struct ring_buffer;
+
+class HardwareSerial : public Stream
+{
+  private:
+    ring_buffer *_rx_buffer;
+    volatile uint8_t *_ubrrh;
+    volatile uint8_t *_ubrrl;
+    volatile uint8_t *_ucsra;
+    volatile uint8_t *_ucsrb;
+    volatile uint8_t *_udr;
+    uint8_t _rxen;
+    uint8_t _txen;
+    uint8_t _rxcie;
+    uint8_t _udre;
+    uint8_t _u2x;
+  public:
+    HardwareSerial(ring_buffer *rx_buffer,
+      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
+      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
+      volatile uint8_t *udr,
+      uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udre, uint8_t u2x);
+    void begin(long);
+    void end();
+    virtual int available(void);
+    virtual int peek(void);
+    virtual int read(void);
+    virtual void flush(void);
+    virtual void write(uint8_t);
+    using Print::write; // pull in write(str) and write(buf, size) from Print
+};
+
+#if defined(UBRRH) || defined(UBRR0H)
+  extern HardwareSerial Serial;
+#elif defined(USBCON)
+  #include "usb_api.h"
+#endif
+#if defined(UBRR1H)
+  extern HardwareSerial Serial1;
+#endif
+#if defined(UBRR2H)
+  extern HardwareSerial Serial2;
+#endif
+#if defined(UBRR3H)
+  extern HardwareSerial Serial3;
+#endif
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/Print.cpp b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/Print.cpp
new file mode 100644
index 0000000..4ee556d
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/Print.cpp
@@ -0,0 +1,220 @@
+/*
+ Print.cpp - Base class that provides print() and println()
+ Copyright (c) 2008 David A. Mellis.  All right reserved.
+ 
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Lesser General Public
+ License as published by the Free Software Foundation; either
+ version 2.1 of the License, or (at your option) any later version.
+ 
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Lesser General Public License for more details.
+ 
+ You should have received a copy of the GNU Lesser General Public
+ License along with this library; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ 
+ Modified 23 November 2006 by David A. Mellis
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include "wiring.h"
+
+#include "Print.h"
+
+// Public Methods //////////////////////////////////////////////////////////////
+
+/* default implementation: may be overridden */
+void Print::write(const char *str)
+{
+  while (*str)
+    write(*str++);
+}
+
+/* default implementation: may be overridden */
+void Print::write(const uint8_t *buffer, size_t size)
+{
+  while (size--)
+    write(*buffer++);
+}
+
+void Print::print(const String &s)
+{
+  for (int i = 0; i < s.length(); i++) {
+    write(s[i]);
+  }
+}
+
+void Print::print(const char str[])
+{
+  write(str);
+}
+
+void Print::print(char c, int base)
+{
+  print((long) c, base);
+}
+
+void Print::print(unsigned char b, int base)
+{
+  print((unsigned long) b, base);
+}
+
+void Print::print(int n, int base)
+{
+  print((long) n, base);
+}
+
+void Print::print(unsigned int n, int base)
+{
+  print((unsigned long) n, base);
+}
+
+void Print::print(long n, int base)
+{
+  if (base == 0) {
+    write(n);
+  } else if (base == 10) {
+    if (n < 0) {
+      print('-');
+      n = -n;
+    }
+    printNumber(n, 10);
+  } else {
+    printNumber(n, base);
+  }
+}
+
+void Print::print(unsigned long n, int base)
+{
+  if (base == 0) write(n);
+  else printNumber(n, base);
+}
+
+void Print::print(double n, int digits)
+{
+  printFloat(n, digits);
+}
+
+void Print::println(void)
+{
+  print('\r');
+  print('\n');  
+}
+
+void Print::println(const String &s)
+{
+  print(s);
+  println();
+}
+
+void Print::println(const char c[])
+{
+  print(c);
+  println();
+}
+
+void Print::println(char c, int base)
+{
+  print(c, base);
+  println();
+}
+
+void Print::println(unsigned char b, int base)
+{
+  print(b, base);
+  println();
+}
+
+void Print::println(int n, int base)
+{
+  print(n, base);
+  println();
+}
+
+void Print::println(unsigned int n, int base)
+{
+  print(n, base);
+  println();
+}
+
+void Print::println(long n, int base)
+{
+  print(n, base);
+  println();
+}
+
+void Print::println(unsigned long n, int base)
+{
+  print(n, base);
+  println();
+}
+
+void Print::println(double n, int digits)
+{
+  print(n, digits);
+  println();
+}
+
+// Private Methods /////////////////////////////////////////////////////////////
+
+void Print::printNumber(unsigned long n, uint8_t base)
+{
+  unsigned char buf[8 * sizeof(long)]; // Assumes 8-bit chars. 
+  unsigned long i = 0;
+
+  if (n == 0) {
+    print('0');
+    return;
+  } 
+
+  while (n > 0) {
+    buf[i++] = n % base;
+    n /= base;
+  }
+
+  for (; i > 0; i--)
+    print((char) (buf[i - 1] < 10 ?
+      '0' + buf[i - 1] :
+      'A' + buf[i - 1] - 10));
+}
+
+void Print::printFloat(double number, uint8_t digits) 
+{ 
+  // Handle negative numbers
+  if (number < 0.0)
+  {
+     print('-');
+     number = -number;
+  }
+
+  // Round correctly so that print(1.999, 2) prints as "2.00"
+  double rounding = 0.5;
+  for (uint8_t i=0; i<digits; ++i)
+    rounding /= 10.0;
+  
+  number += rounding;
+
+  // Extract the integer part of the number and print it
+  unsigned long int_part = (unsigned long)number;
+  double remainder = number - (double)int_part;
+  print(int_part);
+
+  // Print the decimal point, but only if there are digits beyond
+  if (digits > 0)
+    print("."); 
+
+  // Extract digits from the remainder one at a time
+  while (digits-- > 0)
+  {
+    remainder *= 10.0;
+    int toPrint = int(remainder);
+    print(toPrint);
+    remainder -= toPrint; 
+  } 
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/Print.h b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/Print.h
new file mode 100644
index 0000000..b092ae5
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/Print.h
@@ -0,0 +1,66 @@
+/*
+  Print.h - Base class that provides print() and println()
+  Copyright (c) 2008 David A. Mellis.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef Print_h
+#define Print_h
+
+#include <inttypes.h>
+#include <stdio.h> // for size_t
+
+#include "WString.h"
+
+#define DEC 10
+#define HEX 16
+#define OCT 8
+#define BIN 2
+#define BYTE 0
+
+class Print
+{
+  private:
+    void printNumber(unsigned long, uint8_t);
+    void printFloat(double, uint8_t);
+  public:
+    virtual void write(uint8_t) = 0;
+    virtual void write(const char *str);
+    virtual void write(const uint8_t *buffer, size_t size);
+    
+    void print(const String &);
+    void print(const char[]);
+    void print(char, int = BYTE);
+    void print(unsigned char, int = BYTE);
+    void print(int, int = DEC);
+    void print(unsigned int, int = DEC);
+    void print(long, int = DEC);
+    void print(unsigned long, int = DEC);
+    void print(double, int = 2);
+
+    void println(const String &s);
+    void println(const char[]);
+    void println(char, int = BYTE);
+    void println(unsigned char, int = BYTE);
+    void println(int, int = DEC);
+    void println(unsigned int, int = DEC);
+    void println(long, int = DEC);
+    void println(unsigned long, int = DEC);
+    void println(double, int = 2);
+    void println(void);
+};
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/Stream.h b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/Stream.h
new file mode 100644
index 0000000..93d8275
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/Stream.h
@@ -0,0 +1,35 @@
+/*
+  Stream.h - base class for character-based streams.
+  Copyright (c) 2010 David A. Mellis.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef Stream_h
+#define Stream_h
+
+#include <inttypes.h>
+#include "Print.h"
+
+class Stream : public Print
+{
+  public:
+    virtual int available() = 0;
+    virtual int read() = 0;
+    virtual int peek() = 0;
+    virtual void flush() = 0;
+};
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/Tone.cpp b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/Tone.cpp
new file mode 100644
index 0000000..c3910e7
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/Tone.cpp
@@ -0,0 +1,601 @@
+/* Tone.cpp
+
+  A Tone Generator Library
+
+  Written by Brett Hagman
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+Version Modified By Date     Comments
+------- ----------- -------- --------
+0001    B Hagman    09/08/02 Initial coding
+0002    B Hagman    09/08/18 Multiple pins
+0003    B Hagman    09/08/18 Moved initialization from constructor to begin()
+0004    B Hagman    09/09/26 Fixed problems with ATmega8
+0005    B Hagman    09/11/23 Scanned prescalars for best fit on 8 bit timers
+                    09/11/25 Changed pin toggle method to XOR
+                    09/11/25 Fixed timer0 from being excluded
+0006    D Mellis    09/12/29 Replaced objects with functions
+0007    M Sproul    10/08/29 Changed #ifdefs from cpu to register
+*************************************************/
+
+#include <avr/interrupt.h>
+#include <avr/pgmspace.h>
+#include "wiring.h"
+#include "pins_arduino.h"
+
+#if defined(__AVR_ATmega8__) || defined(__AVR_ATmega128__)
+#define TCCR2A TCCR2
+#define TCCR2B TCCR2
+#define COM2A1 COM21
+#define COM2A0 COM20
+#define OCR2A OCR2
+#define TIMSK2 TIMSK
+#define OCIE2A OCIE2
+#define TIMER2_COMPA_vect TIMER2_COMP_vect
+#define TIMSK1 TIMSK
+#endif
+
+// timerx_toggle_count:
+//  > 0 - duration specified
+//  = 0 - stopped
+//  < 0 - infinitely (until stop() method called, or new play() called)
+
+#if !defined(__AVR_ATmega8__)
+volatile long timer0_toggle_count;
+volatile uint8_t *timer0_pin_port;
+volatile uint8_t timer0_pin_mask;
+#endif
+
+volatile long timer1_toggle_count;
+volatile uint8_t *timer1_pin_port;
+volatile uint8_t timer1_pin_mask;
+volatile long timer2_toggle_count;
+volatile uint8_t *timer2_pin_port;
+volatile uint8_t timer2_pin_mask;
+
+#if defined(TIMSK3)
+volatile long timer3_toggle_count;
+volatile uint8_t *timer3_pin_port;
+volatile uint8_t timer3_pin_mask;
+#endif
+
+#if defined(TIMSK4)
+volatile long timer4_toggle_count;
+volatile uint8_t *timer4_pin_port;
+volatile uint8_t timer4_pin_mask;
+#endif
+
+#if defined(TIMSK5)
+volatile long timer5_toggle_count;
+volatile uint8_t *timer5_pin_port;
+volatile uint8_t timer5_pin_mask;
+#endif
+
+
+// MLS: This does not make sense, the 3 options are the same
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+
+#define AVAILABLE_TONE_PINS 1
+
+const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 3, 4, 5, 1, 0 */ };
+static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255, 255, 255, 255, 255 */ };
+
+#elif defined(__AVR_ATmega8__)
+
+#define AVAILABLE_TONE_PINS 1
+
+const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 1 */ };
+static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255 */ };
+
+#else
+
+#define AVAILABLE_TONE_PINS 1
+
+// Leave timer 0 to last.
+const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 1, 0 */ };
+static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255, 255 */ };
+
+#endif
+
+
+
+static int8_t toneBegin(uint8_t _pin)
+{
+  int8_t _timer = -1;
+
+  // if we're already using the pin, the timer should be configured.  
+  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
+    if (tone_pins[i] == _pin) {
+      return pgm_read_byte(tone_pin_to_timer_PGM + i);
+    }
+  }
+  
+  // search for an unused timer.
+  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
+    if (tone_pins[i] == 255) {
+      tone_pins[i] = _pin;
+      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
+      break;
+    }
+  }
+  
+  if (_timer != -1)
+  {
+    // Set timer specific stuff
+    // All timers in CTC mode
+    // 8 bit timers will require changing prescalar values,
+    // whereas 16 bit timers are set to either ck/1 or ck/64 prescalar
+    switch (_timer)
+    {
+      #if defined(TCCR0A) && defined(TCCR0B)
+      case 0:
+        // 8 bit timer
+        TCCR0A = 0;
+        TCCR0B = 0;
+        bitWrite(TCCR0A, WGM01, 1);
+        bitWrite(TCCR0B, CS00, 1);
+        timer0_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer0_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR1A) && defined(TCCR1B) && defined(WGM12)
+      case 1:
+        // 16 bit timer
+        TCCR1A = 0;
+        TCCR1B = 0;
+        bitWrite(TCCR1B, WGM12, 1);
+        bitWrite(TCCR1B, CS10, 1);
+        timer1_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer1_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR2A) && defined(TCCR2B)
+      case 2:
+        // 8 bit timer
+        TCCR2A = 0;
+        TCCR2B = 0;
+        bitWrite(TCCR2A, WGM21, 1);
+        bitWrite(TCCR2B, CS20, 1);
+        timer2_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer2_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR3A) && defined(TCCR3B) &&  defined(TIMSK3)
+      case 3:
+        // 16 bit timer
+        TCCR3A = 0;
+        TCCR3B = 0;
+        bitWrite(TCCR3B, WGM32, 1);
+        bitWrite(TCCR3B, CS30, 1);
+        timer3_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer3_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR4A) && defined(TCCR4B) &&  defined(TIMSK4)
+      case 4:
+        // 16 bit timer
+        TCCR4A = 0;
+        TCCR4B = 0;
+        #if defined(WGM42)
+          bitWrite(TCCR4B, WGM42, 1);
+        #elif defined(CS43)
+          #warning this may not be correct
+          // atmega32u4
+          bitWrite(TCCR4B, CS43, 1);
+        #endif
+        bitWrite(TCCR4B, CS40, 1);
+        timer4_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer4_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR5A) && defined(TCCR5B) &&  defined(TIMSK5)
+      case 5:
+        // 16 bit timer
+        TCCR5A = 0;
+        TCCR5B = 0;
+        bitWrite(TCCR5B, WGM52, 1);
+        bitWrite(TCCR5B, CS50, 1);
+        timer5_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer5_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+    }
+  }
+
+  return _timer;
+}
+
+
+
+// frequency (in hertz) and duration (in milliseconds).
+
+void tone(uint8_t _pin, unsigned int frequency, unsigned long duration)
+{
+  uint8_t prescalarbits = 0b001;
+  long toggle_count = 0;
+  uint32_t ocr = 0;
+  int8_t _timer;
+
+  _timer = toneBegin(_pin);
+
+  if (_timer >= 0)
+  {
+    // Set the pinMode as OUTPUT
+    pinMode(_pin, OUTPUT);
+    
+    // if we are using an 8 bit timer, scan through prescalars to find the best fit
+    if (_timer == 0 || _timer == 2)
+    {
+      ocr = F_CPU / frequency / 2 - 1;
+      prescalarbits = 0b001;  // ck/1: same for both timers
+      if (ocr > 255)
+      {
+        ocr = F_CPU / frequency / 2 / 8 - 1;
+        prescalarbits = 0b010;  // ck/8: same for both timers
+
+        if (_timer == 2 && ocr > 255)
+        {
+          ocr = F_CPU / frequency / 2 / 32 - 1;
+          prescalarbits = 0b011;
+        }
+
+        if (ocr > 255)
+        {
+          ocr = F_CPU / frequency / 2 / 64 - 1;
+          prescalarbits = _timer == 0 ? 0b011 : 0b100;
+
+          if (_timer == 2 && ocr > 255)
+          {
+            ocr = F_CPU / frequency / 2 / 128 - 1;
+            prescalarbits = 0b101;
+          }
+
+          if (ocr > 255)
+          {
+            ocr = F_CPU / frequency / 2 / 256 - 1;
+            prescalarbits = _timer == 0 ? 0b100 : 0b110;
+            if (ocr > 255)
+            {
+              // can't do any better than /1024
+              ocr = F_CPU / frequency / 2 / 1024 - 1;
+              prescalarbits = _timer == 0 ? 0b101 : 0b111;
+            }
+          }
+        }
+      }
+
+#if defined(TCCR0B)
+      if (_timer == 0)
+      {
+        TCCR0B = prescalarbits;
+      }
+      else
+#endif
+#if defined(TCCR2B)
+      {
+        TCCR2B = prescalarbits;
+      }
+#else
+      {
+        // dummy place holder to make the above ifdefs work
+      }
+#endif
+    }
+    else
+    {
+      // two choices for the 16 bit timers: ck/1 or ck/64
+      ocr = F_CPU / frequency / 2 - 1;
+
+      prescalarbits = 0b001;
+      if (ocr > 0xffff)
+      {
+        ocr = F_CPU / frequency / 2 / 64 - 1;
+        prescalarbits = 0b011;
+      }
+
+      if (_timer == 1)
+      {
+#if defined(TCCR1B)
+        TCCR1B = (TCCR1B & 0b11111000) | prescalarbits;
+#endif
+      }
+#if defined(TCCR3B)
+      else if (_timer == 3)
+        TCCR3B = (TCCR3B & 0b11111000) | prescalarbits;
+#endif
+#if defined(TCCR4B)
+      else if (_timer == 4)
+        TCCR4B = (TCCR4B & 0b11111000) | prescalarbits;
+#endif
+#if defined(TCCR5B)
+      else if (_timer == 5)
+        TCCR5B = (TCCR5B & 0b11111000) | prescalarbits;
+#endif
+
+    }
+    
+
+    // Calculate the toggle count
+    if (duration > 0)
+    {
+      toggle_count = 2 * frequency * duration / 1000;
+    }
+    else
+    {
+      toggle_count = -1;
+    }
+
+    // Set the OCR for the given timer,
+    // set the toggle count,
+    // then turn on the interrupts
+    switch (_timer)
+    {
+
+#if defined(OCR0A) && defined(TIMSK0) && defined(OCIE0A)
+      case 0:
+        OCR0A = ocr;
+        timer0_toggle_count = toggle_count;
+        bitWrite(TIMSK0, OCIE0A, 1);
+        break;
+#endif
+
+      case 1:
+#if defined(OCR1A) && defined(TIMSK1) && defined(OCIE1A)
+        OCR1A = ocr;
+        timer1_toggle_count = toggle_count;
+        bitWrite(TIMSK1, OCIE1A, 1);
+#elif defined(OCR1A) && defined(TIMSK) && defined(OCIE1A)
+        // this combination is for at least the ATmega32
+        OCR1A = ocr;
+        timer1_toggle_count = toggle_count;
+        bitWrite(TIMSK, OCIE1A, 1);
+#endif
+        break;
+
+#if defined(OCR2A) && defined(TIMSK2) && defined(OCIE2A)
+      case 2:
+        OCR2A = ocr;
+        timer2_toggle_count = toggle_count;
+        bitWrite(TIMSK2, OCIE2A, 1);
+        break;
+#endif
+
+#if defined(TIMSK3)
+      case 3:
+        OCR3A = ocr;
+        timer3_toggle_count = toggle_count;
+        bitWrite(TIMSK3, OCIE3A, 1);
+        break;
+#endif
+
+#if defined(TIMSK4)
+      case 4:
+        OCR4A = ocr;
+        timer4_toggle_count = toggle_count;
+        bitWrite(TIMSK4, OCIE4A, 1);
+        break;
+#endif
+
+#if defined(OCR5A) && defined(TIMSK5) && defined(OCIE5A)
+      case 5:
+        OCR5A = ocr;
+        timer5_toggle_count = toggle_count;
+        bitWrite(TIMSK5, OCIE5A, 1);
+        break;
+#endif
+
+    }
+  }
+}
+
+
+// XXX: this function only works properly for timer 2 (the only one we use
+// currently).  for the others, it should end the tone, but won't restore
+// proper PWM functionality for the timer.
+void disableTimer(uint8_t _timer)
+{
+  switch (_timer)
+  {
+    case 0:
+      #if defined(TIMSK0)
+        TIMSK0 = 0;
+      #elif defined(TIMSK)
+        TIMSK = 0; // atmega32
+      #endif
+      break;
+
+#if defined(TIMSK1) && defined(OCIE1A)
+    case 1:
+      bitWrite(TIMSK1, OCIE1A, 0);
+      break;
+#endif
+
+    case 2:
+      #if defined(TIMSK2) && defined(OCIE2A)
+        bitWrite(TIMSK2, OCIE2A, 0); // disable interrupt
+      #endif
+      #if defined(TCCR2A) && defined(WGM20)
+        TCCR2A = (1 << WGM20);
+      #endif
+      #if defined(TCCR2B) && defined(CS22)
+        TCCR2B = (TCCR2B & 0b11111000) | (1 << CS22);
+      #endif
+      #if defined(OCR2A)
+        OCR2A = 0;
+      #endif
+      break;
+
+#if defined(TIMSK3)
+    case 3:
+      TIMSK3 = 0;
+      break;
+#endif
+
+#if defined(TIMSK4)
+    case 4:
+      TIMSK4 = 0;
+      break;
+#endif
+
+#if defined(TIMSK5)
+    case 5:
+      TIMSK5 = 0;
+      break;
+#endif
+  }
+}
+
+
+void noTone(uint8_t _pin)
+{
+  int8_t _timer = -1;
+  
+  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
+    if (tone_pins[i] == _pin) {
+      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
+      tone_pins[i] = 255;
+    }
+  }
+  
+  disableTimer(_timer);
+
+  digitalWrite(_pin, 0);
+}
+
+#if 0
+#if !defined(__AVR_ATmega8__)
+ISR(TIMER0_COMPA_vect)
+{
+  if (timer0_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer0_pin_port ^= timer0_pin_mask;
+
+    if (timer0_toggle_count > 0)
+      timer0_toggle_count--;
+  }
+  else
+  {
+    disableTimer(0);
+    *timer0_pin_port &= ~(timer0_pin_mask);  // keep pin low after stop
+  }
+}
+#endif
+
+
+ISR(TIMER1_COMPA_vect)
+{
+  if (timer1_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer1_pin_port ^= timer1_pin_mask;
+
+    if (timer1_toggle_count > 0)
+      timer1_toggle_count--;
+  }
+  else
+  {
+    disableTimer(1);
+    *timer1_pin_port &= ~(timer1_pin_mask);  // keep pin low after stop
+  }
+}
+#endif
+
+
+ISR(TIMER2_COMPA_vect)
+{
+
+  if (timer2_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer2_pin_port ^= timer2_pin_mask;
+
+    if (timer2_toggle_count > 0)
+      timer2_toggle_count--;
+  }
+  else
+  {
+    // need to call noTone() so that the tone_pins[] entry is reset, so the
+    // timer gets initialized next time we call tone().
+    // XXX: this assumes timer 2 is always the first one used.
+    noTone(tone_pins[0]);
+//    disableTimer(2);
+//    *timer2_pin_port &= ~(timer2_pin_mask);  // keep pin low after stop
+  }
+}
+
+
+
+//#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+#if 0
+
+ISR(TIMER3_COMPA_vect)
+{
+  if (timer3_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer3_pin_port ^= timer3_pin_mask;
+
+    if (timer3_toggle_count > 0)
+      timer3_toggle_count--;
+  }
+  else
+  {
+    disableTimer(3);
+    *timer3_pin_port &= ~(timer3_pin_mask);  // keep pin low after stop
+  }
+}
+
+ISR(TIMER4_COMPA_vect)
+{
+  if (timer4_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer4_pin_port ^= timer4_pin_mask;
+
+    if (timer4_toggle_count > 0)
+      timer4_toggle_count--;
+  }
+  else
+  {
+    disableTimer(4);
+    *timer4_pin_port &= ~(timer4_pin_mask);  // keep pin low after stop
+  }
+}
+
+ISR(TIMER5_COMPA_vect)
+{
+  if (timer5_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer5_pin_port ^= timer5_pin_mask;
+
+    if (timer5_toggle_count > 0)
+      timer5_toggle_count--;
+  }
+  else
+  {
+    disableTimer(5);
+    *timer5_pin_port &= ~(timer5_pin_mask);  // keep pin low after stop
+  }
+}
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WCharacter.h b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WCharacter.h
new file mode 100644
index 0000000..79733b5
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WCharacter.h
@@ -0,0 +1,168 @@
+/*
+ WCharacter.h - Character utility functions for Wiring & Arduino
+ Copyright (c) 2010 Hernando Barragan.  All right reserved.
+ 
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Lesser General Public
+ License as published by the Free Software Foundation; either
+ version 2.1 of the License, or (at your option) any later version.
+ 
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Lesser General Public License for more details.
+ 
+ You should have received a copy of the GNU Lesser General Public
+ License along with this library; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef Character_h
+#define Character_h
+
+#include <ctype.h>
+
+// WCharacter.h prototypes
+inline boolean isAlphaNumeric(int c) __attribute__((always_inline));
+inline boolean isAlpha(int c) __attribute__((always_inline));
+inline boolean isAscii(int c) __attribute__((always_inline));
+inline boolean isWhitespace(int c) __attribute__((always_inline));
+inline boolean isControl(int c) __attribute__((always_inline));
+inline boolean isDigit(int c) __attribute__((always_inline));
+inline boolean isGraph(int c) __attribute__((always_inline));
+inline boolean isLowerCase(int c) __attribute__((always_inline));
+inline boolean isPrintable(int c) __attribute__((always_inline));
+inline boolean isPunct(int c) __attribute__((always_inline));
+inline boolean isSpace(int c) __attribute__((always_inline));
+inline boolean isUpperCase(int c) __attribute__((always_inline));
+inline boolean isHexadecimalDigit(int c) __attribute__((always_inline));
+inline int toAscii(int c) __attribute__((always_inline));
+inline int toLowerCase(int c) __attribute__((always_inline));
+inline int toUpperCase(int c)__attribute__((always_inline));
+
+
+// Checks for an alphanumeric character. 
+// It is equivalent to (isalpha(c) || isdigit(c)).
+inline boolean isAlphaNumeric(int c) 
+{
+  return ( isalnum(c) == 0 ? false : true);
+}
+
+
+// Checks for an alphabetic character. 
+// It is equivalent to (isupper(c) || islower(c)).
+inline boolean isAlpha(int c)
+{
+  return ( isalpha(c) == 0 ? false : true);
+}
+
+
+// Checks whether c is a 7-bit unsigned char value 
+// that fits into the ASCII character set.
+inline boolean isAscii(int c)
+{
+  return ( isascii (c) == 0 ? false : true);
+}
+
+
+// Checks for a blank character, that is, a space or a tab.
+inline boolean isWhitespace(int c)
+{
+  return ( isblank (c) == 0 ? false : true);
+}
+
+
+// Checks for a control character.
+inline boolean isControl(int c)
+{
+  return ( iscntrl (c) == 0 ? false : true);
+}
+
+
+// Checks for a digit (0 through 9).
+inline boolean isDigit(int c)
+{
+  return ( isdigit (c) == 0 ? false : true);
+}
+
+
+// Checks for any printable character except space.
+inline boolean isGraph(int c)
+{
+  return ( isgraph (c) == 0 ? false : true);
+}
+
+
+// Checks for a lower-case character.
+inline boolean isLowerCase(int c)
+{
+  return (islower (c) == 0 ? false : true);
+}
+
+
+// Checks for any printable character including space.
+inline boolean isPrintable(int c)
+{
+  return ( isprint (c) == 0 ? false : true);
+}
+
+
+// Checks for any printable character which is not a space 
+// or an alphanumeric character.
+inline boolean isPunct(int c)
+{
+  return ( ispunct (c) == 0 ? false : true);
+}
+
+
+// Checks for white-space characters. For the avr-libc library, 
+// these are: space, formfeed ('\f'), newline ('\n'), carriage 
+// return ('\r'), horizontal tab ('\t'), and vertical tab ('\v').
+inline boolean isSpace(int c)
+{
+  return ( isspace (c) == 0 ? false : true);
+}
+
+
+// Checks for an uppercase letter.
+inline boolean isUpperCase(int c)
+{
+  return ( isupper (c) == 0 ? false : true);
+}
+
+
+// Checks for a hexadecimal digits, i.e. one of 0 1 2 3 4 5 6 7 
+// 8 9 a b c d e f A B C D E F.
+inline boolean isHexadecimalDigit(int c)
+{
+  return ( isxdigit (c) == 0 ? false : true);
+}
+
+
+// Converts c to a 7-bit unsigned char value that fits into the 
+// ASCII character set, by clearing the high-order bits.
+inline int toAscii(int c)
+{
+  return toascii (c);
+}
+
+
+// Warning:
+// Many people will be unhappy if you use this function. 
+// This function will convert accented letters into random 
+// characters.
+
+// Converts the letter c to lower case, if possible.
+inline int toLowerCase(int c)
+{
+  return tolower (c);
+}
+
+
+// Converts the letter c to upper case, if possible.
+inline int toUpperCase(int c)
+{
+  return toupper (c);
+}
+
+#endif
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WConstants.h b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WConstants.h
new file mode 100644
index 0000000..3e19ac4
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WConstants.h
@@ -0,0 +1 @@
+#include "wiring.h"
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WInterrupts.c b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WInterrupts.c
new file mode 100644
index 0000000..3b3e0c9
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WInterrupts.c
@@ -0,0 +1,249 @@
+/* -*- mode: jde; c-basic-offset: 2; indent-tabs-mode: nil -*- */
+
+/*
+  Part of the Wiring project - http://wiring.uniandes.edu.co
+
+  Copyright (c) 2004-05 Hernando Barragan
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+  
+  Modified 24 November 2006 by David A. Mellis
+  Modified 1 August 2010 by Mark Sproul
+*/
+
+#include <inttypes.h>
+#include <avr/io.h>
+#include <avr/interrupt.h>
+#include <avr/pgmspace.h>
+#include <stdio.h>
+
+#include "WConstants.h"
+#include "wiring_private.h"
+
+volatile static voidFuncPtr intFunc[EXTERNAL_NUM_INTERRUPTS];
+// volatile static voidFuncPtr twiIntFunc;
+
+void attachInterrupt(uint8_t interruptNum, void (*userFunc)(void), int mode) {
+  if(interruptNum < EXTERNAL_NUM_INTERRUPTS) {
+    intFunc[interruptNum] = userFunc;
+    
+    // Configure the interrupt mode (trigger on low input, any change, rising
+    // edge, or falling edge).  The mode constants were chosen to correspond
+    // to the configuration bits in the hardware register, so we simply shift
+    // the mode into place.
+      
+    // Enable the interrupt.
+      
+    switch (interruptNum) {
+#if defined(EICRA) && defined(EICRB) && defined(EIMSK)
+    case 2:
+      EICRA = (EICRA & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
+      EIMSK |= (1 << INT0);
+      break;
+    case 3:
+      EICRA = (EICRA & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
+      EIMSK |= (1 << INT1);
+      break;
+    case 4:
+      EICRA = (EICRA & ~((1 << ISC20) | (1 << ISC21))) | (mode << ISC20);
+      EIMSK |= (1 << INT2);
+      break;
+    case 5:
+      EICRA = (EICRA & ~((1 << ISC30) | (1 << ISC31))) | (mode << ISC30);
+      EIMSK |= (1 << INT3);
+      break;
+    case 0:
+      EICRB = (EICRB & ~((1 << ISC40) | (1 << ISC41))) | (mode << ISC40);
+      EIMSK |= (1 << INT4);
+      break;
+    case 1:
+      EICRB = (EICRB & ~((1 << ISC50) | (1 << ISC51))) | (mode << ISC50);
+      EIMSK |= (1 << INT5);
+      break;
+    case 6:
+      EICRB = (EICRB & ~((1 << ISC60) | (1 << ISC61))) | (mode << ISC60);
+      EIMSK |= (1 << INT6);
+      break;
+    case 7:
+      EICRB = (EICRB & ~((1 << ISC70) | (1 << ISC71))) | (mode << ISC70);
+      EIMSK |= (1 << INT7);
+      break;
+#else
+    case 0:
+    #if defined(EICRA) && defined(ISC00) && defined(EIMSK)
+      EICRA = (EICRA & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
+      EIMSK |= (1 << INT0);
+    #elif defined(MCUCR) && defined(ISC00) && defined(GICR)
+      MCUCR = (MCUCR & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
+      GICR |= (1 << INT0);
+    #elif defined(MCUCR) && defined(ISC00) && defined(GIMSK)
+      MCUCR = (MCUCR & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
+      GIMSK |= (1 << INT0);
+    #else
+      #error attachInterrupt not finished for this CPU (case 0)
+    #endif
+      break;
+
+    case 1:
+    #if defined(EICRA) && defined(ISC10) && defined(ISC11) && defined(EIMSK)
+      EICRA = (EICRA & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
+      EIMSK |= (1 << INT1);
+    #elif defined(MCUCR) && defined(ISC10) && defined(ISC11) && defined(GICR)
+      MCUCR = (MCUCR & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
+      GICR |= (1 << INT1);
+    #elif defined(MCUCR) && defined(ISC10) && defined(GIMSK) && defined(GIMSK)
+      MCUCR = (MCUCR & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
+      GIMSK |= (1 << INT1);
+    #else
+      #warning attachInterrupt may need some more work for this cpu (case 1)
+    #endif
+      break;
+#endif
+    }
+  }
+}
+
+void detachInterrupt(uint8_t interruptNum) {
+  if(interruptNum < EXTERNAL_NUM_INTERRUPTS) {
+    // Disable the interrupt.  (We can't assume that interruptNum is equal
+    // to the number of the EIMSK bit to clear, as this isn't true on the 
+    // ATmega8.  There, INT0 is 6 and INT1 is 7.)
+    switch (interruptNum) {
+#if defined(EICRA) && defined(EICRB) && defined(EIMSK)
+    case 2:
+      EIMSK &= ~(1 << INT0);
+      break;
+    case 3:
+      EIMSK &= ~(1 << INT1);
+      break;
+    case 4:
+      EIMSK &= ~(1 << INT2);
+      break;
+    case 5:
+      EIMSK &= ~(1 << INT3);
+      break;
+    case 0:
+      EIMSK &= ~(1 << INT4);
+      break;
+    case 1:
+      EIMSK &= ~(1 << INT5);
+      break;
+    case 6:
+      EIMSK &= ~(1 << INT6);
+      break;
+    case 7:
+      EIMSK &= ~(1 << INT7);
+      break;
+#else
+    case 0:
+    #if defined(EIMSK) && defined(INT0)
+      EIMSK &= ~(1 << INT0);
+    #elif defined(GICR) && defined(ISC00)
+      GICR &= ~(1 << INT0); // atmega32
+    #elif defined(GIMSK) && defined(INT0)
+      GIMSK &= ~(1 << INT0);
+    #else
+      #error detachInterrupt not finished for this cpu
+    #endif
+      break;
+
+    case 1:
+    #if defined(EIMSK) && defined(INT1)
+      EIMSK &= ~(1 << INT1);
+    #elif defined(GICR) && defined(INT1)
+      GICR &= ~(1 << INT1); // atmega32
+    #elif defined(GIMSK) && defined(INT1)
+      GIMSK &= ~(1 << INT1);
+    #else
+      #warning detachInterrupt may need some more work for this cpu (case 1)
+    #endif
+      break;
+#endif
+    }
+      
+    intFunc[interruptNum] = 0;
+  }
+}
+
+/*
+void attachInterruptTwi(void (*userFunc)(void) ) {
+  twiIntFunc = userFunc;
+}
+*/
+
+#if defined(EICRA) && defined(EICRB)
+
+SIGNAL(INT0_vect) {
+  if(intFunc[EXTERNAL_INT_2])
+    intFunc[EXTERNAL_INT_2]();
+}
+
+SIGNAL(INT1_vect) {
+  if(intFunc[EXTERNAL_INT_3])
+    intFunc[EXTERNAL_INT_3]();
+}
+
+SIGNAL(INT2_vect) {
+  if(intFunc[EXTERNAL_INT_4])
+    intFunc[EXTERNAL_INT_4]();
+}
+
+SIGNAL(INT3_vect) {
+  if(intFunc[EXTERNAL_INT_5])
+    intFunc[EXTERNAL_INT_5]();
+}
+
+SIGNAL(INT4_vect) {
+  if(intFunc[EXTERNAL_INT_0])
+    intFunc[EXTERNAL_INT_0]();
+}
+
+SIGNAL(INT5_vect) {
+  if(intFunc[EXTERNAL_INT_1])
+    intFunc[EXTERNAL_INT_1]();
+}
+
+SIGNAL(INT6_vect) {
+  if(intFunc[EXTERNAL_INT_6])
+    intFunc[EXTERNAL_INT_6]();
+}
+
+SIGNAL(INT7_vect) {
+  if(intFunc[EXTERNAL_INT_7])
+    intFunc[EXTERNAL_INT_7]();
+}
+
+#else
+
+SIGNAL(INT0_vect) {
+  if(intFunc[EXTERNAL_INT_0])
+    intFunc[EXTERNAL_INT_0]();
+}
+
+SIGNAL(INT1_vect) {
+  if(intFunc[EXTERNAL_INT_1])
+    intFunc[EXTERNAL_INT_1]();
+}
+
+#endif
+
+/*
+SIGNAL(SIG_2WIRE_SERIAL) {
+  if(twiIntFunc)
+    twiIntFunc();
+}
+*/
+
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WMath.cpp b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WMath.cpp
new file mode 100644
index 0000000..2120c4c
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WMath.cpp
@@ -0,0 +1,60 @@
+/* -*- mode: jde; c-basic-offset: 2; indent-tabs-mode: nil -*- */
+
+/*
+  Part of the Wiring project - http://wiring.org.co
+  Copyright (c) 2004-06 Hernando Barragan
+  Modified 13 August 2006, David A. Mellis for Arduino - http://www.arduino.cc/
+  
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+  
+  $Id$
+*/
+
+extern "C" {
+  #include "stdlib.h"
+}
+
+void randomSeed(unsigned int seed)
+{
+  if (seed != 0) {
+    srandom(seed);
+  }
+}
+
+long random(long howbig)
+{
+  if (howbig == 0) {
+    return 0;
+  }
+  return random() % howbig;
+}
+
+long random(long howsmall, long howbig)
+{
+  if (howsmall >= howbig) {
+    return howsmall;
+  }
+  long diff = howbig - howsmall;
+  return random(diff) + howsmall;
+}
+
+long map(long x, long in_min, long in_max, long out_min, long out_max)
+{
+  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
+}
+
+unsigned int makeWord(unsigned int w) { return w; }
+unsigned int makeWord(unsigned char h, unsigned char l) { return (h << 8) | l; }
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WProgram.h b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WProgram.h
new file mode 100644
index 0000000..f73e760
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WProgram.h
@@ -0,0 +1,63 @@
+#ifndef WProgram_h
+#define WProgram_h
+
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+
+#include <avr/interrupt.h>
+
+#include "wiring.h"
+
+#ifdef __cplusplus
+#include "WCharacter.h"
+#include "WString.h"
+#include "HardwareSerial.h"
+
+uint16_t makeWord(uint16_t w);
+uint16_t makeWord(byte h, byte l);
+
+#define word(...) makeWord(__VA_ARGS__)
+
+unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout = 1000000L);
+
+void tone(uint8_t _pin, unsigned int frequency, unsigned long duration = 0);
+void noTone(uint8_t _pin);
+
+// WMath prototypes
+long random(long);
+long random(long, long);
+void randomSeed(unsigned int);
+long map(long, long, long, long, long);
+
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+const static uint8_t A0 = 54;
+const static uint8_t A1 = 55;
+const static uint8_t A2 = 56;
+const static uint8_t A3 = 57;
+const static uint8_t A4 = 58;
+const static uint8_t A5 = 59;
+const static uint8_t A6 = 60;
+const static uint8_t A7 = 61;
+const static uint8_t A8 = 62;
+const static uint8_t A9 = 63;
+const static uint8_t A10 = 64;
+const static uint8_t A11 = 65;
+const static uint8_t A12 = 66;
+const static uint8_t A13 = 67;
+const static uint8_t A14 = 68;
+const static uint8_t A15 = 69;
+#else
+const static uint8_t A0 = 14;
+const static uint8_t A1 = 15;
+const static uint8_t A2 = 16;
+const static uint8_t A3 = 17;
+const static uint8_t A4 = 18;
+const static uint8_t A5 = 19;
+const static uint8_t A6 = 20;
+const static uint8_t A7 = 21;
+#endif
+
+#endif
+
+#endif
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WString.cpp b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WString.cpp
new file mode 100644
index 0000000..db5a441
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WString.cpp
@@ -0,0 +1,443 @@
+/*
+  WString.cpp - String library for Wiring & Arduino
+  Copyright (c) 2009-10 Hernando Barragan.  All rights reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include <stdlib.h>
+#include "WProgram.h"
+#include "WString.h"
+
+
+String::String( const char *value )
+{
+  if ( value == NULL )
+    value = "";
+  getBuffer( _length = strlen( value ) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, value );
+}
+
+String::String( const String &value )
+{
+  getBuffer( _length = value._length );
+  if ( _buffer != NULL )
+    strcpy( _buffer, value._buffer );
+}
+
+String::String( const char value )
+{
+  _length = 1;
+  getBuffer(1);
+  if ( _buffer != NULL ) {
+    _buffer[0] = value;
+    _buffer[1] = 0;
+  }
+}
+
+String::String( const unsigned char value )
+{
+  _length = 1;
+  getBuffer(1);
+  if ( _buffer != NULL) {
+    _buffer[0] = value;
+    _buffer[1] = 0;
+  }
+}
+
+String::String( const int value, const int base )
+{
+  char buf[33];   
+  itoa((signed long)value, buf, base);
+  getBuffer( _length = strlen(buf) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, buf );
+}
+
+String::String( const unsigned int value, const int base )
+{
+  char buf[33];   
+  ultoa((unsigned long)value, buf, base);
+  getBuffer( _length = strlen(buf) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, buf );
+}
+
+String::String( const long value, const int base )
+{
+  char buf[33];   
+  ltoa(value, buf, base);
+  getBuffer( _length = strlen(buf) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, buf );
+}
+
+String::String( const unsigned long value, const int base )
+{
+  char buf[33];   
+  ultoa(value, buf, 10);
+  getBuffer( _length = strlen(buf) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, buf );
+}
+
+char String::charAt( unsigned int loc ) const
+{
+  return operator[]( loc );
+}
+
+void String::setCharAt( unsigned int loc, const char aChar ) 
+{
+  if(_buffer == NULL) return;
+  if(_length > loc) {
+    _buffer[loc] = aChar;
+  }
+}
+
+int String::compareTo( const String &s2 ) const
+{
+  return strcmp( _buffer, s2._buffer );
+}
+
+const String & String::concat( const String &s2 )
+{
+  return (*this) += s2;
+}
+
+const String & String::operator=( const String &rhs )
+{
+  if ( this == &rhs )
+    return *this;
+
+  if ( rhs._length > _length )
+  {
+    free(_buffer);
+    getBuffer( rhs._length );
+  }
+  
+  if ( _buffer != NULL ) {
+    _length = rhs._length;
+    strcpy( _buffer, rhs._buffer );
+  }
+  return *this;
+}
+
+//const String & String::operator+=( const char aChar )
+//{
+//  if ( _length == _capacity )
+//    doubleBuffer();
+//
+//  _buffer[ _length++ ] = aChar;
+//  _buffer[ _length ] = '\0';
+//  return *this;
+//}
+
+const String & String::operator+=( const String &other )
+{
+  _length += other._length;
+  if ( _length > _capacity )
+  {
+    char *temp = (char *)realloc(_buffer, _length + 1);
+    if ( temp != NULL ) {
+      _buffer = temp;
+      _capacity = _length;
+    } else {
+      _length -= other._length;
+      return *this;
+    }
+  }
+  strcat( _buffer, other._buffer );
+  return *this;
+}
+
+
+int String::operator==( const String &rhs ) const
+{
+  return ( _length == rhs._length && strcmp( _buffer, rhs._buffer ) == 0 );
+}
+
+int String::operator!=( const String &rhs ) const
+{
+  return ( _length != rhs.length() || strcmp( _buffer, rhs._buffer ) != 0 );
+}
+
+int String::operator<( const String &rhs ) const
+{
+  return strcmp( _buffer, rhs._buffer ) < 0;
+}
+
+int String::operator>( const String &rhs ) const
+{
+  return strcmp( _buffer, rhs._buffer ) > 0;
+}
+
+int String::operator<=( const String &rhs ) const
+{
+  return strcmp( _buffer, rhs._buffer ) <= 0;
+}
+
+int String::operator>=( const String & rhs ) const
+{
+  return strcmp( _buffer, rhs._buffer ) >= 0;
+}
+
+char & String::operator[]( unsigned int index )
+{
+  static char dummy_writable_char;
+  if (index >= _length || !_buffer) {
+    dummy_writable_char = 0;
+    return dummy_writable_char;
+  }
+  return _buffer[ index ];
+}
+
+char String::operator[]( unsigned int index ) const
+{
+  // need to check for valid index, to do later
+  return _buffer[ index ];
+}
+
+boolean String::endsWith( const String &s2 ) const
+{
+  if ( _length < s2._length )
+    return 0;
+
+  return strcmp( &_buffer[ _length - s2._length], s2._buffer ) == 0;
+}
+
+boolean String::equals( const String &s2 ) const
+{
+  return ( _length == s2._length && strcmp( _buffer,s2._buffer ) == 0 );
+}
+
+boolean String::equalsIgnoreCase( const String &s2 ) const
+{
+  if ( this == &s2 )
+    return true; //1;
+  else if ( _length != s2._length )
+    return false; //0;
+
+  return strcmp(toLowerCase()._buffer, s2.toLowerCase()._buffer) == 0;
+}
+
+String String::replace( char findChar, char replaceChar )
+{
+  if ( _buffer == NULL ) return *this;
+  String theReturn = _buffer;
+  char* temp = theReturn._buffer;
+  while( (temp = strchr( temp, findChar )) != 0 )
+    *temp = replaceChar;
+
+  return theReturn;
+}
+
+String String::replace( const String& match, const String& replace )
+{
+  if ( _buffer == NULL ) return *this;
+  String temp = _buffer, newString;
+
+  int loc;
+  while ( (loc = temp.indexOf( match )) != -1 )
+  {
+    newString += temp.substring( 0, loc );
+    newString += replace;
+    temp = temp.substring( loc + match._length );
+  }
+  newString += temp;  
+  return newString;
+}
+
+int String::indexOf( char temp ) const
+{
+  return indexOf( temp, 0 );
+}
+
+int String::indexOf( char ch, unsigned int fromIndex ) const
+{
+  if ( fromIndex >= _length )
+    return -1;
+
+  const char* temp = strchr( &_buffer[fromIndex], ch );
+  if ( temp == NULL )
+    return -1;
+
+  return temp - _buffer;
+}
+
+int String::indexOf( const String &s2 ) const
+{
+  return indexOf( s2, 0 );
+}
+
+int String::indexOf( const String &s2, unsigned int fromIndex ) const
+{
+  if ( fromIndex >= _length )
+    return -1;
+
+  const char *theFind = strstr( &_buffer[ fromIndex ], s2._buffer );
+
+  if ( theFind == NULL )
+    return -1;
+
+  return theFind - _buffer; // pointer subtraction
+}
+
+int String::lastIndexOf( char theChar ) const
+{
+  return lastIndexOf( theChar, _length - 1 );
+}
+
+int String::lastIndexOf( char ch, unsigned int fromIndex ) const
+{
+  if ( fromIndex >= _length )
+    return -1;
+
+  char tempchar = _buffer[fromIndex + 1];
+  _buffer[fromIndex + 1] = '\0';
+  char* temp = strrchr( _buffer, ch );
+  _buffer[fromIndex + 1] = tempchar;
+
+  if ( temp == NULL )
+    return -1;
+
+  return temp - _buffer;
+}
+
+int String::lastIndexOf( const String &s2 ) const
+{
+  return lastIndexOf( s2, _length - s2._length );
+}
+
+int String::lastIndexOf( const String &s2, unsigned int fromIndex ) const
+{
+  // check for empty strings
+  if ( s2._length == 0 || s2._length - 1 > fromIndex || fromIndex >= _length )
+    return -1;
+
+  // matching first character
+  char temp = s2[ 0 ];
+
+  for ( int i = fromIndex; i >= 0; i-- )
+  {
+    if ( _buffer[ i ] == temp && (*this).substring( i, i + s2._length ).equals( s2 ) )
+    return i;
+  }
+  return -1;
+}
+
+boolean String::startsWith( const String &s2 ) const
+{
+  if ( _length < s2._length )
+    return 0;
+
+  return startsWith( s2, 0 );
+}
+
+boolean String::startsWith( const String &s2, unsigned int offset ) const
+{
+  if ( offset > _length - s2._length )
+    return 0;
+
+  return strncmp( &_buffer[offset], s2._buffer, s2._length ) == 0;
+}
+
+String String::substring( unsigned int left ) const
+{
+  return substring( left, _length );
+}
+
+String String::substring( unsigned int left, unsigned int right ) const
+{
+  if ( left > right )
+  {
+    int temp = right;
+    right = left;
+    left = temp;
+  }
+
+  if ( right > _length )
+  {
+    right = _length;
+  } 
+
+  char temp = _buffer[ right ];  // save the replaced character
+  _buffer[ right ] = '\0';	
+  String outPut = ( _buffer + left );  // pointer arithmetic
+  _buffer[ right ] = temp;  //restore character
+  return outPut;
+}
+
+String String::toLowerCase() const
+{
+  String temp = _buffer;
+
+  for ( unsigned int i = 0; i < _length; i++ )
+    temp._buffer[ i ] = (char)tolower( temp._buffer[ i ] );
+  return temp;
+}
+
+String String::toUpperCase() const
+{
+  String temp = _buffer;
+
+  for ( unsigned int i = 0; i < _length; i++ )
+    temp._buffer[ i ] = (char)toupper( temp._buffer[ i ] );
+  return temp;
+}
+
+String String::trim() const
+{
+  if ( _buffer == NULL ) return *this;
+  String temp = _buffer;
+  unsigned int i,j;
+
+  for ( i = 0; i < _length; i++ )
+  {
+    if ( !isspace(_buffer[i]) )
+      break;
+  }
+
+  for ( j = temp._length - 1; j > i; j-- )
+  {
+    if ( !isspace(_buffer[j]) )
+      break;
+  }
+
+  return temp.substring( i, j + 1);
+}
+
+void String::getBytes(unsigned char *buf, unsigned int bufsize)
+{
+  if (!bufsize || !buf) return;
+  unsigned int len = bufsize - 1;
+  if (len > _length) len = _length;
+  strncpy((char *)buf, _buffer, len);
+  buf[len] = 0;
+}
+
+void String::toCharArray(char *buf, unsigned int bufsize)
+{
+  if (!bufsize || !buf) return;
+  unsigned int len = bufsize - 1;
+  if (len > _length) len = _length;
+  strncpy(buf, _buffer, len);
+  buf[len] = 0;
+}
+
+
+long String::toInt() {
+  return atol(_buffer);
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WString.h b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WString.h
new file mode 100644
index 0000000..cadddb9
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WString.h
@@ -0,0 +1,112 @@
+/*
+  WString.h - String library for Wiring & Arduino
+  Copyright (c) 2009-10 Hernando Barragan.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef String_h
+#define String_h
+
+//#include "WProgram.h"
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+
+class String
+{
+  public:
+    // constructors
+    String( const char *value = "" );
+    String( const String &value );
+    String( const char );
+    String( const unsigned char );
+    String( const int, const int base=10);
+    String( const unsigned int, const int base=10 );
+    String( const long, const int base=10 );
+    String( const unsigned long, const int base=10 );
+    ~String() { free(_buffer); _length = _capacity = 0;}     //added _length = _capacity = 0;
+
+    // operators
+    const String & operator = ( const String &rhs );
+    const String & operator +=( const String &rhs );
+    //const String & operator +=( const char );
+    int operator ==( const String &rhs ) const;
+    int	operator !=( const String &rhs ) const;
+    int	operator < ( const String &rhs ) const;
+    int	operator > ( const String &rhs ) const;
+    int	operator <=( const String &rhs ) const;
+    int	operator >=( const String &rhs ) const;
+    char operator []( unsigned int index ) const;
+    char& operator []( unsigned int index );
+    //operator const char *() const { return _buffer; }
+    
+    // general methods
+    char charAt( unsigned int index ) const;
+    int	compareTo( const String &anotherString ) const;
+    unsigned char endsWith( const String &suffix ) const;
+    unsigned char equals( const String &anObject ) const;
+    unsigned char equalsIgnoreCase( const String &anotherString ) const;
+    int	indexOf( char ch ) const;
+    int	indexOf( char ch, unsigned int fromIndex ) const;
+    int	indexOf( const String &str ) const;
+    int	indexOf( const String &str, unsigned int fromIndex ) const;
+    int	lastIndexOf( char ch ) const;
+    int	lastIndexOf( char ch, unsigned int fromIndex ) const;
+    int	lastIndexOf( const String &str ) const;
+    int	lastIndexOf( const String &str, unsigned int fromIndex ) const;
+    const unsigned int length( ) const { return _length; }
+    void setCharAt(unsigned int index, const char ch);
+    unsigned char startsWith( const String &prefix ) const;
+    unsigned char startsWith( const String &prefix, unsigned int toffset ) const;
+    String substring( unsigned int beginIndex ) const;
+    String substring( unsigned int beginIndex, unsigned int endIndex ) const;
+    String toLowerCase( ) const;
+    String toUpperCase( ) const;
+    String trim( ) const;
+    void getBytes(unsigned char *buf, unsigned int bufsize);
+    void toCharArray(char *buf, unsigned int bufsize);
+    long toInt( );
+    const String& concat( const String &str );
+    String replace( char oldChar, char newChar );
+    String replace( const String& match, const String& replace );
+    friend String operator + ( String lhs, const String &rhs );
+
+  protected:
+    char *_buffer;	     // the actual char array
+    unsigned int _capacity;  // the array length minus one (for the '\0')
+    unsigned int _length;    // the String length (not counting the '\0')
+
+    void getBuffer(unsigned int maxStrLen);
+
+  private:
+
+};
+
+// allocate buffer space
+inline void String::getBuffer(unsigned int maxStrLen)
+{
+  _capacity = maxStrLen;
+  _buffer = (char *) malloc(_capacity + 1);
+  if (_buffer == NULL) _length = _capacity = 0;
+}
+
+inline String operator+( String lhs, const String &rhs )
+{
+  return lhs += rhs;
+}
+
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/binary.h b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/binary.h
new file mode 100644
index 0000000..af14980
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/binary.h
@@ -0,0 +1,515 @@
+#ifndef Binary_h
+#define Binary_h
+
+#define B0 0
+#define B00 0
+#define B000 0
+#define B0000 0
+#define B00000 0
+#define B000000 0
+#define B0000000 0
+#define B00000000 0
+#define B1 1
+#define B01 1
+#define B001 1
+#define B0001 1
+#define B00001 1
+#define B000001 1
+#define B0000001 1
+#define B00000001 1
+#define B10 2
+#define B010 2
+#define B0010 2
+#define B00010 2
+#define B000010 2
+#define B0000010 2
+#define B00000010 2
+#define B11 3
+#define B011 3
+#define B0011 3
+#define B00011 3
+#define B000011 3
+#define B0000011 3
+#define B00000011 3
+#define B100 4
+#define B0100 4
+#define B00100 4
+#define B000100 4
+#define B0000100 4
+#define B00000100 4
+#define B101 5
+#define B0101 5
+#define B00101 5
+#define B000101 5
+#define B0000101 5
+#define B00000101 5
+#define B110 6
+#define B0110 6
+#define B00110 6
+#define B000110 6
+#define B0000110 6
+#define B00000110 6
+#define B111 7
+#define B0111 7
+#define B00111 7
+#define B000111 7
+#define B0000111 7
+#define B00000111 7
+#define B1000 8
+#define B01000 8
+#define B001000 8
+#define B0001000 8
+#define B00001000 8
+#define B1001 9
+#define B01001 9
+#define B001001 9
+#define B0001001 9
+#define B00001001 9
+#define B1010 10
+#define B01010 10
+#define B001010 10
+#define B0001010 10
+#define B00001010 10
+#define B1011 11
+#define B01011 11
+#define B001011 11
+#define B0001011 11
+#define B00001011 11
+#define B1100 12
+#define B01100 12
+#define B001100 12
+#define B0001100 12
+#define B00001100 12
+#define B1101 13
+#define B01101 13
+#define B001101 13
+#define B0001101 13
+#define B00001101 13
+#define B1110 14
+#define B01110 14
+#define B001110 14
+#define B0001110 14
+#define B00001110 14
+#define B1111 15
+#define B01111 15
+#define B001111 15
+#define B0001111 15
+#define B00001111 15
+#define B10000 16
+#define B010000 16
+#define B0010000 16
+#define B00010000 16
+#define B10001 17
+#define B010001 17
+#define B0010001 17
+#define B00010001 17
+#define B10010 18
+#define B010010 18
+#define B0010010 18
+#define B00010010 18
+#define B10011 19
+#define B010011 19
+#define B0010011 19
+#define B00010011 19
+#define B10100 20
+#define B010100 20
+#define B0010100 20
+#define B00010100 20
+#define B10101 21
+#define B010101 21
+#define B0010101 21
+#define B00010101 21
+#define B10110 22
+#define B010110 22
+#define B0010110 22
+#define B00010110 22
+#define B10111 23
+#define B010111 23
+#define B0010111 23
+#define B00010111 23
+#define B11000 24
+#define B011000 24
+#define B0011000 24
+#define B00011000 24
+#define B11001 25
+#define B011001 25
+#define B0011001 25
+#define B00011001 25
+#define B11010 26
+#define B011010 26
+#define B0011010 26
+#define B00011010 26
+#define B11011 27
+#define B011011 27
+#define B0011011 27
+#define B00011011 27
+#define B11100 28
+#define B011100 28
+#define B0011100 28
+#define B00011100 28
+#define B11101 29
+#define B011101 29
+#define B0011101 29
+#define B00011101 29
+#define B11110 30
+#define B011110 30
+#define B0011110 30
+#define B00011110 30
+#define B11111 31
+#define B011111 31
+#define B0011111 31
+#define B00011111 31
+#define B100000 32
+#define B0100000 32
+#define B00100000 32
+#define B100001 33
+#define B0100001 33
+#define B00100001 33
+#define B100010 34
+#define B0100010 34
+#define B00100010 34
+#define B100011 35
+#define B0100011 35
+#define B00100011 35
+#define B100100 36
+#define B0100100 36
+#define B00100100 36
+#define B100101 37
+#define B0100101 37
+#define B00100101 37
+#define B100110 38
+#define B0100110 38
+#define B00100110 38
+#define B100111 39
+#define B0100111 39
+#define B00100111 39
+#define B101000 40
+#define B0101000 40
+#define B00101000 40
+#define B101001 41
+#define B0101001 41
+#define B00101001 41
+#define B101010 42
+#define B0101010 42
+#define B00101010 42
+#define B101011 43
+#define B0101011 43
+#define B00101011 43
+#define B101100 44
+#define B0101100 44
+#define B00101100 44
+#define B101101 45
+#define B0101101 45
+#define B00101101 45
+#define B101110 46
+#define B0101110 46
+#define B00101110 46
+#define B101111 47
+#define B0101111 47
+#define B00101111 47
+#define B110000 48
+#define B0110000 48
+#define B00110000 48
+#define B110001 49
+#define B0110001 49
+#define B00110001 49
+#define B110010 50
+#define B0110010 50
+#define B00110010 50
+#define B110011 51
+#define B0110011 51
+#define B00110011 51
+#define B110100 52
+#define B0110100 52
+#define B00110100 52
+#define B110101 53
+#define B0110101 53
+#define B00110101 53
+#define B110110 54
+#define B0110110 54
+#define B00110110 54
+#define B110111 55
+#define B0110111 55
+#define B00110111 55
+#define B111000 56
+#define B0111000 56
+#define B00111000 56
+#define B111001 57
+#define B0111001 57
+#define B00111001 57
+#define B111010 58
+#define B0111010 58
+#define B00111010 58
+#define B111011 59
+#define B0111011 59
+#define B00111011 59
+#define B111100 60
+#define B0111100 60
+#define B00111100 60
+#define B111101 61
+#define B0111101 61
+#define B00111101 61
+#define B111110 62
+#define B0111110 62
+#define B00111110 62
+#define B111111 63
+#define B0111111 63
+#define B00111111 63
+#define B1000000 64
+#define B01000000 64
+#define B1000001 65
+#define B01000001 65
+#define B1000010 66
+#define B01000010 66
+#define B1000011 67
+#define B01000011 67
+#define B1000100 68
+#define B01000100 68
+#define B1000101 69
+#define B01000101 69
+#define B1000110 70
+#define B01000110 70
+#define B1000111 71
+#define B01000111 71
+#define B1001000 72
+#define B01001000 72
+#define B1001001 73
+#define B01001001 73
+#define B1001010 74
+#define B01001010 74
+#define B1001011 75
+#define B01001011 75
+#define B1001100 76
+#define B01001100 76
+#define B1001101 77
+#define B01001101 77
+#define B1001110 78
+#define B01001110 78
+#define B1001111 79
+#define B01001111 79
+#define B1010000 80
+#define B01010000 80
+#define B1010001 81
+#define B01010001 81
+#define B1010010 82
+#define B01010010 82
+#define B1010011 83
+#define B01010011 83
+#define B1010100 84
+#define B01010100 84
+#define B1010101 85
+#define B01010101 85
+#define B1010110 86
+#define B01010110 86
+#define B1010111 87
+#define B01010111 87
+#define B1011000 88
+#define B01011000 88
+#define B1011001 89
+#define B01011001 89
+#define B1011010 90
+#define B01011010 90
+#define B1011011 91
+#define B01011011 91
+#define B1011100 92
+#define B01011100 92
+#define B1011101 93
+#define B01011101 93
+#define B1011110 94
+#define B01011110 94
+#define B1011111 95
+#define B01011111 95
+#define B1100000 96
+#define B01100000 96
+#define B1100001 97
+#define B01100001 97
+#define B1100010 98
+#define B01100010 98
+#define B1100011 99
+#define B01100011 99
+#define B1100100 100
+#define B01100100 100
+#define B1100101 101
+#define B01100101 101
+#define B1100110 102
+#define B01100110 102
+#define B1100111 103
+#define B01100111 103
+#define B1101000 104
+#define B01101000 104
+#define B1101001 105
+#define B01101001 105
+#define B1101010 106
+#define B01101010 106
+#define B1101011 107
+#define B01101011 107
+#define B1101100 108
+#define B01101100 108
+#define B1101101 109
+#define B01101101 109
+#define B1101110 110
+#define B01101110 110
+#define B1101111 111
+#define B01101111 111
+#define B1110000 112
+#define B01110000 112
+#define B1110001 113
+#define B01110001 113
+#define B1110010 114
+#define B01110010 114
+#define B1110011 115
+#define B01110011 115
+#define B1110100 116
+#define B01110100 116
+#define B1110101 117
+#define B01110101 117
+#define B1110110 118
+#define B01110110 118
+#define B1110111 119
+#define B01110111 119
+#define B1111000 120
+#define B01111000 120
+#define B1111001 121
+#define B01111001 121
+#define B1111010 122
+#define B01111010 122
+#define B1111011 123
+#define B01111011 123
+#define B1111100 124
+#define B01111100 124
+#define B1111101 125
+#define B01111101 125
+#define B1111110 126
+#define B01111110 126
+#define B1111111 127
+#define B01111111 127
+#define B10000000 128
+#define B10000001 129
+#define B10000010 130
+#define B10000011 131
+#define B10000100 132
+#define B10000101 133
+#define B10000110 134
+#define B10000111 135
+#define B10001000 136
+#define B10001001 137
+#define B10001010 138
+#define B10001011 139
+#define B10001100 140
+#define B10001101 141
+#define B10001110 142
+#define B10001111 143
+#define B10010000 144
+#define B10010001 145
+#define B10010010 146
+#define B10010011 147
+#define B10010100 148
+#define B10010101 149
+#define B10010110 150
+#define B10010111 151
+#define B10011000 152
+#define B10011001 153
+#define B10011010 154
+#define B10011011 155
+#define B10011100 156
+#define B10011101 157
+#define B10011110 158
+#define B10011111 159
+#define B10100000 160
+#define B10100001 161
+#define B10100010 162
+#define B10100011 163
+#define B10100100 164
+#define B10100101 165
+#define B10100110 166
+#define B10100111 167
+#define B10101000 168
+#define B10101001 169
+#define B10101010 170
+#define B10101011 171
+#define B10101100 172
+#define B10101101 173
+#define B10101110 174
+#define B10101111 175
+#define B10110000 176
+#define B10110001 177
+#define B10110010 178
+#define B10110011 179
+#define B10110100 180
+#define B10110101 181
+#define B10110110 182
+#define B10110111 183
+#define B10111000 184
+#define B10111001 185
+#define B10111010 186
+#define B10111011 187
+#define B10111100 188
+#define B10111101 189
+#define B10111110 190
+#define B10111111 191
+#define B11000000 192
+#define B11000001 193
+#define B11000010 194
+#define B11000011 195
+#define B11000100 196
+#define B11000101 197
+#define B11000110 198
+#define B11000111 199
+#define B11001000 200
+#define B11001001 201
+#define B11001010 202
+#define B11001011 203
+#define B11001100 204
+#define B11001101 205
+#define B11001110 206
+#define B11001111 207
+#define B11010000 208
+#define B11010001 209
+#define B11010010 210
+#define B11010011 211
+#define B11010100 212
+#define B11010101 213
+#define B11010110 214
+#define B11010111 215
+#define B11011000 216
+#define B11011001 217
+#define B11011010 218
+#define B11011011 219
+#define B11011100 220
+#define B11011101 221
+#define B11011110 222
+#define B11011111 223
+#define B11100000 224
+#define B11100001 225
+#define B11100010 226
+#define B11100011 227
+#define B11100100 228
+#define B11100101 229
+#define B11100110 230
+#define B11100111 231
+#define B11101000 232
+#define B11101001 233
+#define B11101010 234
+#define B11101011 235
+#define B11101100 236
+#define B11101101 237
+#define B11101110 238
+#define B11101111 239
+#define B11110000 240
+#define B11110001 241
+#define B11110010 242
+#define B11110011 243
+#define B11110100 244
+#define B11110101 245
+#define B11110110 246
+#define B11110111 247
+#define B11111000 248
+#define B11111001 249
+#define B11111010 250
+#define B11111011 251
+#define B11111100 252
+#define B11111101 253
+#define B11111110 254
+#define B11111111 255
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/main.cpp b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/main.cpp
new file mode 100644
index 0000000..cc6e81d
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/main.cpp
@@ -0,0 +1,14 @@
+#include <WProgram.h>
+
+int main(void)
+{
+	init();
+
+	setup();
+    
+	for (;;)
+		loop();
+        
+	return 0;
+}
+
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/pins_arduino.c b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/pins_arduino.c
new file mode 100644
index 0000000..d5fa6fe
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/pins_arduino.c
@@ -0,0 +1,200 @@
+/*
+  pins_arduino.c - pin definitions for the Arduino board
+  Part of Arduino / Wiring Lite
+
+  Copyright (c) 2005 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: pins_arduino.c 254 2007-04-20 23:17:38Z mellis $
+*/
+
+#include <avr/io.h>
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+// On the Sanguino board, digital pins are also used
+// for the analog output (software PWM).  Analog input
+// pins are a separate set.
+
+// ATMEL ATMEGA644P / SANGUINO
+//
+//                   +---\/---+
+//  INT0 (D 0) PB0  1|        |40  PA0 (AI 0 / D31)
+//  INT1 (D 1) PB1  2|        |39  PA1 (AI 1 / D30)
+//  INT2 (D 2) PB2  3|        |38  PA2 (AI 2 / D29)
+//   PWM (D 3) PB3  4|        |37  PA3 (AI 3 / D28)
+//   PWM (D 4) PB4  5|        |36  PA4 (AI 4 / D27)
+//  MOSI (D 5) PB5  6|        |35  PA5 (AI 5 / D26)
+//  MISO (D 6) PB6  7|        |34  PA6 (AI 6 / D25)
+//   SCK (D 7) PB7  8|        |33  PA7 (AI 7 / D24)
+//             RST  9|        |32  AREF
+//             VCC 10|        |31  GND 
+//             GND 11|        |30  AVCC
+//           XTAL2 12|        |29  PC7 (D 23)
+//           XTAL1 13|        |28  PC6 (D 22)
+//  RX0 (D 8)  PD0 14|        |27  PC5 (D 21) TDI
+//  TX0 (D 9)  PD1 15|        |26  PC4 (D 20) TDO
+//  RX1 (D 10) PD2 16|        |25  PC3 (D 19) TMS
+//  TX1 (D 11) PD3 17|        |24  PC2 (D 18) TCK
+//  PWM (D 12) PD4 18|        |23  PC1 (D 17) SDA
+//  PWM (D 13) PD5 19|        |22  PC0 (D 16) SCL
+//  PWM (D 14) PD6 20|        |21  PD7 (D 15) PWM
+//                   +--------+
+//
+
+#define PA 1
+#define PB 2
+#define PC 3
+#define PD 4
+
+// these arrays map port names (e.g. port B) to the
+// appropriate addresses for various functions (e.g. reading
+// and writing)
+const uint8_t PROGMEM port_to_mode_PGM[] =
+{
+	NOT_A_PORT,
+	(uint8_t) (uint16_t) &DDRA,
+	(uint8_t) (uint16_t) &DDRB,
+	(uint8_t) (uint16_t) &DDRC,
+	(uint8_t) (uint16_t) &DDRD,
+};
+
+const uint8_t PROGMEM port_to_output_PGM[] =
+{
+	NOT_A_PORT,
+	(uint8_t) (uint16_t) &PORTA,
+	(uint8_t) (uint16_t) &PORTB,
+	(uint8_t) (uint16_t) &PORTC,
+	(uint8_t) (uint16_t) &PORTD,
+};
+
+const uint8_t PROGMEM port_to_input_PGM[] =
+{
+	NOT_A_PORT,
+	(uint8_t) (uint16_t) &PINA,
+	(uint8_t) (uint16_t) &PINB,
+	(uint8_t) (uint16_t) &PINC,
+	(uint8_t) (uint16_t) &PIND,
+};
+
+const uint8_t PROGMEM digital_pin_to_port_PGM[] =
+{
+	PB, /* 0 */
+	PB,
+	PB,
+	PB,
+	PB,
+	PB,
+	PB,
+	PB,
+	PD, /* 8 */
+	PD,
+	PD,
+	PD,
+	PD,
+	PD,
+	PD,
+	PD,
+	PC, /* 16 */
+	PC,
+	PC,
+	PC,
+	PC,
+	PC,
+   	PC,
+	PC,
+	PA, /* 24 */
+	PA,
+	PA,
+	PA,
+	PA,
+	PA,
+	PA,
+	PA  /* 31 */
+};
+
+const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[] =
+{
+	_BV(0), /* 0, port B */
+	_BV(1),
+	_BV(2),
+	_BV(3),
+	_BV(4),
+	_BV(5),
+	_BV(6),
+	_BV(7),
+	_BV(0), /* 8, port D */
+	_BV(1),
+	_BV(2),
+	_BV(3),
+	_BV(4),
+	_BV(5),
+	_BV(6),
+	_BV(7),
+	_BV(0), /* 16, port C */
+	_BV(1),
+	_BV(2),
+	_BV(3),
+	_BV(4),
+	_BV(5),
+	_BV(6),
+	_BV(7),
+	_BV(7), /* 24, port A */
+	_BV(6),
+	_BV(5),
+	_BV(4),
+	_BV(3),
+	_BV(2),
+	_BV(1),
+	_BV(0)
+};
+
+const uint8_t PROGMEM digital_pin_to_timer_PGM[] =
+{
+	NOT_ON_TIMER, 	/* 0  - PB0 */
+	NOT_ON_TIMER, 	/* 1  - PB1 */
+	NOT_ON_TIMER, 	/* 2  - PB2 */
+	TIMER0A,     	/* 3  - PB3 */
+	TIMER0B, 		/* 4  - PB4 */
+	NOT_ON_TIMER, 	/* 5  - PB5 */
+	NOT_ON_TIMER, 	/* 6  - PB6 */
+	NOT_ON_TIMER,	/* 7  - PB7 */
+	NOT_ON_TIMER, 	/* 8  - PD0 */
+	NOT_ON_TIMER, 	/* 9  - PD1 */
+	NOT_ON_TIMER, 	/* 10 - PD2 */
+	NOT_ON_TIMER, 	/* 11 - PD3 */
+	TIMER1B,     	/* 12 - PD4 */
+	TIMER1A,     	/* 13 - PD5 */
+	TIMER2B,     	/* 14 - PD6 */
+	TIMER2A,     	/* 15 - PD7 */
+	NOT_ON_TIMER, 	/* 16 - PC0 */
+	NOT_ON_TIMER,   /* 17 - PC1 */
+	NOT_ON_TIMER,   /* 18 - PC2 */
+	NOT_ON_TIMER,   /* 19 - PC3 */
+	NOT_ON_TIMER,   /* 20 - PC4 */
+	NOT_ON_TIMER,   /* 21 - PC5 */
+	NOT_ON_TIMER,   /* 22 - PC6 */
+	NOT_ON_TIMER,   /* 23 - PC7 */
+	NOT_ON_TIMER,   /* 24 - PA0 */
+	NOT_ON_TIMER,   /* 25 - PA1 */
+	NOT_ON_TIMER,   /* 26 - PA2 */
+	NOT_ON_TIMER,   /* 27 - PA3 */
+	NOT_ON_TIMER,   /* 28 - PA4 */
+	NOT_ON_TIMER,   /* 29 - PA5 */
+	NOT_ON_TIMER,   /* 30 - PA6 */
+	NOT_ON_TIMER   /* 31 - PA7 */
+};
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/pins_arduino.h b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/pins_arduino.h
new file mode 100644
index 0000000..046f033
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/pins_arduino.h
@@ -0,0 +1,70 @@
+/*
+  pins_arduino.h - Pin definition functions for Arduino
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2007 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.h 249 2007-02-03 16:52:51Z mellis $
+*/
+
+#ifndef Pins_Arduino_h
+#define Pins_Arduino_h
+
+#include <avr/pgmspace.h>
+
+#define NOT_A_PIN 0
+#define NOT_A_PORT 0
+
+#define NOT_ON_TIMER 0
+#define TIMER0A 1
+#define TIMER0B 2
+#define TIMER1A 3
+#define TIMER1B 4
+#define TIMER2  5
+#define TIMER2A 6
+#define TIMER2B 7
+
+const static uint8_t SS   = 4;
+const static uint8_t MOSI = 5;
+const static uint8_t MISO = 6;
+const static uint8_t SCK  = 7;
+
+extern const uint8_t PROGMEM port_to_mode_PGM[];
+extern const uint8_t PROGMEM port_to_input_PGM[];
+extern const uint8_t PROGMEM port_to_output_PGM[];
+
+extern const uint8_t PROGMEM digital_pin_to_port_PGM[];
+extern const uint8_t PROGMEM digital_pin_to_bit_PGM[];
+extern const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[];
+
+extern const uint8_t PROGMEM digital_pin_to_timer_PGM[];
+
+// Get the bit location within the hardware port of the given virtual pin.
+// This comes from the pins_*.c file for the active board configuration.
+// 
+// These perform slightly better as macros compared to inline functions
+//
+#define digitalPinToPort(P) ( pgm_read_byte( digital_pin_to_port_PGM + (P) ) )
+#define digitalPinToBitMask(P) ( pgm_read_byte( digital_pin_to_bit_mask_PGM + (P) ) )
+#define digitalPinToTimer(P) ( pgm_read_byte( digital_pin_to_timer_PGM + (P) ) )
+#define analogInPinToBit(P) (P)
+#define portOutputRegister(P) ( (volatile uint8_t *)( (uint16_t) pgm_read_byte( port_to_output_PGM + (P))) )
+#define portInputRegister(P) ( (volatile uint8_t *)( (uint16_t) pgm_read_byte( port_to_input_PGM + (P))) )
+#define portModeRegister(P) ( (volatile uint8_t *)( (uint16_t) pgm_read_byte( port_to_mode_PGM + (P))) )
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring.c b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring.c
new file mode 100644
index 0000000..b90d07e
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring.c
@@ -0,0 +1,289 @@
+/*
+  wiring.c - Partial implementation of the Wiring API for the ATmega8.
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id$
+*/
+
+#include "wiring_private.h"
+
+// the prescaler is set so that timer0 ticks every 64 clock cycles, and the
+// the overflow handler is called every 256 ticks.
+#define MICROSECONDS_PER_TIMER0_OVERFLOW (clockCyclesToMicroseconds(64 * 256))
+
+// the whole number of milliseconds per timer0 overflow
+#define MILLIS_INC (MICROSECONDS_PER_TIMER0_OVERFLOW / 1000)
+
+// the fractional number of milliseconds per timer0 overflow. we shift right
+// by three to fit these numbers into a byte. (for the clock speeds we care
+// about - 8 and 16 MHz - this doesn't lose precision.)
+#define FRACT_INC ((MICROSECONDS_PER_TIMER0_OVERFLOW % 1000) >> 3)
+#define FRACT_MAX (1000 >> 3)
+
+volatile unsigned long timer0_overflow_count = 0;
+volatile unsigned long timer0_millis = 0;
+static unsigned char timer0_fract = 0;
+
+SIGNAL(TIMER0_OVF_vect)
+{
+	// copy these to local variables so they can be stored in registers
+	// (volatile variables must be read from memory on every access)
+	unsigned long m = timer0_millis;
+	unsigned char f = timer0_fract;
+
+	m += MILLIS_INC;
+	f += FRACT_INC;
+	if (f >= FRACT_MAX) {
+		f -= FRACT_MAX;
+		m += 1;
+	}
+
+	timer0_fract = f;
+	timer0_millis = m;
+	timer0_overflow_count++;
+}
+
+unsigned long millis()
+{
+	unsigned long m;
+	uint8_t oldSREG = SREG;
+
+	// disable interrupts while we read timer0_millis or we might get an
+	// inconsistent value (e.g. in the middle of a write to timer0_millis)
+	cli();
+	m = timer0_millis;
+	SREG = oldSREG;
+
+	return m;
+}
+
+unsigned long micros() {
+	unsigned long m;
+	uint8_t oldSREG = SREG, t;
+	
+	cli();
+	m = timer0_overflow_count;
+#if defined(TCNT0)
+	t = TCNT0;
+#elif defined(TCNT0L)
+	t = TCNT0L;
+#else
+	#error TIMER 0 not defined
+#endif
+
+  
+#ifdef TIFR0
+	if ((TIFR0 & _BV(TOV0)) && (t < 255))
+		m++;
+#else
+	if ((TIFR & _BV(TOV0)) && (t < 255))
+		m++;
+#endif
+
+	SREG = oldSREG;
+	
+	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
+}
+
+void delay(unsigned long ms)
+{
+	uint16_t start = (uint16_t)micros();
+
+	while (ms > 0) {
+		if (((uint16_t)micros() - start) >= 1000) {
+			ms--;
+			start += 1000;
+		}
+	}
+}
+
+/* Delay for the given number of microseconds.  Assumes a 8 or 16 MHz clock. */
+void delayMicroseconds(unsigned int us)
+{
+	// calling avrlib's delay_us() function with low values (e.g. 1 or
+	// 2 microseconds) gives delays longer than desired.
+	//delay_us(us);
+
+#if F_CPU >= 16000000L
+	// for the 16 MHz clock on most Arduino boards
+
+	// for a one-microsecond delay, simply return.  the overhead
+	// of the function call yields a delay of approximately 1 1/8 us.
+	if (--us == 0)
+		return;
+
+	// the following loop takes a quarter of a microsecond (4 cycles)
+	// per iteration, so execute it four times for each microsecond of
+	// delay requested.
+	us <<= 2;
+
+	// account for the time taken in the preceeding commands.
+	us -= 2;
+#else
+	// for the 8 MHz internal clock on the ATmega168
+
+	// for a one- or two-microsecond delay, simply return.  the overhead of
+	// the function calls takes more than two microseconds.  can't just
+	// subtract two, since us is unsigned; we'd overflow.
+	if (--us == 0)
+		return;
+	if (--us == 0)
+		return;
+
+	// the following loop takes half of a microsecond (4 cycles)
+	// per iteration, so execute it twice for each microsecond of
+	// delay requested.
+	us <<= 1;
+    
+	// partially compensate for the time taken by the preceeding commands.
+	// we can't subtract any more than this or we'd overflow w/ small delays.
+	us--;
+#endif
+
+	// busy wait
+	__asm__ __volatile__ (
+		"1: sbiw %0,1" "\n\t" // 2 cycles
+		"brne 1b" : "=w" (us) : "0" (us) // 2 cycles
+	);
+}
+
+void init()
+{
+	// this needs to be called before setup() or some functions won't
+	// work there
+	sei();
+	
+	// on the ATmega168, timer 0 is also used for fast hardware pwm
+	// (using phase-correct PWM would mean that timer 0 overflowed half as often
+	// resulting in different millis() behavior on the ATmega8 and ATmega168)
+#if defined(TCCR0A) && defined(WGM01)
+	sbi(TCCR0A, WGM01);
+	sbi(TCCR0A, WGM00);
+#endif  
+
+	// set timer 0 prescale factor to 64
+#if defined(__AVR_ATmega128__)
+	// CPU specific: different values for the ATmega128
+	sbi(TCCR0, CS02);
+#elif defined(TCCR0) && defined(CS01) && defined(CS00)
+	// this combination is for the standard atmega8
+	sbi(TCCR0, CS01);
+	sbi(TCCR0, CS00);
+#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
+	// this combination is for the standard 168/328/1280/2560
+	sbi(TCCR0B, CS01);
+	sbi(TCCR0B, CS00);
+#elif defined(TCCR0A) && defined(CS01) && defined(CS00)
+	// this combination is for the __AVR_ATmega645__ series
+	sbi(TCCR0A, CS01);
+	sbi(TCCR0A, CS00);
+#else
+	#error Timer 0 prescale factor 64 not set correctly
+#endif
+
+	// enable timer 0 overflow interrupt
+#if defined(TIMSK) && defined(TOIE0)
+	sbi(TIMSK, TOIE0);
+#elif defined(TIMSK0) && defined(TOIE0)
+	sbi(TIMSK0, TOIE0);
+#else
+	#error	Timer 0 overflow interrupt not set correctly
+#endif
+
+	// timers 1 and 2 are used for phase-correct hardware pwm
+	// this is better for motors as it ensures an even waveform
+	// note, however, that fast pwm mode can achieve a frequency of up
+	// 8 MHz (with a 16 MHz clock) at 50% duty cycle
+
+	TCCR1B = 0;
+
+	// set timer 1 prescale factor to 64
+#if defined(TCCR1B) && defined(CS11) && defined(CS10)
+	sbi(TCCR1B, CS11);
+	sbi(TCCR1B, CS10);
+#elif defined(TCCR1) && defined(CS11) && defined(CS10)
+	sbi(TCCR1, CS11);
+	sbi(TCCR1, CS10);
+#endif
+	// put timer 1 in 8-bit phase correct pwm mode
+#if defined(TCCR1A) && defined(WGM10)
+	sbi(TCCR1A, WGM10);
+#elif defined(TCCR1)
+	#warning this needs to be finished
+#endif
+
+	// set timer 2 prescale factor to 64
+#if defined(TCCR2) && defined(CS22)
+	sbi(TCCR2, CS22);
+#elif defined(TCCR2B) && defined(CS22)
+	sbi(TCCR2B, CS22);
+#else
+	#warning Timer 2 not finished (may not be present on this CPU)
+#endif
+
+	// configure timer 2 for phase correct pwm (8-bit)
+#if defined(TCCR2) && defined(WGM20)
+	sbi(TCCR2, WGM20);
+#elif defined(TCCR2A) && defined(WGM20)
+	sbi(TCCR2A, WGM20);
+#else
+	#warning Timer 2 not finished (may not be present on this CPU)
+#endif
+
+#if defined(TCCR3B) && defined(CS31) && defined(WGM30)
+	sbi(TCCR3B, CS31);		// set timer 3 prescale factor to 64
+	sbi(TCCR3B, CS30);
+	sbi(TCCR3A, WGM30);		// put timer 3 in 8-bit phase correct pwm mode
+#endif
+	
+#if defined(TCCR4B) && defined(CS41) && defined(WGM40)
+	sbi(TCCR4B, CS41);		// set timer 4 prescale factor to 64
+	sbi(TCCR4B, CS40);
+	sbi(TCCR4A, WGM40);		// put timer 4 in 8-bit phase correct pwm mode
+#endif
+
+#if defined(TCCR5B) && defined(CS51) && defined(WGM50)
+	sbi(TCCR5B, CS51);		// set timer 5 prescale factor to 64
+	sbi(TCCR5B, CS50);
+	sbi(TCCR5A, WGM50);		// put timer 5 in 8-bit phase correct pwm mode
+#endif
+
+#if defined(ADCSRA)
+	// set a2d prescale factor to 128
+	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.
+	// XXX: this will not work properly for other clock speeds, and
+	// this code should use F_CPU to determine the prescale factor.
+	sbi(ADCSRA, ADPS2);
+	sbi(ADCSRA, ADPS1);
+	sbi(ADCSRA, ADPS0);
+
+	// enable a2d conversions
+	sbi(ADCSRA, ADEN);
+#endif
+
+	// the bootloader connects pins 0 and 1 to the USART; disconnect them
+	// here so they can be used as normal digital i/o; they will be
+	// reconnected in Serial.begin()
+#if defined(UCSRB)
+	UCSRB = 0;
+#elif defined(UCSR0B)
+	UCSR0B = 0;
+#endif
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring.h b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring.h
new file mode 100644
index 0000000..0a93678
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring.h
@@ -0,0 +1,136 @@
+/*
+  wiring.h - Partial implementation of the Wiring API for the ATmega8.
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id$
+*/
+
+#ifndef Wiring_h
+#define Wiring_h
+
+#include <math.h>
+#include <avr/io.h>
+#include <stdlib.h>
+#include "binary.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+#define HIGH 0x1
+#define LOW  0x0
+
+#define INPUT 0x0
+#define OUTPUT 0x1
+
+#define true 0x1
+#define false 0x0
+
+#define PI 3.1415926535897932384626433832795
+#define HALF_PI 1.5707963267948966192313216916398
+#define TWO_PI 6.283185307179586476925286766559
+#define DEG_TO_RAD 0.017453292519943295769236907684886
+#define RAD_TO_DEG 57.295779513082320876798154814105
+
+#define SERIAL  0x0
+#define DISPLAY 0x1
+
+#define LSBFIRST 0
+#define MSBFIRST 1
+
+#define CHANGE 1
+#define FALLING 2
+#define RISING 3
+
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+#define INTERNAL1V1 2
+#define INTERNAL2V56 3
+#else
+#define INTERNAL 3
+#endif
+#define DEFAULT 1
+#define EXTERNAL 0
+
+// undefine stdlib's abs if encountered
+#ifdef abs
+#undef abs
+#endif
+
+#define min(a,b) ((a)<(b)?(a):(b))
+#define max(a,b) ((a)>(b)?(a):(b))
+#define abs(x) ((x)>0?(x):-(x))
+#define constrain(amt,low,high) ((amt)<(low)?(low):((amt)>(high)?(high):(amt)))
+#define round(x)     ((x)>=0?(long)((x)+0.5):(long)((x)-0.5))
+#define radians(deg) ((deg)*DEG_TO_RAD)
+#define degrees(rad) ((rad)*RAD_TO_DEG)
+#define sq(x) ((x)*(x))
+
+#define interrupts() sei()
+#define noInterrupts() cli()
+
+#define clockCyclesPerMicrosecond() ( F_CPU / 1000000L )
+#define clockCyclesToMicroseconds(a) ( ((a) * 1000L) / (F_CPU / 1000L) )
+#define microsecondsToClockCycles(a) ( ((a) * (F_CPU / 1000L)) / 1000L )
+
+#define lowByte(w) ((uint8_t) ((w) & 0xff))
+#define highByte(w) ((uint8_t) ((w) >> 8))
+
+#define bitRead(value, bit) (((value) >> (bit)) & 0x01)
+#define bitSet(value, bit) ((value) |= (1UL << (bit)))
+#define bitClear(value, bit) ((value) &= ~(1UL << (bit)))
+#define bitWrite(value, bit, bitvalue) (bitvalue ? bitSet(value, bit) : bitClear(value, bit))
+
+
+typedef unsigned int word;
+
+#define bit(b) (1UL << (b))
+
+typedef uint8_t boolean;
+typedef uint8_t byte;
+
+void init(void);
+
+void pinMode(uint8_t, uint8_t);
+void digitalWrite(uint8_t, uint8_t);
+int digitalRead(uint8_t);
+int analogRead(uint8_t);
+void analogReference(uint8_t mode);
+void analogWrite(uint8_t, int);
+
+unsigned long millis(void);
+unsigned long micros(void);
+void delay(unsigned long);
+void delayMicroseconds(unsigned int us);
+unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout);
+
+void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val);
+uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder);
+
+void attachInterrupt(uint8_t, void (*)(void), int mode);
+void detachInterrupt(uint8_t);
+
+void setup(void);
+void loop(void);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring_analog.c b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring_analog.c
new file mode 100644
index 0000000..d248f4c
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring_analog.c
@@ -0,0 +1,259 @@
+/*
+  wiring_analog.c - analog input and output
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  Modified 28 September 2010 by Mark Sproul
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+uint8_t analog_reference = DEFAULT;
+
+void analogReference(uint8_t mode)
+{
+	// can't actually set the register here because the default setting
+	// will connect AVCC and the AREF pin, which would cause a short if
+	// there's something connected to AREF.
+	analog_reference = mode;
+}
+
+int analogRead(uint8_t pin)
+{
+	uint8_t low, high;
+
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+	if (pin >= 54) pin -= 54; // allow for channel or pin numbers
+#else
+	if (pin >= 14) pin -= 14; // allow for channel or pin numbers
+#endif
+
+#if defined(ADCSRB) && defined(MUX5)
+	// the MUX5 bit of ADCSRB selects whether we're reading from channels
+	// 0 to 7 (MUX5 low) or 8 to 15 (MUX5 high).
+	ADCSRB = (ADCSRB & ~(1 << MUX5)) | (((pin >> 3) & 0x01) << MUX5);
+#endif
+  
+	// set the analog reference (high two bits of ADMUX) and select the
+	// channel (low 4 bits).  this also sets ADLAR (left-adjust result)
+	// to 0 (the default).
+#if defined(ADMUX)
+	ADMUX = (analog_reference << 6) | (pin & 0x07);
+#endif
+
+	// without a delay, we seem to read from the wrong channel
+	//delay(1);
+
+#if defined(ADCSRA) && defined(ADCL)
+	// start the conversion
+	sbi(ADCSRA, ADSC);
+
+	// ADSC is cleared when the conversion finishes
+	while (bit_is_set(ADCSRA, ADSC));
+
+	// we have to read ADCL first; doing so locks both ADCL
+	// and ADCH until ADCH is read.  reading ADCL second would
+	// cause the results of each conversion to be discarded,
+	// as ADCL and ADCH would be locked when it completed.
+	low  = ADCL;
+	high = ADCH;
+#else
+	// we dont have an ADC, return 0
+	low  = 0;
+	high = 0;
+#endif
+
+	// combine the two bytes
+	return (high << 8) | low;
+}
+
+// Right now, PWM output only works on the pins with
+// hardware support.  These are defined in the appropriate
+// pins_*.c file.  For the rest of the pins, we default
+// to digital output.
+void analogWrite(uint8_t pin, int val)
+{
+	// We need to make sure the PWM output is enabled for those pins
+	// that support it, as we turn it off when digitally reading or
+	// writing with them.  Also, make sure the pin is in output mode
+	// for consistenty with Wiring, which doesn't require a pinMode
+	// call for the analog output pins.
+	pinMode(pin, OUTPUT);
+	if (val == 0)
+	{
+		digitalWrite(pin, LOW);
+	}
+	else if (val == 255)
+	{
+		digitalWrite(pin, HIGH);
+	}
+	else
+	{
+		switch(digitalPinToTimer(pin))
+		{
+			// XXX fix needed for atmega8
+			#if defined(TCCR0) && defined(COM00) && !defined(__AVR_ATmega8__)
+			case TIMER0A:
+				// connect pwm to pin on timer 0
+				sbi(TCCR0, COM00);
+				OCR0 = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR0A) && defined(COM0A1)
+			case TIMER0A:
+				// connect pwm to pin on timer 0, channel A
+				sbi(TCCR0A, COM0A1);
+				OCR0A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR0A) && defined(COM0B1)
+			case TIMER0B:
+				// connect pwm to pin on timer 0, channel B
+				sbi(TCCR0A, COM0B1);
+				OCR0B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR1A) && defined(COM1A1)
+			case TIMER1A:
+				// connect pwm to pin on timer 1, channel A
+				sbi(TCCR1A, COM1A1);
+				OCR1A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR1A) && defined(COM1B1)
+			case TIMER1B:
+				// connect pwm to pin on timer 1, channel B
+				sbi(TCCR1A, COM1B1);
+				OCR1B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR2) && defined(COM21)
+			case TIMER2:
+				// connect pwm to pin on timer 2
+				sbi(TCCR2, COM21);
+				OCR2 = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR2A) && defined(COM2A1)
+			case TIMER2A:
+				// connect pwm to pin on timer 2, channel A
+				sbi(TCCR2A, COM2A1);
+				OCR2A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR2A) && defined(COM2B1)
+			case TIMER2B:
+				// connect pwm to pin on timer 2, channel B
+				sbi(TCCR2A, COM2B1);
+				OCR2B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR3A) && defined(COM3A1)
+			case TIMER3A:
+				// connect pwm to pin on timer 3, channel A
+				sbi(TCCR3A, COM3A1);
+				OCR3A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR3A) && defined(COM3B1)
+			case TIMER3B:
+				// connect pwm to pin on timer 3, channel B
+				sbi(TCCR3A, COM3B1);
+				OCR3B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR3A) && defined(COM3C1)
+			case TIMER3C:
+				// connect pwm to pin on timer 3, channel C
+				sbi(TCCR3A, COM3C1);
+				OCR3C = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR4A) && defined(COM4A1)
+			case TIMER4A:
+				// connect pwm to pin on timer 4, channel A
+				sbi(TCCR4A, COM4A1);
+				OCR4A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR4A) && defined(COM4B1)
+			case TIMER4B:
+				// connect pwm to pin on timer 4, channel B
+				sbi(TCCR4A, COM4B1);
+				OCR4B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR4A) && defined(COM4C1)
+			case TIMER4C:
+				// connect pwm to pin on timer 4, channel C
+				sbi(TCCR4A, COM4C1);
+				OCR4C = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR5A) && defined(COM5A1)
+			case TIMER5A:
+				// connect pwm to pin on timer 5, channel A
+				sbi(TCCR5A, COM5A1);
+				OCR5A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR5A) && defined(COM5B1)
+			case TIMER5B:
+				// connect pwm to pin on timer 5, channel B
+				sbi(TCCR5A, COM5B1);
+				OCR5B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR5A) && defined(COM5C1)
+			case TIMER5C:
+				// connect pwm to pin on timer 5, channel C
+				sbi(TCCR5A, COM5C1);
+				OCR5C = val; // set pwm duty
+				break;
+			#endif
+
+			case NOT_ON_TIMER:
+			default:
+				if (val < 128) {
+					digitalWrite(pin, LOW);
+				} else {
+					digitalWrite(pin, HIGH);
+				}
+		}
+	}
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring_digital.c b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring_digital.c
new file mode 100644
index 0000000..0949da4
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring_digital.c
@@ -0,0 +1,166 @@
+/*
+  wiring_digital.c - digital input and output functions
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  Modified 28 September 2010 by Mark Sproul
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+void pinMode(uint8_t pin, uint8_t mode)
+{
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+	volatile uint8_t *reg;
+
+	if (port == NOT_A_PIN) return;
+
+	// JWS: can I let the optimizer do this?
+	reg = portModeRegister(port);
+
+	if (mode == INPUT) { 
+		uint8_t oldSREG = SREG;
+                cli();
+		*reg &= ~bit;
+		SREG = oldSREG;
+	} else {
+		uint8_t oldSREG = SREG;
+                cli();
+		*reg |= bit;
+		SREG = oldSREG;
+	}
+}
+
+// Forcing this inline keeps the callers from having to push their own stuff
+// on the stack. It is a good performance win and only takes 1 more byte per
+// user than calling. (It will take more bytes on the 168.)
+//
+// But shouldn't this be moved into pinMode? Seems silly to check and do on
+// each digitalread or write.
+//
+// Mark Sproul:
+// - Removed inline. Save 170 bytes on atmega1280
+// - changed to a switch statment; added 32 bytes but much easier to read and maintain.
+// - Added more #ifdefs, now compiles for atmega645
+//
+//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
+//static inline void turnOffPWM(uint8_t timer)
+static void turnOffPWM(uint8_t timer)
+{
+	switch (timer)
+	{
+		#if defined(TCCR1A) && defined(COM1A1)
+		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
+		#endif
+		#if defined(TCCR1A) && defined(COM1B1)
+		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
+		#endif
+		
+		#if defined(TCCR2) && defined(COM21)
+		case  TIMER2:   cbi(TCCR2, COM21);      break;
+		#endif
+		
+		#if defined(TCCR0A) && defined(COM0A1)
+		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
+		#endif
+		
+		#if defined(TIMER0B) && defined(COM0B1)
+		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
+		#endif
+		#if defined(TCCR2A) && defined(COM2A1)
+		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
+		#endif
+		#if defined(TCCR2A) && defined(COM2B1)
+		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
+		#endif
+		
+		#if defined(TCCR3A) && defined(COM3A1)
+		case  TIMER3A:  cbi(TCCR3A, COM3A1);    break;
+		#endif
+		#if defined(TCCR3A) && defined(COM3B1)
+		case  TIMER3B:  cbi(TCCR3A, COM3B1);    break;
+		#endif
+		#if defined(TCCR3A) && defined(COM3C1)
+		case  TIMER3C:  cbi(TCCR3A, COM3C1);    break;
+		#endif
+
+		#if defined(TCCR4A) && defined(COM4A1)
+		case  TIMER4A:  cbi(TCCR4A, COM4A1);    break;
+		#endif
+		#if defined(TCCR4A) && defined(COM4B1)
+		case  TIMER4B:  cbi(TCCR4A, COM4B1);    break;
+		#endif
+		#if defined(TCCR4A) && defined(COM4C1)
+		case  TIMER4C:  cbi(TCCR4A, COM4C1);    break;
+		#endif
+		#if defined(TCCR5A)
+		case  TIMER5A:  cbi(TCCR5A, COM5A1);    break;
+		case  TIMER5B:  cbi(TCCR5A, COM5B1);    break;
+		case  TIMER5C:  cbi(TCCR5A, COM5C1);    break;
+		#endif
+	}
+}
+
+void digitalWrite(uint8_t pin, uint8_t val)
+{
+	uint8_t timer = digitalPinToTimer(pin);
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+	volatile uint8_t *out;
+
+	if (port == NOT_A_PIN) return;
+
+	// If the pin that support PWM output, we need to turn it off
+	// before doing a digital write.
+	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
+
+	out = portOutputRegister(port);
+
+	if (val == LOW) {
+		uint8_t oldSREG = SREG;
+                cli();
+		*out &= ~bit;
+		SREG = oldSREG;
+	} else {
+		uint8_t oldSREG = SREG;
+                cli();
+		*out |= bit;
+		SREG = oldSREG;
+	}
+}
+
+int digitalRead(uint8_t pin)
+{
+	uint8_t timer = digitalPinToTimer(pin);
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+
+	if (port == NOT_A_PIN) return LOW;
+
+	// If the pin that support PWM output, we need to turn it off
+	// before getting a digital reading.
+	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
+
+	if (*portInputRegister(port) & bit) return HIGH;
+	return LOW;
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring_private.h b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring_private.h
new file mode 100644
index 0000000..7449c76
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring_private.h
@@ -0,0 +1,68 @@
+/*
+  wiring_private.h - Internal header file.
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.h 239 2007-01-12 17:58:39Z mellis $
+*/
+
+#ifndef WiringPrivate_h
+#define WiringPrivate_h
+#include <math.h>
+#include <avr/io.h>
+#include <avr/interrupt.h>
+#include <util/delay.h>
+#include <stdio.h>
+#include <stdarg.h>
+
+#include "wiring.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+#ifndef cbi
+#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
+#endif
+#ifndef sbi
+#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
+#endif
+
+#define EXTERNAL_INT_0 0
+#define EXTERNAL_INT_1 1
+#define EXTERNAL_INT_2 2
+#define EXTERNAL_INT_3 3
+#define EXTERNAL_INT_4 4
+#define EXTERNAL_INT_5 5
+#define EXTERNAL_INT_6 6
+#define EXTERNAL_INT_7 7
+
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+#define EXTERNAL_NUM_INTERRUPTS 8
+#else
+#define EXTERNAL_NUM_INTERRUPTS 2
+#endif
+
+typedef void (*voidFuncPtr)(void);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring_pulse.c b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring_pulse.c
new file mode 100644
index 0000000..0d96886
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring_pulse.c
@@ -0,0 +1,69 @@
+/*
+  wiring_pulse.c - pulseIn() function
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+/* Measures the length (in microseconds) of a pulse on the pin; state is HIGH
+ * or LOW, the type of pulse to measure.  Works on pulses from 2-3 microseconds
+ * to 3 minutes in length, but must be called at least a few dozen microseconds
+ * before the start of the pulse. */
+unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout)
+{
+	// cache the port and bit of the pin in order to speed up the
+	// pulse width measuring loop and achieve finer resolution.  calling
+	// digitalRead() instead yields much coarser resolution.
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+	uint8_t stateMask = (state ? bit : 0);
+	unsigned long width = 0; // keep initialization out of time critical area
+	
+	// convert the timeout from microseconds to a number of times through
+	// the initial loop; it takes 16 clock cycles per iteration.
+	unsigned long numloops = 0;
+	unsigned long maxloops = microsecondsToClockCycles(timeout) / 16;
+	
+	// wait for any previous pulse to end
+	while ((*portInputRegister(port) & bit) == stateMask)
+		if (numloops++ == maxloops)
+			return 0;
+	
+	// wait for the pulse to start
+	while ((*portInputRegister(port) & bit) != stateMask)
+		if (numloops++ == maxloops)
+			return 0;
+	
+	// wait for the pulse to stop
+	while ((*portInputRegister(port) & bit) == stateMask) {
+		if (numloops++ == maxloops)
+			return 0;
+		width++;
+	}
+
+	// convert the reading to microseconds. The loop has been determined
+	// to be 20 clock cycles long and have about 16 clocks between the edge
+	// and the start of the loop. There will be some error introduced by
+	// the interrupt handlers.
+	return clockCyclesToMicroseconds(width * 21 + 16); 
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring_shift.c b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring_shift.c
new file mode 100644
index 0000000..cfe7867
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring_shift.c
@@ -0,0 +1,55 @@
+/*
+  wiring_shift.c - shiftOut() function
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+
+uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder) {
+	uint8_t value = 0;
+	uint8_t i;
+
+	for (i = 0; i < 8; ++i) {
+		digitalWrite(clockPin, HIGH);
+		if (bitOrder == LSBFIRST)
+			value |= digitalRead(dataPin) << i;
+		else
+			value |= digitalRead(dataPin) << (7 - i);
+		digitalWrite(clockPin, LOW);
+	}
+	return value;
+}
+
+void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val)
+{
+	uint8_t i;
+
+	for (i = 0; i < 8; i++)  {
+		if (bitOrder == LSBFIRST)
+			digitalWrite(dataPin, !!(val & (1 << i)));
+		else	
+			digitalWrite(dataPin, !!(val & (1 << (7 - i))));
+			
+		digitalWrite(clockPin, HIGH);
+		digitalWrite(clockPin, LOW);		
+	}
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/programmers.txt b/ArduinoAddons/Arduino_0.xx/Sanguino/programmers.txt
new file mode 100644
index 0000000..466f602
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/programmers.txt
@@ -0,0 +1,20 @@
+avrisp.name=AVR ISP
+avrisp.communication=serial
+avrisp.protocol=stk500v1
+
+avrispmkii.name=AVRISP mkII
+avrispmkii.communication=usb
+avrispmkii.protocol=stk500v2
+
+usbtinyisp.name=USBtinyISP
+usbtinyisp.protocol=usbtiny
+
+parallel.name=Parallel Programmer
+parallel.protocol=dapa
+parallel.force=true
+# parallel.delay=200
+
+arduinoisp.name=Arduino as ISP
+arduinoisp.communication=serial
+arduinoisp.protocol=stk500v1
+arduinoisp.speed=19200
diff --git a/ArduinoAddons/Arduino_0.xx/hardware/tools/avr/etc/avrdude.conf b/ArduinoAddons/Arduino_0.xx/hardware/tools/avr/etc/avrdude.conf
new file mode 100644
index 0000000..ec921df
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/hardware/tools/avr/etc/avrdude.conf
@@ -0,0 +1,12104 @@
+# $Id: avrdude.conf.in,v 1.122 2007/05/16 21:29:36 joerg_wunsch Exp $
+#
+# AVRDUDE Configuration File
+#
+# This file contains configuration data used by AVRDUDE which describes
+# the programming hardware pinouts and also provides part definitions.
+# AVRDUDE's "-C" command line option specifies the location of the
+# configuration file.  The "-c" option names the programmer configuration
+# which must match one of the entry's "id" parameter.  The "-p" option
+# identifies which part AVRDUDE is going to be programming and must match
+# one of the parts' "id" parameter.
+#
+# Possible entry formats are:
+#
+#   programmer
+#       id       = <id1> [, <id2> [, <id3>] ...] ;  # <idN> are quoted strings
+#       desc     = <description> ;                  # quoted string
+#       type     = par | stk500 | stk500v2 | stk500pp | stk500hvsp | stk500generic |
+#                  avr910 | butterfly | usbasp |
+#                  jtagmki | jtagmkii | jtagmkii_isp | jtagmkii_dw |
+#                  dragon_dw | dragon_jtag | dragon_isp | dragon_pp |
+#                  dragon_hvsp; # programmer type
+#       baudrate = <num> ;                          # baudrate for avr910-programmer
+#       vcc      = <num1> [, <num2> ... ] ;         # pin number(s)
+#       reset    = <num> ;                          # pin number
+#       sck      = <num> ;                          # pin number
+#       mosi     = <num> ;                          # pin number
+#       miso     = <num> ;                          # pin number
+#       errled   = <num> ;                          # pin number
+#       rdyled   = <num> ;                          # pin number
+#       pgmled   = <num> ;                          # pin number
+#       vfyled   = <num> ;                          # pin number
+#     ;
+#
+#   part
+#       id               = <id> ;                 # quoted string
+#       desc             = <description> ;        # quoted string
+#       has_jtag         = <yes/no> ;             # part has JTAG i/f
+#       has_debugwire    = <yes/no> ;             # part has debugWire i/f
+#       devicecode       = <num> ;            # deprecated, use stk500_devcode
+#       stk500_devcode   = <num> ;                # numeric
+#       avr910_devcode   = <num> ;                # numeric
+#       signature        = <num> <num> <num> ;    # signature bytes
+#       chip_erase_delay = <num> ;                # micro-seconds
+#       reset            = dedicated | io;
+#       retry_pulse      = reset | sck;
+#       pgm_enable       = <instruction format> ;
+#       chip_erase       = <instruction format> ;
+#       chip_erase_delay = <num> ;                # chip erase delay (us)
+#       # STK500 parameters (parallel programming IO lines)
+#       pagel            = <num> ;                # pin name in hex, i.e., 0xD7
+#       bs2              = <num> ;                # pin name in hex, i.e., 0xA0
+#       serial           = <yes/no> ;             # can use serial downloading
+#       parallel         = <yes/no/pseudo>;       # can use par. programming
+#       # STK500v2 parameters, to be taken from Atmel's XML files
+#       timeout          = <num> ;
+#       stabdelay        = <num> ;
+#       cmdexedelay      = <num> ;
+#       synchloops       = <num> ;
+#       bytedelay        = <num> ;
+#       pollvalue        = <num> ;
+#       pollindex        = <num> ;
+#       predelay         = <num> ;
+#       postdelay        = <num> ;
+#       pollmethod       = <num> ;
+#       mode             = <num> ;
+#       delay            = <num> ;
+#       blocksize        = <num> ;
+#       readsize         = <num> ;
+#       hvspcmdexedelay  = <num> ;
+#       # STK500v2 HV programming parameters, from XML
+#       pp_controlstack  = <num>, <num>, ...;   # PP only
+#       hvsp_controlstack = <num>, <num>, ...;  # HVSP only
+#       hventerstabdelay = <num>;
+#       progmodedelay    = <num>;               # PP only
+#       latchcycles      = <num>;
+#       togglevtg        = <num>;
+#       poweroffdelay    = <num>;
+#       resetdelayms     = <num>;
+#       resetdelayus     = <num>;
+#       hvleavestabdelay = <num>;
+#       resetdelay       = <num>;
+#       synchcycles      = <num>;               # HVSP only
+#       chiperasepulsewidth = <num>;            # PP only
+#       chiperasepolltimeout = <num>;
+#       chiperasetime    = <num>;               # HVSP only
+#       programfusepulsewidth = <num>;          # PP only
+#       programfusepolltimeout = <num>;
+#       programlockpulsewidth = <num>;          # PP only
+#       programlockpolltimeout = <num>;
+#       # JTAG ICE mkII parameters, also from XML files
+#       allowfullpagebitstream = <yes/no> ;
+#       enablepageprogramming = <yes/no> ;
+#       idr              = <num> ;                # IO addr of IDR (OCD) reg.
+#       rampz            = <num> ;                # IO addr of RAMPZ reg.
+#       spmcr            = <num> ;                # mem addr of SPMC[S]R reg.
+#       eecr             = <num> ;                # mem addr of EECR reg.
+#                                                 # (only when != 0x3c)
+#
+#       memory <memtype>
+#           paged           = <yes/no> ;          # yes / no
+#           size            = <num> ;             # bytes
+#           page_size       = <num> ;             # bytes
+#           num_pages       = <num> ;             # numeric
+#           min_write_delay = <num> ;             # micro-seconds
+#           max_write_delay = <num> ;             # micro-seconds
+#           readback_p1     = <num> ;             # byte value
+#           readback_p2     = <num> ;             # byte value
+#           pwroff_after_write = <yes/no> ;       # yes / no
+#           read            = <instruction format> ;
+#           write           = <instruction format> ;
+#           read_lo         = <instruction format> ;
+#           read_hi         = <instruction format> ;
+#           write_lo        = <instruction format> ;
+#           write_hi        = <instruction format> ;
+#           loadpage_lo     = <instruction format> ;
+#           loadpage_hi     = <instruction format> ;
+#           writepage       = <instruction format> ;
+#         ;
+#     ;
+#
+# If any of the above parameters are not specified, the default value
+# of 0 is used for numerics or the empty string ("") for string
+# values.  If a required parameter is left empty, AVRDUDE will
+# complain.
+#
+# NOTES:
+#   * 'devicecode' is the device code used by the STK500 (see codes 
+#       listed below)
+#   * Not all memory types will implement all instructions.
+#   * AVR Fuse bits and Lock bits are implemented as a type of memory.
+#   * Example memory types are:
+#       "flash", "eeprom", "fuse", "lfuse" (low fuse), "hfuse" (high
+#       fuse), "signature", "calibration", "lock"
+#   * The memory type specified on the avrdude command line must match
+#     one of the memory types defined for the specified chip.
+#   * The pwroff_after_write flag causes avrdude to attempt to
+#     power the device off and back on after an unsuccessful write to
+#     the affected memory area if VCC programmer pins are defined.  If
+#     VCC pins are not defined for the programmer, a message
+#     indicating that the device needs a power-cycle is printed out.
+#     This flag was added to work around a problem with the
+#     at90s4433/2333's; see the at90s4433 errata at:
+#
+#         http://www.atmel.com/atmel/acrobat/doc1280.pdf
+#
+# INSTRUCTION FORMATS
+#
+#    Instruction formats are specified as a comma seperated list of
+#    string values containing information (bit specifiers) about each
+#    of the 32 bits of the instruction.  Bit specifiers may be one of
+#    the following formats:
+#
+#       '1'  = the bit is always set on input as well as output
+#
+#       '0'  = the bit is always clear on input as well as output
+#
+#       'x'  = the bit is ignored on input and output
+#
+#       'a'  = the bit is an address bit, the bit-number matches this bit
+#              specifier's position within the current instruction byte
+#
+#       'aN' = the bit is the Nth address bit, bit-number = N, i.e., a12
+#              is address bit 12 on input, a0 is address bit 0.
+#
+#       'i'  = the bit is an input data bit
+#
+#       'o'  = the bit is an output data bit
+#
+#    Each instruction must be composed of 32 bit specifiers.  The
+#    instruction specification closely follows the instruction data
+#    provided in Atmel's data sheets for their parts.
+#
+# See below for some examples.
+#
+#
+# The following are STK500 part device codes to use for the
+# "devicecode" field of the part.  These came from Atmel's software
+# section avr061.zip which accompanies the application note
+# AVR061 available from:
+#
+#      http://www.atmel.com/atmel/acrobat/doc2525.pdf
+#
+
+#define ATTINY10    0x10
+#define ATTINY11    0x11
+#define ATTINY12    0x12
+#define ATTINY15    0x13
+#define ATTINY13    0x14
+
+#define ATTINY22    0x20
+#define ATTINY26    0x21
+#define ATTINY28    0x22
+#define ATTINY2313  0x23
+
+#define AT90S1200   0x33
+
+#define AT90S2313   0x40
+#define AT90S2323   0x41
+#define AT90S2333   0x42
+#define AT90S2343   0x43
+
+#define AT90S4414   0x50
+#define AT90S4433   0x51
+#define AT90S4434   0x52
+#define ATMEGA48    0x59
+
+#define AT90S8515   0x60
+#define AT90S8535   0x61
+#define AT90C8534   0x62
+#define ATMEGA8515  0x63
+#define ATMEGA8535  0x64
+
+#define ATMEGA8     0x70
+#define ATMEGA88    0x73
+#define ATMEGA168   0x86
+
+#define ATMEGA161   0x80
+#define ATMEGA163   0x81
+#define ATMEGA16    0x82
+#define ATMEGA162   0x83
+#define ATMEGA169   0x84
+
+#define ATMEGA323   0x90
+#define ATMEGA32    0x91
+
+#define ATMEGA64    0xA0
+
+#define ATMEGA103   0xB1
+#define ATMEGA128   0xB2
+#define AT90CAN128  0xB3
+
+#define AT86RF401   0xD0
+
+#define AT89START   0xE0
+#define AT89S51	    0xE0
+#define AT89S52	    0xE1
+
+# The following table lists the devices in the original AVR910
+# appnote:
+# |Device |Signature | Code |
+# +-------+----------+------+
+# |tiny12 | 1E 90 05 | 0x55 |
+# |tiny15 | 1E 90 06 | 0x56 |
+# |       |          |      |
+# | S1200 | 1E 90 01 | 0x13 |
+# |       |          |      |
+# | S2313 | 1E 91 01 | 0x20 |
+# | S2323 | 1E 91 02 | 0x48 |
+# | S2333 | 1E 91 05 | 0x34 |
+# | S2343 | 1E 91 03 | 0x4C |
+# |       |          |      |
+# | S4414 | 1E 92 01 | 0x28 |
+# | S4433 | 1E 92 03 | 0x30 |
+# | S4434 | 1E 92 02 | 0x6C |
+# |       |          |      |
+# | S8515 | 1E 93 01 | 0x38 |
+# | S8535 | 1E 93 03 | 0x68 |
+# |       |          |      |
+# |mega32 | 1E 95 01 | 0x72 |
+# |mega83 | 1E 93 05 | 0x65 |
+# |mega103| 1E 97 01 | 0x41 |
+# |mega161| 1E 94 01 | 0x60 |
+# |mega163| 1E 94 02 | 0x64 |
+
+# Appnote AVR109 also has a table of AVR910 device codes, which
+# lists:
+# dev         avr910   signature
+# ATmega8     0x77     0x1E 0x93 0x07
+# ATmega8515  0x3B     0x1E 0x93 0x06
+# ATmega8535  0x6A     0x1E 0x93 0x08
+# ATmega16    0x75     0x1E 0x94 0x03
+# ATmega162   0x63     0x1E 0x94 0x04
+# ATmega163   0x66     0x1E 0x94 0x02
+# ATmega169   0x79     0x1E 0x94 0x05
+# ATmega32    0x7F     0x1E 0x95 0x02
+# ATmega323   0x73     0x1E 0x95 0x01
+# ATmega64    0x46     0x1E 0x96 0x02
+# ATmega128   0x44     0x1E 0x97 0x02
+#
+# These codes refer to "BOOT" device codes which are apparently
+# different than standard device codes, for whatever reasons
+# (often one above the standard code).
+
+# There are several extended versions of AVR910 implementations around
+# in the Internet.  These add the following codes (only devices that
+# actually exist are listed):
+
+# ATmega8515	0x3A
+# ATmega128	0x43
+# ATmega64	0x45
+# ATtiny26	0x5E
+# ATmega8535	0x69
+# ATmega32	0x72
+# ATmega16	0x74
+# ATmega8	0x76
+# ATmega169	0x78
+
+#
+# Overall avrdude defaults
+#
+default_parallel   = "lpt1";
+default_serial     = "com1";
+
+
+#
+# PROGRAMMER DEFINITIONS
+#
+
+programmer
+  id    = "avrisp";
+  desc  = "Atmel AVR ISP";
+  type  = stk500;
+;
+
+programmer
+  id    = "avrispv2";
+  desc  = "Atmel AVR ISP V2";
+  type  =  stk500v2;
+;
+
+programmer
+  id    = "avrispmkII";
+  desc  = "Atmel AVR ISP mkII";
+  type  =  stk500v2;
+;
+
+programmer
+  id    = "avrisp2";
+  desc  = "Atmel AVR ISP mkII";
+  type  =  stk500v2;
+;
+
+# This is supposed to be the "default" STK500 entry.
+# Attempts to select the correct firmware version
+# by probing for it.  Better use one of the entries
+# below instead.
+programmer
+  id    = "stk500";
+  desc  = "Atmel STK500";
+  type  = stk500generic;
+;
+
+programmer
+  id    = "stk500v1";
+  desc  = "Atmel STK500 Version 1.x firmware";
+  type  = stk500;
+;
+
+programmer
+  id    = "stk500v2";
+  desc  = "Atmel STK500 Version 2.x firmware";
+  type  = stk500v2;
+;
+
+programmer
+  id    = "stk500pp";
+  desc  = "Atmel STK500 V2 in parallel programming mode";
+  type  = stk500pp;
+;
+
+programmer
+  id    = "stk500hvsp";
+  desc  = "Atmel STK500 V2 in high-voltage serial programming mode";
+  type  = stk500hvsp;
+;
+
+programmer
+  id    = "avr910";
+  desc  = "Atmel Low Cost Serial Programmer";
+  type  = avr910;
+;
+
+programmer
+  id    = "usbasp";
+  desc  = "USBasp, http://www.fischl.de/usbasp/";
+  type  = usbasp;
+;
+
+programmer
+  id    = "usbtiny";
+  desc  = "USBtiny simple USB programmer";
+  type  = usbtiny;
+;
+
+programmer
+  id    = "butterfly";
+  desc  = "Atmel Butterfly Development Board";
+  type  = butterfly;
+;
+
+programmer
+  id    = "avr109";
+  desc  = "Atmel AppNote AVR109 Boot Loader";
+  type  = butterfly;
+;
+
+programmer
+  id    = "avr911";
+  desc  = "Atmel AppNote AVR911 AVROSP";
+  type  = butterfly;
+;
+
+programmer
+  id    = "jtagmkI";
+  desc  = "Atmel JTAG ICE (mkI)";
+  baudrate = 115200;    # default is 115200
+  type  = jtagmki;
+;
+
+# easier to type
+programmer
+  id    = "jtag1";
+  desc  = "Atmel JTAG ICE (mkI)";
+  baudrate = 115200;    # default is 115200
+  type  = jtagmki;
+;
+
+# easier to type
+programmer
+  id    = "jtag1slow";
+  desc  = "Atmel JTAG ICE (mkI)";
+  baudrate = 19200;
+  type  = jtagmki;
+;
+
+programmer
+  id    = "jtagmkII";
+  desc  = "Atmel JTAG ICE mkII";
+  baudrate = 19200;    # default is 19200
+  type  = jtagmkii;
+;
+
+# easier to type
+programmer
+  id    = "jtag2slow";
+  desc  = "Atmel JTAG ICE mkII";
+  baudrate = 19200;    # default is 19200
+  type  = jtagmkii;
+;
+
+# JTAG ICE mkII @ 115200 Bd
+programmer
+  id    = "jtag2fast";
+  desc  = "Atmel JTAG ICE mkII";
+  baudrate = 115200;
+  type  = jtagmkii;
+;
+
+# make the fast one the default, people will love that
+programmer
+  id    = "jtag2";
+  desc  = "Atmel JTAG ICE mkII";
+  baudrate = 115200;
+  type  = jtagmkii;
+;
+
+# JTAG ICE mkII in ISP mode
+programmer
+  id    = "jtag2isp";
+  desc  = "Atmel JTAG ICE mkII in ISP mode";
+  baudrate = 115200;
+  type  = jtagmkii_isp;
+;
+
+# JTAG ICE mkII in debugWire mode
+programmer
+  id    = "jtag2dw";
+  desc  = "Atmel JTAG ICE mkII in debugWire mode";
+  baudrate = 115200;
+  type  = jtagmkii_dw;
+;
+
+# AVR Dragon in JTAG mode
+programmer
+  id    = "dragon_jtag";
+  desc  = "Atmel AVR Dragon in JTAG mode";
+  baudrate = 115200;
+  type  = dragon_jtag;
+;
+
+# AVR Dragon in ISP mode
+programmer
+  id    = "dragon_isp";
+  desc  = "Atmel AVR Dragon in ISP mode";
+  baudrate = 115200;
+  type  = dragon_isp;
+;
+
+# AVR Dragon in PP mode
+programmer
+  id    = "dragon_pp";
+  desc  = "Atmel AVR Dragon in PP mode";
+  baudrate = 115200;
+  type  = dragon_pp;
+;
+
+# AVR Dragon in HVSP mode
+programmer
+  id    = "dragon_hvsp";
+  desc  = "Atmel AVR Dragon in HVSP mode";
+  baudrate = 115200;
+  type  = dragon_hvsp;
+;
+
+# AVR Dragon in debugWire mode
+programmer
+  id    = "dragon_dw";
+  desc  = "Atmel AVR Dragon in debugWire mode";
+  baudrate = 115200;
+  type  = dragon_dw;
+;
+
+programmer
+  id    = "pavr";
+  desc  = "Jason Kyle's pAVR Serial Programmer";
+  type  = avr910;
+;
+
+# Parallel port programmers.
+
+programmer
+  id    = "bsd";
+  desc  = "Brian Dean's Programmer, http://www.bsdhome.com/avrdude/";
+  type  = par;
+  vcc   = 2, 3, 4, 5;
+  reset = 7;
+  sck   = 8;
+  mosi  = 9;
+  miso  = 10;
+;
+
+programmer
+  id    = "stk200";
+  desc  = "STK200";
+  type  = par;
+  buff  = 4, 5;
+  sck   = 6;
+  mosi  = 7;
+  reset = 9;
+  miso  = 10;
+;
+
+# The programming dongle used by the popular Ponyprog
+# utility.  It is almost similar to the STK200 one,
+# except that there is a LED indicating that the
+# programming is currently in progress.
+
+programmer
+  id    = "pony-stk200";
+  desc  = "Pony Prog STK200";
+  type  = par;
+  buff  = 4, 5;
+  sck   = 6;
+  mosi  = 7;
+  reset = 9;
+  miso  = 10;
+  pgmled = 8; 
+;
+
+programmer
+  id    = "dt006";
+  desc  = "Dontronics DT006";
+  type  = par;
+  reset = 4;
+  sck   = 5;
+  mosi  = 2;
+  miso  = 11;
+;
+
+programmer
+  id    = "bascom";
+  desc  = "Bascom SAMPLE programming cable";
+  type  = par;
+  reset = 4;
+  sck   = 5;
+  mosi  = 2;
+  miso  = 11;
+;
+
+programmer
+  id     = "alf";
+  desc   = "Nightshade ALF-PgmAVR, http://nightshade.homeip.net/";
+  type   = par;
+  vcc    = 2, 3, 4, 5;
+  buff   = 6;
+  reset  = 7;
+  sck    = 8;
+  mosi   = 9;
+  miso   = 10;
+  errled = 1;
+  rdyled = 14;
+  pgmled = 16;
+  vfyled = 17;
+;
+
+programmer
+  id    = "sp12";
+  desc  = "Steve Bolt's Programmer";
+  type  = par;
+  vcc   = 4,5,6,7,8;
+  reset = 3;
+  sck   = 2;
+  mosi  = 9;
+  miso  = 11;
+;
+
+programmer
+  id     = "picoweb";
+  desc   = "Picoweb Programming Cable, http://www.picoweb.net/";
+  type   = par;
+  reset  = 2;
+  sck    = 3;
+  mosi   = 4;
+  miso   = 13;
+;
+
+programmer
+  id    = "abcmini";
+  desc  = "ABCmini Board, aka Dick Smith HOTCHIP";
+  type  = par;
+  reset = 4;
+  sck   = 3;
+  mosi  = 2;
+  miso  = 10;
+;
+
+programmer
+  id    = "futurlec";
+  desc  = "Futurlec.com programming cable.";
+  type  = par;
+  reset = 3;
+  sck   = 2;
+  mosi  = 1;
+  miso  = 10;
+;
+
+
+# From the contributor of the "xil" jtag cable:
+# The "vcc" definition isn't really vcc (the cable gets its power from
+# the programming circuit) but is necessary to switch one of the
+# buffer lines (trying to add it to the "buff" lines doesn't work).
+# With this, TMS connects to RESET, TDI to MOSI, TDO to MISO and TCK
+# to SCK (plus vcc/gnd of course)
+programmer
+  id    = "xil";
+  desc  = "Xilinx JTAG cable";
+  type  = par;
+  mosi  = 2;
+  sck   = 3;
+  reset = 4;
+  buff  = 5;
+  miso  = 13;
+  vcc   = 6;
+;
+
+
+programmer
+  id = "dapa";
+  desc = "Direct AVR Parallel Access cable";
+  type = par;
+  vcc   = 3;
+  reset = 16;
+  sck = 1;
+  mosi = 2;
+  miso = 11;
+;
+
+programmer
+  id    = "atisp";
+  desc  = "AT-ISP V1.1 programming cable for AVR-SDK1 from <http://micro-research.co.th/> micro-research.co.th";
+  type  = par;
+  reset = ~6;
+  sck   = ~8;
+  mosi  = ~7;
+  miso  = ~10;
+;
+
+programmer
+  id    = "ere-isp-avr";
+  desc  = "ERE ISP-AVR <http://www.ere.co.th/download/sch050713.pdf>";
+  type  = par;
+  reset = ~4;
+  sck   = 3;
+  mosi  = 2;
+  miso  = 10;
+;
+
+programmer
+  id    = "blaster";
+  desc  = "Altera ByteBlaster";
+  type  = par;
+  sck   = 2;
+  miso  = 11;
+  reset = 3;
+  mosi  = 8;
+  buff  = 14;
+;
+
+# It is almost same as pony-stk200, except vcc on pin 5 to auto
+# disconnect port (download on http://electropol.free.fr)
+programmer
+  id    = "frank-stk200";
+  desc  = "Frank STK200";
+  type  = par;
+  vcc   = 5;
+  sck   = 6;
+  mosi  = 7;
+  reset = 9;
+  miso  = 10;
+  pgmled = 8;
+;
+
+
+#
+# some ultra cheap programmers use bitbanging on the 
+# serialport.
+#
+# PC - DB9 - Pins for RS232:
+#
+# GND   5   -- |O
+#              |   O| <-   9   RI
+# DTR   4   <- |O   |
+#              |   O| <-   8   CTS
+# TXD   3   <- |O   |
+#              |   O| ->   7   RTS
+# RXD   2   -> |O   |
+#              |   O| <-   6   DSR
+# DCD   1   -> |O
+#
+# Using RXD is currently not supported.
+# Using RI is not supported under Win32 but is supported under Posix.
+
+# serial ponyprog design (dasa2 in uisp)
+# reset=!txd sck=rts mosi=dtr miso=cts
+
+programmer
+  id    = "ponyser";
+  desc  = "design ponyprog serial, reset=!txd sck=rts mosi=dtr miso=cts";
+  type  = serbb;
+  reset = ~3;
+  sck   = 7;
+  mosi  = 4;
+  miso  = 8;
+;
+
+# Same as above, different name
+# reset=!txd sck=rts mosi=dtr miso=cts
+
+programmer
+  id    = "siprog";
+  desc  = "Lancos SI-Prog <http://www.lancos.com/siprogsch.html>";
+  type  = serbb;
+  reset = ~3;
+  sck   = 7;
+  mosi  = 4;
+  miso  = 8;
+;
+
+# unknown (dasa in uisp)
+# reset=rts sck=dtr mosi=txd miso=cts
+
+programmer
+  id    = "dasa";
+  desc  = "serial port banging, reset=rts sck=dtr mosi=txd miso=cts";
+  type  = serbb;
+  reset = 7;
+  sck   = 4;
+  mosi  = 3;
+  miso  = 8;
+;
+
+# unknown (dasa3 in uisp)
+# reset=!dtr sck=rts mosi=txd miso=cts
+
+programmer
+  id    = "dasa3";
+  desc  = "serial port banging, reset=!dtr sck=rts mosi=txd miso=cts";
+  type  = serbb;
+  reset = ~4;
+  sck   = 7;
+  mosi  = 3;
+  miso  = 8;
+;
+
+#
+# PART DEFINITIONS
+#
+
+#------------------------------------------------------------
+# ATtiny11
+#------------------------------------------------------------
+
+# This is an HVSP-only device.
+
+part
+    id                  = "t11";
+    desc                = "ATtiny11";
+    stk500_devcode      = 0x11;
+    signature           = 0x1e 0x90 0x04;
+    chip_erase_delay    = 20000;
+
+    timeout		= 200;
+    hvsp_controlstack     =
+        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x00,
+        0x68, 0x78, 0x68, 0x68, 0x00, 0x00, 0x68, 0x78,
+        0x78, 0x00, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
+        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    hvspcmdexedelay     = 0;
+    synchcycles         = 6;
+    latchcycles         = 1;
+    togglevtg           = 1;
+    poweroffdelay       = 25;
+    resetdelayms        = 0;
+    resetdelayus        = 50;
+    hvleavestabdelay    = 100;
+    resetdelay          = 25;
+    chiperasepolltimeout = 40;
+    chiperasetime       = 0;
+    programfusepolltimeout = 25;
+    programlockpolltimeout = 25;
+
+    memory "eeprom"
+        size            = 64;
+	blocksize	= 64;
+	readsize	= 256;
+	delay		= 5;
+    ;
+
+    memory "flash"
+        size            = 1024;
+	blocksize	= 128;
+	readsize	= 256;
+	delay		= 3;
+    ;
+
+    memory "signature"
+        size            = 3;
+    ;
+
+    memory "lock"
+        size            = 1;
+    ;
+
+    memory "calibration"
+        size            = 1;
+    ;
+
+    memory "fuse"
+        size            = 1;
+    ;
+;
+
+#------------------------------------------------------------
+# ATtiny12
+#------------------------------------------------------------
+
+part
+    id                  = "t12";
+    desc                = "ATtiny12";
+    stk500_devcode      = 0x12;
+    avr910_devcode      = 0x55;
+    signature           = 0x1e 0x90 0x05;
+    chip_erase_delay    = 20000;
+    pgm_enable          = "1 0 1 0  1 1 0 0   0 1 0 1  0 0 1 1",
+                          "x x x x  x x x x   x x x x  x x x x";
+
+    chip_erase          = "1 0 1 0  1 1 0 0   1 0 0 x  x x x x",
+                          "x x x x  x x x x   x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    hvsp_controlstack   =
+        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x00,
+        0x68, 0x78, 0x68, 0x68, 0x00, 0x00, 0x68, 0x78,
+        0x78, 0x00, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
+        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
+    hventerstabdelay    = 100;
+    hvspcmdexedelay     = 0;
+    synchcycles         = 6;
+    latchcycles         = 1;
+    togglevtg           = 1;
+    poweroffdelay       = 25;
+    resetdelayms        = 0;
+    resetdelayus        = 50;
+    hvleavestabdelay    = 100;
+    resetdelay          = 25;
+    chiperasepolltimeout = 40;
+    chiperasetime       = 0;
+    programfusepolltimeout = 25;
+    programlockpolltimeout = 25;
+
+    memory "eeprom"
+        size            = 64;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read            = "1  0  1  0   0  0  0  0    x x x x  x x x x",
+                          "x  x a5 a4  a3 a2 a1 a0    o o o o  o o o o";
+
+        write           = "1  1  0  0   0  0  0  0    x x x x  x x x x",
+                          "x  x a5 a4  a3 a2 a1 a0    i i i i  i i i i";
+
+	mode		= 0x04;
+	delay		= 8;
+	blocksize	= 64;
+	readsize	= 256;
+    ;
+
+    memory "flash"
+        size            = 1024;
+        min_write_delay = 4500;
+        max_write_delay = 20000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0  0  1  0   0  0  0  0",
+                          "  x  x  x  x   x  x  x a8",
+                          " a7 a6 a5 a4  a3 a2 a1 a0",
+                          "  o  o  o  o   o  o  o  o";
+
+        read_hi         = "  0  0  1  0   1  0  0  0",
+                          "  x  x  x  x   x  x  x a8",
+                          " a7 a6 a5 a4  a3 a2 a1 a0",
+                          "  o  o  o  o   o  o  o  o";
+
+        write_lo        = "  0  1  0  0   0  0  0  0",
+                          "  x  x  x  x   x  x  x a8",
+                          " a7 a6 a5 a4  a3 a2 a1 a0",
+                          "  i  i  i  i   i  i  i  i";
+
+        write_hi        = "  0  1  0  0   1  0  0  0",
+                          "  x  x  x  x   x  x  x a8",
+                          " a7 a6 a5 a4  a3 a2 a1 a0",
+                          "  i  i  i  i   i  i  i  i";
+
+	mode		= 0x04;
+	delay		= 5;
+	blocksize	= 128;
+	readsize	= 256;
+    ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0    x x x x  x x x x",
+                          "0  0  0  0   0  0 a1 a0    o o o o  o o o o";
+    ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0  1  0  1   1  0  0  0    x x x x  x x x x",
+                          "x  x  x  x   x  x  x  x    x x x x  x o o x";
+
+        write           = "1  0  1  0   1  1  0  0    1 1 1 1  1 i i 1",
+                          "x  x  x  x   x  x  x  x    x x x x  x x x x";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+    ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0  0  1  1   1  0  0  0    x x x x  x x x x",
+                          "0  0  0  0   0  0  0  0    o o o o  o o o o";
+    ;
+
+    memory "fuse"
+        size            = 1;
+        read            = "0  1  0  1   0  0  0  0    x x x x  x x x x",
+                          "x  x  x  x   x  x  x  x    o o o o  o o o o";
+
+        write           = "1  0  1  0   1  1  0  0    1 0 1 x  x x x x",
+                          "x  x  x  x   x  x  x  x    i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+    ;
+;
+
+#------------------------------------------------------------
+# ATtiny13
+#------------------------------------------------------------
+
+part
+    id                  = "t13";
+    desc                = "ATtiny13";
+     has_debugwire = yes;
+     flash_instr   = 0xB4, 0x0E, 0x1E;
+     eeprom_instr  = 0xBB, 0xFE, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
+	             0xBC, 0x0E, 0xB4, 0x0E, 0xBA, 0x0D, 0xBB, 0xBC,
+	             0x99, 0xE1, 0xBB, 0xAC;
+    stk500_devcode      = 0x14;
+    signature           = 0x1e 0x90 0x07;
+    chip_erase_delay    = 4000;
+    pgm_enable          = "1 0 1 0  1 1 0 0   0 1 0 1  0 0 1 1",
+                          "x x x x  x x x x   x x x x  x x x x";
+
+    chip_erase          = "1 0 1 0  1 1 0 0   1 0 0 x  x x x x",
+                          "x x x x  x x x x   x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    hvsp_controlstack     =
+	0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
+        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
+        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
+        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    hvspcmdexedelay     = 0;
+    synchcycles         = 6;
+    latchcycles         = 1;
+    togglevtg           = 1;
+    poweroffdelay       = 25;
+    resetdelayms        = 0;
+    resetdelayus        = 90;
+    hvleavestabdelay    = 100;
+    resetdelay          = 25;
+    chiperasepolltimeout = 40;
+    chiperasetime       = 0;
+    programfusepolltimeout = 25;
+    programlockpolltimeout = 25;
+
+    memory "eeprom"
+        size            = 64;
+        page_size       = 4;
+        min_write_delay = 4000;
+        max_write_delay = 4000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read            = "1  0  1  0   0  0  0  0    0 0 0 x  x x x x",
+                          "x  x a5 a4  a3 a2 a1 a0    o o o o  o o o o";
+
+        write           = "1  1  0  0   0  0  0  0    0 0 0 x  x x x x",
+                          "x  x a5 a4  a3 a2 a1 a0    i i i i  i i i i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x   x",
+			  "  x   x  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 5;
+	blocksize	= 4;
+	readsize	= 256;
+    ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 1024;
+        page_size       = 32;
+        num_pages       = 32;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0  0  1  0   0  0  0  0",
+                          "  0  0  0  0   0  0  0 a8",
+                          " a7 a6 a5 a4  a3 a2 a1 a0",
+                          "  o  o  o  o   o  o  o  o";
+
+        read_hi         = "  0  0  1  0   1  0  0  0",
+                          "  0  0  0  0   0  0  0 a8",
+                          " a7 a6 a5 a4  a3 a2 a1 a0",
+                          "  o  o  o  o   o  o  o  o";
+
+        loadpage_lo     = "  0  1  0  0   0  0  0  0",
+                          "  0  0  0  x   x  x  x  x",
+                          "  x  x  x  x  a3 a2 a1 a0",
+                          "  i  i  i  i   i  i  i  i";
+
+        loadpage_hi     = "  0  1  0  0   1  0  0  0",
+                          "  0  0  0  x   x  x  x  x",
+                          "  x  x  x  x  a3 a2 a1 a0",
+                          "  i  i  i  i   i  i  i  i";
+
+        writepage       = "  0  1  0  0   1  1  0  0",
+                          "  0  0  0  0   0  0  0 a8",
+                          " a7 a6 a5 a4   x  x  x  x",
+                          "  x  x  x  x   x  x  x  x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 32;
+	readsize	= 256;
+    ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0    0 0 0 x  x x x x",
+                          "x  x  x  x   x  x a1 a0    o o o o  o o o o";
+    ;
+
+    memory "lock"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+
+	read            = "0  1  0  1   1  0  0  0    0 0 0 0  0 0 0 0",
+                          "x  x  x  x   x  x  x  x    x x o o  o o o o";
+
+        write           = "1  0  1  0   1  1  0  0    1 1 1 x  x x x x",
+                          "x  x  x  x   x  x  x  x    1 1 i i  i i i i";
+    ;
+
+    memory "calibration"
+        size            = 2;
+        read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
+                          "0  0  0  0   0  0  0 a0    o o o o  o o o o";
+    ;
+
+    memory "lfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+      ;
+
+;
+
+
+#------------------------------------------------------------
+# ATtiny15
+#------------------------------------------------------------
+
+part
+    id                  = "t15";
+    desc                = "ATtiny15";
+    stk500_devcode      = 0x13;
+    avr910_devcode      = 0x56;
+    signature           = 0x1e 0x90 0x06;
+    chip_erase_delay    = 8200;
+    pgm_enable          = "1 0 1 0  1 1 0 0   0 1 0 1  0 0 1 1",
+                          "x x x x  x x x x   x x x x  x x x x";
+
+    chip_erase          = "1 0 1 0  1 1 0 0   1 0 0 x  x x x x",
+                          "x x x x  x x x x   x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    hvsp_controlstack   =
+        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x00,
+        0x68, 0x78, 0x68, 0x68, 0x00, 0x00, 0x68, 0x78,
+        0x78, 0x00, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
+        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
+    hventerstabdelay    = 100;
+    hvspcmdexedelay     = 5;
+    synchcycles         = 6;
+    latchcycles         = 16;
+    togglevtg           = 1;
+    poweroffdelay       = 25;
+    resetdelayms        = 0;
+    resetdelayus        = 50;
+    hvleavestabdelay    = 100;
+    resetdelay          = 25;
+    chiperasepolltimeout = 40;
+    chiperasetime       = 0;
+    programfusepolltimeout = 25;
+    programlockpolltimeout = 25;
+
+    memory "eeprom"
+        size            = 64;
+        min_write_delay = 8200;
+        max_write_delay = 8200;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read            = "1  0  1  0   0  0  0  0    x x x x  x x x x",
+                          "x  x a5 a4  a3 a2 a1 a0    o o o o  o o o o";
+
+        write           = "1  1  0  0   0  0  0  0    x x x x  x x x x",
+                          "x  x a5 a4  a3 a2 a1 a0    i i i i  i i i i";
+
+	mode		= 0x04;
+	delay		= 10;
+	blocksize	= 64;
+	readsize	= 256;
+    ;
+
+    memory "flash"
+        size            = 1024;
+        min_write_delay = 4100;
+        max_write_delay = 4100;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0  0  1  0   0  0  0  0",
+                          "  x  x  x  x   x  x  x a8",
+                          " a7 a6 a5 a4  a3 a2 a1 a0",
+                          "  o  o  o  o   o  o  o  o";
+
+        read_hi         = "  0  0  1  0   1  0  0  0",
+                          "  x  x  x  x   x  x  x a8",
+                          " a7 a6 a5 a4  a3 a2 a1 a0",
+                          "  o  o  o  o   o  o  o  o";
+
+        write_lo        = "  0  1  0  0   0  0  0  0",
+                          "  x  x  x  x   x  x  x a8",
+                          " a7 a6 a5 a4  a3 a2 a1 a0",
+                          "  i  i  i  i   i  i  i  i";
+
+        write_hi        = "  0  1  0  0   1  0  0  0",
+                          "  x  x  x  x   x  x  x a8",
+                          " a7 a6 a5 a4  a3 a2 a1 a0",
+                          "  i  i  i  i   i  i  i  i";
+
+	mode		= 0x04;
+	delay		= 5;
+	blocksize	= 128;
+	readsize	= 256;
+    ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0    x x x x  x x x x",
+                          "0  0  0  0   0  0 a1 a0    o o o o  o o o o";
+    ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0  1  0  1   1  0  0  0    x x x x  x x x x",
+                          "x  x  x  x   x  x  x  x    x x x x  x o o x";
+
+        write           = "1  0  1  0   1  1  0  0    1 1 1 1  1 i i 1",
+                          "x  x  x  x   x  x  x  x    x x x x  x x x x";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+    ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0  0  1  1   1  0  0  0    x x x x  x x x x",
+                          "0  0  0  0   0  0  0  0    o o o o  o o o o";
+    ;
+
+    memory "fuse"
+        size            = 1;
+        read            = "0  1  0  1   0  0  0  0    x x x x  x x x x",
+                          "x  x  x  x   x  x  x  x    o o o o  x x o o";
+
+        write           = "1  0  1  0   1  1  0  0    1 0 1 x  x x x x",
+                          "x  x  x  x   x  x  x  x    i i i i  1 1 i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+    ;
+;
+
+#------------------------------------------------------------
+# AT90s1200
+#------------------------------------------------------------
+
+part
+    id               = "1200";
+    desc             = "AT90S1200";
+    stk500_devcode   = 0x33;
+    avr910_devcode   = 0x13;
+    signature        = 0x1e 0x90 0x01;
+    pagel            = 0xd7;
+    bs2              = 0xa0;
+    chip_erase_delay = 20000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 1;
+    bytedelay		= 0;
+    pollindex		= 0;
+    pollvalue		= 0xFF;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 0;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 15;
+    chiperasepolltimeout = 0;
+    programfusepulsewidth = 2;
+    programfusepolltimeout = 0;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 1;
+
+    memory "eeprom"
+        size            = 64;
+        min_write_delay = 4000;
+        max_write_delay = 9000;
+        readback_p1     = 0x00;
+        readback_p2     = 0xff;
+        read            = "1 0  1  0   0  0  0  0   x x x x  x x x x", 
+                          "x x a5 a4  a3 a2 a1 a0   o o o o  o o o o";
+
+        write           = "1 1  0  0   0  0  0  0   x x x x  x x x x",
+                          "x x a5 a4  a3 a2 a1 a0   i i i i  i i i i";
+
+	mode		= 0x04;
+	delay		= 20;
+	blocksize	= 32;
+	readsize	= 256;
+      ;
+    memory "flash"
+        size            = 1024;
+        min_write_delay = 4000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0    0   0   0   0",
+                          "  x   x   x   x    x   x   x  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        read_hi         = "  0   0   1   0    1   0   0   0",
+                          "  x   x   x   x    x   x   x  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        write_lo        = "  0   1   0   0    0   0   0   0",
+                          "  x   x   x   x    x   x   x  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+
+        write_hi        = "  0   1   0   0    1   0   0   0",
+                          "  x   x   x   x    x   x   x  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+
+	mode		= 0x02;
+	delay		= 15;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+    memory "fuse"
+        size            = 1;
+      ;
+    memory "lock"
+        size            = 1;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        write           = "1 0 1 0  1 1 0 0   1 1 1 1  1 i i 1",
+                          "x x x x  x x x x   x x x x  x x x x";
+      ;
+  ;
+
+#------------------------------------------------------------
+# AT90s4414
+#------------------------------------------------------------
+
+part
+    id               = "4414";
+    desc             = "AT90S4414";
+    stk500_devcode   = 0x50;
+    avr910_devcode   = 0x28;
+    signature        = 0x1e 0x92 0x01;
+    chip_erase_delay = 20000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 0;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 15;
+    chiperasepolltimeout = 0;
+    programfusepulsewidth = 2;
+    programfusepolltimeout = 0;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 1;
+
+    memory "eeprom"
+        size            = 256;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        readback_p1     = 0x80;
+        readback_p2     = 0x7f;
+        read            = " 1  0  1  0   0  0  0  0  x x x x  x x x a8", 
+                          "a7 a6 a5 a4 a3 a2 a1 a0   o o o o  o o o o";
+
+        write           = " 1  1  0  0   0  0  0  0   x x x x  x x x a8",
+                          "a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
+
+	mode		= 0x04;
+	delay		= 12;
+	blocksize	= 64;
+	readsize	= 256;
+      ;
+    memory "flash"
+        size            = 4096;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        readback_p1     = 0x7f;
+        readback_p2     = 0x7f;
+        read_lo         = "  0   0   1   0    0   0   0   0",
+                          "  x   x   x   x  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        read_hi         = "  0   0   1   0    1   0   0   0",
+                          "  x   x   x   x  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        write_lo        = "  0   1   0   0    0   0   0   0",
+                          "  x   x   x   x  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+
+        write_hi        = "  0   1   0   0    1   0   0   0",
+                          "  x   x   x   x  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+
+	mode		= 0x04;
+	delay		= 12;
+	blocksize	= 64;
+	readsize	= 256;
+      ;
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+    memory "fuse"
+	size		= 1;
+      ;
+    memory "lock"
+	size		= 1;
+	write		= "1  0  1  0   1  1  0  0   1  1  1  1   1  i  i  1",
+			  "x  x  x  x   x  x  x  x   x  x  x  x   x  x  x  x";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+  ;
+
+#------------------------------------------------------------
+# AT90s2313
+#------------------------------------------------------------
+
+part
+    id               = "2313";
+    desc             = "AT90S2313";
+    stk500_devcode   = 0x40;
+    avr910_devcode   = 0x20;
+    signature        = 0x1e 0x91 0x01;
+    chip_erase_delay = 20000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 0;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 15;
+    chiperasepolltimeout = 0;
+    programfusepulsewidth = 2;
+    programfusepolltimeout = 0;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 1;
+
+    memory "eeprom"
+        size            = 128;
+        min_write_delay = 4000;
+        max_write_delay = 9000;
+        readback_p1     = 0x80;
+        readback_p2     = 0x7f;
+        read            = "1  0  1  0   0  0  0  0   x x x x  x x x x", 
+                          "x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
+
+        write           = "1  1  0  0   0  0  0  0   x x x x  x x x x",
+                          "x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
+
+	mode		= 0x04;
+	delay		= 12;
+	blocksize	= 64;
+	readsize	= 256;
+      ;
+    memory "flash"
+        size            = 2048;
+        min_write_delay = 4000;
+        max_write_delay = 9000;
+        readback_p1     = 0x7f;
+        readback_p2     = 0x7f;
+        read_lo         = "  0   0   1   0    0   0   0   0",
+                          "  x   x   x   x    x   x  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        read_hi         = "  0   0   1   0    1   0   0   0",
+                          "  x   x   x   x    x   x  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        write_lo        = "  0   1   0   0    0   0   0   0",
+                          "  x   x   x   x    x   x  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+
+        write_hi        = "  0   1   0   0    1   0   0   0",
+                          "  x   x   x   x    x   x  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+
+	mode		= 0x04;
+	delay		= 12;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+    memory "fuse"
+        size            = 1;
+      ;
+    memory "lock"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 1 1 x  x i i x",
+                          "x x x x  x x x x  x x x x  x x x x";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+  ;
+
+#------------------------------------------------------------
+# AT90s2333
+#------------------------------------------------------------
+
+part
+    id               = "2333";
+##### WARNING: No XML file for device 'AT90S2333'! #####
+    desc             = "AT90S2333";
+    stk500_devcode   = 0x42;
+    avr910_devcode   = 0x34;
+    signature        = 0x1e 0x91 0x05;
+    chip_erase_delay = 20000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    memory "eeprom"
+        size            = 128;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        readback_p1     = 0x00;
+        readback_p2     = 0xff;
+        read            = "1  0  1  0   0  0  0  0   x x x x  x x x x", 
+                          "x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
+
+        write           = "1  1  0  0   0  0  0  0   x x x x  x x x x",
+                          "x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
+      ;
+    memory "flash"
+        size            = 2048;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0    0   0   0   0",
+                          "  x   x   x   x    x   x  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        read_hi         = "  0   0   1   0    1   0   0   0",
+                          "  x   x   x   x    x   x  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        write_lo        = "  0   1   0   0    0   0   0   0",
+                          "  x   x   x   x    x   x  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+
+        write_hi        = "  0   1   0   0    1   0   0   0",
+                          "  x   x   x   x    x   x  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+      ;
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+    memory "fuse"
+        size            = 1;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        pwroff_after_write = yes;
+        read            = "0 1 0 1  0 0 0 0   x x x x  x x x x",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 i  i i i i",
+                          "x x x x  x x x x   x x x x  x x x x";
+      ;
+    memory "lock"
+        size            = 1;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        read            = "0 1 0 1  1 0 0 0   x x x x  x x x x",
+                          "x x x x  x x x x   x x x x  x o o x";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 1  1 i i 1",
+                          "x x x x  x x x x   x x x x  x x x x";
+      ;
+  ;
+
+#------------------------------------------------------------
+# ATmega1284P
+#------------------------------------------------------------
+
+# similar to ATmega164p
+
+part
+    id               = "m1284p";
+    desc             = "ATMEGA1284P";
+    has_jtag         = yes;
+    stk500_devcode   = 0x82; # no STK500v1 support, use the ATmega16 one
+    avr910_devcode   = 0x74;
+    signature        = 0x1e 0x97 0x05;
+    pagel            = 0xd7;
+    bs2              = 0xa0;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 6;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 4096;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0  a2  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x    a11 a10  a9  a8",
+			  " a7  a6  a5  a4     a3   0   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 131072;
+        page_size       = 256;
+        num_pages       = 512;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  1 1 1 1  1 i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "calibration"
+        size            = 1;
+
+        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+        ;
+  ;
+
+#------------------------------------------------------------
+# AT90s2343 (also AT90s2323 and ATtiny22)
+#------------------------------------------------------------
+
+part
+    id               = "2343";
+    desc             = "AT90S2343";
+    stk500_devcode   = 0x43;
+    avr910_devcode   = 0x4c;
+    signature        = 0x1e 0x91 0x03;
+    chip_erase_delay = 18000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    hvsp_controlstack   =
+        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x00,
+        0x68, 0x78, 0x68, 0x68, 0x00, 0x00, 0x68, 0x78,
+        0x78, 0x00, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
+        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
+    hventerstabdelay    = 100;
+    hvspcmdexedelay     = 0;
+    synchcycles         = 6;
+    latchcycles         = 1;
+    togglevtg           = 0;
+    poweroffdelay       = 25;
+    resetdelayms        = 0;
+    resetdelayus        = 50;
+    hvleavestabdelay    = 100;
+    resetdelay          = 25;
+    chiperasepolltimeout = 40;
+    chiperasetime       = 0;
+    programfusepolltimeout = 25;
+    programlockpolltimeout = 25;
+
+    memory "eeprom"
+        size            = 128;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        readback_p1     = 0x00;
+        readback_p2     = 0xff;
+        read            = "1  0  1  0   0  0  0  0   0 0 0 0  0 0 0 0", 
+                          "x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
+
+        write           = "1  1  0  0   0  0  0  0   0 0 0 0  0 0 0 0",
+                          "x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
+
+	mode		= 0x04;
+	delay		= 12;
+	blocksize	= 64;
+	readsize	= 256;
+      ;
+    memory "flash"
+        size            = 2048;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0    0   0   0   0",
+                          "  x   x   x   x    x   x  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        read_hi         = "  0   0   1   0    1   0   0   0",
+                          "  x   x   x   x    x   x  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        write_lo        = "  0   1   0   0    0   0   0   0",
+                          "  x   x   x   x    x   x  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+
+        write_hi        = "  0   1   0   0    1   0   0   0",
+                          "  x   x   x   x    x   x  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+
+	mode		= 0x04;
+	delay		= 12;
+	blocksize	= 128;
+	readsize	= 128;
+      ;
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+    memory "fuse"
+        size            = 1;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        read            = "0 1 0 1  1 0 0 0   x x x x  x x x x",
+                          "x x x x  x x x x   o o o x  x x x o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 1  1 1 1 i",
+                          "x x x x  x x x x   x x x x  x x x x";
+      ;
+    memory "lock"
+        size            = 1;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        read            = "0 1 0 1  1 0 0 0   x x x x  x x x x",
+                          "x x x x  x x x x   o o o x  x x x o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 1  1 i i 1",
+                          "x x x x  x x x x   x x x x  x x x x";
+      ;
+  ;
+
+
+#------------------------------------------------------------
+# AT90s4433
+#------------------------------------------------------------
+
+part
+    id               = "4433";
+    desc             = "AT90S4433";
+    stk500_devcode   = 0x51;
+    avr910_devcode   = 0x30;
+    signature        = 0x1e 0x92 0x03;
+    chip_erase_delay = 20000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 0;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 15;
+    chiperasepolltimeout = 0;
+    programfusepulsewidth = 2;
+    programfusepolltimeout = 0;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 1;
+
+    memory "eeprom"
+        size            = 256;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        readback_p1     = 0x00;
+        readback_p2     = 0xff;
+        read            = " 1  0  1  0   0  0  0  0   x x x x  x x x x", 
+                          "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
+
+        write           = " 1  1  0  0   0  0  0  0   x x x x  x x x x",
+                          "a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
+
+	mode		= 0x04;
+	delay		= 12;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+    memory "flash"
+        size            = 4096;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0    0   0   0   0",
+                          "  x   x   x   x    x a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        read_hi         = "  0   0   1   0    1   0   0   0",
+                          "  x   x   x   x    x a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        write_lo        = "  0   1   0   0    0   0   0   0",
+                          "  x   x   x   x    x a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+
+        write_hi        = "  0   1   0   0    1   0   0   0",
+                          "  x   x   x   x    x a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+
+	mode		= 0x04;
+	delay		= 12;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+    memory "fuse"
+        size            = 1;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        pwroff_after_write = yes;
+        read            = "0 1 0 1  0 0 0 0   x x x x  x x x x",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 i  i i i i",
+                          "x x x x  x x x x   x x x x  x x x x";
+      ;
+    memory "lock"
+        size            = 1;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        read            = "0 1 0 1  1 0 0 0   x x x x  x x x x",
+                          "x x x x  x x x x   x x x x  x o o x";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 1  1 i i 1",
+                          "x x x x  x x x x   x x x x  x x x x";
+      ;
+  ;
+
+#------------------------------------------------------------
+# AT90s4434
+#------------------------------------------------------------
+
+part
+    id               = "4434";
+##### WARNING: No XML file for device 'AT90S4434'! #####
+    desc             = "AT90S4434";
+    stk500_devcode   = 0x52;
+    avr910_devcode   = 0x6c;
+    signature        = 0x1e 0x92 0x02;
+    chip_erase_delay = 20000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    memory "eeprom"
+        size            = 256;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        readback_p1     = 0x00;
+        readback_p2     = 0xff;
+        read            = " 1  0  1  0   0  0  0  0   x x x x  x x x x", 
+                          "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
+
+        write           = " 1  1  0  0   0  0  0  0   x x x x  x x x x",
+                          "a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
+      ;
+    memory "flash"
+        size            = 4096;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0    0   0   0   0",
+                          "  x   x   x   x    x a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        read_hi         = "  0   0   1   0    1   0   0   0",
+                          "  x   x   x   x    x a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        write_lo        = "  0   1   0   0    0   0   0   0",
+                          "  x   x   x   x    x a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+
+        write_hi        = "  0   1   0   0    1   0   0   0",
+                          "  x   x   x   x    x a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+      ;
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+    memory "fuse"
+        size            = 1;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        read            = "0 1 0 1  0 0 0 0   x x x x  x x x x",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 i  i i i i",
+                          "x x x x  x x x x   x x x x  x x x x";
+      ;
+    memory "lock"
+        size            = 1;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        read            = "0 1 0 1  1 0 0 0   x x x x  x x x x",
+                          "x x x x  x x x x   x x x x  x o o x";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 1  1 i i 1",
+                          "x x x x  x x x x   x x x x  x x x x";
+      ;
+  ;
+
+#------------------------------------------------------------
+# AT90s8515
+#------------------------------------------------------------
+
+part
+    id               = "8515";
+    desc             = "AT90S8515";
+    stk500_devcode   = 0x60;
+    avr910_devcode   = 0x38;
+    signature        = 0x1e 0x93 0x01;
+    chip_erase_delay = 20000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+	0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+	0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+	0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+	0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 0;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    resetdelay          = 15;
+    chiperasepulsewidth = 15;
+    chiperasepolltimeout = 0;
+    programfusepulsewidth = 2;
+    programfusepolltimeout = 0;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 1;
+
+    memory "eeprom"
+        size            = 512;
+        min_write_delay = 4000;
+        max_write_delay = 9000;
+        readback_p1     = 0x80;
+        readback_p2     = 0x7f;
+        read            = " 1  0  1  0   0  0  0  0  x x x x  x x x a8", 
+                          "a7 a6 a5 a4 a3 a2 a1 a0   o o o o  o o o o";
+
+        write           = " 1  1  0  0   0  0  0  0   x x x x  x x x a8",
+                          "a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
+
+	mode		= 0x04;
+	delay		= 12;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+    memory "flash"
+        size            = 8192;
+        min_write_delay = 4000;
+        max_write_delay = 9000;
+        readback_p1     = 0x7f;
+        readback_p2     = 0x7f;
+        read_lo         = "  0   0   1   0    0   0   0   0",
+                          "  x   x   x   x  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        read_hi         = "  0   0   1   0    1   0   0   0",
+                          "  x   x   x   x  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        write_lo        = "  0   1   0   0    0   0   0   0",
+                          "  x   x   x   x  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+
+        write_hi        = "  0   1   0   0    1   0   0   0",
+                          "  x   x   x   x  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+
+	mode		= 0x04;
+	delay		= 12;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+    memory "fuse"
+	size		= 1;
+      ;
+    memory "lock"
+	size		= 1;
+	write		= "1  0  1  0   1  1  0  0   1  1  1  1   1  i  i  1",
+			  "x  x  x  x   x  x  x  x   x  x  x  x   x  x  x  x";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+  ;
+
+#------------------------------------------------------------
+# AT90s8535
+#------------------------------------------------------------
+
+part
+    id               = "8535";
+    desc             = "AT90S8535";
+    stk500_devcode   = 0x61;
+    avr910_devcode   = 0x68;
+    signature        = 0x1e 0x93 0x03;
+    chip_erase_delay = 20000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 0;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 15;
+    chiperasepolltimeout = 0;
+    programfusepulsewidth = 2;
+    programfusepolltimeout = 0;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 1;
+
+    memory "eeprom"
+        size            = 512;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        readback_p1     = 0x00;
+        readback_p2     = 0xff;
+        read            = " 1  0  1  0   0  0  0  0   x x x x  x x x a8", 
+                          "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
+
+        write           = " 1  1  0  0   0  0  0  0   x x x x  x x x a8",
+                          "a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
+
+	mode		= 0x04;
+	delay		= 12;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+    memory "flash"
+        size            = 8192;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0    0   0   0   0",
+                          "  x   x   x   x  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        read_hi         = "  0   0   1   0    1   0   0   0",
+                          "  x   x   x   x  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        write_lo        = "  0   1   0   0    0   0   0   0",
+                          "  x   x   x   x  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+
+        write_hi        = "  0   1   0   0    1   0   0   0",
+                          "  x   x   x   x  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+
+	mode		= 0x04;
+	delay		= 12;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+    memory "fuse"
+	size		= 1;
+	read		= "0  1  0  1   1  0  0  0   x  x  x  x   x  x  x  x",
+			  "x  x  x  x   x  x  x  x   x  x  x  x   x  x  x  o";
+	write		= "1  0  1  0   1  1  0  0   1  0  1  1   1  1  1  i",
+			  "x  x  x  x   x  x  x  x   x  x  x  x   x  x  x  x";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+    memory "lock"
+	size		= 1;
+	read		= "0  1  0  1   1  0  0  0   x  x  x  x   x  x  x  x",
+			  "x  x  x  x   x  x  x  x   o  o  x  x   x  x  x  x";
+	write		= "1  0  1  0   1  1  0  0   1  1  1  1   1  i  i  1",
+			  "x  x  x  x   x  x  x  x   x  x  x  x   x  x  x  x";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+  ;
+
+#------------------------------------------------------------
+# ATmega103
+#------------------------------------------------------------
+
+part
+    id               = "m103";
+    desc             = "ATMEGA103";
+    stk500_devcode   = 0xB1;
+    avr910_devcode   = 0x41;
+    signature        = 0x1e 0x97 0x01;
+    chip_erase_delay = 112000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x8E, 0x9E, 0x2E, 0x3E, 0xAE, 0xBE,
+        0x4E, 0x5E, 0xCE, 0xDE, 0x6E, 0x7E, 0xEE, 0xDE,
+        0x66, 0x76, 0xE6, 0xF6, 0x6A, 0x7A, 0xEA, 0x7A,
+        0x7F, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 0;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 15;
+    chiperasepolltimeout = 0;
+    programfusepulsewidth = 2;
+    programfusepolltimeout = 0;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 10;
+
+    memory "eeprom"
+        size            = 4096;
+        min_write_delay = 4000;
+        max_write_delay = 9000;
+        readback_p1     = 0x80;
+        readback_p2     = 0x7f;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	mode		= 0x04;
+	delay		= 12;
+	blocksize	= 64;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 131072;
+        page_size       = 256;
+        num_pages       = 512;
+        min_write_delay = 22000;
+        max_write_delay = 56000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x11;
+	delay		= 70;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "fuse"
+        size            = 1;
+        read            = "0 1 0 1  0 0 0 0  x x x x  x x x x",
+                          "x x x x  x x x x  x x o x  o 1 o o";
+
+        write           = "1 0 1 0  1 1 0 0  1 0 1 1  i 1 i i",
+                          "x x x x  x x x x  x x x x  x x x x";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   x x x x  x x x x",
+                          "x x x x  x x x x   x x x x  x o o x";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 1  1 i i 1",
+                          "x x x x  x x x x   x x x x  x x x x";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+
+#------------------------------------------------------------
+# ATmega64
+#------------------------------------------------------------
+
+part
+    id               = "m64";
+    desc             = "ATMEGA64";
+    has_jtag         = yes;
+    stk500_devcode   = 0xA0;
+    avr910_devcode   = 0x45;
+    signature        = 0x1e 0x96 0x02;
+    chip_erase_delay = 9000;
+    pagel            = 0xD7;
+    bs2              = 0xA0;
+    reset            = dedicated;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 6;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x22;
+    spmcr               = 0x68;
+    allowfullpagebitstream = yes;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 2048;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	mode		= 0x04;
+	delay		= 20;
+	blocksize	= 64;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 65536;
+        page_size       = 256;
+        num_pages       = 256;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "  x a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "  x a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  x a14 a13 a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x21;
+	delay		= 6;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  x x x x  x x i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "calibration"
+        size            = 4;
+        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
+                          "0 0 0 0  0 0 a1 a0  o o o o  o o o o";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+
+
+
+#------------------------------------------------------------
+# ATmega128
+#------------------------------------------------------------
+
+part
+    id               = "m128";
+    desc             = "ATMEGA128";
+    has_jtag         = yes;
+    stk500_devcode   = 0xB2;
+    avr910_devcode   = 0x43;
+    signature        = 0x1e 0x97 0x02;
+    chip_erase_delay = 9000;
+    pagel            = 0xD7;
+    bs2              = 0xA0;
+    reset            = dedicated;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 6;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x22;
+    spmcr               = 0x68;
+    rampz               = 0x3b;
+    allowfullpagebitstream = yes;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 4096;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	mode		= 0x04;
+	delay		= 12;
+	blocksize	= 64;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 131072;
+        page_size       = 256;
+        num_pages       = 512;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x21;
+	delay		= 6;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  x x x x  x x i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "calibration"
+        size            = 4;
+        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
+                          "0 0 0 0  0 0 a1 a0  o o o o  o o o o";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# AT90CAN128
+#------------------------------------------------------------
+
+part
+    id               = "c128";
+    desc             = "AT90CAN128";
+    has_jtag         = yes;
+    stk500_devcode   = 0xB3;
+#    avr910_devcode   = 0x43;
+    signature        = 0x1e 0x97 0x81;
+    chip_erase_delay = 9000;
+    pagel            = 0xD7;
+    bs2              = 0xA0;
+    reset            = dedicated;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 6;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    rampz               = 0x3b;
+    eecr                = 0x3f;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 4096;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   0   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   0   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0  a2  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x    a11 a10  a9  a8",
+			  " a7  a6  a5  a4     a3   0   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+
+	mode		= 0x41;
+	delay		= 20;
+	blocksize	= 8;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 131072;
+        page_size       = 256;
+        num_pages       = 512;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   0   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   0   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  x x x x  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1  1 0 0 0  0 0 0 x  x x x x",
+                          "0 0 0 0  0 0 0 0  o o o o  o o o o";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+
+#------------------------------------------------------------
+# ATmega16
+#------------------------------------------------------------
+
+part
+    id               = "m16";
+    desc             = "ATMEGA16";
+    has_jtag         = yes;
+    stk500_devcode   = 0x82;
+    avr910_devcode   = 0x74;
+    signature        = 0x1e 0x94 0x03;
+    pagel            = 0xd7;
+    bs2              = 0xa0;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+	0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+	0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+	0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+	0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 100;
+    latchcycles         = 6;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    resetdelay          = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    allowfullpagebitstream = yes;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 4;  /* for parallel programming */
+        size            = 512;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   x   x      x   x  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   x   x      x   x  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x  a9  a8",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x04;
+	delay		= 10;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 16384;
+        page_size       = 128;
+        num_pages       = 128;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "  0   0 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "  0   0 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  0   0 a13 a12    a11 a10  a9  a8",
+                          " a7  a6   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x21;
+	delay		= 6;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+    memory "calibration"
+        size            = 4;
+
+        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
+                          "0 0 0 0  0 0 a1 a0 o o o o  o o o o";
+        ;
+  ;
+
+
+#------------------------------------------------------------
+# ATmega164P
+#------------------------------------------------------------
+
+# close to ATmega16
+
+part
+    id               = "m164p";
+    desc             = "ATMEGA164P";
+    has_jtag         = yes;
+#   stk500_devcode   = 0x82; # no STK500v1 support
+#   avr910_devcode   = 0x?;  # try the ATmega16 one:^
+    avr910_devcode   = 0x74;
+    signature        = 0x1e 0x94 0x0a;
+    pagel            = 0xd7;
+    bs2              = 0xa0;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 4;  /* for parallel programming */
+        size            = 512;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   x   x      x   x  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   x   x      x   x  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x  a9  a8",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 16384;
+        page_size       = 128;
+        num_pages       = 128;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "  0   0 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "  0   0 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  0   0 a13 a12    a11 a10  a9  a8",
+                          " a7  a6   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x21;
+	delay		= 6;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  1 1 1 1  1 i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "calibration"
+        size            = 1;
+
+        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+        ;
+  ;
+
+
+#------------------------------------------------------------
+# ATmega324P
+#------------------------------------------------------------
+
+# similar to ATmega164P
+
+part
+    id               = "m324p";
+    desc             = "ATMEGA324P";
+    has_jtag         = yes;
+#   stk500_devcode   = 0x82; # no STK500v1 support
+#   avr910_devcode   = 0x?;  # try the ATmega16 one:^
+    avr910_devcode   = 0x74;
+    signature        = 0x1e 0x95 0x08;
+    pagel            = 0xd7;
+    bs2              = 0xa0;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 4;  /* for parallel programming */
+        size            = 1024;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   x   x      x a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   x   x      x a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x a10  a9  a8",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 32768;
+        page_size       = 128;
+        num_pages       = 256;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x21;
+	delay		= 6;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  1 1 1 1  1 i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "calibration"
+        size            = 1;
+
+        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+        ;
+  ;
+
+
+#------------------------------------------------------------
+# ATmega644
+#------------------------------------------------------------
+
+# similar to ATmega164
+
+part
+    id               = "m644";
+    desc             = "ATMEGA644";
+    has_jtag         = yes;
+#   stk500_devcode   = 0x82; # no STK500v1 support
+#   avr910_devcode   = 0x?;  # try the ATmega16 one:^
+    avr910_devcode   = 0x74;
+    signature        = 0x1e 0x96 0x09;
+    pagel            = 0xd7;
+    bs2              = 0xa0;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 6;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 2048;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0  a2  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x    a11 a10  a9  a8",
+			  " a7  a6  a5  a4     a3   0   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 65536;
+        page_size       = 256;
+        num_pages       = 256;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x21;
+	delay		= 6;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  1 1 1 1  1 i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "calibration"
+        size            = 1;
+
+        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+        ;
+  ;
+
+#------------------------------------------------------------
+# ATmega644P
+#------------------------------------------------------------
+
+# similar to ATmega164p
+
+part
+    id               = "m644p";
+    desc             = "ATMEGA644P";
+    has_jtag         = yes;
+#   stk500_devcode   = 0x82; # no STK500v1 support
+#   avr910_devcode   = 0x?;  # try the ATmega16 one:^
+    avr910_devcode   = 0x74;
+    signature        = 0x1e 0x96 0x0a;
+    pagel            = 0xd7;
+    bs2              = 0xa0;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 6;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 2048;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0  a2  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x    a11 a10  a9  a8",
+			  " a7  a6  a5  a4     a3   0   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 65536;
+        page_size       = 256;
+        num_pages       = 256;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x21;
+	delay		= 6;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  1 1 1 1  1 i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "calibration"
+        size            = 1;
+
+        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+        ;
+  ;
+
+
+
+#------------------------------------------------------------
+# ATmega162
+#------------------------------------------------------------
+
+part
+    id               = "m162";
+    desc             = "ATMEGA162";
+    has_jtag         = yes;
+    stk500_devcode   = 0x83;
+    avr910_devcode   = 0x63;
+    signature        = 0x1e 0x94 0x04;
+    chip_erase_delay = 9000;
+    pagel            = 0xd7;
+    bs2              = 0xa0;
+
+    idr              = 0x04;
+    spmcr            = 0x57;
+    allowfullpagebitstream = yes;
+
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    memory "flash"
+        paged           = yes;
+        size            = 16384;
+        page_size       = 128;
+        num_pages       = 128;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "  0   0 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "  0   0 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  0   0 a13 a12    a11 a10  a9  a8",
+                          " a7  a6   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+       mode        = 0x41;
+    delay       = 10;
+    blocksize   = 128;
+    readsize    = 256;  
+
+        ;
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 6;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 4;  /* for parallel programming */
+        size            = 512;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+
+                read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   x   x      x   x  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+                write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   x   x      x   x  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x  a9  a8",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 20;
+	blocksize	= 4;
+	readsize	= 256;
+        ;
+
+    memory "lfuse"
+        size            = 1;
+        min_write_delay = 16000;
+        max_write_delay = 16000;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+        ;
+
+    memory "hfuse"
+        size            = 1;
+        min_write_delay = 16000;
+        max_write_delay = 16000;
+
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+        ;
+
+    memory "efuse"
+        size            = 1;
+        min_write_delay = 16000;
+        max_write_delay = 16000;
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  1 1 1 1  1 i i i";
+      ;
+
+    memory "lock"
+        size            = 1;
+        min_write_delay = 16000;
+        max_write_delay = 16000;
+
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        ;
+
+    memory "signature"
+        size            = 3;
+
+        read            = "0  0  1  1   0  0  0  0   0  0  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+        ;
+
+    memory "calibration"
+        size            = 1;
+
+        read            = "0 0 1 1  1 0 0 0   0 0 x x  x x x x",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+        ;
+;
+
+
+
+#------------------------------------------------------------
+# ATmega163
+#------------------------------------------------------------
+
+part
+    id               = "m163";
+    desc             = "ATMEGA163";
+    stk500_devcode   = 0x81;
+    avr910_devcode   = 0x64;
+    signature        = 0x1e 0x94 0x02;
+    chip_erase_delay = 32000;
+    pagel            = 0xd7;
+    bs2              = 0xa0;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 0;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 30;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 2;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 2;
+
+
+   memory "eeprom"
+        size            = 512;
+        min_write_delay = 4000;
+        max_write_delay = 4000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 16384;
+        page_size       = 128;
+        num_pages       = 128;
+        min_write_delay = 16000;
+        max_write_delay = 16000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "  x   x   x a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "  x   x   x a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  x   x   x a12    a11 a10  a9  a8",
+                          " a7  a6   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        min_write_delay = 2000;
+        max_write_delay = 2000;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o x x  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i 1 1  i i i i";
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        min_write_delay = 2000;
+        max_write_delay = 2000;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   x x x x  1 o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   1 1 1 1  1 i i i";
+      ;
+
+    memory "lock"
+        size            = 1;
+        min_write_delay = 2000;
+        max_write_delay = 2000;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  0 x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1  1 0 0 0   x x x x  x x x x",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# ATmega169
+#------------------------------------------------------------
+
+part
+    id               = "m169";
+    desc             = "ATMEGA169";
+    has_jtag         = yes;
+    stk500_devcode   = 0x85;
+    avr910_devcode   = 0x78;
+    signature        = 0x1e 0x94 0x05;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+
+   memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 4;  /* for parallel programming */
+        size            = 512;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x  a8",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 20;
+	blocksize	= 4;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 16384;
+        page_size       = 128;
+        num_pages       = 128;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "  x   x   x a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "  x   x   x a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  x   x   x a12    a11 a10  a9  a8",
+                          " a7  a6   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        min_write_delay = 2000;
+        max_write_delay = 2000;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        min_write_delay = 2000;
+        max_write_delay = 2000;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "efuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  x x x x  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+      ;
+
+    memory "lock"
+        size            = 1;
+        min_write_delay = 2000;
+        max_write_delay = 2000;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# ATmega329
+#------------------------------------------------------------
+
+part
+    id               = "m329";
+    desc             = "ATMEGA329";
+    has_jtag         = yes;
+#    stk500_devcode   = 0x85; # no STK500 support, only STK500v2
+#    avr910_devcode   = 0x?;  # try the ATmega169 one:
+    avr910_devcode   = 0x75;
+    signature        = 0x1e 0x95 0x03;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+
+   memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 4;  /* for parallel programming */
+        size            = 1024;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x      x   x  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x  a9  a8",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 20;
+	blocksize	= 8;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 32768;
+        page_size       = 128;
+        num_pages       = 256;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "  x a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "  x a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  x   x   x a12    a11 a10  a9  a8",
+                          " a7  a6   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "efuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x   x x x x  x i i i";
+      ;
+
+    memory "lock"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# ATmega3290
+#------------------------------------------------------------
+
+# identical to ATmega329
+
+part
+    id               = "m3290";
+    desc             = "ATMEGA3290";
+    has_jtag         = yes;
+#    stk500_devcode   = 0x85; # no STK500 support, only STK500v2
+#    avr910_devcode   = 0x?;  # try the ATmega169 one:
+    avr910_devcode   = 0x75;
+    signature        = 0x1e 0x95 0x04;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+
+   memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 4;  /* for parallel programming */
+        size            = 1024;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x      x   x  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x  a9  a8",
+			  " a7  a6  a5  a4     a3  a3   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 20;
+	blocksize	= 8;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 32768;
+        page_size       = 128;
+        num_pages       = 256;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "  x a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "  x a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  x   x   x a12    a11 a10  a9  a8",
+                          " a7  a6   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "efuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x   x x x x  x i i i";
+      ;
+
+    memory "lock"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# ATmega649
+#------------------------------------------------------------
+
+part
+    id               = "m649";
+    desc             = "ATMEGA649";
+    has_jtag         = yes;
+#    stk500_devcode   = 0x85; # no STK500 support, only STK500v2
+#    avr910_devcode   = 0x?;  # try the ATmega169 one:
+    avr910_devcode   = 0x75;
+    signature        = 0x1e 0x96 0x03;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+
+   memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 2048;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x      x a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0  a2  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x a10  a9  a8",
+			  " a7  a6  a5  a4     a3   0   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 20;
+	blocksize	= 8;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 65536;
+        page_size       = 256;
+        num_pages       = 256;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  x   x   x a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "efuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x   x x x x  x i i i";
+      ;
+
+    memory "lock"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# ATmega6490
+#------------------------------------------------------------
+
+# identical to ATmega649
+
+part
+    id               = "m6490";
+    desc             = "ATMEGA6490";
+    has_jtag         = yes;
+#    stk500_devcode   = 0x85; # no STK500 support, only STK500v2
+#    avr910_devcode   = 0x?;  # try the ATmega169 one:
+    avr910_devcode   = 0x75;
+    signature        = 0x1e 0x96 0x04;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+
+   memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 2048;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x      x a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0  a2  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x  a8",
+			  " a7  a6  a5  a4     a3   0   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0  a2  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x a10  a9  a8",
+			  " a7  a6  a5  a4     a3   0   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 20;
+	blocksize	= 8;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 65536;
+        page_size       = 256;
+        num_pages       = 256;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  x   x   x a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "efuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x   x x x x  x i i i";
+      ;
+
+    memory "lock"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# ATmega32
+#------------------------------------------------------------
+
+part
+    id               = "m32";
+    desc             = "ATMEGA32";
+    has_jtag         = yes;
+    stk500_devcode   = 0x91;
+    avr910_devcode   = 0x72;
+    signature        = 0x1e 0x95 0x02;
+    chip_erase_delay = 9000;
+    pagel            = 0xd7;
+    bs2              = 0xa0;
+    reset            = dedicated;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 6;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    allowfullpagebitstream = yes;
+
+   memory "eeprom"
+        paged           = no;   /* leave this "no" */
+        page_size       = 4;    /* for parallel programming */
+        size            = 1024;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   x   x      x   x  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   x   x      x   x  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x  a9  a8",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x04;
+	delay		= 10;
+	blocksize	= 64;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 32768;
+        page_size       = 128;
+        num_pages       = 256;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "  0   0 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "  0   0 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  0   0 a13 a12    a11 a10  a9  a8",
+                          " a7  a6   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x21;
+	delay		= 6;
+	blocksize	= 64;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        min_write_delay = 2000;
+        max_write_delay = 2000;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        min_write_delay = 2000;
+        max_write_delay = 2000;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "lock"
+        size            = 1;
+        min_write_delay = 2000;
+        max_write_delay = 2000;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o o";
+      ;
+
+    memory "calibration"
+        size            = 4;
+        read            = "0 0 1 1  1 0 0 0    0 0 x x  x x x x",
+                          "0 0 0 0  0 0 a1 a0  o o o o  o o o o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# ATmega161
+#------------------------------------------------------------
+
+part
+    id               = "m161";
+    desc             = "ATMEGA161";
+    stk500_devcode   = 0x80;
+    avr910_devcode   = 0x60;
+    signature        = 0x1e 0x94 0x01;
+    chip_erase_delay = 28000;
+    pagel            = 0xd7;
+    bs2              = 0xa0;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 0;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 30;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 2;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 2;
+
+   memory "eeprom"
+        size            = 512;
+        min_write_delay = 3400;
+        max_write_delay = 3400;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+	mode		= 0x04;
+	delay		= 5;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 16384;
+        page_size       = 128;
+        num_pages       = 128;
+        min_write_delay = 14000;
+        max_write_delay = 14000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "  x   x   x a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "  x   x   x a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  x   x   x a12    a11 a10  a9  a8",
+                          " a7  a6   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x21;
+	delay		= 16;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+
+    memory "fuse"
+        size            = 1;
+        min_write_delay = 2000;
+        max_write_delay = 2000;
+        read            = "0 1 0 1  0 0 0 0   x x x x  x x x x",
+                          "x x x x  x x x x   x o x o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 x  x x x x",
+                          "x x x x  x x x x   1 i 1 i  i i i i";
+      ;
+
+    memory "lock"
+        size            = 1;
+        min_write_delay = 2000;
+        max_write_delay = 2000;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+      ;
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+
+#------------------------------------------------------------
+# ATmega8
+#------------------------------------------------------------
+
+part
+    id               = "m8";
+    desc             = "ATMEGA8";
+    stk500_devcode   = 0x70;
+    avr910_devcode   = 0x76;
+    signature        = 0x1e 0x93 0x07;
+    pagel            = 0xd7;
+    bs2              = 0xc2;
+    chip_erase_delay = 10000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+	0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+	0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+	0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+	0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 2;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    resetdelay          = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    memory "eeprom"
+        size            = 512;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   x   x      x   x   x  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   x   x      x   x   x  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	mode		= 0x04;
+	delay		= 20;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+    memory "flash"
+        paged           = yes;
+        size            = 8192;
+        page_size       = 64;
+        num_pages       = 128;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0x00;
+        read_lo         = "  0   0   1   0    0   0   0   0",
+                          "  0   0   0   0  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        read_hi         = "  0   0   1   0    1   0   0   0",
+                          "  0   0   0   0  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   0   0      x   x   x   x",
+                          "  x   x   x  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   0   0      x   x   x   x",
+                          "  x   x   x  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  0   0   0   0    a11 a10  a9  a8",
+                          " a7  a6  a5   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x21;
+	delay		= 10;
+	blocksize	= 64;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        min_write_delay = 2000;
+        max_write_delay = 2000;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        min_write_delay = 2000;
+        max_write_delay = 2000;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "lock"
+        size            = 1;
+        min_write_delay = 2000;
+        max_write_delay = 2000;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+      ;
+
+    memory "calibration"
+        size            = 4;
+        read            = "0  0  1  1   1  0  0  0   0  0  x  x   x  x  x  x",
+                          "0  0  0  0   0  0 a1 a0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+
+
+#------------------------------------------------------------
+# ATmega8515
+#------------------------------------------------------------
+
+part
+    id               = "m8515";
+    desc             = "ATMEGA8515";
+    stk500_devcode   = 0x63;
+    avr910_devcode   = 0x3A;
+    signature        = 0x1e 0x93 0x06;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 6;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    memory "eeprom"
+        size            = 512;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+ read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   x   x      x   x   x  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+ write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   x   x      x   x   x  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+	mode		= 0x04;
+	delay		= 10;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+    memory "flash"
+        paged           = yes;
+        size            = 8192;
+        page_size       = 64;
+        num_pages       = 128;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0    0   0   0   0",
+                          "  0   0   0   0  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        read_hi         = "  0   0   1   0    1   0   0   0",
+                          "  0   0   0   0  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   0   0      x   x   x   x",
+                          "  x   x   x  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   0   0      x   x   x   x",
+                          "  x   x   x  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  0   0   0   0    a11 a10  a9  a8",
+                          " a7  a6  a5   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x21;
+	delay		= 6;
+	blocksize	= 64;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "lock"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+      ;
+
+    memory "calibration"
+        size            = 4;
+        read            = "0 0 1 1  1 0 0 0     0 0 x x  x x x x",
+                          "0 0 0 0  0 0 a1 a0   o o o o  o o o o";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+
+
+
+#------------------------------------------------------------
+# ATmega8535
+#------------------------------------------------------------
+
+part
+    id               = "m8535";
+    desc             = "ATMEGA8535";
+    stk500_devcode   = 0x64;
+    avr910_devcode   = 0x69;
+    signature        = 0x1e 0x93 0x08;
+    pagel            = 0xd7;
+    bs2              = 0xa0;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 6;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    memory "eeprom"
+        size            = 512;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   x   x      x   x   x  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   x   x      x   x   x  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+	mode		= 0x04;
+	delay		= 10;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+    memory "flash"
+        paged           = yes;
+        size            = 8192;
+        page_size       = 64;
+        num_pages       = 128;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0    0   0   0   0",
+                          "  0   0   0   0  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        read_hi         = "  0   0   1   0    1   0   0   0",
+                          "  0   0   0   0  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   0   0      x   x   x   x",
+                          "  x   x   x  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   0   0      x   x   x   x",
+                          "  x   x   x  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  0   0   0   0    a11 a10  a9  a8",
+                          " a7  a6  a5   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x21;
+	delay		= 6;
+	blocksize	= 64;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        min_write_delay = 2000;
+        max_write_delay = 2000;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        min_write_delay = 2000;
+        max_write_delay = 2000;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "lock"
+        size            = 1;
+        min_write_delay = 2000;
+        max_write_delay = 2000;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+      ;
+
+    memory "calibration"
+        size            = 4;
+        read            = "0 0 1 1  1 0 0 0   0 0 x x  x x x x",
+                          "0 0 0 0  0 0 a1 a0 o o o o  o o o o";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+
+#------------------------------------------------------------
+# ATtiny26
+#------------------------------------------------------------
+
+part
+    id                  = "t26";
+    desc                = "ATTINY26";
+    stk500_devcode      = 0x21;
+    avr910_devcode      = 0x5e;
+    signature           = 0x1e 0x91 0x09;
+    pagel               = 0xb3;
+    bs2                 = 0xb2;
+    chip_erase_delay    = 9000;
+    pgm_enable          = "1 0 1 0  1 1 0 0   0 1 0 1  0 0 1 1",
+                          "x x x x  x x x x   x x x x  x x x x";
+
+    chip_erase          = "1 0 1 0  1 1 0 0   1 0 0 x  x x x x",
+                          "x x x x  x x x x   x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0xC4, 0xE4, 0xC4, 0xE4, 0xCC, 0xEC, 0xCC, 0xEC,
+        0xD4, 0xF4, 0xD4, 0xF4, 0xDC, 0xFC, 0xDC, 0xFC,
+        0xC8, 0xE8, 0xD8, 0xF8, 0x4C, 0x6C, 0x5C, 0x7C,
+        0xEC, 0xBC, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 2;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    memory "eeprom"
+        size            = 128;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read            = "1  0  1  0   0  0  0  0    x x x x  x x x x",
+                          "x a6 a5 a4  a3 a2 a1 a0    o o o o  o o o o";
+
+        write           = "1  1  0  0   0  0  0  0    x x x x  x x x x",
+                          "x a6 a5 a4  a3 a2 a1 a0    i i i i  i i i i";
+
+	mode		= 0x04;
+	delay		= 10;
+	blocksize	= 64;
+	readsize	= 256;
+    ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 2048;
+        page_size       = 32;
+        num_pages       = 64;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0  0  1  0   0  0  0  0",
+                          "  x  x  x  x   x  x a9 a8",
+                          " a7 a6 a5 a4  a3 a2 a1 a0",
+                          "  o  o  o  o   o  o  o  o";
+
+        read_hi         = "  0  0  1  0   1  0  0  0",
+                          "  x  x  x  x   x  x a9 a8",
+                          " a7 a6 a5 a4  a3 a2 a1 a0",
+                          "  o  o  o  o   o  o  o  o";
+
+        loadpage_lo     = "  0  1  0  0   0  0  0  0",
+                          "  x  x  x  x   x  x  x  x",
+                          "  x  x  x  x  a3 a2 a1 a0",
+                          "  i  i  i  i   i  i  i  i";
+
+        loadpage_hi     = "  0  1  0  0   1  0  0  0",
+                          "  x  x  x  x   x  x  x  x",
+                          "  x  x  x  x  a3 a2 a1 a0",
+                          "  i  i  i  i   i  i  i  i";
+
+        writepage       = "  0  1  0  0   1  1  0  0",
+                          "  x  x  x  x   x  x a9 a8",
+                          " a7 a6 a5 a4   x  x  x  x",
+                          "  x  x  x  x   x  x  x  x";
+
+	mode		= 0x21;
+	delay		= 6;
+	blocksize	= 16;
+	readsize	= 256;
+    ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0    x x x x  x x x x",
+                          "0  0  0  0   0  0 a1 a0    o o o o  o o o o";
+    ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0  1  0  1   1  0  0  0    x x x x  x x x x",
+                          "x  x  x  x   x  x  x  x    x x x x  x x o o";
+
+        write           = "1  0  1  0   1  1  0  0    1 1 1 1  1 1 i i",
+                          "x  x  x  x   x  x  x  x    x x x x  x x x x";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+    ;
+
+    memory "lfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x  x x x i  i i i i";
+
+        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  x x x o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "calibration"
+        size            = 4;
+        read            = "0  0  1  1   1  0  0  0    x x x x  x x x x",
+                          "0  0  0  0   0  0 a1 a0    o o o o  o o o o";
+    ;
+
+;
+
+
+#------------------------------------------------------------
+# ATtiny261
+#------------------------------------------------------------
+# Close to ATtiny26
+
+part
+    id                  = "t261";
+    desc                = "ATTINY261";
+     has_debugwire = yes;
+     flash_instr   = 0xB4, 0x00, 0x10;
+     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
+	             0xBC, 0x00, 0xB4, 0x00, 0xBA, 0x0D, 0xBB, 0xBC,
+	             0x99, 0xE1, 0xBB, 0xAC;
+#    stk500_devcode      = 0x21;
+#    avr910_devcode      = 0x5e;
+    signature           = 0x1e 0x91 0x0c;
+    pagel               = 0xb3;
+    bs2                 = 0xb2;
+    chip_erase_delay    = 4000;
+
+    pgm_enable          = "1 0 1 0  1 1 0 0   0 1 0 1  0 0 1 1",
+                          "x x x x  x x x x   x x x x  x x x x";
+
+    chip_erase          = "1 0 1 0  1 1 0 0   1 0 0 x  x x x x",
+                          "x x x x  x x x x   x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0xC4, 0xE4, 0xC4, 0xE4, 0xCC, 0xEC, 0xCC, 0xEC,
+        0xD4, 0xF4, 0xD4, 0xF4, 0xDC, 0xFC, 0xDC, 0xFC,
+        0xC8, 0xE8, 0xD8, 0xF8, 0x4C, 0x6C, 0x5C, 0x7C,
+        0xEC, 0xBC, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 2;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    memory "eeprom"
+        paged           = no;
+        size            = 128;
+        page_size       = 4;
+        num_pages       = 32;
+        min_write_delay = 4000;
+        max_write_delay = 4000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+
+        read            = "1  0  1  0   0  0  0  0    x x x x  x x x x",
+                          "x a6 a5 a4  a3 a2 a1 a0    o o o o  o o o o";
+
+        write           = "1  1  0  0   0  0  0  0    x x x x  x x x x",
+                          "x a6 a5 a4  a3 a2 a1 a0    i i i i  i i i i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x   x",
+			  "  x  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 4;
+	readsize	= 256;
+    ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 2048;
+        page_size       = 32;
+        num_pages       = 64;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+
+        read_lo         = "  0  0  1  0   0  0  0  0",
+                          "  x  x  x  x   x  x a9 a8",
+                          " a7 a6 a5 a4  a3 a2 a1 a0",
+                          "  o  o  o  o   o  o  o  o";
+
+        read_hi         = "  0  0  1  0   1  0  0  0",
+                          "  x  x  x  x   x  x a9 a8",
+                          " a7 a6 a5 a4  a3 a2 a1 a0",
+                          "  o  o  o  o   o  o  o  o";
+
+        loadpage_lo     = "  0  1  0  0   0  0  0  0",
+                          "  x  x  x  x   x  x  x  x",
+                          "  x  x  x  x  a3 a2 a1 a0",
+                          "  i  i  i  i   i  i  i  i";
+
+        loadpage_hi     = "  0  1  0  0   1  0  0  0",
+                          "  x  x  x  x   x  x  x  x",
+                          "  x  x  x  x  a3 a2 a1 a0",
+                          "  i  i  i  i   i  i  i  i";
+
+        writepage       = "  0  1  0  0   1  1  0  0",
+                          "  x  x  x  x   x  x a9 a8",
+                          " a7 a6 a5 a4   x  x  x  x",
+                          "  x  x  x  x   x  x  x  x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 32;
+	readsize	= 256;
+    ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0    x x x x  x x x x",
+                          "0  0  0  0   0  0 a1 a0    o o o o  o o o o";
+    ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0  1  0  1   1  0  0  0    x x x x  x x x x",
+                          "x  x  x  x   x  x  x  x    x x x x  x x o o";
+
+        write           = "1  0  1  0   1  1  0  0    1 1 1 1  1 1 i i",
+                          "x  x  x  x   x  x  x  x    x x x x  x x x x";
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+    ;
+
+    memory "lfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+      ;
+
+    memory "efuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x   x x x x  x x x i";
+
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   x x x x  x x x o";
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0  0  1  1   1  0  0  0    x x x x  x x x x",
+                          "0  0  0  0   0  0  0  0    o o o o  o o o o";
+    ;
+
+;
+
+
+#------------------------------------------------------------
+# ATtiny461
+#------------------------------------------------------------
+# Close to ATtiny261
+
+part
+    id                  = "t461";
+    desc                = "ATTINY461";
+     has_debugwire = yes;
+     flash_instr   = 0xB4, 0x00, 0x10;
+     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
+	             0xBC, 0x00, 0xB4, 0x00, 0xBA, 0x0D, 0xBB, 0xBC,
+	             0x99, 0xE1, 0xBB, 0xAC;
+#    stk500_devcode      = 0x21;
+#    avr910_devcode      = 0x5e;
+    signature           = 0x1e 0x92 0x08;
+    pagel               = 0xb3;
+    bs2                 = 0xb2;
+    chip_erase_delay    = 4000;
+
+    pgm_enable          = "1 0 1 0  1 1 0 0   0 1 0 1  0 0 1 1",
+                          "x x x x  x x x x   x x x x  x x x x";
+
+    chip_erase          = "1 0 1 0  1 1 0 0   1 0 0 x  x x x x",
+                          "x x x x  x x x x   x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0xC4, 0xE4, 0xC4, 0xE4, 0xCC, 0xEC, 0xCC, 0xEC,
+        0xD4, 0xF4, 0xD4, 0xF4, 0xDC, 0xFC, 0xDC, 0xFC,
+        0xC8, 0xE8, 0xD8, 0xF8, 0x4C, 0x6C, 0x5C, 0x7C,
+        0xEC, 0xBC, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 2;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    memory "eeprom"
+        paged           = no;
+        size            = 256;
+        page_size       = 4;
+        num_pages       = 64;
+        min_write_delay = 4000;
+        max_write_delay = 4000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+
+        read            = " 1  0  1  0   0  0  0  0    x x x x  x x x x",
+                          "a7 a6 a5 a4  a3 a2 a1 a0    o o o o  o o o o";
+
+        write           = " 1  1  0  0   0  0  0  0    x x x x  x x x x",
+                          "a7 a6 a5 a4  a3 a2 a1 a0    i i i i  i i i i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x   x",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 4;
+	readsize	= 256;
+    ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 4096;
+        page_size       = 64;
+        num_pages       = 64;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+
+        read_lo         = "  0  0  1  0   0   0  0  0",
+                          "  x  x  x  x   x a10 a9 a8",
+                          " a7 a6 a5 a4  a3  a2 a1 a0",
+                          "  o  o  o  o   o   o  o  o";
+
+        read_hi         = "  0  0  1  0   1   0  0  0",
+                          "  x  x  x  x   x a10 a9 a8",
+                          " a7 a6 a5 a4  a3  a2 a1 a0",
+                          "  o  o  o  o   o   o  o  o";
+
+        loadpage_lo     = "  0  1  0  0   0  0  0  0",
+                          "  x  x  x  x   x  x  x  x",
+                          "  x  x  x a4  a3 a2 a1 a0",
+                          "  i  i  i  i   i  i  i  i";
+
+        loadpage_hi     = "  0  1  0  0   1  0  0  0",
+                          "  x  x  x  x   x  x  x  x",
+                          "  x  x  x a4  a3 a2 a1 a0",
+                          "  i  i  i  i   i  i  i  i";
+
+        writepage       = "  0  1  0  0   1   1  0  0",
+                          "  x  x  x  x   x a10 a9 a8",
+                          " a7 a6 a5  x   x   x  x  x",
+                          "  x  x  x  x   x   x  x  x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 64;
+	readsize	= 256;
+    ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0    x x x x  x x x x",
+                          "0  0  0  0   0  0 a1 a0    o o o o  o o o o";
+    ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0  1  0  1   1  0  0  0    x x x x  x x x x",
+                          "x  x  x  x   x  x  x  x    x x x x  x x o o";
+
+        write           = "1  0  1  0   1  1  0  0    1 1 1 1  1 1 i i",
+                          "x  x  x  x   x  x  x  x    x x x x  x x x x";
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+    ;
+
+    memory "lfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+      ;
+
+    memory "efuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x   x x x x  x x x i";
+
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   x x x x  x x x o";
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0  0  1  1   1  0  0  0    x x x x  x x x x",
+                          "0  0  0  0   0  0  0  0    o o o o  o o o o";
+    ;
+
+;
+
+
+#------------------------------------------------------------
+# ATtiny861
+#------------------------------------------------------------
+# Close to ATtiny461
+
+part
+    id                  = "t861";
+    desc                = "ATTINY861";
+     has_debugwire = yes;
+     flash_instr   = 0xB4, 0x00, 0x10;
+     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
+	             0xBC, 0x00, 0xB4, 0x00, 0xBA, 0x0D, 0xBB, 0xBC,
+	             0x99, 0xE1, 0xBB, 0xAC;
+#    stk500_devcode      = 0x21;
+#    avr910_devcode      = 0x5e;
+    signature           = 0x1e 0x93 0x0d;
+    pagel               = 0xb3;
+    bs2                 = 0xb2;
+    chip_erase_delay    = 4000;
+
+    pgm_enable          = "1 0 1 0  1 1 0 0   0 1 0 1  0 0 1 1",
+                          "x x x x  x x x x   x x x x  x x x x";
+
+    chip_erase          = "1 0 1 0  1 1 0 0   1 0 0 x  x x x x",
+                          "x x x x  x x x x   x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0xC4, 0xE4, 0xC4, 0xE4, 0xCC, 0xEC, 0xCC, 0xEC,
+        0xD4, 0xF4, 0xD4, 0xF4, 0xDC, 0xFC, 0xDC, 0xFC,
+        0xC8, 0xE8, 0xD8, 0xF8, 0x4C, 0x6C, 0x5C, 0x7C,
+        0xEC, 0xBC, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 2;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    memory "eeprom"
+        paged           = no;
+        size            = 512;
+        num_pages       = 128;
+        page_size       = 4;
+        min_write_delay = 4000;
+        max_write_delay = 4000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+
+        read            = " 1  0  1  0   0  0  0  0    x x x x  x x x a8",
+                          "a7 a6 a5 a4  a3 a2 a1 a0    o o o o  o o o  o";
+
+        write           = " 1  1  0  0   0  0  0  0    x x x x  x x x a8",
+                          "a7 a6 a5 a4  a3 a2 a1 a0    i i i i  i i i  i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x  a8",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 4;
+	readsize	= 256;
+    ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 8192;
+        page_size       = 64;
+        num_pages       = 128;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+
+        read_lo         = "  0  0  1  0   0   0  0  0",
+                          "  x  x  x  x a11 a10 a9 a8",
+                          " a7 a6 a5 a4  a3  a2 a1 a0",
+                          "  o  o  o  o   o   o  o  o";
+
+        read_hi         = "  0  0  1  0   1   0  0  0",
+                          "  x  x  x  x a11 a10 a9 a8",
+                          " a7 a6 a5 a4  a3  a2 a1 a0",
+                          "  o  o  o  o   o   o  o  o";
+
+        loadpage_lo     = "  0  1  0  0   0  0  0  0",
+                          "  x  x  x  x   x  x  x  x",
+                          "  x  x  x a4  a3 a2 a1 a0",
+                          "  i  i  i  i   i  i  i  i";
+
+        loadpage_hi     = "  0  1  0  0   1  0  0  0",
+                          "  x  x  x  x   x  x  x  x",
+                          "  x  x  x a4  a3 a2 a1 a0",
+                          "  i  i  i  i   i  i  i  i";
+
+        writepage       = "  0  1  0  0   1   1  0  0",
+                          "  x  x  x  x a11 a10 a9 a8",
+                          " a7 a6 a5  x   x   x  x  x",
+                          "  x  x  x  x   x   x  x  x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 64;
+	readsize	= 256;
+    ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0    x x x x  x x x x",
+                          "0  0  0  0   0  0 a1 a0    o o o o  o o o o";
+    ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0  1  0  1   1  0  0  0    x x x x  x x x x",
+                          "x  x  x  x   x  x  x  x    x x x x  x x o o";
+
+        write           = "1  0  1  0   1  1  0  0    1 1 1 1  1 1 i i",
+                          "x  x  x  x   x  x  x  x    x x x x  x x x x";
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+    ;
+
+    memory "lfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+      ;
+
+    memory "efuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x   x x x x  x x x i";
+
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   x x x x  x x x o";
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0  0  1  1   1  0  0  0    x x x x  x x x x",
+                          "0  0  0  0   0  0  0  0    o o o o  o o o o";
+    ;
+
+;
+
+
+#------------------------------------------------------------
+# ATmega48
+#------------------------------------------------------------
+
+part
+    id               = "m48";
+    desc             = "ATMEGA48";
+     has_debugwire = yes;
+     flash_instr   = 0xB6, 0x01, 0x11;
+     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
+	             0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
+	             0x99, 0xF9, 0xBB, 0xAF;
+    stk500_devcode   = 0x59;
+#    avr910_devcode   = 0x;
+    signature        = 0x1e 0x92 0x05;
+    pagel            = 0xd7;
+    bs2              = 0xc2;
+    chip_erase_delay = 45000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+	0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+	0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+	0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+	0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    resetdelay          = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    memory "eeprom"
+        paged           = no;
+        page_size       = 4;
+        size            = 256;
+        min_write_delay = 3600;
+        max_write_delay = 3600;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   0   x      x   x   x   x",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   0   x      x   x   x   x",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x   x",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 5;
+	blocksize	= 4;
+	readsize	= 256;
+      ;
+    memory "flash"
+        paged           = yes;
+        size            = 4096;
+        page_size       = 64;
+        num_pages       = 64;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read_lo         = "  0   0   1   0    0   0   0   0",
+                          "  0   0   0   0    0 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        read_hi         = "  0   0   1   0    1   0   0   0",
+                          "  0   0   0   0    0 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   0   x      x   x   x   x",
+                          "  x   x   x  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   0   x      x   x   x   x",
+                          "  x   x   x  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  0   0   0   0      0 a10  a9  a8",
+                          " a7  a6  a5   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 64;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "efuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   x x x x  x x x o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x   x x x x  x x x i";
+      ;
+
+    memory "lock"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0  0  1  1   1  0  0  0   0  0  0  x   x  x  x  x",
+                          "0  0  0  0   0  0  0  0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+
+#------------------------------------------------------------
+# ATmega88
+#------------------------------------------------------------
+
+part
+    id               = "m88";
+    desc             = "ATMEGA88";
+     has_debugwire = yes;
+     flash_instr   = 0xB6, 0x01, 0x11;
+     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
+	             0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
+	             0x99, 0xF9, 0xBB, 0xAF;
+    stk500_devcode   = 0x73;
+#    avr910_devcode   = 0x;
+    signature        = 0x1e 0x93 0x0a;
+    pagel            = 0xd7;
+    bs2              = 0xc2;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+	0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+	0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+	0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+	0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    resetdelay          = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    memory "eeprom"
+        paged           = no;
+        page_size       = 4;
+        size            = 512;
+        min_write_delay = 3600;
+        max_write_delay = 3600;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   0   x      x   x   x  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   0   x      x   x   x  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x  a8",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 5;
+	blocksize	= 4;
+	readsize	= 256;
+      ;
+    memory "flash"
+        paged           = yes;
+        size            = 8192;
+        page_size       = 64;
+        num_pages       = 128;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0    0   0   0   0",
+                          "  0   0   0   0  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        read_hi         = "  0   0   1   0    1   0   0   0",
+                          "  0   0   0   0  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   0   x      x   x   x   x",
+                          "  x   x   x  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   0   x      x   x   x   x",
+                          "  x   x   x  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  0   0   0   0    a11 a10  a9  a8",
+                          " a7  a6  a5   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 64;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "efuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   x x x x  x o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x   x x x x  x i i i";
+      ;
+
+    memory "lock"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0  0  1  1   1  0  0  0   0  0  0  x   x  x  x  x",
+                          "0  0  0  0   0  0  0  0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# ATmega168
+#------------------------------------------------------------
+
+part
+    id              = "m168";
+    desc            = "ATMEGA168";
+     has_debugwire = yes;
+     flash_instr   = 0xB6, 0x01, 0x11;
+     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
+	             0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
+	             0x99, 0xF9, 0xBB, 0xAF;
+    stk500_devcode  = 0x86;
+    # avr910_devcode = 0x;
+    signature       = 0x1e 0x94 0x06;
+    pagel           = 0xd7;
+    bs2             = 0xc2;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0 1 1 0 0 0 1 0 1 0 0 1 1",
+                       "x x x x x x x x x x x x x x x x";
+
+    chip_erase       = "1 0 1 0 1 1 0 0 1 0 0 x x x x x",
+                       "x x x x x x x x x x x x x x x x";
+
+    timeout         = 200;
+    stabdelay       = 100;
+    cmdexedelay     = 25;
+    synchloops      = 32;
+    bytedelay       = 0;
+    pollindex       = 3;
+    pollvalue       = 0x53;
+    predelay        = 1;
+    postdelay       = 1;
+    pollmethod      = 1;
+
+    pp_controlstack     =
+	0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+	0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+	0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+	0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    resetdelay          = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    memory "eeprom"
+        paged           = no;
+        page_size       = 4;
+        size            = 512;
+        min_write_delay = 3600;
+        max_write_delay = 3600;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read            = " 1 0 1 0 0 0 0 0",
+                          " 0 0 0 x x x x a8",
+                          " a7 a6 a5 a4 a3 a2 a1 a0",
+                          " o o o o o o o o";
+    
+        write           = " 1 1 0 0 0 0 0 0",
+                          " 0 0 0 x x x x a8",
+                          " a7 a6 a5 a4 a3 a2 a1 a0",
+                          " i i i i i i i i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x  a8",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 5;
+	blocksize	= 4;
+	readsize	= 256;
+        ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 16384;
+        page_size       = 128;
+        num_pages       = 128;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = " 0 0 1 0 0 0 0 0",
+                          " 0 0 0 a12 a11 a10 a9 a8",
+                          " a7 a6 a5 a4 a3 a2 a1 a0",
+                          " o o o o o o o o";
+        
+        read_hi          = " 0 0 1 0 1 0 0 0",
+                           " 0 0 0 a12 a11 a10 a9 a8",
+                           " a7 a6 a5 a4 a3 a2 a1 a0",
+                           " o o o o o o o o";
+        
+        loadpage_lo     = " 0 1 0 0 0 0 0 0",
+                          " 0 0 0 x x x x x",
+                          " x x a5 a4 a3 a2 a1 a0",
+                          " i i i i i i i i";
+        
+        loadpage_hi     = " 0 1 0 0 1 0 0 0",
+                          " 0 0 0 x x x x x",
+                          " x x a5 a4 a3 a2 a1 a0",
+                          " i i i i i i i i";
+        
+        writepage       = " 0 1 0 0 1 1 0 0",
+                          " 0 0 0 a12 a11 a10 a9 a8",
+                          " a7 a6 x x x x x x",
+                          " x x x x x x x x";
+
+        mode        = 0x41;
+        delay       = 6;
+        blocksize   = 128;
+        readsize    = 256;
+
+        ;
+        
+    memory "lfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0",
+                          "x x x x x x x x o o o o o o o o";
+        
+        write           = "1 0 1 0 1 1 0 0 1 0 1 0 0 0 0 0",
+                          "x x x x x x x x i i i i i i i i";
+        ;
+    
+    memory "hfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1 1 0 0 0 0 0 0 0 1 0 0 0",
+                          "x x x x x x x x o o o o o o o o";
+        
+        write           = "1 0 1 0 1 1 0 0 1 0 1 0 1 0 0 0",
+                          "x x x x x x x x i i i i i i i i";
+        ;
+    
+    memory "efuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0",
+                          "x x x x x x x x x x x x x o o o";
+        
+        write           = "1 0 1 0 1 1 0 0 1 0 1 0 0 1 0 0",
+                          "x x x x x x x x x x x x x i i i";
+        ;
+    
+    memory "lock"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0",
+                          "x x x x x x x x x x o o o o o o";
+        
+        write           = "1 0 1 0 1 1 0 0 1 1 1 x x x x x",
+                          "x x x x x x x x 1 1 i i i i i i";
+        ;
+    
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1 1 0 0 0 0 0 0 x x x x x",
+                          "0 0 0 0 0 0 0 0 o o o o o o o o";
+        ;
+    
+    memory "signature"
+        size            = 3;
+        read            = "0 0 1 1 0 0 0 0 0 0 0 x x x x x",
+                          "x x x x x x a1 a0 o o o o o o o o";
+        ;
+;
+
+#------------------------------------------------------------
+# ATmega328
+#------------------------------------------------------------
+
+part
+    id              = "m328p";
+    desc            = "ATMEGA328P";
+     has_debugwire = yes;
+     flash_instr   = 0xB6, 0x01, 0x11;
+     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
+	             0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
+	             0x99, 0xF9, 0xBB, 0xAF;
+    stk500_devcode  = 0x86;
+    # avr910_devcode = 0x;
+    signature       = 0x1e 0x95 0x0F;
+    pagel           = 0xd7;
+    bs2             = 0xc2;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0 1 1 0 0 0 1 0 1 0 0 1 1",
+                       "x x x x x x x x x x x x x x x x";
+
+    chip_erase       = "1 0 1 0 1 1 0 0 1 0 0 x x x x x",
+                       "x x x x x x x x x x x x x x x x";
+
+    timeout         = 200;
+    stabdelay       = 100;
+    cmdexedelay     = 25;
+    synchloops      = 32;
+    bytedelay       = 0;
+    pollindex       = 3;
+    pollvalue       = 0x53;
+    predelay        = 1;
+    postdelay       = 1;
+    pollmethod      = 1;
+
+    pp_controlstack     =
+	0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+	0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+	0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+	0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    resetdelay          = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    memory "eeprom"
+        paged           = no;
+        page_size       = 4;
+        size            = 1024;
+        min_write_delay = 3600;
+        max_write_delay = 3600;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read            = " 1 0 1 0 0 0 0 0",
+                          " 0 0 0 x x x a9 a8",
+                          " a7 a6 a5 a4 a3 a2 a1 a0",
+                          " o o o o o o o o";
+    
+        write           = " 1 1 0 0 0 0 0 0",
+                          " 0 0 0 x x x a9 a8",
+                          " a7 a6 a5 a4 a3 a2 a1 a0",
+                          " i i i i i i i i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   a9  a8",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 5;
+	blocksize	= 4;
+	readsize	= 256;
+        ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 32768;
+        page_size       = 128;
+        num_pages       = 256;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = " 0 0 1 0 0 0 0 0",
+                          " 0 0 a13 a12 a11 a10 a9 a8",
+                          " a7 a6 a5 a4 a3 a2 a1 a0",
+                          " o o o o o o o o";
+        
+        read_hi          = " 0 0 1 0 1 0 0 0",
+                           " 0 0 a13 a12 a11 a10 a9 a8",
+                           " a7 a6 a5 a4 a3 a2 a1 a0",
+                           " o o o o o o o o";
+        
+        loadpage_lo     = " 0 1 0 0 0 0 0 0",
+                          " 0 0 0 x x x x x",
+                          " x x a5 a4 a3 a2 a1 a0",
+                          " i i i i i i i i";
+        
+        loadpage_hi     = " 0 1 0 0 1 0 0 0",
+                          " 0 0 0 x x x x x",
+                          " x x a5 a4 a3 a2 a1 a0",
+                          " i i i i i i i i";
+        
+        writepage       = " 0 1 0 0 1 1 0 0",
+                          " 0 0 a13 a12 a11 a10 a9 a8",
+                          " a7 a6 x x x x x x",
+                          " x x x x x x x x";
+
+        mode        = 0x41;
+        delay       = 6;
+        blocksize   = 128;
+        readsize    = 256;
+
+        ;
+        
+    memory "lfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0",
+                          "x x x x x x x x o o o o o o o o";
+        
+        write           = "1 0 1 0 1 1 0 0 1 0 1 0 0 0 0 0",
+                          "x x x x x x x x i i i i i i i i";
+        ;
+    
+    memory "hfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1 1 0 0 0 0 0 0 0 1 0 0 0",
+                          "x x x x x x x x o o o o o o o o";
+        
+        write           = "1 0 1 0 1 1 0 0 1 0 1 0 1 0 0 0",
+                          "x x x x x x x x i i i i i i i i";
+        ;
+    
+    memory "efuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0",
+                          "x x x x x x x x x x x x x o o o";
+        
+        write           = "1 0 1 0 1 1 0 0 1 0 1 0 0 1 0 0",
+                          "x x x x x x x x x x x x x i i i";
+        ;
+    
+    memory "lock"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0",
+                          "x x x x x x x x x x o o o o o o";
+        
+        write           = "1 0 1 0 1 1 0 0 1 1 1 x x x x x",
+                          "x x x x x x x x 1 1 i i i i i i";
+        ;
+    
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1 1 0 0 0 0 0 0 x x x x x",
+                          "0 0 0 0 0 0 0 0 o o o o o o o o";
+        ;
+    
+    memory "signature"
+        size            = 3;
+        read            = "0 0 1 1 0 0 0 0 0 0 0 x x x x x",
+                          "x x x x x x a1 a0 o o o o o o o o";
+        ;
+;
+
+#------------------------------------------------------------
+# ATtiny2313
+#------------------------------------------------------------
+
+part
+     id            = "t2313";
+     desc          = "ATtiny2313";
+     has_debugwire = yes;
+     flash_instr   = 0xB2, 0x0F, 0x1F;
+     eeprom_instr  = 0xBB, 0xFE, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
+	             0xBA, 0x0F, 0xB2, 0x0F, 0xBA, 0x0D, 0xBB, 0xBC,
+	             0x99, 0xE1, 0xBB, 0xAC;
+     stk500_devcode   = 0x23;
+##   Use the ATtiny26 devcode:
+     avr910_devcode   = 0x5e;
+     signature        = 0x1e 0x91 0x0a;
+     pagel            = 0xD4;
+     bs2              = 0xD6;
+     reset            = io;
+     chip_erase_delay = 9000;
+
+     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0E, 0x1E, 0x2E, 0x3E, 0x2E, 0x3E,
+        0x4E, 0x5E, 0x4E, 0x5E, 0x6E, 0x7E, 0x6E, 0x7E,
+        0x26, 0x36, 0x66, 0x76, 0x2A, 0x3A, 0x6A, 0x7A,
+        0x2E, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+     memory "eeprom"
+         size            = 128;
+        paged           = no;
+        page_size       = 4;
+         min_write_delay = 4000;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read            = "1  0  1  0   0  0  0  0   0 0 0 x  x x x x",
+                           "x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
+
+         write           = "1  1  0  0   0  0  0  0   0 0 0 x  x x x x",
+                           "x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x   x",
+			  "  x  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 4;
+	readsize	= 256;
+       ;
+     memory "flash"
+         paged           = yes;
+         size            = 2048;
+         page_size       = 32;
+         num_pages       = 64;
+         min_write_delay = 4500;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read_lo         = "  0   0   1   0    0   0   0   0",
+                           "  0   0   0   0    0   0  a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         read_hi         = "  0   0   1   0    1   0   0   0",
+                           "  0   0   0   0    0   0  a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+# The information in the data sheet of April/2004 is wrong, this works:
+         loadpage_lo     = "  0   1   0   0    0   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x   x   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+# The information in the data sheet of April/2004 is wrong, this works:
+         loadpage_hi     = "  0   1   0   0    1   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x   x   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+# The information in the data sheet of April/2004 is wrong, this works:
+         writepage       = "  0  1  0  0   1  1  0  0",
+                           "  0  0  0  0   0  0 a9 a8",
+                           " a7 a6 a5 a4   x  x  x  x",
+                           "  x  x  x  x   x  x  x  x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 32;
+	readsize	= 256;
+       ;
+#   ATtiny2313 has Signature Bytes: 0x1E 0x91 0x0A.
+     memory "signature"
+         size            = 3;
+         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
+                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+       ;
+     memory "lock"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
+                           "x x x x  x x x x  1 1 i i  i i i i";
+         read           = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  x x o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "lfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "hfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "efuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                           "x x x x  x x x x  x x x x  x x x i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+     ;
+# The Tiny2313 has calibration data for both 4 MHz and 8 MHz.
+# The information in the data sheet of April/2004 is wrong, this works:
+
+     memory "calibration"
+         size            = 2;
+         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
+                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
+     ;
+  ;
+
+#------------------------------------------------------------
+# AT90PWM2
+#------------------------------------------------------------
+
+part
+     id            = "pwm2";
+     desc          = "AT90PWM2";
+     has_debugwire = yes;
+     flash_instr   = 0xB6, 0x01, 0x11;
+     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
+	             0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
+	             0x99, 0xF9, 0xBB, 0xAF;
+     stk500_devcode   = 0x65;
+##  avr910_devcode   = ?;
+     signature        = 0x1e 0x93 0x81;
+     pagel            = 0xD8;
+     bs2              = 0xE2;
+     reset            = io;
+     chip_erase_delay = 9000;
+
+     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+     memory "eeprom"
+         size            = 512;
+        paged           = no;
+        page_size       = 4;
+         min_write_delay = 4000;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read            = "1  0  1  0   0  0  0  0   0 0 0 x  x x x a8",
+                           "a7 a6 a5 a4  a3 a2 a1 a0  o o o o  o o o o";
+
+         write           = "1  1  0  0   0  0  0  0   0 0 0 x  x x x a8",
+                           "a7 a6 a5 a4  a3 a2 a1 a0  i i i i  i i i i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x   x",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 4;
+	readsize	= 256;
+       ;
+     memory "flash"
+         paged           = yes;
+         size            = 8192;
+         page_size       = 64;
+         num_pages       = 128;
+         min_write_delay = 4500;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read_lo         = "  0   0   1   0    0   0   0   0",
+                           "  0   0   0   0   a11 a10 a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         read_hi         = "  0   0   1   0    1   0   0   0",
+                           "  0   0   0   0   a11 a10 a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         loadpage_lo     = "  0   1   0   0    0   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x  a4   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         loadpage_hi     = "  0   1   0   0    1   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x  a4   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         writepage       = "  0  1  0  0   1   1   0   0",
+                           "  0  0  0  0   a11 a10 a9  a8",
+                           " a7 a6 a5  x   x   x   x   x",
+                           "  x  x  x  x   x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 64;
+	readsize	= 256;
+       ;
+#   AT90PWM2 has Signature Bytes: 0x1E 0x93 0x81.
+     memory "signature"
+         size            = 3;
+         read            = "0  0  1  1   0  0  0  0   0  0  x  x   x  x  x  x",
+                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+       ;
+     memory "lock"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
+                           "x x x x  x x x x  1 1 i i  i i i i";
+
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
+                           "x x x x  x x x x  x x o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "lfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "hfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "efuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                           "x x x x  x x x x  x x x x  x x x i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+     ;
+
+     memory "calibration"
+         size            = 1;
+         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
+                           "0  0  0  0   0  0  0  0    o o o o  o o o o";
+     ;
+  ;
+
+#------------------------------------------------------------
+# AT90PWM3
+#------------------------------------------------------------
+
+# Completely identical to AT90PWM2 (including the signature!)
+
+part
+     id            = "pwm3";
+     desc          = "AT90PWM3";
+     has_debugwire = yes;
+     flash_instr   = 0xB6, 0x01, 0x11;
+     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
+	             0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
+	             0x99, 0xF9, 0xBB, 0xAF;
+     stk500_devcode   = 0x65;
+##  avr910_devcode   = ?;
+     signature        = 0x1e 0x93 0x81;
+     pagel            = 0xD8;
+     bs2              = 0xE2;
+     reset            = io;
+     chip_erase_delay = 9000;
+
+     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+     memory "eeprom"
+         size            = 512;
+        paged           = no;
+        page_size       = 4;
+         min_write_delay = 4000;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read            = "1  0  1  0   0  0  0  0   0 0 0 x  x x x a8",
+                           "a7 a6 a5 a4  a3 a2 a1 a0  o o o o  o o o o";
+
+         write           = "1  1  0  0   0  0  0  0   0 0 0 x  x x x a8",
+                           "a7 a6 a5 a4  a3 a2 a1 a0  i i i i  i i i i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x   x",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 4;
+	readsize	= 256;
+       ;
+     memory "flash"
+         paged           = yes;
+         size            = 8192;
+         page_size       = 64;
+         num_pages       = 128;
+         min_write_delay = 4500;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read_lo         = "  0   0   1   0    0   0   0   0",
+                           "  0   0   0   0   a11 a10 a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         read_hi         = "  0   0   1   0    1   0   0   0",
+                           "  0   0   0   0   a11 a10 a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         loadpage_lo     = "  0   1   0   0    0   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x  a4   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         loadpage_hi     = "  0   1   0   0    1   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x  a4   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         writepage       = "  0  1  0  0   1   1   0   0",
+                           "  0  0  0  0   a11 a10 a9  a8",
+                           " a7 a6 a5  x   x   x   x   x",
+                           "  x  x  x  x   x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 64;
+	readsize	= 256;
+       ;
+#   AT90PWM2 has Signature Bytes: 0x1E 0x93 0x81.
+     memory "signature"
+         size            = 3;
+         read            = "0  0  1  1   0  0  0  0   0  0  x  x   x  x  x  x",
+                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+       ;
+     memory "lock"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
+                           "x x x x  x x x x  1 1 i i  i i i i";
+
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
+                           "x x x x  x x x x  x x o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "lfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "hfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "efuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                           "x x x x  x x x x  x x x x  x x x i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+     ;
+
+     memory "calibration"
+         size            = 1;
+         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
+                           "0  0  0  0   0  0  0  0    o o o o  o o o o";
+     ;
+  ;
+
+#------------------------------------------------------------
+# AT90PWM2B
+#------------------------------------------------------------
+# Same as AT90PWM2 but different signature.
+
+part
+     id            = "pwm2b";
+     desc          = "AT90PWM2B";
+     has_debugwire = yes;
+     flash_instr   = 0xB6, 0x01, 0x11;
+     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
+	             0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
+	             0x99, 0xF9, 0xBB, 0xAF;
+     stk500_devcode   = 0x65;
+##  avr910_devcode   = ?;
+     signature        = 0x1e 0x93 0x83;
+     pagel            = 0xD8;
+     bs2              = 0xE2;
+     reset            = io;
+     chip_erase_delay = 9000;
+
+     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+     memory "eeprom"
+         size            = 512;
+        paged           = no;
+        page_size       = 4;
+         min_write_delay = 4000;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read            = "1  0  1  0   0  0  0  0   0 0 0 x  x x x a8",
+                           "a7 a6 a5 a4  a3 a2 a1 a0  o o o o  o o o o";
+
+         write           = "1  1  0  0   0  0  0  0   0 0 0 x  x x x a8",
+                           "a7 a6 a5 a4  a3 a2 a1 a0  i i i i  i i i i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x   x",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 4;
+	readsize	= 256;
+       ;
+     memory "flash"
+         paged           = yes;
+         size            = 8192;
+         page_size       = 64;
+         num_pages       = 128;
+         min_write_delay = 4500;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read_lo         = "  0   0   1   0    0   0   0   0",
+                           "  0   0   0   0   a11 a10 a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         read_hi         = "  0   0   1   0    1   0   0   0",
+                           "  0   0   0   0   a11 a10 a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         loadpage_lo     = "  0   1   0   0    0   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x  a4   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         loadpage_hi     = "  0   1   0   0    1   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x  a4   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         writepage       = "  0  1  0  0   1   1   0   0",
+                           "  0  0  0  0   a11 a10 a9  a8",
+                           " a7 a6 a5  x   x   x   x   x",
+                           "  x  x  x  x   x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 64;
+	readsize	= 256;
+       ;
+     memory "signature"
+         size            = 3;
+         read            = "0  0  1  1   0  0  0  0   0  0  x  x   x  x  x  x",
+                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+       ;
+     memory "lock"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
+                           "x x x x  x x x x  1 1 i i  i i i i";
+
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
+                           "x x x x  x x x x  x x o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "lfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "hfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "efuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                           "x x x x  x x x x  x x x x  x x x i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+     ;
+
+     memory "calibration"
+         size            = 1;
+         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
+                           "0  0  0  0   0  0  0  0    o o o o  o o o o";
+     ;
+  ;
+
+#------------------------------------------------------------
+# AT90PWM3B
+#------------------------------------------------------------
+
+# Completely identical to AT90PWM2B (including the signature!)
+
+part
+     id            = "pwm3b";
+     desc          = "AT90PWM3B";
+     has_debugwire = yes;
+     flash_instr   = 0xB6, 0x01, 0x11;
+     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
+	             0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
+	             0x99, 0xF9, 0xBB, 0xAF;
+     stk500_devcode   = 0x65;
+##  avr910_devcode   = ?;
+     signature        = 0x1e 0x93 0x83;
+     pagel            = 0xD8;
+     bs2              = 0xE2;
+     reset            = io;
+     chip_erase_delay = 9000;
+
+     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+     memory "eeprom"
+         size            = 512;
+        paged           = no;
+        page_size       = 4;
+         min_write_delay = 4000;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read            = "1  0  1  0   0  0  0  0   0 0 0 x  x x x a8",
+                           "a7 a6 a5 a4  a3 a2 a1 a0  o o o o  o o o o";
+
+         write           = "1  1  0  0   0  0  0  0   0 0 0 x  x x x a8",
+                           "a7 a6 a5 a4  a3 a2 a1 a0  i i i i  i i i i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x   x",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 4;
+	readsize	= 256;
+       ;
+     memory "flash"
+         paged           = yes;
+         size            = 8192;
+         page_size       = 64;
+         num_pages       = 128;
+         min_write_delay = 4500;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read_lo         = "  0   0   1   0    0   0   0   0",
+                           "  0   0   0   0   a11 a10 a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         read_hi         = "  0   0   1   0    1   0   0   0",
+                           "  0   0   0   0   a11 a10 a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         loadpage_lo     = "  0   1   0   0    0   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x  a4   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         loadpage_hi     = "  0   1   0   0    1   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x  a4   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         writepage       = "  0  1  0  0   1   1   0   0",
+                           "  0  0  0  0   a11 a10 a9  a8",
+                           " a7 a6 a5  x   x   x   x   x",
+                           "  x  x  x  x   x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 64;
+	readsize	= 256;
+       ;
+     memory "signature"
+         size            = 3;
+         read            = "0  0  1  1   0  0  0  0   0  0  x  x   x  x  x  x",
+                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+       ;
+     memory "lock"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
+                           "x x x x  x x x x  1 1 i i  i i i i";
+
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
+                           "x x x x  x x x x  x x o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "lfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "hfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "efuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                           "x x x x  x x x x  x x x x  x x x i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+     ;
+
+     memory "calibration"
+         size            = 1;
+         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
+                           "0  0  0  0   0  0  0  0    o o o o  o o o o";
+     ;
+  ;
+
+#------------------------------------------------------------
+# ATtiny25
+#------------------------------------------------------------
+
+part
+     id            = "t25";
+     desc          = "ATtiny25";
+     has_debugwire = yes;
+     flash_instr   = 0xB4, 0x02, 0x12;
+     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
+	             0xBC, 0x02, 0xB4, 0x02, 0xBA, 0x0D, 0xBB, 0xBC,
+	             0x99, 0xE1, 0xBB, 0xAC;
+## no STK500 devcode in XML file, use the ATtiny45 one
+     stk500_devcode   = 0x14;
+##  avr910_devcode   = ?;
+##  Try the AT90S2313 devcode:
+     avr910_devcode   = 0x20;
+     signature        = 0x1e 0x91 0x08;
+     reset            = io;
+     chip_erase_delay = 4500;
+
+     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    hvsp_controlstack   =
+        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
+        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
+        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
+        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
+    hventerstabdelay    = 100;
+    hvspcmdexedelay     = 0;
+    synchcycles         = 6;
+    latchcycles         = 1;
+    togglevtg           = 1;
+    poweroffdelay       = 25;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 100;
+    resetdelay          = 25;
+    chiperasepolltimeout = 40;
+    chiperasetime       = 0;
+    programfusepolltimeout = 25;
+    programlockpolltimeout = 25;
+
+     memory "eeprom"
+         size            = 128;
+        paged           = no;
+        page_size       = 4;
+         min_write_delay = 4000;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read            = "1  0  1  0   0  0  0  0   0 0 0 x  x x x x",
+                           "x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
+
+         write           = "1  1  0  0   0  0  0  0   0 0 0 x  x x x x",
+                           "x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x   x",
+			  "  x  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 4;
+	readsize	= 256;
+       ;
+     memory "flash"
+         paged           = yes;
+         size            = 2048;
+         page_size       = 32;
+         num_pages       = 64;
+         min_write_delay = 4500;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read_lo         = "  0   0   1   0    0   0   0   0",
+                           "  0   0   0   0    0   0  a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         read_hi         = "  0   0   1   0    1   0   0   0",
+                           "  0   0   0   0    0   0  a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         loadpage_lo     = "  0   1   0   0    0   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x   x   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         loadpage_hi     = "  0   1   0   0    1   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x   x   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         writepage       = "  0  1  0  0   1  1  0  0",
+                           "  0  0  0  0   0  0 a9 a8",
+                           " a7 a6 a5 a4   x  x  x  x",
+                           "  x  x  x  x   x  x  x  x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 32;
+	readsize	= 256;
+       ;
+#   ATtiny25 has Signature Bytes: 0x1E 0x91 0x08.
+     memory "signature"
+         size            = 3;
+         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
+                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+       ;
+     memory "lock"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
+                           "x x x x  x x x x  1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "lfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "hfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "efuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                           "x x x x  x x x x  x x x x  x x x i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+     ;
+
+     memory "calibration"
+         size            = 2;
+         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
+                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
+     ;
+  ;
+
+#------------------------------------------------------------
+# ATtiny45
+#------------------------------------------------------------
+
+part
+     id            = "t45";
+     desc          = "ATtiny45";
+     has_debugwire = yes;
+     flash_instr   = 0xB4, 0x02, 0x12;
+     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
+	             0xBC, 0x02, 0xB4, 0x02, 0xBA, 0x0D, 0xBB, 0xBC,
+	             0x99, 0xE1, 0xBB, 0xAC;
+     stk500_devcode   = 0x14;
+##  avr910_devcode   = ?;
+##  Try the AT90S2313 devcode:
+     avr910_devcode   = 0x20;
+     signature        = 0x1e 0x92 0x06;
+     reset            = io;
+     chip_erase_delay = 4500;
+
+     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    hvsp_controlstack     =
+	0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
+        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
+        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
+        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    hvspcmdexedelay     = 0;
+    synchcycles         = 6;
+    latchcycles         = 1;
+    togglevtg           = 1;
+    poweroffdelay       = 25;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 100;
+    resetdelay          = 25;
+    chiperasepolltimeout = 40;
+    chiperasetime       = 0;
+    programfusepolltimeout = 25;
+    programlockpolltimeout = 25;
+
+     memory "eeprom"
+         size            = 256;
+         page_size       = 4;
+         min_write_delay = 4000;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read            = "1  0  1  0   0  0  0  0    0 0 0 x  x x x x",
+                           "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
+
+         write           = "1  1  0  0   0  0  0  0    0 0 0 x  x x x x",
+                           "a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x   x",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 4;
+	readsize	= 256;
+       ;
+     memory "flash"
+         paged           = yes;
+         size            = 4096;
+         page_size       = 64;
+         num_pages       = 64;
+         min_write_delay = 4500;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read_lo         = "  0   0   1   0    0   0   0   0",
+                           "  0   0   0   0    0  a10 a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         read_hi         = "  0   0   1   0    1   0   0   0",
+                           "  0   0   0   0    0  a10 a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         loadpage_lo     = "  0   1   0   0    0   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x  a4   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         loadpage_hi     = "  0   1   0   0    1   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x  a4   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         writepage       = "  0  1  0  0   1  1  0  0",
+                           "  0  0  0  0   0 a10 a9 a8",
+                           " a7 a6 a5  x   x  x  x  x",
+                           "  x  x  x  x   x  x  x  x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 32;
+	readsize	= 256;
+       ;
+#   ATtiny45 has Signature Bytes: 0x1E 0x92 0x08. (Data sheet 2586C-AVR-06/05 (doc2586.pdf) indicates otherwise!)
+     memory "signature"
+         size            = 3;
+         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
+                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+       ;
+     memory "lock"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
+                           "x x x x  x x x x  1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "lfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "hfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "efuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                           "x x x x  x x x x  x x x x  x x x i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+     ;
+
+     memory "calibration"
+         size            = 2;
+         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
+                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
+     ;
+  ;
+
+#------------------------------------------------------------
+# ATtiny85
+#------------------------------------------------------------
+
+part
+     id            = "t85";
+     desc          = "ATtiny85";
+     has_debugwire = yes;
+     flash_instr   = 0xB4, 0x02, 0x12;
+     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
+	             0xBC, 0x02, 0xB4, 0x02, 0xBA, 0x0D, 0xBB, 0xBC,
+	             0x99, 0xE1, 0xBB, 0xAC;
+## no STK500 devcode in XML file, use the ATtiny45 one
+     stk500_devcode   = 0x14;
+##  avr910_devcode   = ?;
+##  Try the AT90S2313 devcode:
+     avr910_devcode   = 0x20;
+     signature        = 0x1e 0x93 0x0b;
+     reset            = io;
+     chip_erase_delay = 4500;
+
+     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    hvsp_controlstack   =
+        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
+        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
+        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
+        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
+    hventerstabdelay    = 100;
+    hvspcmdexedelay     = 0;
+    synchcycles         = 6;
+    latchcycles         = 1;
+    togglevtg           = 1;
+    poweroffdelay       = 25;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 100;
+    resetdelay          = 25;
+    chiperasepolltimeout = 40;
+    chiperasetime       = 0;
+    programfusepolltimeout = 25;
+    programlockpolltimeout = 25;
+
+     memory "eeprom"
+         size            = 512;
+        paged           = no;
+        page_size       = 4;
+         min_write_delay = 4000;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read            = "1  0  1  0   0  0  0  0    0 0 0 x  x x x a8",
+                           "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
+
+         write           = "1  1  0  0   0  0  0  0    0 0 0 x  x x x a8",
+                           "a8 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x  a8",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 4;
+	readsize	= 256;
+       ;
+     memory "flash"
+         paged           = yes;
+         size            = 8192;
+         page_size       = 64;
+         num_pages       = 128;
+         min_write_delay = 4500;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read_lo         = "  0   0   1   0    0   0   0   0",
+                           "  0   0   0   0  a11 a10  a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         read_hi         = "  0   0   1   0    1   0   0   0",
+                           "  0   0   0   0  a11 a10  a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         loadpage_lo     = "  0   1   0   0    0   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x  a4   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         loadpage_hi     = "  0   1   0   0    1   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x  a4   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         writepage       = "  0  1  0  0   1   1   0  0",
+                           "  0  0  0  0  a11 a10 a9 a8",
+                           " a7 a6 a5  x   x  x  x  x",
+                           "  x  x  x  x   x  x  x  x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 32;
+	readsize	= 256;
+       ;
+#   ATtiny85 has Signature Bytes: 0x1E 0x93 0x08.
+     memory "signature"
+         size            = 3;
+         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
+                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+       ;
+     memory "lock"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
+                           "x x x x  x x x x  1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "lfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "hfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "efuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                           "x x x x  x x x x  x x x x  x x x i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+     ;
+
+     memory "calibration"
+         size            = 2;
+         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
+                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
+     ;
+  ;
+
+#------------------------------------------------------------
+# ATmega640
+#------------------------------------------------------------
+# Almost same as ATmega1280, except for different memory sizes
+
+part
+    id               = "m640";
+    desc             = "ATMEGA640";
+    signature        = 0x1e 0x96 0x08;
+    has_jtag         = yes;
+#    stk500_devcode   = 0xB2;
+#    avr910_devcode   = 0x43;
+    chip_erase_delay = 9000;
+    pagel            = 0xD7;
+    bs2              = 0xA0;
+    reset            = dedicated;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    rampz               = 0x3b;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 4096;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0  a2  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x    a11 a10  a9  a8",
+			  " a7  a6  a5  a4     a3   0   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 8;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 65536;
+        page_size       = 256;
+        num_pages       = 256;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  x x x x  x i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
+                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# ATmega1280
+#------------------------------------------------------------
+
+part
+    id               = "m1280";
+    desc             = "ATMEGA1280";
+    signature        = 0x1e 0x97 0x03;
+    has_jtag         = yes;
+#    stk500_devcode   = 0xB2;
+#    avr910_devcode   = 0x43;
+    chip_erase_delay = 9000;
+    pagel            = 0xD7;
+    bs2              = 0xA0;
+    reset            = dedicated;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    rampz               = 0x3b;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 4096;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0  a2  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x    a11 a10  a9  a8",
+			  " a7  a6  a5  a4     a3   0   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 8;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 131072;
+        page_size       = 256;
+        num_pages       = 512;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  x x x x  x i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
+                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# ATmega1281
+#------------------------------------------------------------
+# Identical to ATmega1280
+
+part
+    id               = "m1281";
+    desc             = "ATMEGA1281";
+    signature        = 0x1e 0x97 0x04;
+    has_jtag         = yes;
+#    stk500_devcode   = 0xB2;
+#    avr910_devcode   = 0x43;
+    chip_erase_delay = 9000;
+    pagel            = 0xD7;
+    bs2              = 0xA0;
+    reset            = dedicated;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    rampz               = 0x3b;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 4096;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0  a2  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x    a11 a10  a9  a8",
+			  " a7  a6  a5  a4     a3   0   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 8;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 131072;
+        page_size       = 256;
+        num_pages       = 512;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  x x x x  x i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
+                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# ATmega2560
+#------------------------------------------------------------
+
+part
+    id               = "m2560";
+    desc             = "ATMEGA2560";
+    signature        = 0x1e 0x98 0x01;
+    has_jtag         = yes;
+#    stk500_devcode   = 0xB2;
+#    avr910_devcode   = 0x43;
+    chip_erase_delay = 9000;
+    pagel            = 0xD7;
+    bs2              = 0xA0;
+    reset            = dedicated;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    rampz               = 0x3b;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 4096;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0  a2  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x    a11 a10  a9  a8",
+			  " a7  a6  a5  a4     a3   0   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 8;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 262144;
+        page_size       = 256;
+        num_pages       = 1024;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+        load_ext_addr   = "  0   1   0   0      1   1   0   1",
+                          "  0   0   0   0      0   0   0   0",
+                          "  0   0   0   0      0   0   0 a16",
+                          "  0   0   0   0      0   0   0   0";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  x x x x  x i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
+                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# ATmega2561
+#------------------------------------------------------------
+
+part
+    id               = "m2561";
+    desc             = "ATMEGA2561";
+    signature        = 0x1e 0x98 0x02;
+    has_jtag         = yes;
+#    stk500_devcode   = 0xB2;
+#    avr910_devcode   = 0x43;
+    chip_erase_delay = 9000;
+    pagel            = 0xD7;
+    bs2              = 0xA0;
+    reset            = dedicated;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    rampz               = 0x3b;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 4096;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0  a2  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x    a11 a10  a9  a8",
+			  " a7  a6  a5  a4     a3   0   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 8;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 262144;
+        page_size       = 256;
+        num_pages       = 1024;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+        load_ext_addr   = "  0   1   0   0      1   1   0   1",
+                          "  0   0   0   0      0   0   0   0",
+                          "  0   0   0   0      0   0   0 a16",
+                          "  0   0   0   0      0   0   0   0";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  x x x x  x i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
+                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# ATtiny24
+#------------------------------------------------------------
+
+part
+     id            = "t24";
+     desc          = "ATtiny24";
+     has_debugwire = yes;
+     flash_instr   = 0xB4, 0x07, 0x17;
+     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
+	             0xBC, 0x07, 0xB4, 0x07, 0xBA, 0x0D, 0xBB, 0xBC,
+	             0x99, 0xE1, 0xBB, 0xAC;
+## no STK500 devcode in XML file, use the ATtiny45 one
+     stk500_devcode   = 0x14;
+##  avr910_devcode   = ?;
+##  Try the AT90S2313 devcode:
+     avr910_devcode   = 0x20;
+     signature        = 0x1e 0x91 0x0b;
+     reset            = io;
+     chip_erase_delay = 4500;
+
+     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    hvsp_controlstack   =
+        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
+        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
+        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
+        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x0F;
+    hventerstabdelay    = 100;
+    hvspcmdexedelay     = 0;
+    synchcycles         = 6;
+    latchcycles         = 1;
+    togglevtg           = 1;
+    poweroffdelay       = 25;
+    resetdelayms        = 0;
+    resetdelayus        = 70;
+    hvleavestabdelay    = 100;
+    resetdelay          = 25;
+    chiperasepolltimeout = 40;
+    chiperasetime       = 0;
+    programfusepolltimeout = 25;
+    programlockpolltimeout = 25;
+
+     memory "eeprom"
+         size            = 128;
+        paged           = no;
+        page_size       = 4;
+         min_write_delay = 4000;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read            = "1  0  1  0   0  0  0  0   0 0 0 x  x x x x",
+                           "x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
+
+         write           = "1  1  0  0   0  0  0  0   0 0 0 x  x x x x",
+                           "x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x   x",
+			  "  x  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 4;
+	readsize	= 256;
+       ;
+     memory "flash"
+         paged           = yes;
+         size            = 2048;
+         page_size       = 32;
+         num_pages       = 64;
+         min_write_delay = 4500;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read_lo         = "  0   0   1   0    0   0   0   0",
+                           "  0   0   0   0    0   0  a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         read_hi         = "  0   0   1   0    1   0   0   0",
+                           "  0   0   0   0    0   0  a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         loadpage_lo     = "  0   1   0   0    0   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x   x   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         loadpage_hi     = "  0   1   0   0    1   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x   x   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         writepage       = "  0  1  0  0   1  1  0  0",
+                           "  0  0  0  0   0  0 a9 a8",
+                           " a7 a6 a5 a4   x  x  x  x",
+                           "  x  x  x  x   x  x  x  x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 32;
+	readsize	= 256;
+       ;
+#   ATtiny24 has Signature Bytes: 0x1E 0x91 0x0B.
+     memory "signature"
+         size            = 3;
+         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
+                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+       ;
+     memory "lock"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
+                           "x x x x  x x x x  x x x x  x x i i";
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
+                           "0 0 0 0  0 0 0 0  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "lfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "hfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "efuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                           "x x x x  x x x x  x x x x  x x x i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+     ;
+
+     memory "calibration"
+         size            = 1;
+         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
+                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
+     ;
+  ;
+
+#------------------------------------------------------------
+# ATtiny44
+#------------------------------------------------------------
+
+part
+     id            = "t44";
+     desc          = "ATtiny44";
+     has_debugwire = yes;
+     flash_instr   = 0xB4, 0x07, 0x17;
+     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
+                     0xBC, 0x07, 0xB4, 0x07, 0xBA, 0x0D, 0xBB, 0xBC,
+                     0x99, 0xE1, 0xBB, 0xAC;
+## no STK500 devcode in XML file, use the ATtiny45 one
+     stk500_devcode   = 0x14;
+##  avr910_devcode   = ?;
+##  Try the AT90S2313 devcode:
+     avr910_devcode   = 0x20;
+     signature        = 0x1e 0x92 0x07;
+     reset            = io;
+     chip_erase_delay = 4500;
+
+     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    hvsp_controlstack   =
+        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
+        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
+        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
+        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x0F;
+    hventerstabdelay    = 100;
+    hvspcmdexedelay     = 0;
+    synchcycles         = 6;
+    latchcycles         = 1;
+    togglevtg           = 1;
+    poweroffdelay       = 25;
+    resetdelayms        = 0;
+    resetdelayus        = 70;
+    hvleavestabdelay    = 100;
+    resetdelay          = 25;
+    chiperasepolltimeout = 40;
+    chiperasetime       = 0;
+    programfusepolltimeout = 25;
+    programlockpolltimeout = 25;
+
+     memory "eeprom"
+         size            = 256;
+        paged           = no;
+        page_size       = 4;
+         min_write_delay = 4000;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read            = "1  0  1  0   0  0  0  0    0 0 0 x  x x x x",
+                           "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
+
+         write           = "1  1  0  0   0  0  0  0    0 0 0 x  x x x x",
+                           "a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x   x",
+			  "  x  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 4;
+	readsize	= 256;
+       ;
+     memory "flash"
+         paged           = yes;
+         size            = 4096;
+         page_size       = 64;
+         num_pages       = 64;
+         min_write_delay = 4500;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read_lo         = "  0   0   1   0    0   0   0   0",
+                           "  0   0   0   0    0  a10 a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         read_hi         = "  0   0   1   0    1   0   0   0",
+                           "  0   0   0   0    0  a10 a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         loadpage_lo     = "  0   1   0   0    0   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x  a4   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         loadpage_hi     = "  0   1   0   0    1   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x  a4   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         writepage       = "  0  1  0  0   1  1  0  0",
+                           "  0  0  0  0   0 a10 a9 a8",
+                           " a7 a6 a5  x   x  x  x  x",
+                           "  x  x  x  x   x  x  x  x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 32;
+	readsize	= 256;
+       ;
+#   ATtiny44 has Signature Bytes: 0x1E 0x92 0x07.
+     memory "signature"
+         size            = 3;
+         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
+                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+       ;
+     memory "lock"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
+                           "x x x x  x x x x  x x x x  x x i i";
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
+                           "0 0 0 0  0 0 0 0  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "lfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "hfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "efuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                           "x x x x  x x x x  x x x x  x x x i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+     ;
+
+     memory "calibration"
+         size            = 1;
+         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
+                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
+     ;
+  ;
+
+#------------------------------------------------------------
+# ATtiny84
+#------------------------------------------------------------
+
+part
+     id            = "t84";
+     desc          = "ATtiny84";
+     has_debugwire = yes;
+     flash_instr   = 0xB4, 0x07, 0x17;
+     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
+	             0xBC, 0x07, 0xB4, 0x07, 0xBA, 0x0D, 0xBB, 0xBC,
+	             0x99, 0xE1, 0xBB, 0xAC;
+## no STK500 devcode in XML file, use the ATtiny45 one
+     stk500_devcode   = 0x14;
+##  avr910_devcode   = ?;
+##  Try the AT90S2313 devcode:
+     avr910_devcode   = 0x20;
+     signature        = 0x1e 0x93 0x0c;
+     reset            = io;
+     chip_erase_delay = 4500;
+
+     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    hvsp_controlstack   =
+        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
+        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
+        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
+        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x0F;
+    hventerstabdelay    = 100;
+    hvspcmdexedelay     = 0;
+    synchcycles         = 6;
+    latchcycles         = 1;
+    togglevtg           = 1;
+    poweroffdelay       = 25;
+    resetdelayms        = 0;
+    resetdelayus        = 70;
+    hvleavestabdelay    = 100;
+    resetdelay          = 25;
+    chiperasepolltimeout = 40;
+    chiperasetime       = 0;
+    programfusepolltimeout = 25;
+    programlockpolltimeout = 25;
+
+     memory "eeprom"
+         size            = 512;
+        paged           = no;
+        page_size       = 4;
+         min_write_delay = 4000;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read            = "1  0  1  0   0  0  0  0    0 0 0 x  x x x a8",
+                           "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
+
+         write           = "1  1  0  0   0  0  0  0    0 0 0 x  x x x a8",
+                           "a8 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x   x",
+			  "  x  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 4;
+	readsize	= 256;
+       ;
+     memory "flash"
+         paged           = yes;
+         size            = 8192;
+         page_size       = 64;
+         num_pages       = 128;
+         min_write_delay = 4500;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read_lo         = "  0   0   1   0    0   0   0   0",
+                           "  0   0   0   0  a11 a10  a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         read_hi         = "  0   0   1   0    1   0   0   0",
+                           "  0   0   0   0  a11 a10  a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         loadpage_lo     = "  0   1   0   0    0   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x  a4   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         loadpage_hi     = "  0   1   0   0    1   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x  a4   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         writepage       = "  0  1  0  0   1   1   0  0",
+                           "  0  0  0  0  a11 a10 a9 a8",
+                           " a7 a6 a5  x   x  x  x  x",
+                           "  x  x  x  x   x  x  x  x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 32;
+	readsize	= 256;
+       ;
+#   ATtiny84 has Signature Bytes: 0x1E 0x93 0x0C.
+     memory "signature"
+         size            = 3;
+         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
+                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+       ;
+
+     memory "lock"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
+                           "x x x x  x x x x  x x x x  x x i i";
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
+                           "0 0 0 0  0 0 0 0  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "lfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "hfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "efuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                           "x x x x  x x x x  x x x x  x x x i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+     ;
+
+     memory "calibration"
+         size            = 1;
+         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
+                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
+     ;
+  ;
+
+#------------------------------------------------------------
+# AT90USB646
+#------------------------------------------------------------
+
+part
+    id               = "usb646";
+    desc             = "AT90USB646";
+#    signature        = 0x1e 0x96 0x82; ?
+    signature        = 0x1e 0x97 0x82;
+    has_jtag         = yes;
+#    stk500_devcode   = 0xB2;
+#    avr910_devcode   = 0x43;
+    chip_erase_delay = 9000;
+    pagel            = 0xD7;
+    bs2              = 0xA0;
+    reset            = dedicated;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    rampz               = 0x3b;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 2048;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x      x a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0  a2  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x a10  a9  a8",
+			  " a7  a6  a5  a4     a3   0   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 8;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 65536;
+        page_size       = 256;
+        num_pages       = 256;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  x x x x  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
+                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# AT90USB647
+#------------------------------------------------------------
+# identical to AT90USB646
+
+part
+    id               = "usb647";
+    desc             = "AT90USB647";
+#    signature        = 0x1e 0x96 0x82; ?
+    signature        = 0x1e 0x97 0x82;
+    has_jtag         = yes;
+#    stk500_devcode   = 0xB2;
+#    avr910_devcode   = 0x43;
+    chip_erase_delay = 9000;
+    pagel            = 0xD7;
+    bs2              = 0xA0;
+    reset            = dedicated;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    rampz               = 0x3b;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 2048;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x      x a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0  a2  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x a10  a9  a8",
+			  " a7  a6  a5  a4     a3   0   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 8;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 65536;
+        page_size       = 256;
+        num_pages       = 256;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  x x x x  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
+                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# AT90USB1286
+#------------------------------------------------------------
+
+part
+    id               = "usb1286";
+    desc             = "AT90USB1286";
+    signature        = 0x1e 0x97 0x82;
+    has_jtag         = yes;
+#    stk500_devcode   = 0xB2;
+#    avr910_devcode   = 0x43;
+    chip_erase_delay = 9000;
+    pagel            = 0xD7;
+    bs2              = 0xA0;
+    reset            = dedicated;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    rampz               = 0x3b;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 4096;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0  a2  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x a10  a9  a8",
+			  " a7  a6  a5  a4     a3   0   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 8;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 131072;
+        page_size       = 256;
+        num_pages       = 512;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  x x x x  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
+                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# AT90USB1287
+#------------------------------------------------------------
+# identical to AT90USB1286
+
+part
+    id               = "usb1287";
+    desc             = "AT90USB1287";
+    signature        = 0x1e 0x97 0x82;
+    has_jtag         = yes;
+#    stk500_devcode   = 0xB2;
+#    avr910_devcode   = 0x43;
+    chip_erase_delay = 9000;
+    pagel            = 0xD7;
+    bs2              = 0xA0;
+    reset            = dedicated;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    rampz               = 0x3b;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 4096;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0  a2  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x a10  a9  a8",
+			  " a7  a6  a5  a4     a3   0   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 8;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 131072;
+        page_size       = 256;
+        num_pages       = 512;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  x x x x  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
+                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# ATmega325
+#------------------------------------------------------------
+
+part
+    id               = "m325";
+    desc             = "ATMEGA325";
+    signature        = 0x1e 0x95 0x05;
+    has_jtag         = yes;
+#   stk500_devcode   = 0x??; # No STK500v1 support?
+#   avr910_devcode   = 0x??; # Try the ATmega16 one
+    avr910_devcode   = 0x74;
+    pagel            = 0xd7;
+    bs2              = 0xa0;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "0 0 0 0  0 0 0 0    0 0 0 0  0 0 0 0";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "0 0 0 0  0 0 0 0    0 0 0 0  0 0 0 0";
+
+    timeout             = 200;
+    stabdelay           = 100;
+    cmdexedelay         = 25;
+    synchloops          = 32;
+    bytedelay           = 0;
+    pollindex           = 3;
+    pollvalue           = 0x53;
+    predelay            = 1;
+    postdelay           = 1;
+    pollmethod          = 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 4;  /* for parallel programming */
+        size            = 1024;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   0   0      0   0  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   0   0      0   0  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_lo     = "  1   1   0   0      0   0   0   1",
+                          "  0   0   0   0      0   0   0   0",
+                          "  0   0   0   0      0   0  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  1   1   0   0      0   0   1   0",
+                          "  0   0   0   0      0   0  a9  a8",
+                          " a7  a6  a5  a4     a3  a2   0   0",
+                          "  x   x   x   x      x   x   x   x";
+
+        mode            = 0x41;
+        delay           = 10;
+        blocksize       = 4;
+        readsize        = 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 32768;
+        page_size       = 128;
+        num_pages       = 256;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   0   0      0   0   0   0",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   0   0      0   0   0   0",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  x   x   x   x      x   x   x   x";
+
+        mode            = 0x41;
+        delay           = 10;
+        blocksize       = 128;
+        readsize        = 256;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 0  0 0 0 0",
+                          "0 0 0 0  0 0 0 0   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "0 0 0 0  0 0 0 0   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "0 0 0 0  0 0 0 0   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "0 0 0 0  0 0 0 0  o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "0 0 0 0  0 0 0 0  1 1 1 1  1 i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   0  0  0  0   0  0  0  0",
+                          "0  0  0  0   0  0 a1 a0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "calibration"
+        size            = 1;
+
+        read            = "0 0 1 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+        ;
+  ;
+
+#------------------------------------------------------------
+# ATmega645
+#------------------------------------------------------------
+
+part
+    id               = "m645";
+    desc             = "ATMEGA645";
+    signature        = 0x1E 0x96 0x05;
+    has_jtag         = yes;
+#   stk500_devcode   = 0x??; # No STK500v1 support?
+#   avr910_devcode   = 0x??; # Try the ATmega16 one
+    avr910_devcode   = 0x74;
+    pagel            = 0xd7;
+    bs2              = 0xa0;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "0 0 0 0  0 0 0 0    0 0 0 0  0 0 0 0";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "0 0 0 0  0 0 0 0    0 0 0 0  0 0 0 0";
+
+    timeout             = 200;
+    stabdelay           = 100;
+    cmdexedelay         = 25;
+    synchloops          = 32;
+    bytedelay           = 0;
+    pollindex           = 3;
+    pollvalue           = 0x53;
+    predelay            = 1;
+    postdelay           = 1;
+    pollmethod          = 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 2048;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   0   0      0 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   0   0      0 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_lo     = "  1   1   0   0      0   0   0   1",
+                          "  0   0   0   0      0   0   0   0",
+                          "  0   0   0   0      0  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  1   1   0   0      0   0   1   0",
+                          "  0   0   0   0      0 a10  a9  a8",
+                          " a7  a6  a5  a4     a3   0   0   0",
+                          "  x   x   x   x      x   x   x   x";
+
+        mode            = 0x41;
+        delay           = 10;
+        blocksize       = 8;
+        readsize        = 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 65536;
+        page_size       = 256;
+        num_pages       = 256;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "   0   0   1   0      0   0   0   0",
+                          " a15 a14 a13 a12    a11 a10  a9  a8",
+                          "  a7  a6  a5  a4     a3  a2  a1  a0",
+                          "   o   o   o   o      o   o   o   o";
+
+        read_hi         = "   0   0   1   0      1   0   0   0",
+                          " a15 a14 a13 a12    a11 a10  a9  a8",
+                          "  a7  a6  a5  a4     a3  a2  a1  a0",
+                          "   o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   0   0      0   0   0   0",
+                          "  a7 a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   0   0      0   0   0   0",
+                          "  a7 a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "   0   1   0   0      1   1   0   0",
+                          " a15 a14 a13 a12    a11 a10  a9  a8",
+                          "  a7  a6  a5  a4     a3  a2  a1  a0",
+                          "   0   0   0   0      0   0   0   0";
+
+        mode            = 0x41;
+        delay           = 10;
+        blocksize       = 128;
+        readsize        = 256;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 0  0 0 0 0",
+                          "0 0 0 0  0 0 0 0   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "0 0 0 0  0 0 0 0   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "0 0 0 0  0 0 0 0   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "0 0 0 0  0 0 0 0  o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "0 0 0 0  0 0 0 0  1 1 1 1  1 i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   0  0  0  0   0  0  0  0",
+                          "0  0  0  0   0  0 a1 a0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "calibration"
+        size            = 1;
+
+        read            = "0 0 1 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+        ;
+  ;
+
+#------------------------------------------------------------
+# ATmega3250
+#------------------------------------------------------------
+
+part
+    id               = "m3250";
+    desc             = "ATMEGA3250";
+    signature        = 0x1E 0x95 0x06;
+    has_jtag         = yes;
+#   stk500_devcode   = 0x??; # No STK500v1 support?
+#   avr910_devcode   = 0x??; # Try the ATmega16 one
+    avr910_devcode   = 0x74;
+    pagel            = 0xd7;
+    bs2              = 0xa0;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "0 0 0 0  0 0 0 0    0 0 0 0  0 0 0 0";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "0 0 0 0  0 0 0 0    0 0 0 0  0 0 0 0";
+
+    timeout             = 200;
+    stabdelay           = 100;
+    cmdexedelay         = 25;
+    synchloops          = 32;
+    bytedelay           = 0;
+    pollindex           = 3;
+    pollvalue           = 0x53;
+    predelay            = 1;
+    postdelay           = 1;
+    pollmethod          = 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 4;  /* for parallel programming */
+        size            = 1024;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   0   0      0   0  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   0   0      0   0  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_lo     = "  1   1   0   0      0   0   0   1",
+                          "  0   0   0   0      0   0   0   0",
+                          "  0   0   0   0      0   0  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  1   1   0   0      0   0   1   0",
+                          "  0   0   0   0      0   0  a9  a8",
+                          " a7  a6  a5  a4     a3  a2   0   0",
+                          "  x   x   x   x      x   x   x   x";
+
+        mode            = 0x41;
+        delay           = 10;
+        blocksize       = 4;
+        readsize        = 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 32768;
+        page_size       = 128;
+        num_pages       = 256;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   0   0      0   0   0   0",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   0   0      0   0   0   0",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  x   x   x   x      x   x   x   x";
+
+        mode            = 0x41;
+        delay           = 10;
+        blocksize       = 128;
+        readsize        = 256;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 0  0 0 0 0",
+                          "0 0 0 0  0 0 0 0   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "0 0 0 0  0 0 0 0   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "0 0 0 0  0 0 0 0   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "0 0 0 0  0 0 0 0  o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "0 0 0 0  0 0 0 0  1 1 1 1  1 i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   0  0  0  0   0  0  0  0",
+                          "0  0  0  0   0  0 a1 a0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "calibration"
+        size            = 1;
+
+        read            = "0 0 1 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+        ;
+  ;
+
+#------------------------------------------------------------
+# ATmega6450
+#------------------------------------------------------------
+
+part
+    id               = "m6450";
+    desc             = "ATMEGA6450";
+    signature        = 0x1E 0x96 0x06;
+    has_jtag         = yes;
+#   stk500_devcode   = 0x??; # No STK500v1 support?
+#   avr910_devcode   = 0x??; # Try the ATmega16 one
+    avr910_devcode   = 0x74;
+    pagel            = 0xd7;
+    bs2              = 0xa0;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "0 0 0 0  0 0 0 0    0 0 0 0  0 0 0 0";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "0 0 0 0  0 0 0 0    0 0 0 0  0 0 0 0";
+
+    timeout             = 200;
+    stabdelay           = 100;
+    cmdexedelay         = 25;
+    synchloops          = 32;
+    bytedelay           = 0;
+    pollindex           = 3;
+    pollvalue           = 0x53;
+    predelay            = 1;
+    postdelay           = 1;
+    pollmethod          = 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 2048;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   0   0      0 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   0   0      0 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_lo     = "  1   1   0   0      0   0   0   1",
+                          "  0   0   0   0      0   0   0   0",
+                          "  0   0   0   0      0  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  1   1   0   0      0   0   1   0",
+                          "  0   0   0   0      0 a10  a9  a8",
+                          " a7  a6  a5  a4     a3   0   0   0",
+                          "  x   x   x   x      x   x   x   x";
+
+        mode            = 0x41;
+        delay           = 10;
+        blocksize       = 4;
+        readsize        = 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 65536;
+        page_size       = 256;
+        num_pages       = 256;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "   0   0   1   0      0   0   0   0",
+                          " a15 a14 a13 a12    a11 a10  a9  a8",
+                          "  a7  a6  a5  a4     a3  a2  a1  a0",
+                          "   o   o   o   o      o   o   o   o";
+
+        read_hi         = "   0   0   1   0      1   0   0   0",
+                          " a15 a14 a13 a12    a11 a10  a9  a8",
+                          "  a7  a6  a5  a4     a3  a2  a1  a0",
+                          "   o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   0   0      0   0   0   0",
+                          "  a7 a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   0   0      0   0   0   0",
+                          "  a7 a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "   0   1   0   0      1   1   0   0",
+                          " a15 a14 a13 a12    a11 a10  a9  a8",
+                          "  a7  a6  a5  a4     a3  a2  a1  a0",
+                          "   0   0   0   0      0   0   0   0";
+
+        mode            = 0x41;
+        delay           = 10;
+        blocksize       = 128;
+        readsize        = 256;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 0  0 0 0 0",
+                          "0 0 0 0  0 0 0 0   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "0 0 0 0  0 0 0 0   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "0 0 0 0  0 0 0 0   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "0 0 0 0  0 0 0 0  o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "0 0 0 0  0 0 0 0  1 1 1 1  1 i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   0  0  0  0   0  0  0  0",
+                          "0  0  0  0   0  0 a1 a0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "calibration"
+        size            = 1;
+
+        read            = "0 0 1 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+        ;
+  ;
diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index 00ccaa0..1d2a481 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -5,37 +5,55 @@
 // Advanced settings can be found in Configuration_adv.h 
 // BASIC SETTINGS: select your board type, temperature sensor type, axis scaling, and endstop configuration
 
-//User specified version info of THIS file to display in [Pronterface, etc] terminal window during startup.
+//User specified version info of this build to display in [Pronterface, etc] terminal window during startup.
 //Implementation of an idea by Prof Braino to inform user that any changes made
-//to THIS file by the user have been successfully uploaded into firmware.
-#define STRING_VERSION_CONFIG_H "2012-05-02" //Personal revision number for changes to THIS file.
-#define STRING_CONFIG_H_AUTHOR "erik" //Who made the changes.
+//to this build by the user have been successfully uploaded into firmware.
+#define STRING_VERSION_CONFIG_H __DATE__ " " __TIME__ // build date and time
+#define STRING_CONFIG_H_AUTHOR "(none, default config)" //Who made the changes.
+
+// SERIAL_PORT selects which serial port should be used for communication with the host.
+// This allows the connection of wireless adapters (for instance) to non-default port pins.
+// Serial port 0 is still used by the Arduino bootloader regardless of this setting.
+#define SERIAL_PORT 0
 
 // This determines the communication speed of the printer
 #define BAUDRATE 250000
 //#define BAUDRATE 115200
 
 //// The following define selects which electronics board you have. Please choose the one that matches your setup
-// Gen7 custom (Alfons3 Version) = 10 "https://github.com/Alfons3/Generation_7_Electronics"
-// Gen7 v1.1, v1.2 = 11
-// Gen7 v1.3 = 12
-// Gen7 v1.4 = 13
-// MEGA/RAMPS up to 1.2 = 3
-// RAMPS 1.3 = 33 (Power outputs: Extruder, Bed, Fan)
-// RAMPS 1.3 = 34 (Power outputs: Extruder0, Extruder1, Bed)
-// Gen6 = 5
-// Gen6 deluxe = 51
-// Sanguinololu 1.2 and above = 62
-// Melzi = 63
-// Ultimaker = 7
-// Teensylu = 8
-// Gen3+ =9
+// 10 = Gen7 custom (Alfons3 Version) "https://github.com/Alfons3/Generation_7_Electronics"
+// 11 = Gen7 v1.1, v1.2 = 11
+// 12 = Gen7 v1.3
+// 13 = Gen7 v1.4
+// 3  = MEGA/RAMPS up to 1.2 = 3
+// 33 = RAMPS 1.3 (Power outputs: Extruder, Bed, Fan)
+// 34 = RAMPS 1.3 (Power outputs: Extruder0, Extruder1, Bed)
+// 4  = Duemilanove w/ ATMega328P pin assignment
+// 5  = Gen6
+// 51 = Gen6 deluxe
+// 6  = Sanguinololu < 1.2
+// 62 = Sanguinololu 1.2 and above
+// 63 = Melzi
+// 7  = Ultimaker
+// 71 = Ultimaker (Older electronics. Pre 1.5.4. This is rare)
+// 8  = Teensylu
+// 81 = Printrboard (AT90USB1286)
+// 82 = Brainwave (AT90USB646)
+// 9  = Gen3+
+// 70 = Megatronics
+// 90 = Alpha OMCA board
+// 91 = Final OMCA board
+// 301 = Rambo
 
 #ifndef MOTHERBOARD
 #define MOTHERBOARD 7
 #endif
 
+//// The following define selects which power supply you have. Please choose the one that matches your setup
+// 1 = ATX
+// 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
 
+#define POWER_SUPPLY 1
 
 //===========================================================================
 //=============================Thermal Settings  ============================
@@ -95,13 +113,15 @@
 // PID settings:
 // Comment the following line to disable PID and enable bang-bang.
 #define PIDTEMP
-#define PID_MAX 255 // limits current to nozzle; 255=full current
+#define PID_MAX 256 // limits current to nozzle; 256=full current
 #ifdef PIDTEMP
   //#define PID_DEBUG // Sends debug data to the serial port. 
-  //#define PID_OPENLOOP 1 // Puts PID in open loop. M104 sets the output power in %
+  //#define PID_OPENLOOP 1 // Puts PID in open loop. M104/M140 sets the output power from 0 to PID_MAX
+  #define PID_FUNCTIONAL_RANGE 10 // If the temperature difference between the target temperature and the actual temperature
+                                  // is more then PID_FUNCTIONAL_RANGE then the PID will be shut off and the heater will be set to min/max.
   #define PID_INTEGRAL_DRIVE_MAX 255  //limit for the integral term
   #define K1 0.95 //smoothing factor withing the PID
-  #define PID_dT ((16.0 * 8.0)/(F_CPU / 64.0 / 256.0)) //sampling period of the
+  #define PID_dT ((16.0 * 8.0)/(F_CPU / 64.0 / 256.0)) //sampling period of the temperature routine
 
 // If you are using a preconfigured hotend then you can use one of the value sets by uncommenting it
 // Ultimaker
@@ -120,6 +140,44 @@
 //    #define  DEFAULT_Kd 440
 #endif // PIDTEMP
 
+// Bed Temperature Control
+// Select PID or bang-bang with PIDTEMPBED.  If bang-bang, BED_LIMIT_SWITCHING will enable hysteresis
+//
+// uncomment this to enable PID on the bed.   It uses the same ferquency PWM as the extruder. 
+// If your PID_dT above is the default, and correct for your hardware/configuration, that means 7.689Hz,
+// which is fine for driving a square wave into a resistive load and does not significantly impact you FET heating.
+// This also works fine on a Fotek SSR-10DA Solid State Relay into a 250W heater. 
+// If your configuration is significantly different than this and you don't understand the issues involved, you proabaly 
+// shouldn't use bed PID until someone else verifies your hardware works.
+// If this is enabled, find your own PID constants below.
+//#define PIDTEMPBED
+//
+//#define BED_LIMIT_SWITCHING
+
+// This sets the max power delived to the bed, and replaces the HEATER_BED_DUTY_CYCLE_DIVIDER option.
+// all forms of bed control obey this (PID, bang-bang, bang-bang with hysteresis)
+// setting this to anything other than 256 enables a form of PWM to the bed just like HEATER_BED_DUTY_CYCLE_DIVIDER did,
+// so you shouldn't use it unless you are OK with PWM on your bed.  (see the comment on enabling PIDTEMPBED)
+#define MAX_BED_POWER 256 // limits duty cycle to bed; 256=full current
+
+#ifdef PIDTEMPBED
+//120v 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
+//from FOPDT model - kp=.39 Tp=405 Tdead=66, Tc set to 79.2, argressive factor of .15 (vs .1, 1, 10)
+    #define  DEFAULT_bedKp 10.00
+    #define  DEFAULT_bedKi .023
+    #define  DEFAULT_bedKd 305.4
+
+//120v 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
+//from pidautotune
+//    #define  DEFAULT_bedKp 97.1
+//    #define  DEFAULT_bedKi 1.41
+//    #define  DEFAULT_bedKd 1675.16
+
+// FIND YOUR OWN: "M303 E-1 C8 S90" to run autotune on the bed at 90 degreesC for 8 cycles.
+#endif // PIDTEMPBED
+
+
+
 //this prevents dangerous Extruder moves, i.e. if the temperature is under the limit
 //can be software-disabled for whatever purposes by
 #define PREVENT_DANGEROUS_EXTRUDE
@@ -204,8 +262,8 @@ const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
 #define Z_MAX_LENGTH (Z_MAX_POS - Z_MIN_POS)
 
 // The position of the homing switches
-//#define MANUAL_HOME_POSITIONS  // If defined, manualy programed locations will be used
-//#define BED_CENTER_AT_0_0  // If defined the center of the bed is defined as (0,0)
+//#define MANUAL_HOME_POSITIONS  // If defined, MANUAL_*_HOME_POS below will be used
+//#define BED_CENTER_AT_0_0  // If defined, the center of the bed is at (X=0, Y=0)
 
 //Manual homing switch locations:
 #define MANUAL_X_HOME_POS 0
@@ -252,12 +310,26 @@ const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
 //#define ULTIMAKERCONTROLLER //as available from the ultimaker online store.
 //#define ULTIPANEL  //the ultipanel as on thingiverse
 
+// The RepRapDiscount Smart Controller
+// http://reprap.org/wiki/RepRapDiscount_Smart_Controller
+//#define REPRAP_DISCOUNT_SMART_CONTROLLER
+
 
-#ifdef ULTIMAKERCONTROLLER    //automatic expansion
+//automatic expansion
+#if defined(ULTIMAKERCONTROLLER) || defined(REPRAP_DISCOUNT_SMART_CONTROLLER)
  #define ULTIPANEL
  #define NEWPANEL
 #endif 
- 
+
+// Preheat Constants
+#define PLA_PREHEAT_HOTEND_TEMP 180 
+#define PLA_PREHEAT_HPB_TEMP 70
+#define PLA_PREHEAT_FAN_SPEED 255		// Insert Value between 0 and 255
+
+#define ABS_PREHEAT_HOTEND_TEMP 240
+#define ABS_PREHEAT_HPB_TEMP 100
+#define ABS_PREHEAT_FAN_SPEED 255		// Insert Value between 0 and 255
+
 
 #ifdef ULTIPANEL
 //  #define NEWPANEL  //enable this if you have a click-encoder panel
@@ -266,15 +338,6 @@ const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
   #define LCD_WIDTH 20
   #define LCD_HEIGHT 4
   
-// Preheat Constants
-  #define PLA_PREHEAT_HOTEND_TEMP 180 
-  #define PLA_PREHEAT_HPB_TEMP 70
-  #define PLA_PREHEAT_FAN_SPEED 255		// Insert Value between 0 and 255
-
-  #define ABS_PREHEAT_HOTEND_TEMP 240
-  #define ABS_PREHEAT_HPB_TEMP 100
-  #define ABS_PREHEAT_FAN_SPEED 255		// Insert Value between 0 and 255
-
 #else //no panel but just lcd 
   #ifdef ULTRA_LCD
     #define LCD_WIDTH 16
diff --git a/Marlin/ConfigurationStore.cpp b/Marlin/ConfigurationStore.cpp
new file mode 100644
index 0000000..6d47777
--- /dev/null
+++ b/Marlin/ConfigurationStore.cpp
@@ -0,0 +1,244 @@
+#include "Marlin.h"
+#include "planner.h"
+#include "temperature.h"
+#include "ultralcd.h"
+#include "ConfigurationStore.h"
+
+void _EEPROM_writeData(int &pos, uint8_t* value, uint8_t size)
+{
+    do
+    {
+        eeprom_write_byte((unsigned char*)pos, *value);
+        pos++;
+        value++;
+    }while(--size);
+}
+#define EEPROM_WRITE_VAR(pos, value) _EEPROM_writeData(pos, (uint8_t*)&value, sizeof(value))
+void _EEPROM_readData(int &pos, uint8_t* value, uint8_t size)
+{
+    do
+    {
+        *value = eeprom_read_byte((unsigned char*)pos);
+        pos++;
+        value++;
+    }while(--size);
+}
+#define EEPROM_READ_VAR(pos, value) _EEPROM_readData(pos, (uint8_t*)&value, sizeof(value))
+//======================================================================================
+
+
+
+
+#define EEPROM_OFFSET 100
+
+
+// IMPORTANT:  Whenever there are changes made to the variables stored in EEPROM
+// in the functions below, also increment the version number. This makes sure that
+// the default values are used whenever there is a change to the data, to prevent
+// wrong data being written to the variables.
+// ALSO:  always make sure the variables in the Store and retrieve sections are in the same order.
+#define EEPROM_VERSION "V07"
+
+#ifdef EEPROM_SETTINGS
+void Config_StoreSettings() 
+{
+  char ver[4]= "000";
+  int i=EEPROM_OFFSET;
+  EEPROM_WRITE_VAR(i,ver); // invalidate data first 
+  EEPROM_WRITE_VAR(i,axis_steps_per_unit);  
+  EEPROM_WRITE_VAR(i,max_feedrate);  
+  EEPROM_WRITE_VAR(i,max_acceleration_units_per_sq_second);
+  EEPROM_WRITE_VAR(i,acceleration);
+  EEPROM_WRITE_VAR(i,retract_acceleration);
+  EEPROM_WRITE_VAR(i,minimumfeedrate);
+  EEPROM_WRITE_VAR(i,mintravelfeedrate);
+  EEPROM_WRITE_VAR(i,minsegmenttime);
+  EEPROM_WRITE_VAR(i,max_xy_jerk);
+  EEPROM_WRITE_VAR(i,max_z_jerk);
+  EEPROM_WRITE_VAR(i,max_e_jerk);
+  EEPROM_WRITE_VAR(i,add_homeing);
+  #ifndef ULTIPANEL
+  int plaPreheatHotendTemp = PLA_PREHEAT_HOTEND_TEMP, plaPreheatHPBTemp = PLA_PREHEAT_HPB_TEMP, plaPreheatFanSpeed = PLA_PREHEAT_FAN_SPEED;
+  int absPreheatHotendTemp = ABS_PREHEAT_HOTEND_TEMP, absPreheatHPBTemp = ABS_PREHEAT_HPB_TEMP, absPreheatFanSpeed = ABS_PREHEAT_FAN_SPEED;
+  #endif
+  EEPROM_WRITE_VAR(i,plaPreheatHotendTemp);
+  EEPROM_WRITE_VAR(i,plaPreheatHPBTemp);
+  EEPROM_WRITE_VAR(i,plaPreheatFanSpeed);
+  EEPROM_WRITE_VAR(i,absPreheatHotendTemp);
+  EEPROM_WRITE_VAR(i,absPreheatHPBTemp);
+  EEPROM_WRITE_VAR(i,absPreheatFanSpeed);
+  #ifdef PIDTEMP
+    EEPROM_WRITE_VAR(i,Kp);
+    EEPROM_WRITE_VAR(i,Ki);
+    EEPROM_WRITE_VAR(i,Kd);
+  #else
+    EEPROM_WRITE_VAR(i,3000);
+    EEPROM_WRITE_VAR(i,0);
+    EEPROM_WRITE_VAR(i,0);
+  #endif
+  char ver2[4]=EEPROM_VERSION;
+  i=EEPROM_OFFSET;
+  EEPROM_WRITE_VAR(i,ver2); // validate data
+  SERIAL_ECHO_START;
+  SERIAL_ECHOLNPGM("Settings Stored");
+}
+#endif //EEPROM_SETTINGS
+
+
+#ifdef EEPROM_CHITCHAT
+void Config_PrintSettings()
+{  // Always have this function, even with EEPROM_SETTINGS disabled, the current values will be shown
+    SERIAL_ECHO_START;
+    SERIAL_ECHOLNPGM("Steps per unit:");
+    SERIAL_ECHO_START;
+    SERIAL_ECHOPAIR("  M92 X",axis_steps_per_unit[0]);
+    SERIAL_ECHOPAIR(" Y",axis_steps_per_unit[1]);
+    SERIAL_ECHOPAIR(" Z",axis_steps_per_unit[2]);
+    SERIAL_ECHOPAIR(" E",axis_steps_per_unit[3]);
+    SERIAL_ECHOLN("");
+      
+    SERIAL_ECHO_START;
+    SERIAL_ECHOLNPGM("Maximum feedrates (mm/s):");
+    SERIAL_ECHO_START;
+    SERIAL_ECHOPAIR("  M203 X",max_feedrate[0]);
+    SERIAL_ECHOPAIR(" Y",max_feedrate[1] ); 
+    SERIAL_ECHOPAIR(" Z", max_feedrate[2] ); 
+    SERIAL_ECHOPAIR(" E", max_feedrate[3]);
+    SERIAL_ECHOLN("");
+
+    SERIAL_ECHO_START;
+    SERIAL_ECHOLNPGM("Maximum Acceleration (mm/s2):");
+    SERIAL_ECHO_START;
+    SERIAL_ECHOPAIR("  M201 X" ,max_acceleration_units_per_sq_second[0] ); 
+    SERIAL_ECHOPAIR(" Y" , max_acceleration_units_per_sq_second[1] ); 
+    SERIAL_ECHOPAIR(" Z" ,max_acceleration_units_per_sq_second[2] );
+    SERIAL_ECHOPAIR(" E" ,max_acceleration_units_per_sq_second[3]);
+    SERIAL_ECHOLN("");
+    SERIAL_ECHO_START;
+    SERIAL_ECHOLNPGM("Acceleration: S=acceleration, T=retract acceleration");
+    SERIAL_ECHO_START;
+    SERIAL_ECHOPAIR("  M204 S",acceleration ); 
+    SERIAL_ECHOPAIR(" T" ,retract_acceleration);
+    SERIAL_ECHOLN("");
+
+    SERIAL_ECHO_START;
+    SERIAL_ECHOLNPGM("Advanced variables: S=Min feedrate (mm/s), T=Min travel feedrate (mm/s), B=minimum segment time (ms), X=maximum xY jerk (mm/s),  Z=maximum Z jerk (mm/s)");
+    SERIAL_ECHO_START;
+    SERIAL_ECHOPAIR("  M205 S",minimumfeedrate ); 
+    SERIAL_ECHOPAIR(" T" ,mintravelfeedrate ); 
+    SERIAL_ECHOPAIR(" B" ,minsegmenttime ); 
+    SERIAL_ECHOPAIR(" X" ,max_xy_jerk ); 
+    SERIAL_ECHOPAIR(" Z" ,max_z_jerk);
+    SERIAL_ECHOPAIR(" E" ,max_e_jerk);
+    SERIAL_ECHOLN(""); 
+
+    SERIAL_ECHO_START;
+    SERIAL_ECHOLNPGM("Home offset (mm):");
+    SERIAL_ECHO_START;
+    SERIAL_ECHOPAIR("  M206 X",add_homeing[0] );
+    SERIAL_ECHOPAIR(" Y" ,add_homeing[1] );
+    SERIAL_ECHOPAIR(" Z" ,add_homeing[2] );
+    SERIAL_ECHOLN("");
+#ifdef PIDTEMP
+    SERIAL_ECHO_START;
+    SERIAL_ECHOLNPGM("PID settings:");
+    SERIAL_ECHO_START;
+    SERIAL_ECHOPAIR("   M301 P",Kp); 
+    SERIAL_ECHOPAIR(" I" ,Ki/PID_dT); 
+    SERIAL_ECHOPAIR(" D" ,Kd*PID_dT);
+    SERIAL_ECHOLN(""); 
+#endif
+} 
+#endif
+
+
+#ifdef EEPROM_SETTINGS
+void Config_RetrieveSettings()
+{
+    int i=EEPROM_OFFSET;
+    char stored_ver[4];
+    char ver[4]=EEPROM_VERSION;
+    EEPROM_READ_VAR(i,stored_ver); //read stored version
+    //  SERIAL_ECHOLN("Version: [" << ver << "] Stored version: [" << stored_ver << "]");
+    if (strncmp(ver,stored_ver,3) == 0)
+    {
+        // version number match
+        EEPROM_READ_VAR(i,axis_steps_per_unit);  
+        EEPROM_READ_VAR(i,max_feedrate);  
+        EEPROM_READ_VAR(i,max_acceleration_units_per_sq_second);
+        EEPROM_READ_VAR(i,acceleration);
+        EEPROM_READ_VAR(i,retract_acceleration);
+        EEPROM_READ_VAR(i,minimumfeedrate);
+        EEPROM_READ_VAR(i,mintravelfeedrate);
+        EEPROM_READ_VAR(i,minsegmenttime);
+        EEPROM_READ_VAR(i,max_xy_jerk);
+        EEPROM_READ_VAR(i,max_z_jerk);
+        EEPROM_READ_VAR(i,max_e_jerk);
+        EEPROM_READ_VAR(i,add_homeing);
+        #ifndef ULTIPANEL
+        int plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed;
+        int absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed;
+        #endif
+        EEPROM_READ_VAR(i,plaPreheatHotendTemp);
+        EEPROM_READ_VAR(i,plaPreheatHPBTemp);
+        EEPROM_READ_VAR(i,plaPreheatFanSpeed);
+        EEPROM_READ_VAR(i,absPreheatHotendTemp);
+        EEPROM_READ_VAR(i,absPreheatHPBTemp);
+        EEPROM_READ_VAR(i,absPreheatFanSpeed);
+        #ifndef PIDTEMP
+        float Kp,Ki,Kd;
+        #endif
+        EEPROM_READ_VAR(i,Kp);
+        EEPROM_READ_VAR(i,Ki);
+        EEPROM_READ_VAR(i,Kd);
+
+        SERIAL_ECHO_START;
+        SERIAL_ECHOLNPGM("Stored settings retreived:");
+    }
+    else
+    {
+        Config_ResetDefault();
+        SERIAL_ECHO_START;
+        SERIAL_ECHOLN("Using Default settings:");
+    }
+    Config_PrintSettings();
+}
+#endif
+
+void Config_ResetDefault()
+{
+    float tmp1[]=DEFAULT_AXIS_STEPS_PER_UNIT;
+    float tmp2[]=DEFAULT_MAX_FEEDRATE;
+    long tmp3[]=DEFAULT_MAX_ACCELERATION;
+    for (short i=0;i<4;i++) 
+    {
+        axis_steps_per_unit[i]=tmp1[i];  
+        max_feedrate[i]=tmp2[i];  
+        max_acceleration_units_per_sq_second[i]=tmp3[i];
+    }
+    acceleration=DEFAULT_ACCELERATION;
+    retract_acceleration=DEFAULT_RETRACT_ACCELERATION;
+    minimumfeedrate=DEFAULT_MINIMUMFEEDRATE;
+    minsegmenttime=DEFAULT_MINSEGMENTTIME;       
+    mintravelfeedrate=DEFAULT_MINTRAVELFEEDRATE;
+    max_xy_jerk=DEFAULT_XYJERK;
+    max_z_jerk=DEFAULT_ZJERK;
+    max_e_jerk=DEFAULT_EJERK;
+    add_homeing[0] = add_homeing[1] = add_homeing[2] = 0;
+#ifdef ULTIPANEL
+    plaPreheatHotendTemp = PLA_PREHEAT_HOTEND_TEMP;
+    plaPreheatHPBTemp = PLA_PREHEAT_HPB_TEMP;
+    plaPreheatFanSpeed = PLA_PREHEAT_FAN_SPEED;
+    absPreheatHotendTemp = ABS_PREHEAT_HOTEND_TEMP;
+    absPreheatHPBTemp = ABS_PREHEAT_HPB_TEMP;
+    absPreheatFanSpeed = ABS_PREHEAT_FAN_SPEED;
+#endif
+#ifdef PIDTEMP
+    Kp = DEFAULT_Kp;
+    Ki = (DEFAULT_Ki*PID_dT);
+    Kd = (DEFAULT_Kd/PID_dT);
+#ifdef PID_ADD_EXTRUSION_RATE
+    Kc = DEFAULT_Kc;
+#endif//PID_ADD_EXTRUSION_RATE
+#endif//PIDTEMP
+}
diff --git a/Marlin/ConfigurationStore.h b/Marlin/ConfigurationStore.h
new file mode 100644
index 0000000..2bbf480
--- /dev/null
+++ b/Marlin/ConfigurationStore.h
@@ -0,0 +1,22 @@
+#ifndef CONFIG_STORE_H
+#define CONFIG_STORE_H
+
+#include "Configuration.h"
+
+void Config_ResetDefault();
+
+#ifdef EEPROM_CHITCHAT
+void Config_PrintSettings();
+#else
+FORCE_INLINE void Config_PrintSettings() {}
+#endif
+
+#ifdef EEPROM_SETTINGS
+void Config_StoreSettings();
+void Config_RetrieveSettings();
+#else
+FORCE_INLINE void Config_StoreSettings() {}
+FORCE_INLINE void Config_RetrieveSettings() { Config_ResetDefault(); Config_PrintSettings(); }
+#endif
+
+#endif//CONFIG_STORE_H
diff --git a/Marlin/Configuration_adv.h b/Marlin/Configuration_adv.h
index a356c91..b718640 100644
--- a/Marlin/Configuration_adv.h
+++ b/Marlin/Configuration_adv.h
@@ -5,19 +5,18 @@
 //=============================Thermal Settings  ============================
 //===========================================================================
 
-// Select one of these only to define how the bed temp is read.
-//
-//#define BED_LIMIT_SWITCHING
 #ifdef BED_LIMIT_SWITCHING
   #define BED_HYSTERESIS 2 //only disable heating if T>target+BED_HYSTERESIS and enable heating if T>target-BED_HYSTERESIS
 #endif
-#define BED_CHECK_INTERVAL 5000 //ms
+#define BED_CHECK_INTERVAL 5000 //ms between checks in bang-bang control
 
 //// Heating sanity check:
 // This waits for the watchperiod in milliseconds whenever an M104 or M109 increases the target temperature
 // If the temperature has not increased at the end of that period, the target temperature is set to zero. 
-// It can be reset with another M104/M109
-//#define WATCHPERIOD 20000 //20 seconds
+// It can be reset with another M104/M109. This check is also only triggered if the target temperature and the current temperature
+//  differ by at least 2x WATCH_TEMP_INCREASE
+//#define WATCH_TEMP_PERIOD 40000 //40 seconds
+//#define WATCH_TEMP_INCREASE 10  //Heat up at least 10 degree in 20 seconds
 
 // Wait for Cooldown
 // This defines if the M109 call should not block if it is cooling down.
@@ -79,7 +78,7 @@
 
 //// AUTOSET LOCATIONS OF LIMIT SWITCHES
 //// Added by ZetaPhoenix 09-15-2012
-#ifdef MANUAL_HOME_POSITION  //Use manual limit switch locations
+#ifdef MANUAL_HOME_POSITIONS  // Use manual limit switch locations
   #define X_HOME_POS MANUAL_X_HOME_POS
   #define Y_HOME_POS MANUAL_Y_HOME_POS
   #define Z_HOME_POS MANUAL_Z_HOME_POS
@@ -176,23 +175,39 @@
 // if unwanted behavior is observed on a user's machine when running at very slow speeds.
 #define MINIMUM_PLANNER_SPEED 0.05// (mm/sec)
 
+// MS1 MS2 Stepper Driver Microstepping mode table
+#define MICROSTEP1 LOW,LOW
+#define MICROSTEP2 HIGH,LOW
+#define MICROSTEP4 LOW,HIGH
+#define MICROSTEP8 HIGH,HIGH
+#define MICROSTEP16 HIGH,HIGH
+
+// Microstep setting (Only functional when stepper driver microstep pins are connected to MCU.
+#define MICROSTEP_MODES {16,16,16,16,16} // [1,2,4,8,16]
+
+// Motor Current setting (Only functional when motor driver current ref pins are connected to a digital trimpot on supported boards)
+#define DIGIPOT_MOTOR_CURRENT {135,135,135,135,135} // Values 0-255 (RAMBO 135 = ~0.75A, 185 = ~1A)
+
+
 //===========================================================================
 //=============================Additional Features===========================
 //===========================================================================
 
-
 #define SD_FINISHED_STEPPERRELEASE true  //if sd support and the file is finished: disable steppers?
-#define SD_FINISHED_RELEASECOMMAND "M84 X Y Z E" // no z because of layer shift.
+#define SD_FINISHED_RELEASECOMMAND "M84 X Y Z E" // You might want to keep the z enabled so your bed stays in place.
 
-// The hardware watchdog should halt the Microcontroller, in case the firmware gets stuck somewhere. However:
-// the Watchdog is not working well, so please only enable this for testing
-// this enables the watchdog interrupt.
+// The hardware watchdog should reset the Microcontroller disabling all outputs, in case the firmware gets stuck and doesn't do temperature regulation.
 //#define USE_WATCHDOG
-//#ifdef USE_WATCHDOG
-  // you cannot reboot on a mega2560 due to a bug in he bootloader. Hence, you have to reset manually, and this is done hereby:
-//#define RESET_MANUAL
-//#define WATCHDOG_TIMEOUT 4  //seconds
-//#endif
+
+#ifdef USE_WATCHDOG
+// If you have a watchdog reboot in an ArduinoMega2560 then the device will hang forever, as a watchdog reset will leave the watchdog on.
+// The "WATCHDOG_RESET_MANUAL" goes around this by not using the hardware reset.
+//  However, THIS FEATURE IS UNSAFE!, as it will only work if interrupts are disabled. And the code could hang in an interrupt routine with interrupts disabled.
+//#define WATCHDOG_RESET_MANUAL
+#endif
+
+// Enable the option to stop SD printing when hitting and endstops, needs to be enabled from the LCD menu when this option is enabled.
+//#define ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
 
 // extruder advance constant (s2/mm3)
 //
@@ -217,7 +232,7 @@
 #define MM_PER_ARC_SEGMENT 1
 #define N_ARC_CORRECTION 25
 
-const int dropsegments=5; //everything with less than this number of steps will be ignored as move and joined with the next movement
+const unsigned int dropsegments=5; //everything with less than this number of steps will be ignored as move and joined with the next movement
 
 // If you are using a RAMPS board or cheap E-bay purchased boards that do not detect when an SD card is inserted
 // You can get round this by connecting a push button or single throw switch to the pin defined as SDCARDCARDDETECT 
@@ -228,6 +243,23 @@ const int dropsegments=5; //everything with less than this number of steps will
 #ifdef ULTIPANEL
  #undef SDCARDDETECTINVERTED
 #endif
+
+// Power Signal Control Definitions
+// By default use ATX definition
+#ifndef POWER_SUPPLY
+  #define POWER_SUPPLY 1
+#endif
+// 1 = ATX
+#if (POWER_SUPPLY == 1) 
+  #define PS_ON_AWAKE  LOW
+  #define PS_ON_ASLEEP HIGH
+#endif
+// 2 = X-Box 360 203W
+#if (POWER_SUPPLY == 2) 
+  #define PS_ON_AWAKE  HIGH
+  #define PS_ON_ASLEEP LOW
+#endif
+
 //===========================================================================
 //=============================Buffers           ============================
 //===========================================================================
@@ -239,7 +271,7 @@ const int dropsegments=5; //everything with less than this number of steps will
 #else
   #define BLOCK_BUFFER_SIZE 16 // maximize block buffer
 #endif
-
+
 
 //The ASCII buffer for recieving from the serial:
 #define MAX_CMD_SIZE 96
diff --git a/Marlin/EEPROMwrite.h b/Marlin/EEPROMwrite.h
deleted file mode 100644
index 12674ef..0000000
--- a/Marlin/EEPROMwrite.h
+++ /dev/null
@@ -1,232 +0,0 @@
-#ifndef EEPROM_H
-#define EEPROM_H
-
-#include "Marlin.h"
-#include "planner.h"
-#include "temperature.h"
-//#include <EEPROM.h>
-
-int plaPreheatHotendTemp;
-int plaPreheatHPBTemp;
-int plaPreheatFanSpeed;
-
-int absPreheatHotendTemp;
-int absPreheatHPBTemp;
-int absPreheatFanSpeed;
-
-template <class T> int EEPROM_writeAnything(int &ee, const T& value)
-{
-  const byte* p = (const byte*)(const void*)&value;
-  int i;
-  for (i = 0; i < (int)sizeof(value); i++)
-    eeprom_write_byte((unsigned char *)ee++, *p++);
-  return i;
-}
-
-template <class T> int EEPROM_readAnything(int &ee, T& value)
-{
-  byte* p = (byte*)(void*)&value;
-  int i;
-  for (i = 0; i < (int)sizeof(value); i++)
-    *p++ = eeprom_read_byte((unsigned char *)ee++);
-  return i;
-}
-//======================================================================================
-
-
-
-
-#define EEPROM_OFFSET 100
-
-
-// IMPORTANT:  Whenever there are changes made to the variables stored in EEPROM
-// in the functions below, also increment the version number. This makes sure that
-// the default values are used whenever there is a change to the data, to prevent
-// wrong data being written to the variables.
-// ALSO:  always make sure the variables in the Store and retrieve sections are in the same order.
-#define EEPROM_VERSION "V07"
-
-inline void EEPROM_StoreSettings() 
-{
-#ifdef EEPROM_SETTINGS
-  char ver[4]= "000";
-  int i=EEPROM_OFFSET;
-  EEPROM_writeAnything(i,ver); // invalidate data first 
-  EEPROM_writeAnything(i,axis_steps_per_unit);  
-  EEPROM_writeAnything(i,max_feedrate);  
-  EEPROM_writeAnything(i,max_acceleration_units_per_sq_second);
-  EEPROM_writeAnything(i,acceleration);
-  EEPROM_writeAnything(i,retract_acceleration);
-  EEPROM_writeAnything(i,minimumfeedrate);
-  EEPROM_writeAnything(i,mintravelfeedrate);
-  EEPROM_writeAnything(i,minsegmenttime);
-  EEPROM_writeAnything(i,max_xy_jerk);
-  EEPROM_writeAnything(i,max_z_jerk);
-  EEPROM_writeAnything(i,max_e_jerk);
-  EEPROM_writeAnything(i,add_homeing);
-  EEPROM_writeAnything(i,plaPreheatHotendTemp);
-  EEPROM_writeAnything(i,plaPreheatHPBTemp);
-  EEPROM_writeAnything(i,plaPreheatFanSpeed);
-  EEPROM_writeAnything(i,absPreheatHotendTemp);
-  EEPROM_writeAnything(i,absPreheatHPBTemp);
-  EEPROM_writeAnything(i,absPreheatFanSpeed);
-  #ifdef PIDTEMP
-    EEPROM_writeAnything(i,Kp);
-    EEPROM_writeAnything(i,Ki);
-    EEPROM_writeAnything(i,Kd);
-  #else
-    EEPROM_writeAnything(i,3000);
-    EEPROM_writeAnything(i,0);
-    EEPROM_writeAnything(i,0);
-  #endif
-  char ver2[4]=EEPROM_VERSION;
-  i=EEPROM_OFFSET;
-  EEPROM_writeAnything(i,ver2); // validate data
-  SERIAL_ECHO_START;
-  SERIAL_ECHOLNPGM("Settings Stored");
-#endif //EEPROM_SETTINGS
-}
-
-
-inline void EEPROM_printSettings()
-{  // if def=true, the default values will be used
-//  #ifdef EEPROM_SETTINGS  
-      SERIAL_ECHO_START;
-      SERIAL_ECHOLNPGM("Steps per unit:");
-      SERIAL_ECHO_START;
-      SERIAL_ECHOPAIR("  M92 X",axis_steps_per_unit[0]);
-      SERIAL_ECHOPAIR(" Y",axis_steps_per_unit[1]);
-      SERIAL_ECHOPAIR(" Z",axis_steps_per_unit[2]);
-      SERIAL_ECHOPAIR(" E",axis_steps_per_unit[3]);
-      SERIAL_ECHOLN("");
-      
-    SERIAL_ECHO_START;
-      SERIAL_ECHOLNPGM("Maximum feedrates (mm/s):");
-      SERIAL_ECHO_START;
-      SERIAL_ECHOPAIR("  M203 X",max_feedrate[0]);
-      SERIAL_ECHOPAIR(" Y",max_feedrate[1] ); 
-      SERIAL_ECHOPAIR(" Z", max_feedrate[2] ); 
-      SERIAL_ECHOPAIR(" E", max_feedrate[3]);
-      SERIAL_ECHOLN("");
-    SERIAL_ECHO_START;
-      SERIAL_ECHOLNPGM("Maximum Acceleration (mm/s2):");
-      SERIAL_ECHO_START;
-      SERIAL_ECHOPAIR("  M201 X" ,max_acceleration_units_per_sq_second[0] ); 
-      SERIAL_ECHOPAIR(" Y" , max_acceleration_units_per_sq_second[1] ); 
-      SERIAL_ECHOPAIR(" Z" ,max_acceleration_units_per_sq_second[2] );
-      SERIAL_ECHOPAIR(" E" ,max_acceleration_units_per_sq_second[3]);
-      SERIAL_ECHOLN("");
-    SERIAL_ECHO_START;
-      SERIAL_ECHOLNPGM("Acceleration: S=acceleration, T=retract acceleration");
-      SERIAL_ECHO_START;
-      SERIAL_ECHOPAIR("  M204 S",acceleration ); 
-      SERIAL_ECHOPAIR(" T" ,retract_acceleration);
-      SERIAL_ECHOLN("");
-    SERIAL_ECHO_START;
-      SERIAL_ECHOLNPGM("Advanced variables: S=Min feedrate (mm/s), T=Min travel feedrate (mm/s), B=minimum segment time (ms), X=maximum xY jerk (mm/s),  Z=maximum Z jerk (mm/s)");
-      SERIAL_ECHO_START;
-      SERIAL_ECHOPAIR("  M205 S",minimumfeedrate ); 
-      SERIAL_ECHOPAIR(" T" ,mintravelfeedrate ); 
-      SERIAL_ECHOPAIR(" B" ,minsegmenttime ); 
-      SERIAL_ECHOPAIR(" X" ,max_xy_jerk ); 
-      SERIAL_ECHOPAIR(" Z" ,max_z_jerk);
-      SERIAL_ECHOPAIR(" E" ,max_e_jerk);
-      SERIAL_ECHOLN(""); 
-    SERIAL_ECHO_START;
-      SERIAL_ECHOLNPGM("Home offset (mm):");
-      SERIAL_ECHO_START;
-      SERIAL_ECHOPAIR("  M206 X",add_homeing[0] );
-      SERIAL_ECHOPAIR(" Y" ,add_homeing[1] );
-      SERIAL_ECHOPAIR(" Z" ,add_homeing[2] );
-      SERIAL_ECHOLN("");
-    #ifdef PIDTEMP
-      SERIAL_ECHO_START;
-      SERIAL_ECHOLNPGM("PID settings:");
-      SERIAL_ECHO_START;
-      SERIAL_ECHOPAIR("   M301 P",Kp); 
-      SERIAL_ECHOPAIR(" I" ,Ki/PID_dT); 
-      SERIAL_ECHOPAIR(" D" ,Kd*PID_dT);
-      SERIAL_ECHOLN(""); 
-    #endif
-//  #endif
-} 
-
-
-inline void EEPROM_RetrieveSettings(bool def=false)
-{  // if def=true, the default values will be used
-  #ifdef EEPROM_SETTINGS
-    int i=EEPROM_OFFSET;
-    char stored_ver[4];
-    char ver[4]=EEPROM_VERSION;
-    EEPROM_readAnything(i,stored_ver); //read stored version
-    //  SERIAL_ECHOLN("Version: [" << ver << "] Stored version: [" << stored_ver << "]");
-    if ((!def)&&(strncmp(ver,stored_ver,3)==0)) 
-    {   // version number match
-      EEPROM_readAnything(i,axis_steps_per_unit);  
-      EEPROM_readAnything(i,max_feedrate);  
-      EEPROM_readAnything(i,max_acceleration_units_per_sq_second);
-      EEPROM_readAnything(i,acceleration);
-      EEPROM_readAnything(i,retract_acceleration);
-      EEPROM_readAnything(i,minimumfeedrate);
-      EEPROM_readAnything(i,mintravelfeedrate);
-      EEPROM_readAnything(i,minsegmenttime);
-      EEPROM_readAnything(i,max_xy_jerk);
-      EEPROM_readAnything(i,max_z_jerk);
-      EEPROM_readAnything(i,max_e_jerk);
-      EEPROM_readAnything(i,add_homeing);
-	  EEPROM_readAnything(i,plaPreheatHotendTemp);
-	  EEPROM_readAnything(i,plaPreheatHPBTemp);
-	  EEPROM_readAnything(i,plaPreheatFanSpeed);
-	  EEPROM_readAnything(i,absPreheatHotendTemp);
-	  EEPROM_readAnything(i,absPreheatHPBTemp);
-	  EEPROM_readAnything(i,absPreheatFanSpeed);
-      #ifndef PIDTEMP
-        float Kp,Ki,Kd;
-      #endif
-      EEPROM_readAnything(i,Kp);
-      EEPROM_readAnything(i,Ki);
-      EEPROM_readAnything(i,Kd);
-
-      SERIAL_ECHO_START;
-      SERIAL_ECHOLNPGM("Stored settings retreived:");
-    }
-    else 
-  #endif
-    {
-      float tmp1[]=DEFAULT_AXIS_STEPS_PER_UNIT;
-      float tmp2[]=DEFAULT_MAX_FEEDRATE;
-      long tmp3[]=DEFAULT_MAX_ACCELERATION;
-      for (short i=0;i<4;i++) 
-      {
-        axis_steps_per_unit[i]=tmp1[i];  
-        max_feedrate[i]=tmp2[i];  
-        max_acceleration_units_per_sq_second[i]=tmp3[i];
-      }
-      acceleration=DEFAULT_ACCELERATION;
-      retract_acceleration=DEFAULT_RETRACT_ACCELERATION;
-      minimumfeedrate=DEFAULT_MINIMUMFEEDRATE;
-      minsegmenttime=DEFAULT_MINSEGMENTTIME;       
-      mintravelfeedrate=DEFAULT_MINTRAVELFEEDRATE;
-      max_xy_jerk=DEFAULT_XYJERK;
-      max_z_jerk=DEFAULT_ZJERK;
-      max_e_jerk=DEFAULT_EJERK;
-      add_homeing[0] = add_homeing[1] = add_homeing[2] = 0;
-      SERIAL_ECHO_START;
-      SERIAL_ECHOLN("Using Default settings:");
-#ifdef ULTIPANEL
-	  plaPreheatHotendTemp = PLA_PREHEAT_HOTEND_TEMP;
-	  plaPreheatHPBTemp = PLA_PREHEAT_HPB_TEMP;
-	  plaPreheatFanSpeed = PLA_PREHEAT_FAN_SPEED;
-	  absPreheatHotendTemp = ABS_PREHEAT_HOTEND_TEMP;
-	  absPreheatHPBTemp = ABS_PREHEAT_HPB_TEMP;
-	  absPreheatFanSpeed = ABS_PREHEAT_FAN_SPEED;
-#endif
-    }
-  #ifdef EEPROM_CHITCHAT
-    EEPROM_printSettings();
-  #endif
-}  
-
-#endif
-
-
diff --git a/Marlin/Gen7/boards.txt b/Marlin/Gen7/boards.txt
deleted file mode 100644
index d6fbaee..0000000
--- a/Marlin/Gen7/boards.txt
+++ /dev/null
@@ -1,101 +0,0 @@
-##############################################################
-
-Gen7-644-16.name=Gen7 with ATmega644 and 16 MHz
-Gen7-644-16.upload.protocol=stk500v2
-Gen7-644-16.upload.maximum_size=63488
-Gen7-644-16.upload.speed=115200
-Gen7-644-16.bootloader.low_fuses=0xF7
-Gen7-644-16.bootloader.high_fuses=0xD4
-Gen7-644-16.bootloader.extended_fuses=0xFD
-Gen7-644-16.bootloader.path=Gen7
-Gen7-644-16.bootloader.file=bootloader-644-16MHz.hex
-Gen7-644-16.bootloader.unlock_bits=0x3F
-Gen7-644-16.bootloader.lock_bits=0x0F
-Gen7-644-16.build.mcu=atmega644
-Gen7-644-16.build.f_cpu=16000000L
-Gen7-644-16.build.core=arduino
-
-##############################################################
-
-Gen7-644-20.name=Gen7 with ATmega644 and 20 MHz
-Gen7-644-20.upload.protocol=stk500v2
-Gen7-644-20.upload.maximum_size=63488
-Gen7-644-20.upload.speed=115200
-Gen7-644-20.bootloader.low_fuses=0xF7
-Gen7-644-20.bootloader.high_fuses=0xD4
-Gen7-644-20.bootloader.extended_fuses=0xFD
-Gen7-644-20.bootloader.path=Gen7
-Gen7-644-20.bootloader.file=bootloader-644-20MHz.hex
-Gen7-644-20.bootloader.unlock_bits=0x3F
-Gen7-644-20.bootloader.lock_bits=0x0F
-Gen7-644-20.build.mcu=atmega644
-Gen7-644-20.build.f_cpu=20000000L
-Gen7-644-20.build.core=arduino
-
-##############################################################
-
-Gen7-644P-16.name=Gen7 with ATmega644P and 16 MHz
-Gen7-644P-16.upload.protocol=stk500v2
-Gen7-644P-16.upload.maximum_size=63488
-Gen7-644P-16.upload.speed=115200
-Gen7-644P-16.bootloader.low_fuses=0xF7
-Gen7-644P-16.bootloader.high_fuses=0xD4
-Gen7-644P-16.bootloader.extended_fuses=0xFD
-Gen7-644P-16.bootloader.path=Gen7
-Gen7-644P-16.bootloader.file=bootloader-644P-16MHz.hex
-Gen7-644P-16.bootloader.unlock_bits=0x3F
-Gen7-644P-16.bootloader.lock_bits=0x0F
-Gen7-644P-16.build.mcu=atmega644p
-Gen7-644P-16.build.f_cpu=16000000L
-Gen7-644P-16.build.core=arduino
-
-##############################################################
-
-Gen7-644P-20.name=Gen7 with ATmega644P and 20 MHz
-Gen7-644P-20.upload.protocol=stk500v2
-Gen7-644P-20.upload.maximum_size=63488
-Gen7-644P-20.upload.speed=115200
-Gen7-644P-20.bootloader.low_fuses=0xF7
-Gen7-644P-20.bootloader.high_fuses=0xD4
-Gen7-644P-20.bootloader.extended_fuses=0xFD
-Gen7-644P-20.bootloader.path=Gen7
-Gen7-644P-20.bootloader.file=bootloader-644P-20MHz.hex
-Gen7-644P-20.bootloader.unlock_bits=0x3F
-Gen7-644P-20.bootloader.lock_bits=0x0F
-Gen7-644P-20.build.mcu=atmega644p
-Gen7-644P-20.build.f_cpu=20000000L
-Gen7-644P-20.build.core=arduino
-
-##############################################################
-
-Gen7-1284p-16.name=Gen7 with ATmega1284 and 16 MHz
-Gen7-1284p-16.upload.protocol=stk500v2
-Gen7-1284p-16.upload.maximum_size=129024
-Gen7-1284p-16.upload.speed=115200
-Gen7-1284p-16.bootloader.low_fuses=0xF7
-Gen7-1284p-16.bootloader.high_fuses=0xD4
-Gen7-1284p-16.bootloader.extended_fuses=0xFD
-Gen7-1284p-16.bootloader.path=Gen7
-Gen7-1284p-16.bootloader.file=bootloader-1284P-16MHz.hex
-Gen7-1284p-16.bootloader.unlock_bits=0x3F
-Gen7-1284p-16.bootloader.lock_bits=0x2F
-Gen7-1284p-16.build.mcu=atmega1284p
-Gen7-1284p-16.build.f_cpu=16000000L
-Gen7-1284p-16.build.core=arduino
-
-##############################################################
-
-Gen7-1284p-20.name=Gen7 with ATmega1284 and 20 MHz
-Gen7-1284p-20.upload.protocol=stk500v2
-Gen7-1284p-20.upload.maximum_size=129024
-Gen7-1284p-20.upload.speed=115200
-Gen7-1284p-20.bootloader.low_fuses=0xF7
-Gen7-1284p-20.bootloader.high_fuses=0xD4
-Gen7-1284p-20.bootloader.extended_fuses=0xFD
-Gen7-1284p-20.bootloader.path=Gen7
-Gen7-1284p-20.bootloader.file=bootloader-1284P-16MHz.hex
-Gen7-1284p-20.bootloader.unlock_bits=0x3F
-Gen7-1284p-20.bootloader.lock_bits=0x2F
-Gen7-1284p-20.build.mcu=atmega1284p
-Gen7-1284p-20.build.f_cpu=20000000L
-Gen7-1284p-20.build.core=arduino
diff --git a/Marlin/Gen7/bootloaders/Gen7/bootloader-1284P-16MHz.hex b/Marlin/Gen7/bootloaders/Gen7/bootloader-1284P-16MHz.hex
deleted file mode 100644
index 93df372..0000000
--- a/Marlin/Gen7/bootloaders/Gen7/bootloader-1284P-16MHz.hex
+++ /dev/null
@@ -1,113 +0,0 @@
-:020000021000EC
-:10F8000011241FBE8FEF90E49EBF8DBF01C32F92C6
-:10F810003F924F925F926F927F928F929F92AF92A0
-:10F82000BF92CF92DF92EF92FF920F931F93DF93DD
-:10F83000CF93CDB7DEB7C252D1400FB6F894DEBF3A
-:10F840000FBECDBF44245524DD24C25EDE4F188296
-:10F85000CE51D1408824992454013AC20E9428FFF5
-:10F86000282F133059F1143028F4113081F0123060
-:10F8700000F507C0153081F1153030F1163071F701
-:10F880003DC08B3159F711E05BE1D52EE7CF8130D8
-:10F8900041F0C25EDE4F3881CE51D140831709F06E
-:10F8A00019C2D226C25EDE4F2883CE51D14012E06B
-:10F8B000D5CFF82EEE24D82613E0D0CF90E0E82A5A
-:10F8C000F92AD22614E0CACF8E3009F003C2D82616
-:10F8D00015E044245524C2CFE1E0F0E0EC0FFD1F19
-:10F8E000E40DF51D80830894411C511CD8264E144C
-:10F8F0005F0409F0B3CF720116E0B0CF8D1509F0A7
-:10F90000E9C1EAC1CC2447C08D81803311F090E079
-:10F910000AC08F81882311F49EE105C0813011F067
-:10F9200095E001C097E91A821B828D818C838E81BC
-:10F930008D839E831F8247E0E42EF12C88C11A82BA
-:10F9400068E06B8383E58C8394E59D83EBE4EE8331
-:10F9500085E38F8380E3888789878FE58A8782E3C1
-:10F960008B873BE0E32EF12C72C18A81813941F013
-:10F97000823941F0803911F48FE005C080E003C086
-:10F9800082E001C08AE01A828B8323E0E22EF12C10
-:10F990005EC1CC24C3941A8292E0E92EF12C58C1A6
-:10F9A0008D81882311F48EE128C0813011F085E02B
-:10F9B00024C087E922C01A8229E0E1E0F0E0209328
-:10F9C000570084911BC08B81803589F48C818830ED
-:10F9D00039F439E0E2E0F0E03093570084910DC053
-:10F9E00069E0E0E0F0E060935700849106C099E0A0
-:10F9F000E3E0F0E09093570084911A828B831C829D
-:10FA000084E0E82EF12C23C18A8190E0A0E0B0E0F0
-:10FA1000B82EAA24992488248B8190E0A0E0B0E03D
-:10FA2000DC0199278827882A992AAA2ABB2A8D814E
-:10FA300090E0A0E0B0E0882A992AAA2ABB2A8C810B
-:10FA400090E0A0E0B0E0BA2FA92F982F8827882A4D
-:10FA5000992AAA2ABB2A88C0EA81C05EDE4FE883C1
-:10FA6000C052D140C15EDE4F1882CF51D1408B8150
-:10FA7000A82FB0E0C15EDE4F28813981CF51D1403F
-:10FA8000A22BB32B933109F042C075016401CC0C59
-:10FA9000DD1CEE1CFF1C33E0F601E0925B003093AE
-:10FAA0005700E89507B600FCFDCF8E01055F1F4F9C
-:10FAB000F801808161810E5F1F4FA5019401220F23
-:10FAC000331F441F551F362E222490E0822993298C
-:10FAD00061E00C01F90140935B0060935700E895E9
-:10FAE00011240894811C911CA11CB11C129701F7D0
-:10FAF00085E0F601E0925B0080935700E89507B639
-:10FB000000FCFDCF81E180935700E8952DC0FE01F8
-:10FB10003B9620E030E040E050E011977D0100E0AE
-:10FB200010E00894E11CF11C011D111D6081F99980
-:10FB3000FECF1FBAC901880D991D92BD81BD60BD60
-:10FB40000FB6F894FA9AF99A0FBE2F5F3F4F4F4FB6
-:10FB50005F4F2E153F054007510711F03196E6CF54
-:10FB6000820E931EA41EB51E1A826EC09A81CE5DAF
-:10FB7000DE4F9883C252D140CF5DDE4F1882C15212
-:10FB8000D1408B81C82EDD24CF5DDE4FE881F98125
-:10FB9000C152D140CE2ADF2A1A8289818431E1F410
-:10FBA0009601BE016D5F7F4FD501C401880F991F7B
-:10FBB000AA1FBB1FABBFFC0187919691FB018083FD
-:10FBC00091836E5F7F4F0894811C911CA11CB11C16
-:10FBD0002250304049F72EC0BE016D5F7F4F20E0BC
-:10FBE00030E040E050E00894C108D108760100E020
-:10FBF00010E00894C11CD11C0894E11CF11C011DEB
-:10FC0000111DF999FECFC901880D991D92BD81BDC5
-:10FC1000F89A80B5FB018193BF012F5F3F4F4F4F93
-:10FC20005F4F2E153F054007510759F7820E931E6F
-:10FC3000A41EB51E23E0E22EF12CEC0CFD1CFB01F2
-:10FC4000108205C080EC8A8392E0E92EF12CCC244E
-:10FC50008BE10E94C7FEC25EDE4F8881CE51D1404B
-:10FC60000E94C7FE8F2D0E94C7FE8E2D0E94C7FEE8
-:10FC70008EE00E94C7FE85E1D82EC25EDE4FF8817D
-:10FC8000CE51D140DF26DE24DF243E010894611CE2
-:10FC9000711C0AC0F30111913F01812F0E94C7FE20
-:10FCA000D1260894E108F108E114F10499F78D2DAB
-:10FCB0000E94C7FECC2009F044C0C25EDE4FF8812E
-:10FCC000CE51D140FF5FC25EDE4FF883CE51D140AE
-:10FCD000EE24FF2410E0C2CD9981933109F4BCCE0B
-:10FCE0009431B0F4933009F440CE943038F491302C
-:10FCF00009F425CE923009F0A5CF04CE903109F455
-:10FD000001CE913109F445CE963009F09BCF7CCEDF
-:10FD1000983109F458CE993150F4953109F49CCEBC
-:10FD2000953108F423CF963109F08CCF1FCF9B314A
-:10FD300009F436CE9D3109F4E7CD9A3109F082CF2E
-:10FD40003ACECE5DDE4F0FB6F894DEBF0FBECDBF0C
-:10FD5000CF91DF911F910F91FF90EF90DF90CF90A7
-:10FD6000BF90AF909F908F907F906F905F904F90DB
-:10FD70003F902F9008958091C00087FFFCCF089599
-:10FD80008091C00087FFFCCF8091C6000895982F16
-:10FD90008091C00085FFFCCF9093C60008959B0121
-:10FDA000AC0197FF11C08091C00082608093C000B9
-:10FDB00050954095309521953F4F4F4F5F4F60E0F4
-:10FDC00074E284EF90E009C08091C0008D7F809341
-:10FDD000C00060E072E18AE790E00E9447FF2C5F7C
-:10FDE0003F4F4F4F5F4F83E0569547953795279587
-:10FDF0008A95D1F7215030403093C5002093C4003C
-:10FE0000089518B817B81F921F921F920895FFCF38
-:10FE100084B714BE90E083709070892B39F418B8C1
-:10FE200017B81F921F921F920895FFCF88E1809309
-:10FE3000C10060E07EE38EEF9FEF0E94CFFE0E9444
-:10FE400007FC18B817B81F921F921F920895FFCF92
-:10FE500020E030E040E050E013C02F5F3F4F4F4FB5
-:10FE60005F4F21308AE6380788E1480780E058076D
-:10FE700039F418B817B81F921F921F920895FFCF38
-:10FE80008091C00087FFE9CF0E94C0FE0895A1E2E3
-:10FE90001A2EAA1BBB1BFD010DC0AA1FBB1FEE1F04
-:10FEA000FF1FA217B307E407F50720F0A21BB30B4F
-:10FEB000E40BF50B661F771F881F991F1A9469F7CB
-:10FEC00060957095809590959B01AC01BD01CF0127
-:02FED000089593
-:040000031000F800F1
-:00000001FF
diff --git a/Marlin/Gen7/bootloaders/Gen7/bootloader-644-16MHz.hex b/Marlin/Gen7/bootloaders/Gen7/bootloader-644-16MHz.hex
deleted file mode 100644
index 5809869..0000000
--- a/Marlin/Gen7/bootloaders/Gen7/bootloader-644-16MHz.hex
+++ /dev/null
@@ -1,75 +0,0 @@
-:10F800008FEF90E19EBF8DBF11241FBE5A9A00C09A
-:10F81000CDB7DEB7CD51D140DEBFCDBF1092C50010
-:10F8200088E08093C40088E18093C100EE24FF2427
-:10F8300020E0552400E010E039E0432E9BE0292E23
-:10F84000312C2C0E3D1ECFC14150504060407040C5
-:10F8500011F43FE206C08091C00087FFF5CF3091E0
-:10F86000C600933021F1943028F4913099F0923011
-:10F87000C8F407C0953049F1953000F19630D1F5C4
-:10F8800035C03B3119F491E02BE134C03F3291F5A2
-:10F890003983BBC1313011F0351559F52327532E6B
-:10F8A00092E028C0B32FA0E0232793E023C0832F4A
-:10F8B00090E0A82BB92B232794E01CC03E30C9F45C
-:10F8C000232795E0EE24FF2415C0E1E0F0E0EC0FE3
-:10F8D000FD1FEE0DFF1D30830894E11CF11C232752
-:10F8E000EA16FB0639F4D70196E004C0321709F492
-:10F8F0008CC190E044E755E962E470E0ACCF90E061
-:10F9000044C08D81803311F090E00AC08F8188233C
-:10F9100011F49EE105C0813011F099E001C096E933
-:10F920001A821B828D818C838E818D839E831F82A0
-:10F9300047E050E0F4C01A8288E08B8381E48C8336
-:10F9400086E58D8382E58E8389E48F8383E58887CE
-:10F9500080E589878FE58A8782E38B874BE050E0DB
-:10F96000DEC08A81813941F0823941F0803911F459
-:10F970008FE005C080E003C082E001C08AE01A8207
-:10F980008B8343E050E0CBC091E01A8242E050E02C
-:10F99000C7C08D81882311F48EE124C0813011F01D
-:10F9A00089E020C086E91EC01A82E1E0F0E04092C2
-:10F9B0005700849118C08B81803579F48C81883010
-:10F9C00031F4E2E0F0E04092570084910BC0E0E0B7
-:10F9D000F0E040925700849105C0E3E0F0E04092EF
-:10F9E000570084911A828B831C8244E050E097C0B8
-:10F9F000BC80AA248D81082F10E00A291B29000F42
-:10FA0000111F1A828AC09A8088248B81682F70E027
-:10FA100068297929933109F033C0F7EF0F3F1F07A9
-:10FA200010F0A8013FC023E0F80120935700E895AB
-:10FA300007B600FCFDCFA801D1018C9111962C9145
-:10FA400011971296D22ECC2490E08C299D2921E08A
-:10FA5000FA010C0120935700E89511244E5F5F4F87
-:10FA60006250704051F725E0F80120935700E89567
-:10FA700007B600FCFDCF81E180935700E89512C0E6
-:10FA8000A801FB01D10141BD52BD4F5F5F4F8D9178
-:10FA900080BDFA9AF99AF999FECF3197A1F7A8019A
-:10FAA000460F571F1A828A0138C07A8066248B81DC
-:10FAB000A82FB0E0A629B7291A828981843191F450
-:10FAC000BD019E012D5F3F4FF80185919491F90191
-:10FAD000808391832E5F3F4F0E5F1F4F62507040B7
-:10FAE00099F713C0A801BD019E012D5F3F4F41BD95
-:10FAF00052BD4F5F5F4FF89A80B5F90181939F0126
-:10FB000061507040A1F70A0F1B1FAD014D5F5F4FA1
-:10FB1000F901108204C080EC8A8342E050E090E05A
-:10FB2000FBE1F093C6008091C00086FFFCCF80917E
-:10FB3000C00080648093C0005092C6008091C000D5
-:10FB400086FFFCCF8091C00080648093C000652F49
-:10FB50005093C6008091C00086FFFCCF8091C0000A
-:10FB600080648093C000342F4093C6008091C00011
-:10FB700086FFFCCF8091C00080648093C0008EE03F
-:10FB80008093C6008091C00086FFFCCF8091C000AA
-:10FB900080648093C00025E1252523272627FE01C8
-:10FBA000319610C030813093C6008091C00086FF2E
-:10FBB000FCCF31968091C00080648093C0002327E1
-:10FBC000415050404115510569F72093C60080917E
-:10FBD000C00086FFFCCF8091C00080648093C0008D
-:10FBE000992349F4539444E755E962E470E090E0C6
-:10FBF000A0E0B0E030CE5A9881E180935700E895BC
-:10FC000011241F921F920895FFCF9981933109F417
-:10FC1000FACE9431C8F4963009F4EACE973050F415
-:10FC2000923009F46CCE933009F49BCE913009F0F8
-:10FC300072CF81CE913109F4A7CE923108F0E1CE96
-:10FC4000903109F068CF5BCE983109F4B4CE993188
-:10FC500050F4953109F4D7CE953108F426CF96317A
-:10FC600009F059CF22CF9B3109F493CE9C3120F477
-:10FC70009A3109F050CF98CE9D3109F442CE9F328F
-:06FC800009F049CFB8CFE6
-:040000030000F80001
-:00000001FF
diff --git a/Marlin/Gen7/bootloaders/Gen7/bootloader-644-20MHz.hex b/Marlin/Gen7/bootloaders/Gen7/bootloader-644-20MHz.hex
deleted file mode 100644
index d216c65..0000000
--- a/Marlin/Gen7/bootloaders/Gen7/bootloader-644-20MHz.hex
+++ /dev/null
@@ -1,75 +0,0 @@
-:10F800008FEF90E19EBF8DBF11241FBE5A9A00C09A
-:10F81000CDB7DEB7CD51D140DEBFCDBF1092C50010
-:10F820008AE08093C40088E18093C100EE24FF2425
-:10F8300020E0552400E010E039E0432E9BE0292E23
-:10F84000312C2C0E3D1ECFC14150504060407040C5
-:10F8500011F43FE206C08091C00087FFF5CF3091E0
-:10F86000C600933021F1943028F4913099F0923011
-:10F87000C8F407C0953049F1953000F19630D1F5C4
-:10F8800035C03B3119F491E02BE134C03F3291F5A2
-:10F890003983BBC1313011F0351559F52327532E6B
-:10F8A00092E028C0B32FA0E0232793E023C0832F4A
-:10F8B00090E0A82BB92B232794E01CC03E30C9F45C
-:10F8C000232795E0EE24FF2415C0E1E0F0E0EC0FE3
-:10F8D000FD1FEE0DFF1D30830894E11CF11C232752
-:10F8E000EA16FB0639F4D70196E004C0321709F492
-:10F8F0008CC190E041ED5AE363E570E0ACCF90E05D
-:10F9000044C08D81803311F090E00AC08F8188233C
-:10F9100011F49EE105C0813011F099E001C096E933
-:10F920001A821B828D818C838E818D839E831F82A0
-:10F9300047E050E0F4C01A8288E08B8381E48C8336
-:10F9400086E58D8382E58E8389E48F8383E58887CE
-:10F9500080E589878FE58A8782E38B874BE050E0DB
-:10F96000DEC08A81813941F0823941F0803911F459
-:10F970008FE005C080E003C082E001C08AE01A8207
-:10F980008B8343E050E0CBC091E01A8242E050E02C
-:10F99000C7C08D81882311F48EE124C0813011F01D
-:10F9A00089E020C086E91EC01A82E1E0F0E04092C2
-:10F9B0005700849118C08B81803579F48C81883010
-:10F9C00031F4E2E0F0E04092570084910BC0E0E0B7
-:10F9D000F0E040925700849105C0E3E0F0E04092EF
-:10F9E000570084911A828B831C8244E050E097C0B8
-:10F9F000BC80AA248D81082F10E00A291B29000F42
-:10FA0000111F1A828AC09A8088248B81682F70E027
-:10FA100068297929933109F033C0F7EF0F3F1F07A9
-:10FA200010F0A8013FC023E0F80120935700E895AB
-:10FA300007B600FCFDCFA801D1018C9111962C9145
-:10FA400011971296D22ECC2490E08C299D2921E08A
-:10FA5000FA010C0120935700E89511244E5F5F4F87
-:10FA60006250704051F725E0F80120935700E89567
-:10FA700007B600FCFDCF81E180935700E89512C0E6
-:10FA8000A801FB01D10141BD52BD4F5F5F4F8D9178
-:10FA900080BDFA9AF99AF999FECF3197A1F7A8019A
-:10FAA000460F571F1A828A0138C07A8066248B81DC
-:10FAB000A82FB0E0A629B7291A828981843191F450
-:10FAC000BD019E012D5F3F4FF80185919491F90191
-:10FAD000808391832E5F3F4F0E5F1F4F62507040B7
-:10FAE00099F713C0A801BD019E012D5F3F4F41BD95
-:10FAF00052BD4F5F5F4FF89A80B5F90181939F0126
-:10FB000061507040A1F70A0F1B1FAD014D5F5F4FA1
-:10FB1000F901108204C080EC8A8342E050E090E05A
-:10FB2000FBE1F093C6008091C00086FFFCCF80917E
-:10FB3000C00080648093C0005092C6008091C000D5
-:10FB400086FFFCCF8091C00080648093C000652F49
-:10FB50005093C6008091C00086FFFCCF8091C0000A
-:10FB600080648093C000342F4093C6008091C00011
-:10FB700086FFFCCF8091C00080648093C0008EE03F
-:10FB80008093C6008091C00086FFFCCF8091C000AA
-:10FB900080648093C00025E1252523272627FE01C8
-:10FBA000319610C030813093C6008091C00086FF2E
-:10FBB000FCCF31968091C00080648093C0002327E1
-:10FBC000415050404115510569F72093C60080917E
-:10FBD000C00086FFFCCF8091C00080648093C0008D
-:10FBE000992349F4539441ED5AE363E570E090E0C2
-:10FBF000A0E0B0E030CE5A9881E180935700E895BC
-:10FC000011241F921F920895FFCF9981933109F417
-:10FC1000FACE9431C8F4963009F4EACE973050F415
-:10FC2000923009F46CCE933009F49BCE913009F0F8
-:10FC300072CF81CE913109F4A7CE923108F0E1CE96
-:10FC4000903109F068CF5BCE983109F4B4CE993188
-:10FC500050F4953109F4D7CE953108F426CF96317A
-:10FC600009F059CF22CF9B3109F493CE9C3120F477
-:10FC70009A3109F050CF98CE9D3109F442CE9F328F
-:06FC800009F049CFB8CFE6
-:040000030000F80001
-:00000001FF
diff --git a/Marlin/Gen7/bootloaders/Gen7/bootloader-644P-16MHz.hex b/Marlin/Gen7/bootloaders/Gen7/bootloader-644P-16MHz.hex
deleted file mode 100644
index a9105a2..0000000
--- a/Marlin/Gen7/bootloaders/Gen7/bootloader-644P-16MHz.hex
+++ /dev/null
@@ -1,75 +0,0 @@
-:10F800008FEF90E19EBF8DBF11241FBE5A9A00C09A
-:10F81000CDB7DEB7CD51D140DEBFCDBF1092C50010
-:10F8200088E08093C40088E18093C100EE24FF2427
-:10F8300020E0552400E010E039E0432E93E0292E2B
-:10F84000312C2C0E3D1ECDC14150504060407040C7
-:10F8500011F43FE206C08091C00087FFF5CF3091E0
-:10F86000C600933021F1943028F4913099F0923011
-:10F87000C8F407C0953049F1953000F19630D1F5C4
-:10F8800035C03B3119F491E02BE134C03F3291F5A2
-:10F890003983B9C1313011F0351559F52327532E6D
-:10F8A00092E028C0B32FA0E0232793E023C0832F4A
-:10F8B00090E0A82BB92B232794E01CC03E30C9F45C
-:10F8C000232795E0EE24FF2415C0E1E0F0E0EC0FE3
-:10F8D000FD1FEE0DFF1D30830894E11CF11C232752
-:10F8E000EA16FB0639F4D70196E004C0321709F492
-:10F8F0008AC190E044E755E962E470E0ACCF90E063
-:10F9000044C08D81803311F090E00AC08F8188233C
-:10F9100011F49EE105C0813011F09AE001C096E932
-:10F920001A821B828D818C838E818D839E831F82A0
-:10F9300047E050E0F2C01A8288E08B8381E48C8338
-:10F9400086E58D8382E58E8389E48F8383E58887CE
-:10F9500080E589878FE58A8782E38B874BE050E0DB
-:10F96000DCC08A81813941F0823941F0803911F45B
-:10F970008FE005C080E003C082E001C08AE01A8207
-:10F980008B8343E050E0C9C091E01A8242E050E02E
-:10F99000C5C08D81882311F48EE124C0813011F01F
-:10F9A0008AE020C086E91EC01A82E1E0F0E04092C1
-:10F9B0005700849118C08B81803579F48C81883010
-:10F9C00031F4E2E0F0E04092570084910BC0E0E0B7
-:10F9D000F0E040925700849105C0E3E0F0E04092EF
-:10F9E000570084911A828B831C8244E050E095C0BA
-:10F9F000BC80AA248D81082F10E00A291B29000F42
-:10FA0000111F1A8288C09A8088248B81682F70E029
-:10FA100068297929933109F034C0F7EF0F3F1F07A8
-:10FA200010F0A80141C023E0F80120935700E895A9
-:10FA300007B600FCFDCFA801DE011B968C91119644
-:10FA40002C9111971296D22ECC2490E08C299D29CE
-:10FA500021E0FA010C0120935700E89511244E5F34
-:10FA60005F4F6250704051F725E0F8012093570036
-:10FA7000E89507B600FCFDCF81E180935700E8953B
-:10FA800013C0A801FB01DE011B9641BD52BD4F5FB3
-:10FA90005F4F8D9180BDFA9AF99AF999FECF31970F
-:10FAA000A1F7A801460F571F1A828A0134C07A8035
-:10FAB00066248B81A82FB0E0A629B7291A828981F4
-:10FAC000843181F4BD019101F80185919491F9018E
-:10FAD000808391832E5F3F4F0E5F1F4F62507040B7
-:10FAE00099F711C0A801BD01910141BD52BD4F5F01
-:10FAF0005F4FF89A80B5F90181939F016150704082
-:10FB0000A1F70A0F1B1FAD014D5F5F4FF901108276
-:10FB100004C080EC8A8342E050E090E0FBE1F09387
-:10FB2000C6008091C00086FFFCCF8091C000806439
-:10FB30008093C0005092C6008091C00086FFFCCF29
-:10FB40008091C00080648093C000652F5093C600F0
-:10FB50008091C00086FFFCCF8091C00080648093BC
-:10FB6000C000342F4093C6008091C00086FFFCCFB8
-:10FB70008091C00080648093C0008EE08093C600B6
-:10FB80008091C00086FFFCCF8091C000806480938C
-:10FB9000C00025E1252523272627FE01319610C028
-:10FBA00030813093C6008091C00086FFFCCF319633
-:10FBB0008091C00080648093C00023274150504052
-:10FBC0004115510569F72093C6008091C00086FF5A
-:10FBD000FCCF8091C00080648093C000992349F4D9
-:10FBE000539444E755E962E470E090E0A0E0B0E0AF
-:10FBF00032CE5A9881E180935700E89511241F92E4
-:10FC00001F920895FFCF9981933109F4FCCE94316E
-:10FC1000C8F4963009F4ECCE973050F4923009F4E1
-:10FC20006ECE933009F49DCE913009F072CF83CE21
-:10FC3000913109F4A9CE923108F0E3CE903109F068
-:10FC400068CF5DCE983109F4B6CE993150F4953134
-:10FC500009F4D9CE953108F42ACF963109F059CF5D
-:10FC600026CF9B3109F495CE9C3120F49A3109F0CE
-:10FC700050CF9ACE9D3109F444CE9F3209F049CF3E
-:02FC8000B8CFFB
-:040000030000F80001
-:00000001FF
diff --git a/Marlin/Gen7/bootloaders/Gen7/bootloader-644P-20MHz.hex b/Marlin/Gen7/bootloaders/Gen7/bootloader-644P-20MHz.hex
deleted file mode 100644
index 4ee0c6b..0000000
--- a/Marlin/Gen7/bootloaders/Gen7/bootloader-644P-20MHz.hex
+++ /dev/null
@@ -1,75 +0,0 @@
-:10F800008FEF90E19EBF8DBF11241FBE5A9A00C09A
-:10F81000CDB7DEB7CD51D140DEBFCDBF1092C50010
-:10F820008AE08093C40088E18093C100EE24FF2425
-:10F8300020E0552400E010E039E0432E93E0292E2B
-:10F84000312C2C0E3D1ECDC14150504060407040C7
-:10F8500011F43FE206C08091C00087FFF5CF3091E0
-:10F86000C600933021F1943028F4913099F0923011
-:10F87000C8F407C0953049F1953000F19630D1F5C4
-:10F8800035C03B3119F491E02BE134C03F3291F5A2
-:10F890003983B9C1313011F0351559F52327532E6D
-:10F8A00092E028C0B32FA0E0232793E023C0832F4A
-:10F8B00090E0A82BB92B232794E01CC03E30C9F45C
-:10F8C000232795E0EE24FF2415C0E1E0F0E0EC0FE3
-:10F8D000FD1FEE0DFF1D30830894E11CF11C232752
-:10F8E000EA16FB0639F4D70196E004C0321709F492
-:10F8F0008AC190E041ED5AE363E570E0ACCF90E05F
-:10F9000044C08D81803311F090E00AC08F8188233C
-:10F9100011F49EE105C0813011F09AE001C096E932
-:10F920001A821B828D818C838E818D839E831F82A0
-:10F9300047E050E0F2C01A8288E08B8381E48C8338
-:10F9400086E58D8382E58E8389E48F8383E58887CE
-:10F9500080E589878FE58A8782E38B874BE050E0DB
-:10F96000DCC08A81813941F0823941F0803911F45B
-:10F970008FE005C080E003C082E001C08AE01A8207
-:10F980008B8343E050E0C9C091E01A8242E050E02E
-:10F99000C5C08D81882311F48EE124C0813011F01F
-:10F9A0008AE020C086E91EC01A82E1E0F0E04092C1
-:10F9B0005700849118C08B81803579F48C81883010
-:10F9C00031F4E2E0F0E04092570084910BC0E0E0B7
-:10F9D000F0E040925700849105C0E3E0F0E04092EF
-:10F9E000570084911A828B831C8244E050E095C0BA
-:10F9F000BC80AA248D81082F10E00A291B29000F42
-:10FA0000111F1A8288C09A8088248B81682F70E029
-:10FA100068297929933109F034C0F7EF0F3F1F07A8
-:10FA200010F0A80141C023E0F80120935700E895A9
-:10FA300007B600FCFDCFA801DE011B968C91119644
-:10FA40002C9111971296D22ECC2490E08C299D29CE
-:10FA500021E0FA010C0120935700E89511244E5F34
-:10FA60005F4F6250704051F725E0F8012093570036
-:10FA7000E89507B600FCFDCF81E180935700E8953B
-:10FA800013C0A801FB01DE011B9641BD52BD4F5FB3
-:10FA90005F4F8D9180BDFA9AF99AF999FECF31970F
-:10FAA000A1F7A801460F571F1A828A0134C07A8035
-:10FAB00066248B81A82FB0E0A629B7291A828981F4
-:10FAC000843181F4BD019101F80185919491F9018E
-:10FAD000808391832E5F3F4F0E5F1F4F62507040B7
-:10FAE00099F711C0A801BD01910141BD52BD4F5F01
-:10FAF0005F4FF89A80B5F90181939F016150704082
-:10FB0000A1F70A0F1B1FAD014D5F5F4FF901108276
-:10FB100004C080EC8A8342E050E090E0FBE1F09387
-:10FB2000C6008091C00086FFFCCF8091C000806439
-:10FB30008093C0005092C6008091C00086FFFCCF29
-:10FB40008091C00080648093C000652F5093C600F0
-:10FB50008091C00086FFFCCF8091C00080648093BC
-:10FB6000C000342F4093C6008091C00086FFFCCFB8
-:10FB70008091C00080648093C0008EE08093C600B6
-:10FB80008091C00086FFFCCF8091C000806480938C
-:10FB9000C00025E1252523272627FE01319610C028
-:10FBA00030813093C6008091C00086FFFCCF319633
-:10FBB0008091C00080648093C00023274150504052
-:10FBC0004115510569F72093C6008091C00086FF5A
-:10FBD000FCCF8091C00080648093C000992349F4D9
-:10FBE000539441ED5AE363E570E090E0A0E0B0E0AB
-:10FBF00032CE5A9881E180935700E89511241F92E4
-:10FC00001F920895FFCF9981933109F4FCCE94316E
-:10FC1000C8F4963009F4ECCE973050F4923009F4E1
-:10FC20006ECE933009F49DCE913009F072CF83CE21
-:10FC3000913109F4A9CE923108F0E3CE903109F068
-:10FC400068CF5DCE983109F4B6CE993150F4953134
-:10FC500009F4D9CE953108F42ACF963109F059CF5D
-:10FC600026CF9B3109F495CE9C3120F49A3109F0CE
-:10FC700050CF9ACE9D3109F444CE9F3209F049CF3E
-:02FC8000B8CFFB
-:040000030000F80001
-:00000001FF
diff --git a/Marlin/Gen7/cores/arduino/HardwareSerial.cpp b/Marlin/Gen7/cores/arduino/HardwareSerial.cpp
deleted file mode 100644
index 8b1fcc6..0000000
--- a/Marlin/Gen7/cores/arduino/HardwareSerial.cpp
+++ /dev/null
@@ -1,239 +0,0 @@
-/*
-  HardwareSerial.cpp - Hardware serial library for Wiring
-  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-  
-  Modified 23 November 2006 by David A. Mellis
-*/
-
-#include <stdio.h>
-#include <string.h>
-#include <inttypes.h>
-#include "wiring.h"
-#include "wiring_private.h"
-
-#include "HardwareSerial.h"
-
-// Define constants and variables for buffering incoming serial data.  We're
-// using a ring buffer (I think), in which rx_buffer_head is the index of the
-// location to which to write the next incoming character and rx_buffer_tail
-// is the index of the location from which to read.
-#define RX_BUFFER_SIZE 128
-
-struct ring_buffer {
-  unsigned char buffer[RX_BUFFER_SIZE];
-  int head;
-  int tail;
-};
-
-ring_buffer rx_buffer = { { 0 }, 0, 0 };
-
-#ifdef UDR1
-ring_buffer rx_buffer1 = { { 0 }, 0, 0 };
-#endif
-
-#ifdef UDR2
-ring_buffer rx_buffer2 = { { 0 }, 0, 0 };
-#endif
-#ifdef UDR3
-ring_buffer rx_buffer3 = { { 0 }, 0, 0 };
-#endif
-
-inline void store_char(unsigned char c, ring_buffer *rx_buffer)
-{
-  int i = (rx_buffer->head + 1) % RX_BUFFER_SIZE;
-
-  // if we should be storing the received character into the location
-  // just before the tail (meaning that the head would advance to the
-  // current location of the tail), we're about to overflow the buffer
-  // and so we don't write the character or advance the head.
-  if (i != rx_buffer->tail) {
-    rx_buffer->buffer[rx_buffer->head] = c;
-    rx_buffer->head = i;
-  }
-}
-
-ISR(USART0_RX_vect)
-{
-  unsigned char c = UDR0;
-  store_char(c, &rx_buffer);
-}
-
-#ifdef UDR1
-ISR(USART1_RX_vect)
-{
-  unsigned char c = UDR1;
-  store_char(c, &rx_buffer1);
-}
-
-#ifdef UDR2
-ISR(USART2_RX_vect)
-{
-  unsigned char c = UDR2;
-  store_char(c, &rx_buffer2);
-}
-
-#ifdef UDR2
-ISR(USART3_RX_vect)
-{
-  unsigned char c = UDR3;
-  store_char(c, &rx_buffer3);
-}
-#endif
-#endif
-
-#else
-
-#if defined(__AVR_ATmega8__)
-SIGNAL(SIG_UART_RECV)
-#else
-SIGNAL(USART_RX_vect)
-#endif
-{
-#if defined(__AVR_ATmega8__)
-  unsigned char c = UDR;
-#else
-  unsigned char c = UDR0;
-#endif
-  store_char(c, &rx_buffer);
-}
-
-#endif
-
-// Constructors ////////////////////////////////////////////////////////////////
-
-HardwareSerial::HardwareSerial(ring_buffer *rx_buffer,
-  volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
-  volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
-  volatile uint8_t *udr,
-  uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udre, uint8_t u2x)
-{
-  _rx_buffer = rx_buffer;
-  _ubrrh = ubrrh;
-  _ubrrl = ubrrl;
-  _ucsra = ucsra;
-  _ucsrb = ucsrb;
-  _udr = udr;
-  _rxen = rxen;
-  _txen = txen;
-  _rxcie = rxcie;
-  _udre = udre;
-  _u2x = u2x;
-}
-
-// Public Methods //////////////////////////////////////////////////////////////
-
-void HardwareSerial::begin(long baud)
-{
-  uint16_t baud_setting;
-  bool use_u2x;
-
-  // U2X mode is needed for baud rates higher than (CPU Hz / 16)
-  if (baud > F_CPU / 16) {
-    use_u2x = true;
-  } else {
-    // figure out if U2X mode would allow for a better connection
-    
-    // calculate the percent difference between the baud-rate specified and
-    // the real baud rate for both U2X and non-U2X mode (0-255 error percent)
-    uint8_t nonu2x_baud_error = abs((int)(255-((F_CPU/(16*(((F_CPU/8/baud-1)/2)+1))*255)/baud)));
-    uint8_t u2x_baud_error = abs((int)(255-((F_CPU/(8*(((F_CPU/4/baud-1)/2)+1))*255)/baud)));
-    
-    // prefer non-U2X mode because it handles clock skew better
-    use_u2x = (nonu2x_baud_error > u2x_baud_error);
-  }
-  
-  if (use_u2x) {
-    *_ucsra = 1 << _u2x;
-    baud_setting = (F_CPU / 4 / baud - 1) / 2;
-  } else {
-    *_ucsra = 0;
-    baud_setting = (F_CPU / 8 / baud - 1) / 2;
-  }
-
-  // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)
-  *_ubrrh = baud_setting >> 8;
-  *_ubrrl = baud_setting;
-
-  sbi(*_ucsrb, _rxen);
-  sbi(*_ucsrb, _txen);
-  sbi(*_ucsrb, _rxcie);
-}
-
-void HardwareSerial::end()
-{
-  cbi(*_ucsrb, _rxen);
-  cbi(*_ucsrb, _txen);
-  cbi(*_ucsrb, _rxcie);  
-}
-
-uint8_t HardwareSerial::available(void)
-{
-  return (RX_BUFFER_SIZE + _rx_buffer->head - _rx_buffer->tail) % RX_BUFFER_SIZE;
-}
-
-int HardwareSerial::read(void)
-{
-  // if the head isn't ahead of the tail, we don't have any characters
-  if (_rx_buffer->head == _rx_buffer->tail) {
-    return -1;
-  } else {
-    unsigned char c = _rx_buffer->buffer[_rx_buffer->tail];
-    _rx_buffer->tail = (_rx_buffer->tail + 1) % RX_BUFFER_SIZE;
-    return c;
-  }
-}
-
-void HardwareSerial::flush()
-{
-  // don't reverse this or there may be problems if the RX interrupt
-  // occurs after reading the value of rx_buffer_head but before writing
-  // the value to rx_buffer_tail; the previous value of rx_buffer_head
-  // may be written to rx_buffer_tail, making it appear as if the buffer
-  // don't reverse this or there may be problems if the RX interrupt
-  // occurs after reading the value of rx_buffer_head but before writing
-  // the value to rx_buffer_tail; the previous value of rx_buffer_head
-  // may be written to rx_buffer_tail, making it appear as if the buffer
-  // were full, not empty.
-  _rx_buffer->head = _rx_buffer->tail;
-}
-
-void HardwareSerial::write(uint8_t c)
-{
-  while (!((*_ucsra) & (1 << _udre)))
-    ;
-
-  *_udr = c;
-}
-
-// Preinstantiate Objects //////////////////////////////////////////////////////
-
-#if defined(__AVR_ATmega8__)
-HardwareSerial Serial(&rx_buffer, &UBRRH, &UBRRL, &UCSRA, &UCSRB, &UDR, RXEN, TXEN, RXCIE, UDRE, U2X);
-#else
-HardwareSerial Serial(&rx_buffer, &UBRR0H, &UBRR0L, &UCSR0A, &UCSR0B, &UDR0, RXEN0, TXEN0, RXCIE0, UDRE0, U2X0);
-#endif
-
-#ifdef UDR1
-HardwareSerial Serial1(&rx_buffer1, &UBRR1H, &UBRR1L, &UCSR1A, &UCSR1B, &UDR1, RXEN1, TXEN1, RXCIE1, UDRE1, U2X1);
-#endif
-
-#ifdef UDR2
-HardwareSerial Serial2(&rx_buffer2, &UBRR2H, &UBRR2L, &UCSR2A, &UCSR2B, &UDR2, RXEN2, TXEN2, RXCIE2, UDRE2, U2X2);
-#endif
-#ifdef UDR3
-HardwareSerial Serial3(&rx_buffer3, &UBRR3H, &UBRR3L, &UCSR3A, &UCSR3B, &UDR3, RXEN3, TXEN3, RXCIE3, UDRE3, U2X3);
-#endif
diff --git a/Marlin/Gen7/cores/arduino/HardwareSerial.h b/Marlin/Gen7/cores/arduino/HardwareSerial.h
deleted file mode 100644
index f609f73..0000000
--- a/Marlin/Gen7/cores/arduino/HardwareSerial.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
-  HardwareSerial.h - Hardware serial library for Wiring
-  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef HardwareSerial_h
-#define HardwareSerial_h
-
-#include <inttypes.h>
-
-#include "Print.h"
-
-struct ring_buffer;
-
-class HardwareSerial : public Print
-{
-  private:
-    ring_buffer *_rx_buffer;
-    volatile uint8_t *_ubrrh;
-    volatile uint8_t *_ubrrl;
-    volatile uint8_t *_ucsra;
-    volatile uint8_t *_ucsrb;
-    volatile uint8_t *_udr;
-    uint8_t _rxen;
-    uint8_t _txen;
-    uint8_t _rxcie;
-    uint8_t _udre;
-    uint8_t _u2x;
-  public:
-    HardwareSerial(ring_buffer *rx_buffer,
-      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
-      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
-      volatile uint8_t *udr,
-      uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udre, uint8_t u2x);
-    void begin(long);
-    void end();
-    uint8_t available(void);
-    int read(void);
-    void flush(void);
-    virtual void write(uint8_t);
-    using Print::write; // pull in write(str) and write(buf, size) from Print
-};
-
-extern HardwareSerial Serial;
-
-#if defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1280__)
-extern HardwareSerial Serial1;
-#endif
-
-#if defined(__AVR_ATmega1280__)
-extern HardwareSerial Serial2;
-extern HardwareSerial Serial3;
-#endif
-
-#endif
diff --git a/Marlin/Gen7/cores/arduino/Makefile b/Marlin/Gen7/cores/arduino/Makefile
deleted file mode 100644
index 571687d..0000000
--- a/Marlin/Gen7/cores/arduino/Makefile
+++ /dev/null
@@ -1,243 +0,0 @@
-# Arduino 0011 Makefile
-# Arduino adaptation by mellis, eighthave, oli.keller
-#
-# This makefile allows you to build sketches from the command line
-# without the Arduino environment (or Java).
-#
-# Detailed instructions for using the makefile:
-#
-#  1. Copy this file into the folder with your sketch. There should be a
-#     file with the same name as the folder and with the extension .pde
-#     (e.g. foo.pde in the foo/ folder).
-#
-#  2. Modify the line containg "INSTALL_DIR" to point to the directory that
-#     contains the Arduino installation (for example, under Mac OS X, this
-#     might be /Applications/arduino-0012).
-#
-#  3. Modify the line containing "PORT" to refer to the filename
-#     representing the USB or serial connection to your Arduino board
-#     (e.g. PORT = /dev/tty.USB0).  If the exact name of this file
-#     changes, you can use * as a wildcard (e.g. PORT = /dev/tty.usb*).
-#
-#  4. Set the line containing "MCU" to match your board's processor. 
-#     Older one's are atmega8 based, newer ones like Arduino Mini, Bluetooth
-#     or Diecimila have the atmega168.  If you're using a LilyPad Arduino,
-#     change F_CPU to 8000000.
-#
-#  5. At the command line, change to the directory containing your
-#     program's file and the makefile.
-#
-#  6. Type "make" and press enter to compile/verify your program.
-#
-#  7. Type "make upload", reset your Arduino board, and press enter to
-#     upload your program to the Arduino board.
-#
-# $Id$
-
-TARGET = $(notdir $(CURDIR))
-INSTALL_DIR = /Users/dmellis/Source/arduino/trunk/build/macosx/build/work
-PORT = /dev/tty.usb*
-UPLOAD_RATE = 19200
-AVRDUDE_PROGRAMMER = stk500v1
-MCU = atmega168
-F_CPU = 16000000
-
-############################################################################
-# Below here nothing should be changed...
-
-ARDUINO = $(INSTALL_DIR)/hardware/cores/arduino
-AVR_TOOLS_PATH = $(INSTALL_DIR)/hardware/tools/avr/bin
-SRC =  $(ARDUINO)/pins_arduino.c $(ARDUINO)/wiring.c \
-$(ARDUINO)/wiring_analog.c $(ARDUINO)/wiring_digital.c \
-$(ARDUINO)/wiring_pulse.c $(ARDUINO)/wiring_serial.c \
-$(ARDUINO)/wiring_shift.c $(ARDUINO)/WInterrupts.c
-CXXSRC = $(ARDUINO)/HardwareSerial.cpp $(ARDUINO)/WMath.cpp
-FORMAT = ihex
-
-
-# Name of this Makefile (used for "make depend").
-MAKEFILE = Makefile
-
-# Debugging format.
-# Native formats for AVR-GCC's -g are stabs [default], or dwarf-2.
-# AVR (extended) COFF requires stabs, plus an avr-objcopy run.
-DEBUG = stabs
-
-OPT = s
-
-# Place -D or -U options here
-CDEFS = -DF_CPU=$(F_CPU)
-CXXDEFS = -DF_CPU=$(F_CPU)
-
-# Place -I options here
-CINCS = -I$(ARDUINO)
-CXXINCS = -I$(ARDUINO)
-
-# Compiler flag to set the C Standard level.
-# c89   - "ANSI" C
-# gnu89 - c89 plus GCC extensions
-# c99   - ISO C99 standard (not yet fully implemented)
-# gnu99 - c99 plus GCC extensions
-CSTANDARD = -std=gnu99
-CDEBUG = -g$(DEBUG)
-CWARN = -Wall -Wstrict-prototypes
-CTUNING = -funsigned-char -funsigned-bitfields -fpack-struct -fshort-enums
-#CEXTRA = -Wa,-adhlns=$(<:.c=.lst)
-
-CFLAGS = $(CDEBUG) $(CDEFS) $(CINCS) -O$(OPT) $(CWARN) $(CSTANDARD) $(CEXTRA)
-CXXFLAGS = $(CDEFS) $(CINCS) -O$(OPT)
-#ASFLAGS = -Wa,-adhlns=$(<:.S=.lst),-gstabs 
-LDFLAGS = -lm
-
-
-# Programming support using avrdude. Settings and variables.
-AVRDUDE_PORT = $(PORT)
-AVRDUDE_WRITE_FLASH = -U flash:w:applet/$(TARGET).hex
-AVRDUDE_FLAGS = -V -F -C $(INSTALL_DIR)/hardware/tools/avr/etc/avrdude.conf \
--p $(MCU) -P $(AVRDUDE_PORT) -c $(AVRDUDE_PROGRAMMER) \
--b $(UPLOAD_RATE)
-
-# Program settings
-CC = $(AVR_TOOLS_PATH)/avr-gcc
-CXX = $(AVR_TOOLS_PATH)/avr-g++
-OBJCOPY = $(AVR_TOOLS_PATH)/avr-objcopy
-OBJDUMP = $(AVR_TOOLS_PATH)/avr-objdump
-AR  = $(AVR_TOOLS_PATH)/avr-ar
-SIZE = $(AVR_TOOLS_PATH)/avr-size
-NM = $(AVR_TOOLS_PATH)/avr-nm
-AVRDUDE = $(AVR_TOOLS_PATH)/avrdude
-REMOVE = rm -f
-MV = mv -f
-
-# Define all object files.
-OBJ = $(SRC:.c=.o) $(CXXSRC:.cpp=.o) $(ASRC:.S=.o) 
-
-# Define all listing files.
-LST = $(ASRC:.S=.lst) $(CXXSRC:.cpp=.lst) $(SRC:.c=.lst)
-
-# Combine all necessary flags and optional flags.
-# Add target processor to flags.
-ALL_CFLAGS = -mmcu=$(MCU) -I. $(CFLAGS)
-ALL_CXXFLAGS = -mmcu=$(MCU) -I. $(CXXFLAGS)
-ALL_ASFLAGS = -mmcu=$(MCU) -I. -x assembler-with-cpp $(ASFLAGS)
-
-
-# Default target.
-all: applet_files build sizeafter
-
-build: elf hex 
-
-applet_files: $(TARGET).pde
-	# Here is the "preprocessing".
-	# It creates a .cpp file based with the same name as the .pde file.
-	# On top of the new .cpp file comes the WProgram.h header.
-	# At the end there is a generic main() function attached.
-	# Then the .cpp file will be compiled. Errors during compile will
-	# refer to this new, automatically generated, file. 
-	# Not the original .pde file you actually edit...
-	test -d applet || mkdir applet
-	echo '#include "WProgram.h"' > applet/$(TARGET).cpp
-	cat $(TARGET).pde >> applet/$(TARGET).cpp
-	cat $(ARDUINO)/main.cxx >> applet/$(TARGET).cpp
-
-elf: applet/$(TARGET).elf
-hex: applet/$(TARGET).hex
-eep: applet/$(TARGET).eep
-lss: applet/$(TARGET).lss 
-sym: applet/$(TARGET).sym
-
-# Program the device.  
-upload: applet/$(TARGET).hex
-	$(AVRDUDE) $(AVRDUDE_FLAGS) $(AVRDUDE_WRITE_FLASH)
-
-
-	# Display size of file.
-HEXSIZE = $(SIZE) --target=$(FORMAT) applet/$(TARGET).hex
-ELFSIZE = $(SIZE)  applet/$(TARGET).elf
-sizebefore:
-	@if [ -f applet/$(TARGET).elf ]; then echo; echo $(MSG_SIZE_BEFORE); $(HEXSIZE); echo; fi
-
-sizeafter:
-	@if [ -f applet/$(TARGET).elf ]; then echo; echo $(MSG_SIZE_AFTER); $(HEXSIZE); echo; fi
-
-
-# Convert ELF to COFF for use in debugging / simulating in AVR Studio or VMLAB.
-COFFCONVERT=$(OBJCOPY) --debugging \
---change-section-address .data-0x800000 \
---change-section-address .bss-0x800000 \
---change-section-address .noinit-0x800000 \
---change-section-address .eeprom-0x810000 
-
-
-coff: applet/$(TARGET).elf
-	$(COFFCONVERT) -O coff-avr applet/$(TARGET).elf $(TARGET).cof
-
-
-extcoff: $(TARGET).elf
-	$(COFFCONVERT) -O coff-ext-avr applet/$(TARGET).elf $(TARGET).cof
-
-
-.SUFFIXES: .elf .hex .eep .lss .sym
-
-.elf.hex:
-	$(OBJCOPY) -O $(FORMAT) -R .eeprom $< $@
-
-.elf.eep:
-	-$(OBJCOPY) -j .eeprom --set-section-flags=.eeprom="alloc,load" \
-	--change-section-lma .eeprom=0 -O $(FORMAT) $< $@
-
-# Create extended listing file from ELF output file.
-.elf.lss:
-	$(OBJDUMP) -h -S $< > $@
-
-# Create a symbol table from ELF output file.
-.elf.sym:
-	$(NM) -n $< > $@
-
-	# Link: create ELF output file from library.
-applet/$(TARGET).elf: $(TARGET).pde applet/core.a 
-	$(CC) $(ALL_CFLAGS) -o $@ applet/$(TARGET).cpp -L. applet/core.a $(LDFLAGS)
-
-applet/core.a: $(OBJ)
-	@for i in $(OBJ); do echo $(AR) rcs applet/core.a $$i; $(AR) rcs applet/core.a $$i; done
-
-
-
-# Compile: create object files from C++ source files.
-.cpp.o:
-	$(CXX) -c $(ALL_CXXFLAGS) $< -o $@ 
-
-# Compile: create object files from C source files.
-.c.o:
-	$(CC) -c $(ALL_CFLAGS) $< -o $@ 
-
-
-# Compile: create assembler files from C source files.
-.c.s:
-	$(CC) -S $(ALL_CFLAGS) $< -o $@
-
-
-# Assemble: create object files from assembler source files.
-.S.o:
-	$(CC) -c $(ALL_ASFLAGS) $< -o $@
-
-
-
-# Target: clean project.
-clean:
-	$(REMOVE) applet/$(TARGET).hex applet/$(TARGET).eep applet/$(TARGET).cof applet/$(TARGET).elf \
-	applet/$(TARGET).map applet/$(TARGET).sym applet/$(TARGET).lss applet/core.a \
-	$(OBJ) $(LST) $(SRC:.c=.s) $(SRC:.c=.d) $(CXXSRC:.cpp=.s) $(CXXSRC:.cpp=.d)
-
-depend:
-	if grep '^# DO NOT DELETE' $(MAKEFILE) >/dev/null; \
-	then \
-		sed -e '/^# DO NOT DELETE/,$$d' $(MAKEFILE) > \
-			$(MAKEFILE).$$$$ && \
-		$(MV) $(MAKEFILE).$$$$ $(MAKEFILE); \
-	fi
-	echo '# DO NOT DELETE THIS LINE -- make depend depends on it.' \
-		>> $(MAKEFILE); \
-	$(CC) -M -mmcu=$(MCU) $(CDEFS) $(CINCS) $(SRC) $(ASRC) >> $(MAKEFILE)
-
-.PHONY:	all build elf hex eep lss sym program coff extcoff clean depend applet_files sizebefore sizeafter
diff --git a/Marlin/Gen7/cores/arduino/Print.cpp b/Marlin/Gen7/cores/arduino/Print.cpp
deleted file mode 100644
index d4833da..0000000
--- a/Marlin/Gen7/cores/arduino/Print.cpp
+++ /dev/null
@@ -1,203 +0,0 @@
-/*
- Print.cpp - Base class that provides print() and println()
- Copyright (c) 2008 David A. Mellis.  All right reserved.
- 
- This library is free software; you can redistribute it and/or
- modify it under the terms of the GNU Lesser General Public
- License as published by the Free Software Foundation; either
- version 2.1 of the License, or (at your option) any later version.
- 
- This library is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- Lesser General Public License for more details.
- 
- You should have received a copy of the GNU Lesser General Public
- License along with this library; if not, write to the Free Software
- Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- 
- Modified 23 November 2006 by David A. Mellis
- */
-
-#include <stdio.h>
-#include <string.h>
-#include <inttypes.h>
-#include <math.h>
-#include "wiring.h"
-
-#include "Print.h"
-
-// Public Methods //////////////////////////////////////////////////////////////
-
-void Print::print(uint8_t b)
-{
-  this->write(b);
-}
-
-void Print::print(char c)
-{
-  print((byte) c);
-}
-
-void Print::print(const char c[])
-{
-  while (*c)
-    print(*c++);
-}
-
-void Print::print(int n)
-{
-  print((long) n);
-}
-
-void Print::print(unsigned int n)
-{
-  print((unsigned long) n);
-}
-
-void Print::print(long n)
-{
-  if (n < 0) {
-    print('-');
-    n = -n;
-  }
-  printNumber(n, 10);
-}
-
-void Print::print(unsigned long n)
-{
-  printNumber(n, 10);
-}
-
-void Print::print(long n, int base)
-{
-  if (base == 0)
-    print((char) n);
-  else if (base == 10)
-    print(n);
-  else
-    printNumber(n, base);
-}
-
-void Print::print(double n)
-{
-  printFloat(n, 2);
-}
-
-void Print::println(void)
-{
-  print('\r');
-  print('\n');  
-}
-
-void Print::println(char c)
-{
-  print(c);
-  println();  
-}
-
-void Print::println(const char c[])
-{
-  print(c);
-  println();
-}
-
-void Print::println(uint8_t b)
-{
-  print(b);
-  println();
-}
-
-void Print::println(int n)
-{
-  print(n);
-  println();
-}
-
-void Print::println(unsigned int n)
-{
-  print(n);
-  println();
-}
-
-void Print::println(long n)
-{
-  print(n);
-  println();  
-}
-
-void Print::println(unsigned long n)
-{
-  print(n);
-  println();  
-}
-
-void Print::println(long n, int base)
-{
-  print(n, base);
-  println();
-}
-
-void Print::println(double n)
-{
-  print(n);
-  println();
-}
-
-// Private Methods /////////////////////////////////////////////////////////////
-
-void Print::printNumber(unsigned long n, uint8_t base)
-{
-  unsigned char buf[8 * sizeof(long)]; // Assumes 8-bit chars. 
-  unsigned long i = 0;
-
-  if (n == 0) {
-    print('0');
-    return;
-  } 
-
-  while (n > 0) {
-    buf[i++] = n % base;
-    n /= base;
-  }
-
-  for (; i > 0; i--)
-    print((char) (buf[i - 1] < 10 ?
-      '0' + buf[i - 1] :
-      'A' + buf[i - 1] - 10));
-}
-
-void Print::printFloat(double number, uint8_t digits) 
-{ 
-  // Handle negative numbers
-  if (number < 0.0)
-  {
-     print('-');
-     number = -number;
-  }
-
-  // Round correctly so that print(1.999, 2) prints as "2.00"
-  double rounding = 0.5;
-  for (uint8_t i=0; i<digits; ++i)
-    rounding /= 10.0;
-  
-  number += rounding;
-
-  // Extract the integer part of the number and print it
-  unsigned long int_part = (unsigned long)number;
-  double remainder = number - (double)int_part;
-  print(int_part);
-
-  // Print the decimal point, but only if there are digits beyond
-  if (digits > 0)
-    print("."); 
-
-  // Extract digits from the remainder one at a time
-  while (digits-- > 0)
-  {
-    remainder *= 10.0;
-    int toPrint = int(remainder);
-    print(toPrint);
-    remainder -= toPrint; 
-  } 
-}
diff --git a/Marlin/Gen7/cores/arduino/Print.h b/Marlin/Gen7/cores/arduino/Print.h
deleted file mode 100644
index c95a0dc..0000000
--- a/Marlin/Gen7/cores/arduino/Print.h
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
-  Print.h - Base class that provides print() and println()
-  Copyright (c) 2008 David A. Mellis.  All right reserved.
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef Print_h
-#define Print_h
-
-#include <inttypes.h>
-
-#define DEC 10
-#define HEX 16
-#define OCT 8
-#define BIN 2
-#define BYTE 0
-
-class Print
-{
-  private:
-    void printNumber(unsigned long, uint8_t);
-    void printFloat(double, uint8_t);
-  public:
-    virtual void write(uint8_t);
-    void print(char);
-    void print(const char[]);
-    void print(uint8_t);
-    void print(int);
-    void print(unsigned int);
-    void print(long);
-    void print(unsigned long);
-    void print(long, int);
-    void print(double);
-    void println(void);
-    void println(char);
-    void println(const char[]);
-    void println(uint8_t);
-    void println(int);
-    void println(unsigned int);
-    void println(long);
-    void println(unsigned long);
-    void println(long, int);
-    void println(double);
-};
-
-#endif
diff --git a/Marlin/Gen7/cores/arduino/Tone.cpp b/Marlin/Gen7/cores/arduino/Tone.cpp
deleted file mode 100644
index 827fe49..0000000
--- a/Marlin/Gen7/cores/arduino/Tone.cpp
+++ /dev/null
@@ -1,515 +0,0 @@
-/* Tone.cpp
-
-  A Tone Generator Library
-
-  Written by Brett Hagman
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-Version Modified By Date     Comments
-------- ----------- -------- --------
-0001    B Hagman    09/08/02 Initial coding
-0002    B Hagman    09/08/18 Multiple pins
-0003    B Hagman    09/08/18 Moved initialization from constructor to begin()
-0004    B Hagman    09/09/26 Fixed problems with ATmega8
-0005    B Hagman    09/11/23 Scanned prescalars for best fit on 8 bit timers
-                    09/11/25 Changed pin toggle method to XOR
-                    09/11/25 Fixed timer0 from being excluded
-0006    D Mellis    09/12/29 Replaced objects with functions
-
-*************************************************/
-
-#include <avr/interrupt.h>
-#include <avr/pgmspace.h>
-#include <wiring.h>
-#include <pins_arduino.h>
-
-#if defined(__AVR_ATmega8__)
-#define TCCR2A TCCR2
-#define TCCR2B TCCR2
-#define COM2A1 COM21
-#define COM2A0 COM20
-#define OCR2A OCR2
-#define TIMSK2 TIMSK
-#define OCIE2A OCIE2
-#define TIMER2_COMPA_vect TIMER2_COMP_vect
-#define TIMSK1 TIMSK
-#endif
-
-// timerx_toggle_count:
-//  > 0 - duration specified
-//  = 0 - stopped
-//  < 0 - infinitely (until stop() method called, or new play() called)
-
-#if !defined(__AVR_ATmega8__)
-volatile long timer0_toggle_count;
-volatile uint8_t *timer0_pin_port;
-volatile uint8_t timer0_pin_mask;
-#endif
-
-volatile long timer1_toggle_count;
-volatile uint8_t *timer1_pin_port;
-volatile uint8_t timer1_pin_mask;
-volatile long timer2_toggle_count;
-volatile uint8_t *timer2_pin_port;
-volatile uint8_t timer2_pin_mask;
-
-#if defined(__AVR_ATmega1280__)
-volatile long timer3_toggle_count;
-volatile uint8_t *timer3_pin_port;
-volatile uint8_t timer3_pin_mask;
-volatile long timer4_toggle_count;
-volatile uint8_t *timer4_pin_port;
-volatile uint8_t timer4_pin_mask;
-volatile long timer5_toggle_count;
-volatile uint8_t *timer5_pin_port;
-volatile uint8_t timer5_pin_mask;
-#endif
-
-
-#if defined(__AVR_ATmega1280__)
-
-#define AVAILABLE_TONE_PINS 1
-
-const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 3, 4, 5, 1, 0 */ };
-static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255, 255, 255, 255, 255 */ };
-
-#elif defined(__AVR_ATmega8__)
-
-#define AVAILABLE_TONE_PINS 1
-
-const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 1 */ };
-static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255 */ };
-
-#else
-
-#define AVAILABLE_TONE_PINS 1
-
-// Leave timer 0 to last.
-const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 1, 0 */ };
-static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255, 255 */ };
-
-#endif
-
-
-
-static int8_t toneBegin(uint8_t _pin)
-{
-  int8_t _timer = -1;
-
-  // if we're already using the pin, the timer should be configured.  
-  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
-    if (tone_pins[i] == _pin) {
-      return pgm_read_byte(tone_pin_to_timer_PGM + i);
-    }
-  }
-  
-  // search for an unused timer.
-  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
-    if (tone_pins[i] == 255) {
-      tone_pins[i] = _pin;
-      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
-      break;
-    }
-  }
-  
-  if (_timer != -1)
-  {
-    // Set timer specific stuff
-    // All timers in CTC mode
-    // 8 bit timers will require changing prescalar values,
-    // whereas 16 bit timers are set to either ck/1 or ck/64 prescalar
-    switch (_timer)
-    {
-#if !defined(__AVR_ATmega8__)
-      case 0:
-        // 8 bit timer
-        TCCR0A = 0;
-        TCCR0B = 0;
-        bitWrite(TCCR0A, WGM01, 1);
-        bitWrite(TCCR0B, CS00, 1);
-        timer0_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer0_pin_mask = digitalPinToBitMask(_pin);
-        break;
-#endif
-
-      case 1:
-        // 16 bit timer
-        TCCR1A = 0;
-        TCCR1B = 0;
-        bitWrite(TCCR1B, WGM12, 1);
-        bitWrite(TCCR1B, CS10, 1);
-        timer1_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer1_pin_mask = digitalPinToBitMask(_pin);
-        break;
-      case 2:
-        // 8 bit timer
-        TCCR2A = 0;
-        TCCR2B = 0;
-        bitWrite(TCCR2A, WGM21, 1);
-        bitWrite(TCCR2B, CS20, 1);
-        timer2_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer2_pin_mask = digitalPinToBitMask(_pin);
-        break;
-
-#if defined(__AVR_ATmega1280__)
-      case 3:
-        // 16 bit timer
-        TCCR3A = 0;
-        TCCR3B = 0;
-        bitWrite(TCCR3B, WGM32, 1);
-        bitWrite(TCCR3B, CS30, 1);
-        timer3_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer3_pin_mask = digitalPinToBitMask(_pin);
-        break;
-      case 4:
-        // 16 bit timer
-        TCCR4A = 0;
-        TCCR4B = 0;
-        bitWrite(TCCR4B, WGM42, 1);
-        bitWrite(TCCR4B, CS40, 1);
-        timer4_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer4_pin_mask = digitalPinToBitMask(_pin);
-        break;
-      case 5:
-        // 16 bit timer
-        TCCR5A = 0;
-        TCCR5B = 0;
-        bitWrite(TCCR5B, WGM52, 1);
-        bitWrite(TCCR5B, CS50, 1);
-        timer5_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer5_pin_mask = digitalPinToBitMask(_pin);
-        break;
-#endif
-    }
-  }
-
-  return _timer;
-}
-
-
-
-// frequency (in hertz) and duration (in milliseconds).
-
-void tone(uint8_t _pin, unsigned int frequency, unsigned long duration)
-{
-  uint8_t prescalarbits = 0b001;
-  long toggle_count = 0;
-  uint32_t ocr = 0;
-  int8_t _timer;
-
-  _timer = toneBegin(_pin);
-
-  if (_timer >= 0)
-  {
-    // Set the pinMode as OUTPUT
-    pinMode(_pin, OUTPUT);
-    
-    // if we are using an 8 bit timer, scan through prescalars to find the best fit
-    if (_timer == 0 || _timer == 2)
-    {
-      ocr = F_CPU / frequency / 2 - 1;
-      prescalarbits = 0b001;  // ck/1: same for both timers
-      if (ocr > 255)
-      {
-        ocr = F_CPU / frequency / 2 / 8 - 1;
-        prescalarbits = 0b010;  // ck/8: same for both timers
-
-        if (_timer == 2 && ocr > 255)
-        {
-          ocr = F_CPU / frequency / 2 / 32 - 1;
-          prescalarbits = 0b011;
-        }
-
-        if (ocr > 255)
-        {
-          ocr = F_CPU / frequency / 2 / 64 - 1;
-          prescalarbits = _timer == 0 ? 0b011 : 0b100;
-
-          if (_timer == 2 && ocr > 255)
-          {
-            ocr = F_CPU / frequency / 2 / 128 - 1;
-            prescalarbits = 0b101;
-          }
-
-          if (ocr > 255)
-          {
-            ocr = F_CPU / frequency / 2 / 256 - 1;
-            prescalarbits = _timer == 0 ? 0b100 : 0b110;
-            if (ocr > 255)
-            {
-              // can't do any better than /1024
-              ocr = F_CPU / frequency / 2 / 1024 - 1;
-              prescalarbits = _timer == 0 ? 0b101 : 0b111;
-            }
-          }
-        }
-      }
-
-#if !defined(__AVR_ATmega8__)
-      if (_timer == 0)
-        TCCR0B = prescalarbits;
-      else
-#endif
-        TCCR2B = prescalarbits;
-    }
-    else
-    {
-      // two choices for the 16 bit timers: ck/1 or ck/64
-      ocr = F_CPU / frequency / 2 - 1;
-
-      prescalarbits = 0b001;
-      if (ocr > 0xffff)
-      {
-        ocr = F_CPU / frequency / 2 / 64 - 1;
-        prescalarbits = 0b011;
-      }
-
-      if (_timer == 1)
-        TCCR1B = (TCCR1B & 0b11111000) | prescalarbits;
-#if defined(__AVR_ATmega1280__)
-      else if (_timer == 3)
-        TCCR3B = (TCCR3B & 0b11111000) | prescalarbits;
-      else if (_timer == 4)
-        TCCR4B = (TCCR4B & 0b11111000) | prescalarbits;
-      else if (_timer == 5)
-        TCCR5B = (TCCR5B & 0b11111000) | prescalarbits;
-#endif
-
-    }
-    
-
-    // Calculate the toggle count
-    if (duration > 0)
-    {
-      toggle_count = 2 * frequency * duration / 1000;
-    }
-    else
-    {
-      toggle_count = -1;
-    }
-
-    // Set the OCR for the given timer,
-    // set the toggle count,
-    // then turn on the interrupts
-    switch (_timer)
-    {
-
-#if !defined(__AVR_ATmega8__)
-      case 0:
-        OCR0A = ocr;
-        timer0_toggle_count = toggle_count;
-        bitWrite(TIMSK0, OCIE0A, 1);
-        break;
-#endif
-
-      case 1:
-        OCR1A = ocr;
-        timer1_toggle_count = toggle_count;
-        bitWrite(TIMSK1, OCIE1A, 1);
-        break;
-      case 2:
-        OCR2A = ocr;
-        timer2_toggle_count = toggle_count;
-        bitWrite(TIMSK2, OCIE2A, 1);
-        break;
-
-#if defined(__AVR_ATmega1280__)
-      case 3:
-        OCR3A = ocr;
-        timer3_toggle_count = toggle_count;
-        bitWrite(TIMSK3, OCIE3A, 1);
-        break;
-      case 4:
-        OCR4A = ocr;
-        timer4_toggle_count = toggle_count;
-        bitWrite(TIMSK4, OCIE4A, 1);
-        break;
-      case 5:
-        OCR5A = ocr;
-        timer5_toggle_count = toggle_count;
-        bitWrite(TIMSK5, OCIE5A, 1);
-        break;
-#endif
-
-    }
-  }
-}
-
-
-void noTone(uint8_t _pin)
-{
-  int8_t _timer = -1;
-  
-  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
-    if (tone_pins[i] == _pin) {
-      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
-      tone_pins[i] = 255;
-    }
-  }
-  
-  switch (_timer)
-  {
-#if defined(__AVR_ATmega8__)
-    case 1:
-      bitWrite(TIMSK1, OCIE1A, 0);
-      break;
-    case 2:
-      bitWrite(TIMSK2, OCIE2A, 0);
-      break;
-
-#else
-    case 0:
-      TIMSK0 = 0;
-      break;
-    case 1:
-      TIMSK1 = 0;
-      break;
-    case 2:
-      TIMSK2 = 0;
-      break;
-#endif
-
-#if defined(__AVR_ATmega1280__)
-    case 3:
-      TIMSK3 = 0;
-      break;
-    case 4:
-      TIMSK4 = 0;
-      break;
-    case 5:
-      TIMSK5 = 0;
-      break;
-#endif
-  }
-
-  digitalWrite(_pin, 0);
-}
-
-#if 0
-#if !defined(__AVR_ATmega8__)
-ISR(TIMER0_COMPA_vect)
-{
-  if (timer0_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer0_pin_port ^= timer0_pin_mask;
-
-    if (timer0_toggle_count > 0)
-      timer0_toggle_count--;
-  }
-  else
-  {
-    TIMSK0 = 0;   // disable the interrupt
-    *timer0_pin_port &= ~(timer0_pin_mask);  // keep pin low after stop
-  }
-}
-#endif
-
-
-ISR(TIMER1_COMPA_vect)
-{
-  if (timer1_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer1_pin_port ^= timer1_pin_mask;
-
-    if (timer1_toggle_count > 0)
-      timer1_toggle_count--;
-  }
-  else
-  {
-    TIMSK1 = 0;   // disable the interrupt
-    *timer1_pin_port &= ~(timer1_pin_mask);  // keep pin low after stop
-  }
-}
-#endif
-
-
-ISR(TIMER2_COMPA_vect)
-{
-
-  if (timer2_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer2_pin_port ^= timer2_pin_mask;
-
-    if (timer2_toggle_count > 0)
-      timer2_toggle_count--;
-  }
-  else
-  {
-    TIMSK2 = 0;   // disable the interrupt
-    *timer2_pin_port &= ~(timer2_pin_mask);  // keep pin low after stop
-  }
-}
-
-
-
-//#if defined(__AVR_ATmega1280__)
-#if 0
-
-ISR(TIMER3_COMPA_vect)
-{
-  if (timer3_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer3_pin_port ^= timer3_pin_mask;
-
-    if (timer3_toggle_count > 0)
-      timer3_toggle_count--;
-  }
-  else
-  {
-    TIMSK3 = 0;   // disable the interrupt
-    *timer3_pin_port &= ~(timer3_pin_mask);  // keep pin low after stop
-  }
-}
-
-ISR(TIMER4_COMPA_vect)
-{
-  if (timer4_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer4_pin_port ^= timer4_pin_mask;
-
-    if (timer4_toggle_count > 0)
-      timer4_toggle_count--;
-  }
-  else
-  {
-    TIMSK4 = 0;   // disable the interrupt
-    *timer4_pin_port &= ~(timer4_pin_mask);  // keep pin low after stop
-  }
-}
-
-ISR(TIMER5_COMPA_vect)
-{
-  if (timer5_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer5_pin_port ^= timer5_pin_mask;
-
-    if (timer5_toggle_count > 0)
-      timer5_toggle_count--;
-  }
-  else
-  {
-    TIMSK5 = 0;   // disable the interrupt
-    *timer5_pin_port &= ~(timer5_pin_mask);  // keep pin low after stop
-  }
-}
-
-#endif
diff --git a/Marlin/Gen7/cores/arduino/WCharacter.h b/Marlin/Gen7/cores/arduino/WCharacter.h
deleted file mode 100644
index 79733b5..0000000
--- a/Marlin/Gen7/cores/arduino/WCharacter.h
+++ /dev/null
@@ -1,168 +0,0 @@
-/*
- WCharacter.h - Character utility functions for Wiring & Arduino
- Copyright (c) 2010 Hernando Barragan.  All right reserved.
- 
- This library is free software; you can redistribute it and/or
- modify it under the terms of the GNU Lesser General Public
- License as published by the Free Software Foundation; either
- version 2.1 of the License, or (at your option) any later version.
- 
- This library is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- Lesser General Public License for more details.
- 
- You should have received a copy of the GNU Lesser General Public
- License along with this library; if not, write to the Free Software
- Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef Character_h
-#define Character_h
-
-#include <ctype.h>
-
-// WCharacter.h prototypes
-inline boolean isAlphaNumeric(int c) __attribute__((always_inline));
-inline boolean isAlpha(int c) __attribute__((always_inline));
-inline boolean isAscii(int c) __attribute__((always_inline));
-inline boolean isWhitespace(int c) __attribute__((always_inline));
-inline boolean isControl(int c) __attribute__((always_inline));
-inline boolean isDigit(int c) __attribute__((always_inline));
-inline boolean isGraph(int c) __attribute__((always_inline));
-inline boolean isLowerCase(int c) __attribute__((always_inline));
-inline boolean isPrintable(int c) __attribute__((always_inline));
-inline boolean isPunct(int c) __attribute__((always_inline));
-inline boolean isSpace(int c) __attribute__((always_inline));
-inline boolean isUpperCase(int c) __attribute__((always_inline));
-inline boolean isHexadecimalDigit(int c) __attribute__((always_inline));
-inline int toAscii(int c) __attribute__((always_inline));
-inline int toLowerCase(int c) __attribute__((always_inline));
-inline int toUpperCase(int c)__attribute__((always_inline));
-
-
-// Checks for an alphanumeric character. 
-// It is equivalent to (isalpha(c) || isdigit(c)).
-inline boolean isAlphaNumeric(int c) 
-{
-  return ( isalnum(c) == 0 ? false : true);
-}
-
-
-// Checks for an alphabetic character. 
-// It is equivalent to (isupper(c) || islower(c)).
-inline boolean isAlpha(int c)
-{
-  return ( isalpha(c) == 0 ? false : true);
-}
-
-
-// Checks whether c is a 7-bit unsigned char value 
-// that fits into the ASCII character set.
-inline boolean isAscii(int c)
-{
-  return ( isascii (c) == 0 ? false : true);
-}
-
-
-// Checks for a blank character, that is, a space or a tab.
-inline boolean isWhitespace(int c)
-{
-  return ( isblank (c) == 0 ? false : true);
-}
-
-
-// Checks for a control character.
-inline boolean isControl(int c)
-{
-  return ( iscntrl (c) == 0 ? false : true);
-}
-
-
-// Checks for a digit (0 through 9).
-inline boolean isDigit(int c)
-{
-  return ( isdigit (c) == 0 ? false : true);
-}
-
-
-// Checks for any printable character except space.
-inline boolean isGraph(int c)
-{
-  return ( isgraph (c) == 0 ? false : true);
-}
-
-
-// Checks for a lower-case character.
-inline boolean isLowerCase(int c)
-{
-  return (islower (c) == 0 ? false : true);
-}
-
-
-// Checks for any printable character including space.
-inline boolean isPrintable(int c)
-{
-  return ( isprint (c) == 0 ? false : true);
-}
-
-
-// Checks for any printable character which is not a space 
-// or an alphanumeric character.
-inline boolean isPunct(int c)
-{
-  return ( ispunct (c) == 0 ? false : true);
-}
-
-
-// Checks for white-space characters. For the avr-libc library, 
-// these are: space, formfeed ('\f'), newline ('\n'), carriage 
-// return ('\r'), horizontal tab ('\t'), and vertical tab ('\v').
-inline boolean isSpace(int c)
-{
-  return ( isspace (c) == 0 ? false : true);
-}
-
-
-// Checks for an uppercase letter.
-inline boolean isUpperCase(int c)
-{
-  return ( isupper (c) == 0 ? false : true);
-}
-
-
-// Checks for a hexadecimal digits, i.e. one of 0 1 2 3 4 5 6 7 
-// 8 9 a b c d e f A B C D E F.
-inline boolean isHexadecimalDigit(int c)
-{
-  return ( isxdigit (c) == 0 ? false : true);
-}
-
-
-// Converts c to a 7-bit unsigned char value that fits into the 
-// ASCII character set, by clearing the high-order bits.
-inline int toAscii(int c)
-{
-  return toascii (c);
-}
-
-
-// Warning:
-// Many people will be unhappy if you use this function. 
-// This function will convert accented letters into random 
-// characters.
-
-// Converts the letter c to lower case, if possible.
-inline int toLowerCase(int c)
-{
-  return tolower (c);
-}
-
-
-// Converts the letter c to upper case, if possible.
-inline int toUpperCase(int c)
-{
-  return toupper (c);
-}
-
-#endif
\ No newline at end of file
diff --git a/Marlin/Gen7/cores/arduino/WConstants.h b/Marlin/Gen7/cores/arduino/WConstants.h
deleted file mode 100644
index 3e19ac4..0000000
--- a/Marlin/Gen7/cores/arduino/WConstants.h
+++ /dev/null
@@ -1 +0,0 @@
-#include "wiring.h"
diff --git a/Marlin/Gen7/cores/arduino/WInterrupts.c b/Marlin/Gen7/cores/arduino/WInterrupts.c
deleted file mode 100644
index 6f3f0b1..0000000
--- a/Marlin/Gen7/cores/arduino/WInterrupts.c
+++ /dev/null
@@ -1,87 +0,0 @@
-/* -*- mode: jde; c-basic-offset: 2; indent-tabs-mode: nil -*- */
-
-/*
-  Part of the Wiring project - http://wiring.uniandes.edu.co
-
-  Copyright (c) 2004-05 Hernando Barragan
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-  
-  Modified 24 November 2006 by David A. Mellis
-*/
-
-#include <inttypes.h>
-#include <avr/io.h>
-#include <avr/interrupt.h>
-#include <avr/pgmspace.h>
-#include <stdio.h>
-
-#include "WConstants.h"
-#include "wiring_private.h"
-
-volatile static voidFuncPtr intFunc[EXTERNAL_NUM_INTERRUPTS];
-// volatile static voidFuncPtr twiIntFunc;
-
-void attachInterrupt(uint8_t interruptNum, void (*userFunc)(void), int mode)
-{
-	if(interruptNum < EXTERNAL_NUM_INTERRUPTS)
-	{
-		intFunc[interruptNum] = userFunc;
-
-		//clear the config for the change settings
-		EICRA &= ~(B00000011 << (interruptNum * 2));
-
-		//set our mode.
-		EICRA |= (mode << (interruptNum * 2));
-
-		// Enable the interrupt.
-		EIMSK |= (1 << interruptNum);
-	}
-}
-
-void detachInterrupt(uint8_t interruptNum)
-{
-	if(interruptNum < EXTERNAL_NUM_INTERRUPTS)
-	{
-		// Disable the interrupt.
-		EIMSK &= ~(1 << interruptNum);
-
-		intFunc[interruptNum] = 0;
-	}
-}
-
-ISR(INT0_vect) {
-  if(intFunc[EXTERNAL_INT_0])
-    intFunc[EXTERNAL_INT_0]();
-}
-
-ISR(INT1_vect) {
-  if(intFunc[EXTERNAL_INT_1])
-    intFunc[EXTERNAL_INT_1]();
-}
-
-ISR(INT2_vect) {
-  if(intFunc[EXTERNAL_INT_2])
-    intFunc[EXTERNAL_INT_2]();
-}
-
-/*
-SIGNAL(SIG_2WIRE_SERIAL) {
-  if(twiIntFunc)
-    twiIntFunc();
-}
-*/
-
diff --git a/Marlin/Gen7/cores/arduino/WMath.cpp b/Marlin/Gen7/cores/arduino/WMath.cpp
deleted file mode 100644
index 7a230f5..0000000
--- a/Marlin/Gen7/cores/arduino/WMath.cpp
+++ /dev/null
@@ -1,60 +0,0 @@
-/* -*- mode: jde; c-basic-offset: 2; indent-tabs-mode: nil -*- */
-
-/*
-  Part of the Wiring project - http://wiring.org.co
-  Copyright (c) 2004-06 Hernando Barragan
-  Modified 13 August 2006, David A. Mellis for Arduino - http://www.arduino.cc/
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-  
-  $Id$
-*/
-
-extern "C" {
-  #include "stdlib.h"
-}
-
-void randomSeed(unsigned int seed)
-{
-  if (seed != 0){
-    srandom(seed);
-  }
-}
-
-long random(long howbig)
-{
-  if (howbig == 0) {
-    return 0;
-  }
-  return random() % howbig;
-}
-
-long random(long howsmall, long howbig)
-{
-  if (howsmall >= howbig) {
-    return howsmall;
-  }
-  long diff = howbig - howsmall;
-  return random(diff) + howsmall;
-}
-
-long map(long x, long in_min, long in_max, long out_min, long out_max)
-{
-  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
-}
-
-unsigned int makeWord(unsigned int w) { return w; }
-unsigned int makeWord(unsigned char h, unsigned char l) { return (h << 8) | l; }
diff --git a/Marlin/Gen7/cores/arduino/WProgram.h b/Marlin/Gen7/cores/arduino/WProgram.h
deleted file mode 100644
index 2c7ed16..0000000
--- a/Marlin/Gen7/cores/arduino/WProgram.h
+++ /dev/null
@@ -1,34 +0,0 @@
-#ifndef WProgram_h
-#define WProgram_h
-
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-
-#include <avr/interrupt.h>
-
-#include "wiring.h"
-
-#ifdef __cplusplus
-#include "WCharacter.h"
-#include "WString.h"
-#include "HardwareSerial.h"
-
-uint16_t makeWord(uint16_t w);
-uint16_t makeWord(byte h, byte l);
-
-#define word(...) makeWord(__VA_ARGS__)
-
-unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout = 1000000L);
-
-void tone(uint8_t _pin, unsigned int frequency, unsigned long duration = 0);
-void noTone(uint8_t _pin);
-
-// WMath prototypes
-long random(long);
-long random(long, long);
-void randomSeed(unsigned int);
-long map(long, long, long, long, long);
-#endif
-
-#endif
diff --git a/Marlin/Gen7/cores/arduino/WString.cpp b/Marlin/Gen7/cores/arduino/WString.cpp
deleted file mode 100644
index db5a441..0000000
--- a/Marlin/Gen7/cores/arduino/WString.cpp
+++ /dev/null
@@ -1,443 +0,0 @@
-/*
-  WString.cpp - String library for Wiring & Arduino
-  Copyright (c) 2009-10 Hernando Barragan.  All rights reserved.
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#include <stdlib.h>
-#include "WProgram.h"
-#include "WString.h"
-
-
-String::String( const char *value )
-{
-  if ( value == NULL )
-    value = "";
-  getBuffer( _length = strlen( value ) );
-  if ( _buffer != NULL )
-    strcpy( _buffer, value );
-}
-
-String::String( const String &value )
-{
-  getBuffer( _length = value._length );
-  if ( _buffer != NULL )
-    strcpy( _buffer, value._buffer );
-}
-
-String::String( const char value )
-{
-  _length = 1;
-  getBuffer(1);
-  if ( _buffer != NULL ) {
-    _buffer[0] = value;
-    _buffer[1] = 0;
-  }
-}
-
-String::String( const unsigned char value )
-{
-  _length = 1;
-  getBuffer(1);
-  if ( _buffer != NULL) {
-    _buffer[0] = value;
-    _buffer[1] = 0;
-  }
-}
-
-String::String( const int value, const int base )
-{
-  char buf[33];   
-  itoa((signed long)value, buf, base);
-  getBuffer( _length = strlen(buf) );
-  if ( _buffer != NULL )
-    strcpy( _buffer, buf );
-}
-
-String::String( const unsigned int value, const int base )
-{
-  char buf[33];   
-  ultoa((unsigned long)value, buf, base);
-  getBuffer( _length = strlen(buf) );
-  if ( _buffer != NULL )
-    strcpy( _buffer, buf );
-}
-
-String::String( const long value, const int base )
-{
-  char buf[33];   
-  ltoa(value, buf, base);
-  getBuffer( _length = strlen(buf) );
-  if ( _buffer != NULL )
-    strcpy( _buffer, buf );
-}
-
-String::String( const unsigned long value, const int base )
-{
-  char buf[33];   
-  ultoa(value, buf, 10);
-  getBuffer( _length = strlen(buf) );
-  if ( _buffer != NULL )
-    strcpy( _buffer, buf );
-}
-
-char String::charAt( unsigned int loc ) const
-{
-  return operator[]( loc );
-}
-
-void String::setCharAt( unsigned int loc, const char aChar ) 
-{
-  if(_buffer == NULL) return;
-  if(_length > loc) {
-    _buffer[loc] = aChar;
-  }
-}
-
-int String::compareTo( const String &s2 ) const
-{
-  return strcmp( _buffer, s2._buffer );
-}
-
-const String & String::concat( const String &s2 )
-{
-  return (*this) += s2;
-}
-
-const String & String::operator=( const String &rhs )
-{
-  if ( this == &rhs )
-    return *this;
-
-  if ( rhs._length > _length )
-  {
-    free(_buffer);
-    getBuffer( rhs._length );
-  }
-  
-  if ( _buffer != NULL ) {
-    _length = rhs._length;
-    strcpy( _buffer, rhs._buffer );
-  }
-  return *this;
-}
-
-//const String & String::operator+=( const char aChar )
-//{
-//  if ( _length == _capacity )
-//    doubleBuffer();
-//
-//  _buffer[ _length++ ] = aChar;
-//  _buffer[ _length ] = '\0';
-//  return *this;
-//}
-
-const String & String::operator+=( const String &other )
-{
-  _length += other._length;
-  if ( _length > _capacity )
-  {
-    char *temp = (char *)realloc(_buffer, _length + 1);
-    if ( temp != NULL ) {
-      _buffer = temp;
-      _capacity = _length;
-    } else {
-      _length -= other._length;
-      return *this;
-    }
-  }
-  strcat( _buffer, other._buffer );
-  return *this;
-}
-
-
-int String::operator==( const String &rhs ) const
-{
-  return ( _length == rhs._length && strcmp( _buffer, rhs._buffer ) == 0 );
-}
-
-int String::operator!=( const String &rhs ) const
-{
-  return ( _length != rhs.length() || strcmp( _buffer, rhs._buffer ) != 0 );
-}
-
-int String::operator<( const String &rhs ) const
-{
-  return strcmp( _buffer, rhs._buffer ) < 0;
-}
-
-int String::operator>( const String &rhs ) const
-{
-  return strcmp( _buffer, rhs._buffer ) > 0;
-}
-
-int String::operator<=( const String &rhs ) const
-{
-  return strcmp( _buffer, rhs._buffer ) <= 0;
-}
-
-int String::operator>=( const String & rhs ) const
-{
-  return strcmp( _buffer, rhs._buffer ) >= 0;
-}
-
-char & String::operator[]( unsigned int index )
-{
-  static char dummy_writable_char;
-  if (index >= _length || !_buffer) {
-    dummy_writable_char = 0;
-    return dummy_writable_char;
-  }
-  return _buffer[ index ];
-}
-
-char String::operator[]( unsigned int index ) const
-{
-  // need to check for valid index, to do later
-  return _buffer[ index ];
-}
-
-boolean String::endsWith( const String &s2 ) const
-{
-  if ( _length < s2._length )
-    return 0;
-
-  return strcmp( &_buffer[ _length - s2._length], s2._buffer ) == 0;
-}
-
-boolean String::equals( const String &s2 ) const
-{
-  return ( _length == s2._length && strcmp( _buffer,s2._buffer ) == 0 );
-}
-
-boolean String::equalsIgnoreCase( const String &s2 ) const
-{
-  if ( this == &s2 )
-    return true; //1;
-  else if ( _length != s2._length )
-    return false; //0;
-
-  return strcmp(toLowerCase()._buffer, s2.toLowerCase()._buffer) == 0;
-}
-
-String String::replace( char findChar, char replaceChar )
-{
-  if ( _buffer == NULL ) return *this;
-  String theReturn = _buffer;
-  char* temp = theReturn._buffer;
-  while( (temp = strchr( temp, findChar )) != 0 )
-    *temp = replaceChar;
-
-  return theReturn;
-}
-
-String String::replace( const String& match, const String& replace )
-{
-  if ( _buffer == NULL ) return *this;
-  String temp = _buffer, newString;
-
-  int loc;
-  while ( (loc = temp.indexOf( match )) != -1 )
-  {
-    newString += temp.substring( 0, loc );
-    newString += replace;
-    temp = temp.substring( loc + match._length );
-  }
-  newString += temp;  
-  return newString;
-}
-
-int String::indexOf( char temp ) const
-{
-  return indexOf( temp, 0 );
-}
-
-int String::indexOf( char ch, unsigned int fromIndex ) const
-{
-  if ( fromIndex >= _length )
-    return -1;
-
-  const char* temp = strchr( &_buffer[fromIndex], ch );
-  if ( temp == NULL )
-    return -1;
-
-  return temp - _buffer;
-}
-
-int String::indexOf( const String &s2 ) const
-{
-  return indexOf( s2, 0 );
-}
-
-int String::indexOf( const String &s2, unsigned int fromIndex ) const
-{
-  if ( fromIndex >= _length )
-    return -1;
-
-  const char *theFind = strstr( &_buffer[ fromIndex ], s2._buffer );
-
-  if ( theFind == NULL )
-    return -1;
-
-  return theFind - _buffer; // pointer subtraction
-}
-
-int String::lastIndexOf( char theChar ) const
-{
-  return lastIndexOf( theChar, _length - 1 );
-}
-
-int String::lastIndexOf( char ch, unsigned int fromIndex ) const
-{
-  if ( fromIndex >= _length )
-    return -1;
-
-  char tempchar = _buffer[fromIndex + 1];
-  _buffer[fromIndex + 1] = '\0';
-  char* temp = strrchr( _buffer, ch );
-  _buffer[fromIndex + 1] = tempchar;
-
-  if ( temp == NULL )
-    return -1;
-
-  return temp - _buffer;
-}
-
-int String::lastIndexOf( const String &s2 ) const
-{
-  return lastIndexOf( s2, _length - s2._length );
-}
-
-int String::lastIndexOf( const String &s2, unsigned int fromIndex ) const
-{
-  // check for empty strings
-  if ( s2._length == 0 || s2._length - 1 > fromIndex || fromIndex >= _length )
-    return -1;
-
-  // matching first character
-  char temp = s2[ 0 ];
-
-  for ( int i = fromIndex; i >= 0; i-- )
-  {
-    if ( _buffer[ i ] == temp && (*this).substring( i, i + s2._length ).equals( s2 ) )
-    return i;
-  }
-  return -1;
-}
-
-boolean String::startsWith( const String &s2 ) const
-{
-  if ( _length < s2._length )
-    return 0;
-
-  return startsWith( s2, 0 );
-}
-
-boolean String::startsWith( const String &s2, unsigned int offset ) const
-{
-  if ( offset > _length - s2._length )
-    return 0;
-
-  return strncmp( &_buffer[offset], s2._buffer, s2._length ) == 0;
-}
-
-String String::substring( unsigned int left ) const
-{
-  return substring( left, _length );
-}
-
-String String::substring( unsigned int left, unsigned int right ) const
-{
-  if ( left > right )
-  {
-    int temp = right;
-    right = left;
-    left = temp;
-  }
-
-  if ( right > _length )
-  {
-    right = _length;
-  } 
-
-  char temp = _buffer[ right ];  // save the replaced character
-  _buffer[ right ] = '\0';	
-  String outPut = ( _buffer + left );  // pointer arithmetic
-  _buffer[ right ] = temp;  //restore character
-  return outPut;
-}
-
-String String::toLowerCase() const
-{
-  String temp = _buffer;
-
-  for ( unsigned int i = 0; i < _length; i++ )
-    temp._buffer[ i ] = (char)tolower( temp._buffer[ i ] );
-  return temp;
-}
-
-String String::toUpperCase() const
-{
-  String temp = _buffer;
-
-  for ( unsigned int i = 0; i < _length; i++ )
-    temp._buffer[ i ] = (char)toupper( temp._buffer[ i ] );
-  return temp;
-}
-
-String String::trim() const
-{
-  if ( _buffer == NULL ) return *this;
-  String temp = _buffer;
-  unsigned int i,j;
-
-  for ( i = 0; i < _length; i++ )
-  {
-    if ( !isspace(_buffer[i]) )
-      break;
-  }
-
-  for ( j = temp._length - 1; j > i; j-- )
-  {
-    if ( !isspace(_buffer[j]) )
-      break;
-  }
-
-  return temp.substring( i, j + 1);
-}
-
-void String::getBytes(unsigned char *buf, unsigned int bufsize)
-{
-  if (!bufsize || !buf) return;
-  unsigned int len = bufsize - 1;
-  if (len > _length) len = _length;
-  strncpy((char *)buf, _buffer, len);
-  buf[len] = 0;
-}
-
-void String::toCharArray(char *buf, unsigned int bufsize)
-{
-  if (!bufsize || !buf) return;
-  unsigned int len = bufsize - 1;
-  if (len > _length) len = _length;
-  strncpy(buf, _buffer, len);
-  buf[len] = 0;
-}
-
-
-long String::toInt() {
-  return atol(_buffer);
-}
diff --git a/Marlin/Gen7/cores/arduino/WString.h b/Marlin/Gen7/cores/arduino/WString.h
deleted file mode 100644
index cadddb9..0000000
--- a/Marlin/Gen7/cores/arduino/WString.h
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
-  WString.h - String library for Wiring & Arduino
-  Copyright (c) 2009-10 Hernando Barragan.  All right reserved.
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef String_h
-#define String_h
-
-//#include "WProgram.h"
-#include <stdlib.h>
-#include <string.h>
-#include <ctype.h>
-
-class String
-{
-  public:
-    // constructors
-    String( const char *value = "" );
-    String( const String &value );
-    String( const char );
-    String( const unsigned char );
-    String( const int, const int base=10);
-    String( const unsigned int, const int base=10 );
-    String( const long, const int base=10 );
-    String( const unsigned long, const int base=10 );
-    ~String() { free(_buffer); _length = _capacity = 0;}     //added _length = _capacity = 0;
-
-    // operators
-    const String & operator = ( const String &rhs );
-    const String & operator +=( const String &rhs );
-    //const String & operator +=( const char );
-    int operator ==( const String &rhs ) const;
-    int	operator !=( const String &rhs ) const;
-    int	operator < ( const String &rhs ) const;
-    int	operator > ( const String &rhs ) const;
-    int	operator <=( const String &rhs ) const;
-    int	operator >=( const String &rhs ) const;
-    char operator []( unsigned int index ) const;
-    char& operator []( unsigned int index );
-    //operator const char *() const { return _buffer; }
-    
-    // general methods
-    char charAt( unsigned int index ) const;
-    int	compareTo( const String &anotherString ) const;
-    unsigned char endsWith( const String &suffix ) const;
-    unsigned char equals( const String &anObject ) const;
-    unsigned char equalsIgnoreCase( const String &anotherString ) const;
-    int	indexOf( char ch ) const;
-    int	indexOf( char ch, unsigned int fromIndex ) const;
-    int	indexOf( const String &str ) const;
-    int	indexOf( const String &str, unsigned int fromIndex ) const;
-    int	lastIndexOf( char ch ) const;
-    int	lastIndexOf( char ch, unsigned int fromIndex ) const;
-    int	lastIndexOf( const String &str ) const;
-    int	lastIndexOf( const String &str, unsigned int fromIndex ) const;
-    const unsigned int length( ) const { return _length; }
-    void setCharAt(unsigned int index, const char ch);
-    unsigned char startsWith( const String &prefix ) const;
-    unsigned char startsWith( const String &prefix, unsigned int toffset ) const;
-    String substring( unsigned int beginIndex ) const;
-    String substring( unsigned int beginIndex, unsigned int endIndex ) const;
-    String toLowerCase( ) const;
-    String toUpperCase( ) const;
-    String trim( ) const;
-    void getBytes(unsigned char *buf, unsigned int bufsize);
-    void toCharArray(char *buf, unsigned int bufsize);
-    long toInt( );
-    const String& concat( const String &str );
-    String replace( char oldChar, char newChar );
-    String replace( const String& match, const String& replace );
-    friend String operator + ( String lhs, const String &rhs );
-
-  protected:
-    char *_buffer;	     // the actual char array
-    unsigned int _capacity;  // the array length minus one (for the '\0')
-    unsigned int _length;    // the String length (not counting the '\0')
-
-    void getBuffer(unsigned int maxStrLen);
-
-  private:
-
-};
-
-// allocate buffer space
-inline void String::getBuffer(unsigned int maxStrLen)
-{
-  _capacity = maxStrLen;
-  _buffer = (char *) malloc(_capacity + 1);
-  if (_buffer == NULL) _length = _capacity = 0;
-}
-
-inline String operator+( String lhs, const String &rhs )
-{
-  return lhs += rhs;
-}
-
-
-#endif
diff --git a/Marlin/Gen7/cores/arduino/binary.h b/Marlin/Gen7/cores/arduino/binary.h
deleted file mode 100644
index af14980..0000000
--- a/Marlin/Gen7/cores/arduino/binary.h
+++ /dev/null
@@ -1,515 +0,0 @@
-#ifndef Binary_h
-#define Binary_h
-
-#define B0 0
-#define B00 0
-#define B000 0
-#define B0000 0
-#define B00000 0
-#define B000000 0
-#define B0000000 0
-#define B00000000 0
-#define B1 1
-#define B01 1
-#define B001 1
-#define B0001 1
-#define B00001 1
-#define B000001 1
-#define B0000001 1
-#define B00000001 1
-#define B10 2
-#define B010 2
-#define B0010 2
-#define B00010 2
-#define B000010 2
-#define B0000010 2
-#define B00000010 2
-#define B11 3
-#define B011 3
-#define B0011 3
-#define B00011 3
-#define B000011 3
-#define B0000011 3
-#define B00000011 3
-#define B100 4
-#define B0100 4
-#define B00100 4
-#define B000100 4
-#define B0000100 4
-#define B00000100 4
-#define B101 5
-#define B0101 5
-#define B00101 5
-#define B000101 5
-#define B0000101 5
-#define B00000101 5
-#define B110 6
-#define B0110 6
-#define B00110 6
-#define B000110 6
-#define B0000110 6
-#define B00000110 6
-#define B111 7
-#define B0111 7
-#define B00111 7
-#define B000111 7
-#define B0000111 7
-#define B00000111 7
-#define B1000 8
-#define B01000 8
-#define B001000 8
-#define B0001000 8
-#define B00001000 8
-#define B1001 9
-#define B01001 9
-#define B001001 9
-#define B0001001 9
-#define B00001001 9
-#define B1010 10
-#define B01010 10
-#define B001010 10
-#define B0001010 10
-#define B00001010 10
-#define B1011 11
-#define B01011 11
-#define B001011 11
-#define B0001011 11
-#define B00001011 11
-#define B1100 12
-#define B01100 12
-#define B001100 12
-#define B0001100 12
-#define B00001100 12
-#define B1101 13
-#define B01101 13
-#define B001101 13
-#define B0001101 13
-#define B00001101 13
-#define B1110 14
-#define B01110 14
-#define B001110 14
-#define B0001110 14
-#define B00001110 14
-#define B1111 15
-#define B01111 15
-#define B001111 15
-#define B0001111 15
-#define B00001111 15
-#define B10000 16
-#define B010000 16
-#define B0010000 16
-#define B00010000 16
-#define B10001 17
-#define B010001 17
-#define B0010001 17
-#define B00010001 17
-#define B10010 18
-#define B010010 18
-#define B0010010 18
-#define B00010010 18
-#define B10011 19
-#define B010011 19
-#define B0010011 19
-#define B00010011 19
-#define B10100 20
-#define B010100 20
-#define B0010100 20
-#define B00010100 20
-#define B10101 21
-#define B010101 21
-#define B0010101 21
-#define B00010101 21
-#define B10110 22
-#define B010110 22
-#define B0010110 22
-#define B00010110 22
-#define B10111 23
-#define B010111 23
-#define B0010111 23
-#define B00010111 23
-#define B11000 24
-#define B011000 24
-#define B0011000 24
-#define B00011000 24
-#define B11001 25
-#define B011001 25
-#define B0011001 25
-#define B00011001 25
-#define B11010 26
-#define B011010 26
-#define B0011010 26
-#define B00011010 26
-#define B11011 27
-#define B011011 27
-#define B0011011 27
-#define B00011011 27
-#define B11100 28
-#define B011100 28
-#define B0011100 28
-#define B00011100 28
-#define B11101 29
-#define B011101 29
-#define B0011101 29
-#define B00011101 29
-#define B11110 30
-#define B011110 30
-#define B0011110 30
-#define B00011110 30
-#define B11111 31
-#define B011111 31
-#define B0011111 31
-#define B00011111 31
-#define B100000 32
-#define B0100000 32
-#define B00100000 32
-#define B100001 33
-#define B0100001 33
-#define B00100001 33
-#define B100010 34
-#define B0100010 34
-#define B00100010 34
-#define B100011 35
-#define B0100011 35
-#define B00100011 35
-#define B100100 36
-#define B0100100 36
-#define B00100100 36
-#define B100101 37
-#define B0100101 37
-#define B00100101 37
-#define B100110 38
-#define B0100110 38
-#define B00100110 38
-#define B100111 39
-#define B0100111 39
-#define B00100111 39
-#define B101000 40
-#define B0101000 40
-#define B00101000 40
-#define B101001 41
-#define B0101001 41
-#define B00101001 41
-#define B101010 42
-#define B0101010 42
-#define B00101010 42
-#define B101011 43
-#define B0101011 43
-#define B00101011 43
-#define B101100 44
-#define B0101100 44
-#define B00101100 44
-#define B101101 45
-#define B0101101 45
-#define B00101101 45
-#define B101110 46
-#define B0101110 46
-#define B00101110 46
-#define B101111 47
-#define B0101111 47
-#define B00101111 47
-#define B110000 48
-#define B0110000 48
-#define B00110000 48
-#define B110001 49
-#define B0110001 49
-#define B00110001 49
-#define B110010 50
-#define B0110010 50
-#define B00110010 50
-#define B110011 51
-#define B0110011 51
-#define B00110011 51
-#define B110100 52
-#define B0110100 52
-#define B00110100 52
-#define B110101 53
-#define B0110101 53
-#define B00110101 53
-#define B110110 54
-#define B0110110 54
-#define B00110110 54
-#define B110111 55
-#define B0110111 55
-#define B00110111 55
-#define B111000 56
-#define B0111000 56
-#define B00111000 56
-#define B111001 57
-#define B0111001 57
-#define B00111001 57
-#define B111010 58
-#define B0111010 58
-#define B00111010 58
-#define B111011 59
-#define B0111011 59
-#define B00111011 59
-#define B111100 60
-#define B0111100 60
-#define B00111100 60
-#define B111101 61
-#define B0111101 61
-#define B00111101 61
-#define B111110 62
-#define B0111110 62
-#define B00111110 62
-#define B111111 63
-#define B0111111 63
-#define B00111111 63
-#define B1000000 64
-#define B01000000 64
-#define B1000001 65
-#define B01000001 65
-#define B1000010 66
-#define B01000010 66
-#define B1000011 67
-#define B01000011 67
-#define B1000100 68
-#define B01000100 68
-#define B1000101 69
-#define B01000101 69
-#define B1000110 70
-#define B01000110 70
-#define B1000111 71
-#define B01000111 71
-#define B1001000 72
-#define B01001000 72
-#define B1001001 73
-#define B01001001 73
-#define B1001010 74
-#define B01001010 74
-#define B1001011 75
-#define B01001011 75
-#define B1001100 76
-#define B01001100 76
-#define B1001101 77
-#define B01001101 77
-#define B1001110 78
-#define B01001110 78
-#define B1001111 79
-#define B01001111 79
-#define B1010000 80
-#define B01010000 80
-#define B1010001 81
-#define B01010001 81
-#define B1010010 82
-#define B01010010 82
-#define B1010011 83
-#define B01010011 83
-#define B1010100 84
-#define B01010100 84
-#define B1010101 85
-#define B01010101 85
-#define B1010110 86
-#define B01010110 86
-#define B1010111 87
-#define B01010111 87
-#define B1011000 88
-#define B01011000 88
-#define B1011001 89
-#define B01011001 89
-#define B1011010 90
-#define B01011010 90
-#define B1011011 91
-#define B01011011 91
-#define B1011100 92
-#define B01011100 92
-#define B1011101 93
-#define B01011101 93
-#define B1011110 94
-#define B01011110 94
-#define B1011111 95
-#define B01011111 95
-#define B1100000 96
-#define B01100000 96
-#define B1100001 97
-#define B01100001 97
-#define B1100010 98
-#define B01100010 98
-#define B1100011 99
-#define B01100011 99
-#define B1100100 100
-#define B01100100 100
-#define B1100101 101
-#define B01100101 101
-#define B1100110 102
-#define B01100110 102
-#define B1100111 103
-#define B01100111 103
-#define B1101000 104
-#define B01101000 104
-#define B1101001 105
-#define B01101001 105
-#define B1101010 106
-#define B01101010 106
-#define B1101011 107
-#define B01101011 107
-#define B1101100 108
-#define B01101100 108
-#define B1101101 109
-#define B01101101 109
-#define B1101110 110
-#define B01101110 110
-#define B1101111 111
-#define B01101111 111
-#define B1110000 112
-#define B01110000 112
-#define B1110001 113
-#define B01110001 113
-#define B1110010 114
-#define B01110010 114
-#define B1110011 115
-#define B01110011 115
-#define B1110100 116
-#define B01110100 116
-#define B1110101 117
-#define B01110101 117
-#define B1110110 118
-#define B01110110 118
-#define B1110111 119
-#define B01110111 119
-#define B1111000 120
-#define B01111000 120
-#define B1111001 121
-#define B01111001 121
-#define B1111010 122
-#define B01111010 122
-#define B1111011 123
-#define B01111011 123
-#define B1111100 124
-#define B01111100 124
-#define B1111101 125
-#define B01111101 125
-#define B1111110 126
-#define B01111110 126
-#define B1111111 127
-#define B01111111 127
-#define B10000000 128
-#define B10000001 129
-#define B10000010 130
-#define B10000011 131
-#define B10000100 132
-#define B10000101 133
-#define B10000110 134
-#define B10000111 135
-#define B10001000 136
-#define B10001001 137
-#define B10001010 138
-#define B10001011 139
-#define B10001100 140
-#define B10001101 141
-#define B10001110 142
-#define B10001111 143
-#define B10010000 144
-#define B10010001 145
-#define B10010010 146
-#define B10010011 147
-#define B10010100 148
-#define B10010101 149
-#define B10010110 150
-#define B10010111 151
-#define B10011000 152
-#define B10011001 153
-#define B10011010 154
-#define B10011011 155
-#define B10011100 156
-#define B10011101 157
-#define B10011110 158
-#define B10011111 159
-#define B10100000 160
-#define B10100001 161
-#define B10100010 162
-#define B10100011 163
-#define B10100100 164
-#define B10100101 165
-#define B10100110 166
-#define B10100111 167
-#define B10101000 168
-#define B10101001 169
-#define B10101010 170
-#define B10101011 171
-#define B10101100 172
-#define B10101101 173
-#define B10101110 174
-#define B10101111 175
-#define B10110000 176
-#define B10110001 177
-#define B10110010 178
-#define B10110011 179
-#define B10110100 180
-#define B10110101 181
-#define B10110110 182
-#define B10110111 183
-#define B10111000 184
-#define B10111001 185
-#define B10111010 186
-#define B10111011 187
-#define B10111100 188
-#define B10111101 189
-#define B10111110 190
-#define B10111111 191
-#define B11000000 192
-#define B11000001 193
-#define B11000010 194
-#define B11000011 195
-#define B11000100 196
-#define B11000101 197
-#define B11000110 198
-#define B11000111 199
-#define B11001000 200
-#define B11001001 201
-#define B11001010 202
-#define B11001011 203
-#define B11001100 204
-#define B11001101 205
-#define B11001110 206
-#define B11001111 207
-#define B11010000 208
-#define B11010001 209
-#define B11010010 210
-#define B11010011 211
-#define B11010100 212
-#define B11010101 213
-#define B11010110 214
-#define B11010111 215
-#define B11011000 216
-#define B11011001 217
-#define B11011010 218
-#define B11011011 219
-#define B11011100 220
-#define B11011101 221
-#define B11011110 222
-#define B11011111 223
-#define B11100000 224
-#define B11100001 225
-#define B11100010 226
-#define B11100011 227
-#define B11100100 228
-#define B11100101 229
-#define B11100110 230
-#define B11100111 231
-#define B11101000 232
-#define B11101001 233
-#define B11101010 234
-#define B11101011 235
-#define B11101100 236
-#define B11101101 237
-#define B11101110 238
-#define B11101111 239
-#define B11110000 240
-#define B11110001 241
-#define B11110010 242
-#define B11110011 243
-#define B11110100 244
-#define B11110101 245
-#define B11110110 246
-#define B11110111 247
-#define B11111000 248
-#define B11111001 249
-#define B11111010 250
-#define B11111011 251
-#define B11111100 252
-#define B11111101 253
-#define B11111110 254
-#define B11111111 255
-
-#endif
diff --git a/Marlin/Gen7/cores/arduino/main.cpp b/Marlin/Gen7/cores/arduino/main.cpp
deleted file mode 100644
index cc6e81d..0000000
--- a/Marlin/Gen7/cores/arduino/main.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-#include <WProgram.h>
-
-int main(void)
-{
-	init();
-
-	setup();
-    
-	for (;;)
-		loop();
-        
-	return 0;
-}
-
diff --git a/Marlin/Gen7/cores/arduino/main.cxx b/Marlin/Gen7/cores/arduino/main.cxx
deleted file mode 100644
index 52351e4..0000000
--- a/Marlin/Gen7/cores/arduino/main.cxx
+++ /dev/null
@@ -1,12 +0,0 @@
-int main(void)
-{
-	init();
-
-	setup();
-    
-	for (;;)
-		loop();
-        
-	return 0;
-}
-
diff --git a/Marlin/Gen7/cores/arduino/pins_arduino.c b/Marlin/Gen7/cores/arduino/pins_arduino.c
deleted file mode 100644
index c67ab73..0000000
--- a/Marlin/Gen7/cores/arduino/pins_arduino.c
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
-  pins_arduino.c - pin definitions for the Arduino board
-  Part of Arduino / Wiring Lite
-
-  Copyright (c) 2005 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: pins_arduino.c 254 2007-04-20 23:17:38Z mellis $
-*/
-
-#include <avr/io.h>
-#include "wiring_private.h"
-#include "pins_arduino.h"
-
-// On the Sanguino board, digital pins are also used
-// for the analog output (software PWM).  Analog input
-// pins are a separate set.
-
-// ATMEL ATMEGA644P / SANGUINO
-//
-//                   +---\/---+
-//  INT0 (D 0) PB0  1|        |40  PA0 (AI 0 / D31)
-//  INT1 (D 1) PB1  2|        |39  PA1 (AI 1 / D30)
-//  INT2 (D 2) PB2  3|        |38  PA2 (AI 2 / D29)
-//   PWM (D 3) PB3  4|        |37  PA3 (AI 3 / D28)
-//   PWM (D 4) PB4  5|        |36  PA4 (AI 4 / D27)
-//  MOSI (D 5) PB5  6|        |35  PA5 (AI 5 / D26)
-//  MISO (D 6) PB6  7|        |34  PA6 (AI 6 / D25)
-//   SCK (D 7) PB7  8|        |33  PA7 (AI 7 / D24)
-//             RST  9|        |32  AREF
-//             VCC 10|        |31  GND 
-//             GND 11|        |30  AVCC
-//           XTAL2 12|        |29  PC7 (D 23)
-//           XTAL1 13|        |28  PC6 (D 22)
-//  RX0 (D 8)  PD0 14|        |27  PC5 (D 21) TDI
-//  TX0 (D 9)  PD1 15|        |26  PC4 (D 20) TDO
-//  RX1 (D 10) PD2 16|        |25  PC3 (D 19) TMS
-//  TX1 (D 11) PD3 17|        |24  PC2 (D 18) TCK
-//  PWM (D 12) PD4 18|        |23  PC1 (D 17) SDA
-//  PWM (D 13) PD5 19|        |22  PC0 (D 16) SCL
-//  PWM (D 14) PD6 20|        |21  PD7 (D 15) PWM
-//                   +--------+
-//
-
-#define PA 1
-#define PB 2
-#define PC 3
-#define PD 4
-
-// these arrays map port names (e.g. port B) to the
-// appropriate addresses for various functions (e.g. reading
-// and writing)
-const uint8_t PROGMEM port_to_mode_PGM[] =
-{
-	NOT_A_PORT,
-        (uint8_t) &DDRA,
-	(uint8_t) &DDRB,
-	(uint8_t) &DDRC,
-	(uint8_t) &DDRD,
-};
-
-const uint8_t PROGMEM port_to_output_PGM[] =
-{
-	NOT_A_PORT,
-	(uint8_t) &PORTA,
-	(uint8_t) &PORTB,
-	(uint8_t) &PORTC,
-	(uint8_t) &PORTD,
-};
-
-const uint8_t PROGMEM port_to_input_PGM[] =
-{
-	NOT_A_PORT,
-	(uint8_t) &PINA,
-	(uint8_t) &PINB,
-	(uint8_t) &PINC,
-	(uint8_t) &PIND,
-};
-
-const uint8_t PROGMEM digital_pin_to_port_PGM[] =
-{
-	PB, /* 0 */
-	PB,
-	PB,
-	PB,
-	PB,
-	PB,
-	PB,
-	PB,
-	PD, /* 8 */
-	PD,
-	PD,
-	PD,
-	PD,
-	PD,
-	PD,
-	PD,
-	PC, /* 16 */
-	PC,
-	PC,
-	PC,
-	PC,
-	PC,
-   	PC,
-	PC,
-	PA, /* 24 */
-	PA,
-	PA,
-	PA,
-	PA,
-	PA,
-	PA,
-	PA  /* 31 */
-};
-
-const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[] =
-{
-	_BV(0), /* 0, port B */
-	_BV(1),
-	_BV(2),
-	_BV(3),
-	_BV(4),
-	_BV(5),
-	_BV(6),
-	_BV(7),
-	_BV(0), /* 8, port D */
-	_BV(1),
-	_BV(2),
-	_BV(3),
-	_BV(4),
-	_BV(5),
-	_BV(6),
-	_BV(7),
-	_BV(0), /* 16, port C */
-	_BV(1),
-	_BV(2),
-	_BV(3),
-	_BV(4),
-	_BV(5),
-	_BV(6),
-	_BV(7),
-	_BV(7), /* 24, port A */
-	_BV(6),
-	_BV(5),
-	_BV(4),
-	_BV(3),
-	_BV(2),
-	_BV(1),
-	_BV(0)
-};
-
-const uint8_t PROGMEM digital_pin_to_timer_PGM[] =
-{
-	NOT_ON_TIMER, 	/* 0  - PB0 */
-	NOT_ON_TIMER, 	/* 1  - PB1 */
-	NOT_ON_TIMER, 	/* 2  - PB2 */
-	TIMER0A,     	/* 3  - PB3 */
-	TIMER0B, 		/* 4  - PB4 */
-	NOT_ON_TIMER, 	/* 5  - PB5 */
-	NOT_ON_TIMER, 	/* 6  - PB6 */
-	NOT_ON_TIMER,	/* 7  - PB7 */
-	NOT_ON_TIMER, 	/* 8  - PD0 */
-	NOT_ON_TIMER, 	/* 9  - PD1 */
-	NOT_ON_TIMER, 	/* 10 - PD2 */
-	NOT_ON_TIMER, 	/* 11 - PD3 */
-	TIMER1B,     	/* 12 - PD4 */
-	TIMER1A,     	/* 13 - PD5 */
-	TIMER2B,     	/* 14 - PD6 */
-	TIMER2A,     	/* 15 - PD7 */
-	NOT_ON_TIMER, 	/* 16 - PC0 */
-	NOT_ON_TIMER,   /* 17 - PC1 */
-	NOT_ON_TIMER,   /* 18 - PC2 */
-	NOT_ON_TIMER,   /* 19 - PC3 */
-	NOT_ON_TIMER,   /* 20 - PC4 */
-	NOT_ON_TIMER,   /* 21 - PC5 */
-	NOT_ON_TIMER,   /* 22 - PC6 */
-	NOT_ON_TIMER,   /* 23 - PC7 */
-	NOT_ON_TIMER,   /* 24 - PA0 */
-	NOT_ON_TIMER,   /* 25 - PA1 */
-	NOT_ON_TIMER,   /* 26 - PA2 */
-	NOT_ON_TIMER,   /* 27 - PA3 */
-	NOT_ON_TIMER,   /* 28 - PA4 */
-	NOT_ON_TIMER,   /* 29 - PA5 */
-	NOT_ON_TIMER,   /* 30 - PA6 */
-	NOT_ON_TIMER   /* 31 - PA7 */
-};
diff --git a/Marlin/Gen7/cores/arduino/pins_arduino.h b/Marlin/Gen7/cores/arduino/pins_arduino.h
deleted file mode 100644
index e0b7add..0000000
--- a/Marlin/Gen7/cores/arduino/pins_arduino.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
-  pins_arduino.h - Pin definition functions for Arduino
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2007 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: wiring.h 249 2007-02-03 16:52:51Z mellis $
-*/
-
-#ifndef Pins_Arduino_h
-#define Pins_Arduino_h
-
-#include <avr/pgmspace.h>
-
-#define NOT_A_PIN 0
-#define NOT_A_PORT 0
-
-#define NOT_ON_TIMER 0
-#define TIMER0A 1
-#define TIMER0B 2
-#define TIMER1A 3
-#define TIMER1B 4
-#define TIMER2  5
-#define TIMER2A 6
-#define TIMER2B 7
-
-extern const uint8_t PROGMEM port_to_mode_PGM[];
-extern const uint8_t PROGMEM port_to_input_PGM[];
-extern const uint8_t PROGMEM port_to_output_PGM[];
-
-extern const uint8_t PROGMEM digital_pin_to_port_PGM[];
-extern const uint8_t PROGMEM digital_pin_to_bit_PGM[];
-extern const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[];
-
-extern const uint8_t PROGMEM digital_pin_to_timer_PGM[];
-
-// Get the bit location within the hardware port of the given virtual pin.
-// This comes from the pins_*.c file for the active board configuration.
-// 
-// These perform slightly better as macros compared to inline functions
-//
-#define digitalPinToPort(P) ( pgm_read_byte( digital_pin_to_port_PGM + (P) ) )
-#define digitalPinToBitMask(P) ( pgm_read_byte( digital_pin_to_bit_mask_PGM + (P) ) )
-#define digitalPinToTimer(P) ( pgm_read_byte( digital_pin_to_timer_PGM + (P) ) )
-#define analogInPinToBit(P) (P)
-#define portOutputRegister(P) ( (volatile uint8_t *)( pgm_read_byte( port_to_output_PGM + (P))) )
-#define portInputRegister(P) ( (volatile uint8_t *)( pgm_read_byte( port_to_input_PGM + (P))) )
-#define portModeRegister(P) ( (volatile uint8_t *)( pgm_read_byte( port_to_mode_PGM + (P))) )
-
-#endif
diff --git a/Marlin/Gen7/cores/arduino/wiring.c b/Marlin/Gen7/cores/arduino/wiring.c
deleted file mode 100644
index 1a102ae..0000000
--- a/Marlin/Gen7/cores/arduino/wiring.c
+++ /dev/null
@@ -1,203 +0,0 @@
-/*
-  wiring.c - Partial implementation of the Wiring API for the ATmega8.
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: wiring.c 388 2008-03-08 22:05:23Z mellis $
-*/
-
-#include "wiring_private.h"
-
-volatile unsigned long timer0_overflow_count = 0;
-volatile unsigned long timer0_clock_cycles = 0;
-volatile unsigned long timer0_millis = 0;
-
-SIGNAL(TIMER0_OVF_vect)
-{
-	timer0_overflow_count++;
-	// timer 0 prescale factor is 64 and the timer overflows at 256
-	timer0_clock_cycles += 64UL * 256UL;
-	while (timer0_clock_cycles > clockCyclesPerMicrosecond() * 1000UL) {
-		timer0_clock_cycles -= clockCyclesPerMicrosecond() * 1000UL;
-		timer0_millis++;
-	}
-}
-
-unsigned long millis()
-{
-	unsigned long m;
-	uint8_t oldSREG = SREG;
-	
-	// disable interrupts while we read timer0_millis or we might get an
-	// inconsistent value (e.g. in the middle of the timer0_millis++)
-	cli();
-	m = timer0_millis;
-	SREG = oldSREG;
-	
-	return m;
-}
-
-unsigned long micros() {
-	unsigned long m, t;
-	uint8_t oldSREG = SREG;
-	
-	cli();	
-	t = TCNT0;
-  
-#ifdef TIFR0
-	if ((TIFR0 & _BV(TOV0)) && (t == 0))
-		t = 256;
-#else
-	if ((TIFR & _BV(TOV0)) && (t == 0))
-		t = 256;
-#endif
-
-	m = timer0_overflow_count;
-	SREG = oldSREG;
-	
-	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
-}
-
-void delay(unsigned long ms)
-{
-	unsigned long start = millis();
-	
-	while (millis() - start <= ms)
-		;
-}
-
-/* Delay for the given number of microseconds.  Assumes a 8 or 16 MHz clock. 
- * Disables interrupts, which will disrupt the millis() function if used
- * too frequently. */
-void delayMicroseconds(unsigned int us)
-{
-	uint8_t oldSREG;
-
-	// calling avrlib's delay_us() function with low values (e.g. 1 or
-	// 2 microseconds) gives delays longer than desired.
-	//delay_us(us);
-
-#if F_CPU >= 16000000L
-	// for the 16 MHz clock on most Arduino boards
-
-	// for a one-microsecond delay, simply return.  the overhead
-	// of the function call yields a delay of approximately 1 1/8 us.
-	if (--us == 0)
-		return;
-
-	// the following loop takes a quarter of a microsecond (4 cycles)
-	// per iteration, so execute it four times for each microsecond of
-	// delay requested.
-	us <<= 2;
-
-	// account for the time taken in the preceeding commands.
-	us -= 2;
-#else
-	// for the 8 MHz internal clock on the ATmega168
-
-	// for a one- or two-microsecond delay, simply return.  the overhead of
-	// the function calls takes more than two microseconds.  can't just
-	// subtract two, since us is unsigned; we'd overflow.
-	if (--us == 0)
-		return;
-	if (--us == 0)
-		return;
-
-	// the following loop takes half of a microsecond (4 cycles)
-	// per iteration, so execute it twice for each microsecond of
-	// delay requested.
-	us <<= 1;
-
-	// partially compensate for the time taken by the preceeding commands.
-	// we can't subtract any more than this or we'd overflow w/ small delays.
-	us--;
-#endif
-
-	// disable interrupts, otherwise the timer 0 overflow interrupt that
-	// tracks milliseconds will make us delay longer than we want.
-	oldSREG = SREG;
-	cli();
-
-	// busy wait
-	__asm__ __volatile__ (
-		"1: sbiw %0,1" "\n\t" // 2 cycles
-		"brne 1b" : "=w" (us) : "0" (us) // 2 cycles
-	);
-
-	// reenable interrupts.
-	SREG = oldSREG;
-}
-
-void init()
-{
-	// this needs to be called before setup() or some functions won't
-	// work there
-	sei();
-	
-	// on the ATmega168, timer 0 is also used for fast hardware pwm
-	// (using phase-correct PWM would mean that timer 0 overflowed half as often
-	// resulting in different millis() behavior on the ATmega8 and ATmega168)
-	sbi(TCCR0A, WGM01);
-	sbi(TCCR0A, WGM00);
-
-	// set timer 0 prescale factor to 64
-	sbi(TCCR0B, CS01);
-	sbi(TCCR0B, CS00);
-
-	// enable timer 0 overflow interrupt
-	sbi(TIMSK0, TOIE0);
-
-	// timers 1 and 2 are used for phase-correct hardware pwm
-	// this is better for motors as it ensures an even waveform
-	// note, however, that fast pwm mode can achieve a frequency of up
-	// 8 MHz (with a 16 MHz clock) at 50% duty cycle
-
-	// set timer 1 prescale factor to 64
-	sbi(TCCR1B, CS11);
-	sbi(TCCR1B, CS10);
-
-	// put timer 1 in 8-bit phase correct pwm mode
-	sbi(TCCR1A, WGM10);
-
-	// set timer 2 prescale factor to 64
-	sbi(TCCR2B, CS22);
-
-	// configure timer 2 for phase correct pwm (8-bit)
-	sbi(TCCR2A, WGM20);
-
-	// set a2d prescale factor to 128
-	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.
-	// XXX: this will not work properly for other clock speeds, and
-	// this code should use F_CPU to determine the prescale factor.
-	sbi(ADCSRA, ADPS2);
-	sbi(ADCSRA, ADPS1);
-	sbi(ADCSRA, ADPS0);
-
-	// enable a2d conversions
-	sbi(ADCSRA, ADEN);
-
-	// the bootloader connects pins 0 and 1 to the USART; disconnect them
-	// here so they can be used as normal digital i/o; they will be
-	// reconnected in Serial.begin()
-	UCSR0B = 0;
-	#if defined(__AVR_ATmega644P__)
-	//TODO: test to see if disabling this helps?
-	//UCSR1B = 0;
-	#endif
-}
diff --git a/Marlin/Gen7/cores/arduino/wiring.h b/Marlin/Gen7/cores/arduino/wiring.h
deleted file mode 100644
index 6309a36..0000000
--- a/Marlin/Gen7/cores/arduino/wiring.h
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
-  wiring.h - Partial implementation of the Wiring API for the ATmega8.
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: wiring.h 387 2008-03-08 21:30:00Z mellis $
-*/
-
-#ifndef Wiring_h
-#define Wiring_h
-
-#include <avr/io.h>
-#include "binary.h"
-
-#ifdef __cplusplus
-extern "C"{
-#endif
-
-#define HIGH 0x1
-#define LOW  0x0
-
-#define INPUT 0x0
-#define OUTPUT 0x1
-
-#define true 0x1
-#define false 0x0
-
-#define PI 3.14159265
-#define HALF_PI 1.57079
-#define TWO_PI 6.283185
-#define DEG_TO_RAD 0.01745329
-#define RAD_TO_DEG 57.2957786
-
-#define SERIAL  0x0
-#define DISPLAY 0x1
-
-#define LSBFIRST 0
-#define MSBFIRST 1
-
-#define CHANGE 1
-#define FALLING 2
-#define RISING 3
-
-#define INTERNAL 3
-#define DEFAULT 1
-#define EXTERNAL 0
-
-// undefine stdlib's abs if encountered
-#ifdef abs
-#undef abs
-#endif
-
-#define min(a,b) ((a)<(b)?(a):(b))
-#define max(a,b) ((a)>(b)?(a):(b))
-#define abs(x) ((x)>0?(x):-(x))
-#define constrain(amt,low,high) ((amt)<(low)?(low):((amt)>(high)?(high):(amt)))
-#define round(x)     ((x)>=0?(long)((x)+0.5):(long)((x)-0.5))
-#define radians(deg) ((deg)*DEG_TO_RAD)
-#define degrees(rad) ((rad)*RAD_TO_DEG)
-#define sq(x) ((x)*(x))
-
-#define interrupts() sei()
-#define noInterrupts() cli()
-
-#define clockCyclesPerMicrosecond() ( F_CPU / 1000000L )
-#define clockCyclesToMicroseconds(a) ( (a) / clockCyclesPerMicrosecond() )
-#define microsecondsToClockCycles(a) ( (a) * clockCyclesPerMicrosecond() )
-
-#define lowByte(w) ((w) & 0xff)
-#define highByte(w) ((w) >> 8)
-
-#define bitRead(value, bit) (((value) >> (bit)) & 0x01)
-#define bitSet(value, bit) ((value) |= (1UL << (bit)))
-#define bitClear(value, bit) ((value) &= ~(1UL << (bit)))
-#define bitWrite(value, bit, bitvalue) (bitvalue ? bitSet(value, bit) : bitClear(value, bit))
-
-typedef unsigned int word;
-
-#define bit(b) (1 << (b))
-
-typedef uint8_t boolean;
-typedef uint8_t byte;
-
-void init(void);
-
-void pinMode(uint8_t, uint8_t);
-void digitalWrite(uint8_t, uint8_t);
-int digitalRead(uint8_t);
-int analogRead(uint8_t);
-void analogReference(uint8_t mode);
-void analogWrite(uint8_t, int);
-
-void beginSerial(uint8_t, long);
-void serialWrite(uint8_t, unsigned char);
-int serialAvailable(uint8_t);
-int serialRead(uint8_t);
-void serialFlush(uint8_t);
-
-unsigned long millis(void);
-unsigned long micros(void);
-void delay(unsigned long);
-void delayMicroseconds(unsigned int us);
-unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout);
-
-void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, byte val);
-
-void attachInterrupt(uint8_t, void (*)(void), int mode);
-void detachInterrupt(uint8_t);
-
-void setup(void);
-void loop(void);
-
-#ifdef __cplusplus
-} // extern "C"
-#endif
-
-#endif
diff --git a/Marlin/Gen7/cores/arduino/wiring_analog.c b/Marlin/Gen7/cores/arduino/wiring_analog.c
deleted file mode 100644
index b98bb1a..0000000
--- a/Marlin/Gen7/cores/arduino/wiring_analog.c
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
-  wiring_analog.c - analog input and output
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
-*/
-
-#include "wiring_private.h"
-#include "pins_arduino.h"
-
-uint8_t analog_reference = DEFAULT;
-
-void analogReference(uint8_t mode)
-{
-	// can't actually set the register here because the default setting
-	// will connect AVCC and the AREF pin, which would cause a short if
-	// there's something connected to AREF.
-	analog_reference = mode;
-}
-
-int analogRead(uint8_t pin)
-{
-	uint8_t low, high, ch = analogInPinToBit(pin);
-
-	// set the analog reference (high two bits of ADMUX) and select the
-	// channel (low 4 bits).  this also sets ADLAR (left-adjust result)
-	// to 0 (the default).
-	// the final AND is to clear the pos/neg reference bits
-	ADMUX = ((analog_reference << 6) | (pin & 0x0f)) & B11000111;
-
-	// without a delay, we seem to read from the wrong channel
-	//delay(1);
-
-	// start the conversion
-	sbi(ADCSRA, ADSC);
-
-	// ADSC is cleared when the conversion finishes
-	while (bit_is_set(ADCSRA, ADSC));
-
-	// we have to read ADCL first; doing so locks both ADCL
-	// and ADCH until ADCH is read.  reading ADCL second would
-	// cause the results of each conversion to be discarded,
-	// as ADCL and ADCH would be locked when it completed.
-	low = ADCL;
-	high = ADCH;
-
-	// combine the two bytes
-	return (high << 8) | low;
-}
-
-// Right now, PWM output only works on the pins with
-// hardware support.  These are defined in the appropriate
-// pins_*.c file.  For the rest of the pins, we default
-// to digital output.
-void analogWrite(uint8_t pin, int val)
-{
-	// We need to make sure the PWM output is enabled for those pins
-	// that support it, as we turn it off when digitally reading or
-	// writing with them.  Also, make sure the pin is in output mode
-	// for consistenty with Wiring, which doesn't require a pinMode
-	// call for the analog output pins.
-	pinMode(pin, OUTPUT);
-	
-	if (digitalPinToTimer(pin) == TIMER1A) {
-		// connect pwm to pin on timer 1, channel A
-		sbi(TCCR1A, COM1A1);
-		// set pwm duty
-		OCR1A = val;
-	} else if (digitalPinToTimer(pin) == TIMER1B) {
-		// connect pwm to pin on timer 1, channel B
-		sbi(TCCR1A, COM1B1);
-		// set pwm duty
-		OCR1B = val;
-	} else if (digitalPinToTimer(pin) == TIMER0A) {
-		// connect pwm to pin on timer 0, channel A
-		sbi(TCCR0A, COM0A1);
-		// set pwm duty
-		OCR0A = val;	
-	} else if (digitalPinToTimer(pin) == TIMER0B) {
-		// connect pwm to pin on timer 0, channel B
-		sbi(TCCR0A, COM0B1);
-		// set pwm duty
-		OCR0B = val;
-	} else if (digitalPinToTimer(pin) == TIMER2A) {
-		// connect pwm to pin on timer 2, channel A
-		sbi(TCCR2A, COM2A1);
-		// set pwm duty
-		OCR2A = val;	
-	} else if (digitalPinToTimer(pin) == TIMER2B) {
-		// connect pwm to pin on timer 2, channel B
-		sbi(TCCR2A, COM2B1);
-		// set pwm duty
-		OCR2B = val;
-	} else if (val < 128)
-	//fail semi-intelligently
-		digitalWrite(pin, LOW);
-	else
-		digitalWrite(pin, HIGH);
-}
diff --git a/Marlin/Gen7/cores/arduino/wiring_digital.c b/Marlin/Gen7/cores/arduino/wiring_digital.c
deleted file mode 100644
index 3d4b4eb..0000000
--- a/Marlin/Gen7/cores/arduino/wiring_digital.c
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
-  wiring_digital.c - digital input and output functions
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
-*/
-
-#include "wiring_private.h"
-#include "pins_arduino.h"
-
-void pinMode(uint8_t pin, uint8_t mode)
-{
-	uint8_t bit = digitalPinToBitMask(pin);
-	uint8_t port = digitalPinToPort(pin);
-	volatile uint8_t *reg;
-
-	if (port == NOT_A_PIN) return;
-
-	// JWS: can I let the optimizer do this?
-	reg = portModeRegister(port);
-
-	if (mode == INPUT) *reg &= ~bit;
-	else *reg |= bit;
-}
-
-// Forcing this inline keeps the callers from having to push their own stuff
-// on the stack. It is a good performance win and only takes 1 more byte per
-// user than calling. (It will take more bytes on the 168.)
-//
-// But shouldn't this be moved into pinMode? Seems silly to check and do on
-// each digitalread or write.
-//
-static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
-static inline void turnOffPWM(uint8_t timer)
-{
-	if (timer == TIMER0A) cbi(TCCR0A, COM0A1);
-	if (timer == TIMER0B) cbi(TCCR0A, COM0B1);
-	if (timer == TIMER1A) cbi(TCCR1A, COM1A1);
-	if (timer == TIMER1B) cbi(TCCR1A, COM1B1);
-	if (timer == TIMER2A) cbi(TCCR2A, COM2A1);
-	if (timer == TIMER2B) cbi(TCCR2A, COM2B1);
-}
-
-void digitalWrite(uint8_t pin, uint8_t val)
-{
-	uint8_t timer = digitalPinToTimer(pin);
-	uint8_t bit = digitalPinToBitMask(pin);
-	uint8_t port = digitalPinToPort(pin);
-	volatile uint8_t *out;
-
-	if (port == NOT_A_PIN) return;
-
-	// If the pin that support PWM output, we need to turn it off
-	// before doing a digital write.
-	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
-
-	out = portOutputRegister(port);
-
-	if (val == LOW) *out &= ~bit;
-	else *out |= bit;
-}
-
-int digitalRead(uint8_t pin)
-{
-	uint8_t timer = digitalPinToTimer(pin);
-	uint8_t bit = digitalPinToBitMask(pin);
-	uint8_t port = digitalPinToPort(pin);
-
-	if (port == NOT_A_PIN) return LOW;
-
-	// If the pin that support PWM output, we need to turn it off
-	// before getting a digital reading.
-	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
-
-	if (*portInputRegister(port) & bit) return HIGH;
-	
-	return LOW;
-}
diff --git a/Marlin/Gen7/cores/arduino/wiring_private.h b/Marlin/Gen7/cores/arduino/wiring_private.h
deleted file mode 100644
index 14394a0..0000000
--- a/Marlin/Gen7/cores/arduino/wiring_private.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
-  wiring_private.h - Internal header file.
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: wiring.h 239 2007-01-12 17:58:39Z mellis $
-*/
-
-#ifndef WiringPrivate_h
-#define WiringPrivate_h
-
-#include <avr/io.h>
-#include <avr/interrupt.h>
-#include <avr/signal.h>
-#include <avr/delay.h>
-#include <stdio.h>
-#include <stdarg.h>
-
-#include "wiring.h"
-
-#ifdef __cplusplus
-extern "C"{
-#endif
-
-#ifndef cbi
-#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
-#endif
-#ifndef sbi
-#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
-#endif
-
-#define EXTERNAL_INT_0 0
-#define EXTERNAL_INT_1 1
-#define EXTERNAL_INT_2 2
-
-#define EXTERNAL_NUM_INTERRUPTS 3
-
-typedef void (*voidFuncPtr)(void);
-
-#ifdef __cplusplus
-} // extern "C"
-#endif
-
-#endif
diff --git a/Marlin/Gen7/cores/arduino/wiring_pulse.c b/Marlin/Gen7/cores/arduino/wiring_pulse.c
deleted file mode 100644
index 8f232f1..0000000
--- a/Marlin/Gen7/cores/arduino/wiring_pulse.c
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
-  wiring_pulse.c - pulseIn() function
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
-*/
-
-#include "wiring_private.h"
-#include "pins_arduino.h"
-
-/* Measures the length (in microseconds) of a pulse on the pin; state is HIGH
- * or LOW, the type of pulse to measure.  Works on pulses from 2-3 microseconds
- * to 3 minutes in length, but must be called at least a few dozen microseconds
- * before the start of the pulse. */
-unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout)
-{
-	// cache the port and bit of the pin in order to speed up the
-	// pulse width measuring loop and achieve finer resolution.  calling
-	// digitalRead() instead yields much coarser resolution.
-	uint8_t bit = digitalPinToBitMask(pin);
-	uint8_t port = digitalPinToPort(pin);
-	uint8_t stateMask = (state ? bit : 0);
-	unsigned long width = 0; // keep initialization out of time critical area
-	
-	// convert the timeout from microseconds to a number of times through
-	// the initial loop; it takes 16 clock cycles per iteration.
-	unsigned long numloops = 0;
-	unsigned long maxloops = microsecondsToClockCycles(timeout) / 16;
-	
-	// wait for any previous pulse to end
-	while ((*portInputRegister(port) & bit) == stateMask)
-		if (numloops++ == maxloops)
-			return 0;
-	
-	// wait for the pulse to start
-	while ((*portInputRegister(port) & bit) != stateMask)
-		if (numloops++ == maxloops)
-			return 0;
-	
-	// wait for the pulse to stop
-	while ((*portInputRegister(port) & bit) == stateMask)
-		width++;
-
-	// convert the reading to microseconds. The loop has been determined
-	// to be 10 clock cycles long and have about 16 clocks between the edge
-	// and the start of the loop. There will be some error introduced by
-	// the interrupt handlers.
-	return clockCyclesToMicroseconds(width * 10 + 16); 
-}
diff --git a/Marlin/Gen7/cores/arduino/wiring_serial.c b/Marlin/Gen7/cores/arduino/wiring_serial.c
deleted file mode 100644
index a3314fa..0000000
--- a/Marlin/Gen7/cores/arduino/wiring_serial.c
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
-  wiring_serial.c - serial functions.
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-  Modified 29 January 2009, Marius Kintel for Sanguino - http://www.sanguino.cc/
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
-*/
-
-
-#include "wiring_private.h"
-
-// Define constants and variables for buffering incoming serial data.  We're
-// using a ring buffer (I think), in which rx_buffer_head is the index of the
-// location to which to write the next incoming character and rx_buffer_tail
-// is the index of the location from which to read.
-#define RX_BUFFER_SIZE 128
-
-#if defined(__AVR_ATmega644P__)
-unsigned char rx_buffer[2][RX_BUFFER_SIZE];
-int rx_buffer_head[2] = {0, 0};
-int rx_buffer_tail[2] = {0, 0};
-#else
-unsigned char rx_buffer[1][RX_BUFFER_SIZE];
-int rx_buffer_head[1] = {0};
-int rx_buffer_tail[1] = {0};
-#endif
-
-
-#define BEGIN_SERIAL(uart_, baud_) \
-{ \
-    UBRR##uart_##H = ((F_CPU / 16 + baud / 2) / baud - 1) >> 8; \
-    UBRR##uart_##L = ((F_CPU / 16 + baud / 2) / baud - 1); \
-    \
-    /* reset config for UART */ \
-    UCSR##uart_##A = 0; \
-    UCSR##uart_##B = 0; \
-    UCSR##uart_##C = 0; \
-    \
-    /* enable rx and tx */ \
-    sbi(UCSR##uart_##B, RXEN##uart_);\
-    sbi(UCSR##uart_##B, TXEN##uart_);\
-    \
-    /* enable interrupt on complete reception of a byte */ \
-    sbi(UCSR##uart_##B, RXCIE##uart_); \
-    UCSR##uart_##C = _BV(UCSZ##uart_##1)|_BV(UCSZ##uart_##0); \
-    /* defaults to 8-bit, no parity, 1 stop bit */ \
-}
-
-void beginSerial(uint8_t uart, long baud)
-{
-  if (uart == 0) BEGIN_SERIAL(0, baud)
-#if defined(__AVR_ATmega644P__)
-  else BEGIN_SERIAL(1, baud)
-#endif
-}
-
-#define SERIAL_WRITE(uart_, c_) \
-    while (!(UCSR##uart_##A & (1 << UDRE##uart_))) \
-      ; \
-    UDR##uart_ = c
-
-void serialWrite(uint8_t uart, unsigned char c)
-{
-  if (uart == 0) {
-    SERIAL_WRITE(0, c);
-  }
-#if defined(__AVR_ATmega644P__)
-  else {
-    SERIAL_WRITE(1, c);
-  }
-#endif
-}
-
-int serialAvailable(uint8_t uart)
-{
-  return (RX_BUFFER_SIZE + rx_buffer_head[uart] - rx_buffer_tail[uart]) % RX_BUFFER_SIZE;
-}
-
-int serialRead(uint8_t uart)
-{
-  // if the head isn't ahead of the tail, we don't have any characters
-  if (rx_buffer_head[uart] == rx_buffer_tail[uart]) {
-    return -1;
-  } else {
-    unsigned char c = rx_buffer[uart][rx_buffer_tail[uart]];
-    rx_buffer_tail[uart] = (rx_buffer_tail[uart] + 1) % RX_BUFFER_SIZE;
-    return c;
-  }
-}
-
-void serialFlush(uint8_t uart)
-{
-  // don't reverse this or there may be problems if the RX interrupt
-  // occurs after reading the value of rx_buffer_head but before writing
-  // the value to rx_buffer_tail; the previous value of rx_buffer_head
-  // may be written to rx_buffer_tail, making it appear as if the buffer
-  // were full, not empty.
-  rx_buffer_head[uart] = rx_buffer_tail[uart];
-}
-
-#define UART_ISR(uart_) \
-ISR(USART##uart_##_RX_vect) \
-{ \
-  unsigned char c = UDR##uart_; \
-  \
-  int i = (rx_buffer_head[uart_] + 1) % RX_BUFFER_SIZE; \
-  \  
-  /* if we should be storing the received character into the location \
-     just before the tail (meaning that the head would advance to the \
-     current location of the tail), we're about to overflow the buffer \
-     and so we don't write the character or advance the head. */ \
-  if (i != rx_buffer_tail[uart_]) { \
-    rx_buffer[uart_][rx_buffer_head[uart_]] = c; \
-    rx_buffer_head[uart_] = i; \
-  } \
-}
-
-UART_ISR(0)
-#if defined(__AVR_ATmega644P__) 
-UART_ISR(1)
-#endif
diff --git a/Marlin/Gen7/cores/arduino/wiring_shift.c b/Marlin/Gen7/cores/arduino/wiring_shift.c
deleted file mode 100644
index 956f864..0000000
--- a/Marlin/Gen7/cores/arduino/wiring_shift.c
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
-  wiring_shift.c - shiftOut() function
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
-*/
-
-#include "wiring_private.h"
-
-void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, byte val)
-{
-	int i;
-
-	for (i = 0; i < 8; i++)  {
-		if (bitOrder == LSBFIRST)
-			digitalWrite(dataPin, !!(val & (1 << i)));
-		else	
-			digitalWrite(dataPin, !!(val & (1 << (7 - i))));
-			
-		digitalWrite(clockPin, HIGH);
-		digitalWrite(clockPin, LOW);		
-	}
-}
diff --git a/Marlin/LiquidCrystalRus.cpp b/Marlin/LiquidCrystalRus.cpp
new file mode 100644
index 0000000..4bd8de7
--- /dev/null
+++ b/Marlin/LiquidCrystalRus.cpp
@@ -0,0 +1,389 @@
+#include "LiquidCrystalRus.h"
+
+#include <stdio.h>
+#include <string.h>
+#include <inttypes.h>
+#include <avr/pgmspace.h>
+
+#if defined(ARDUINO) && ARDUINO >= 100
+  #include "Arduino.h"
+#else
+  #include "WProgram.h"
+#endif
+
+// it is a russian alphabet translation
+// except 0401 --> 0xa2 = , 0451 --> 0xb5
+const PROGMEM uint8_t utf_recode[] = 
+       { 0x41,0xa0,0x42,0xa1,0xe0,0x45,0xa3,0xa4,0xa5,0xa6,0x4b,0xa7,0x4d,0x48,0x4f,
+         0xa8,0x50,0x43,0x54,0xa9,0xaa,0x58,0xe1,0xab,0xac,0xe2,0xad,0xae,0x62,0xaf,0xb0,0xb1,
+         0x61,0xb2,0xb3,0xb4,0xe3,0x65,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0x6f,
+         0xbe,0x70,0x63,0xbf,0x79,0xe4,0x78,0xe5,0xc0,0xc1,0xe6,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7
+        };     
+
+// When the display powers up, it is configured as follows:
+//
+// 1. Display clear
+// 2. Function set: 
+//    DL = 1; 8-bit interface data 
+//    N = 0; 1-line display 
+//    F = 0; 5x8 dot character font 
+// 3. Display on/off control: 
+//    D = 0; Display off 
+//    C = 0; Cursor off 
+//    B = 0; Blinking off 
+// 4. Entry mode set: 
+//    I/D = 1; Increment by 1 
+//    S = 0; No shift 
+//
+// Note, however, that resetting the Arduino doesn't reset the LCD, so we
+// can't assume that its in that state when a sketch starts (and the
+// LiquidCrystal constructor is called).
+// 
+// modified 27 Jul 2011
+// by Ilya V. Danilov http://mk90.ru/
+
+
+LiquidCrystalRus::LiquidCrystalRus(uint8_t rs, uint8_t rw, uint8_t enable,
+			     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
+			     uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)
+{
+  init(0, rs, rw, enable, d0, d1, d2, d3, d4, d5, d6, d7);
+}
+
+LiquidCrystalRus::LiquidCrystalRus(uint8_t rs, uint8_t enable,
+			     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
+			     uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)
+{
+  init(0, rs, 255, enable, d0, d1, d2, d3, d4, d5, d6, d7);
+}
+
+LiquidCrystalRus::LiquidCrystalRus(uint8_t rs, uint8_t rw, uint8_t enable,
+			     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3)
+{
+  init(1, rs, rw, enable, d0, d1, d2, d3, 0, 0, 0, 0);
+}
+
+LiquidCrystalRus::LiquidCrystalRus(uint8_t rs,  uint8_t enable,
+			     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3)
+{
+  init(1, rs, 255, enable, d0, d1, d2, d3, 0, 0, 0, 0);
+}
+
+void LiquidCrystalRus::init(uint8_t fourbitmode, uint8_t rs, uint8_t rw, uint8_t enable,
+			 uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
+			 uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)
+{
+  _rs_pin = rs;
+  _rw_pin = rw;
+  _enable_pin = enable;
+  
+  _data_pins[0] = d0;
+  _data_pins[1] = d1;
+  _data_pins[2] = d2;
+  _data_pins[3] = d3; 
+  _data_pins[4] = d4;
+  _data_pins[5] = d5;
+  _data_pins[6] = d6;
+  _data_pins[7] = d7; 
+
+  pinMode(_rs_pin, OUTPUT);
+  // we can save 1 pin by not using RW. Indicate by passing 255 instead of pin#
+  if (_rw_pin != 255) { 
+    pinMode(_rw_pin, OUTPUT);
+  }
+  pinMode(_enable_pin, OUTPUT);
+  
+  if (fourbitmode)
+    _displayfunction = LCD_4BITMODE | LCD_1LINE | LCD_5x8DOTS;
+  else 
+    _displayfunction = LCD_8BITMODE | LCD_1LINE | LCD_5x8DOTS;
+  
+  begin(16, 1);  
+}
+
+void LiquidCrystalRus::begin(uint8_t cols, uint8_t lines, uint8_t dotsize) {
+  if (lines > 1) {
+    _displayfunction |= LCD_2LINE;
+  }
+  _numlines = lines;
+  _currline = 0;
+
+  // for some 1 line displays you can select a 10 pixel high font
+  if ((dotsize != 0) && (lines == 1)) {
+    _displayfunction |= LCD_5x10DOTS;
+  }
+
+  // SEE PAGE 45/46 FOR INITIALIZATION SPECIFICATION!
+  // according to datasheet, we need at least 40ms after power rises above 2.7V
+  // before sending commands. Arduino can turn on way befer 4.5V so we'll wait 50
+  delayMicroseconds(50000); 
+  // Now we pull both RS and R/W low to begin commands
+  digitalWrite(_rs_pin, LOW);
+  digitalWrite(_enable_pin, LOW);
+  if (_rw_pin != 255) { 
+    digitalWrite(_rw_pin, LOW);
+  }
+  
+  //put the LCD into 4 bit or 8 bit mode
+  if (! (_displayfunction & LCD_8BITMODE)) {
+    // this is according to the hitachi HD44780 datasheet
+    // figure 24, pg 46
+
+    // we start in 8bit mode, try to set 4 bit mode
+    writeNbits(0x03,4);
+    delayMicroseconds(4500); // wait min 4.1ms
+
+    // second try
+    writeNbits(0x03,4);
+    delayMicroseconds(4500); // wait min 4.1ms
+    
+    // third go!
+    writeNbits(0x03,4); 
+    delayMicroseconds(150);
+
+    // finally, set to 8-bit interface
+    writeNbits(0x02,4); 
+  } else {
+    // this is according to the hitachi HD44780 datasheet
+    // page 45 figure 23
+
+    // Send function set command sequence
+    command(LCD_FUNCTIONSET | _displayfunction);
+    delayMicroseconds(4500);  // wait more than 4.1ms
+
+    // second try
+    command(LCD_FUNCTIONSET | _displayfunction);
+    delayMicroseconds(150);
+
+    // third go
+    command(LCD_FUNCTIONSET | _displayfunction);
+  }
+
+  // finally, set # lines, font size, etc.
+  command(LCD_FUNCTIONSET | _displayfunction);  
+
+  // turn the display on with no cursor or blinking default
+  _displaycontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;  
+  display();
+
+  // clear it off
+  clear();
+
+  // Initialize to default text direction (for romance languages)
+  _displaymode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;
+  // set the entry mode
+  command(LCD_ENTRYMODESET | _displaymode);
+
+}
+
+void LiquidCrystalRus::setDRAMModel(uint8_t model) {
+  _dram_model = model;
+}
+
+/********** high level commands, for the user! */
+void LiquidCrystalRus::clear()
+{
+  command(LCD_CLEARDISPLAY);  // clear display, set cursor position to zero
+  delayMicroseconds(2000);  // this command takes a long time!
+}
+
+void LiquidCrystalRus::home()
+{
+  command(LCD_RETURNHOME);  // set cursor position to zero
+  delayMicroseconds(2000);  // this command takes a long time!
+}
+
+void LiquidCrystalRus::setCursor(uint8_t col, uint8_t row)
+{
+  int row_offsets[] = { 0x00, 0x40, 0x14, 0x54 };
+  if ( row >= _numlines ) {
+    row = _numlines-1;    // we count rows starting w/0
+  }
+  
+  command(LCD_SETDDRAMADDR | (col + row_offsets[row]));
+}
+
+// Turn the display on/off (quickly)
+void LiquidCrystalRus::noDisplay() {
+  _displaycontrol &= ~LCD_DISPLAYON;
+  command(LCD_DISPLAYCONTROL | _displaycontrol);
+}
+void LiquidCrystalRus::display() {
+  _displaycontrol |= LCD_DISPLAYON;
+  command(LCD_DISPLAYCONTROL | _displaycontrol);
+}
+
+// Turns the underline cursor on/off
+void LiquidCrystalRus::noCursor() {
+  _displaycontrol &= ~LCD_CURSORON;
+  command(LCD_DISPLAYCONTROL | _displaycontrol);
+}
+void LiquidCrystalRus::cursor() {
+  _displaycontrol |= LCD_CURSORON;
+  command(LCD_DISPLAYCONTROL | _displaycontrol);
+}
+
+// Turn on and off the blinking cursor
+void LiquidCrystalRus::noBlink() {
+  _displaycontrol &= ~LCD_BLINKON;
+  command(LCD_DISPLAYCONTROL | _displaycontrol);
+}
+void LiquidCrystalRus::blink() {
+  _displaycontrol |= LCD_BLINKON;
+  command(LCD_DISPLAYCONTROL | _displaycontrol);
+}
+
+// These commands scroll the display without changing the RAM
+void LiquidCrystalRus::scrollDisplayLeft(void) {
+  command(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVELEFT);
+}
+void LiquidCrystalRus::scrollDisplayRight(void) {
+  command(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVERIGHT);
+}
+
+// This is for text that flows Left to Right
+void LiquidCrystalRus::leftToRight(void) {
+  _displaymode |= LCD_ENTRYLEFT;
+  command(LCD_ENTRYMODESET | _displaymode);
+}
+
+// This is for text that flows Right to Left
+void LiquidCrystalRus::rightToLeft(void) {
+  _displaymode &= ~LCD_ENTRYLEFT;
+  command(LCD_ENTRYMODESET | _displaymode);
+}
+
+// This will 'right justify' text from the cursor
+void LiquidCrystalRus::autoscroll(void) {
+  _displaymode |= LCD_ENTRYSHIFTINCREMENT;
+  command(LCD_ENTRYMODESET | _displaymode);
+}
+
+// This will 'left justify' text from the cursor
+void LiquidCrystalRus::noAutoscroll(void) {
+  _displaymode &= ~LCD_ENTRYSHIFTINCREMENT;
+  command(LCD_ENTRYMODESET | _displaymode);
+}
+
+// Allows us to fill the first 8 CGRAM locations
+// with custom characters
+void LiquidCrystalRus::createChar(uint8_t location, uint8_t charmap[]) {
+  location &= 0x7; // we only have 8 locations 0-7
+  command(LCD_SETCGRAMADDR | (location << 3));
+  for (int i=0; i<8; i++) {
+    write(charmap[i]);
+  }
+}
+
+/*********** mid level commands, for sending data/cmds */
+
+inline void LiquidCrystalRus::command(uint8_t value) {
+  send(value, LOW);
+}
+
+#if defined(ARDUINO) && ARDUINO >= 100
+  size_t LiquidCrystalRus::write(uint8_t value)
+#else
+  void   LiquidCrystalRus::write(uint8_t value)
+#endif
+{
+  uint8_t out_char=value;
+
+  if (_dram_model == LCD_DRAM_WH1601) {  
+    uint8_t ac=recv(LOW) & 0x7f;
+    if (ac>7 && ac<0x14) command(LCD_SETDDRAMADDR | (0x40+ac-8));
+  }
+
+  if (value>=0x80) { // UTF-8 handling
+    if (value >= 0xc0) {
+      utf_hi_char = value - 0xd0;
+    } else {
+      value &= 0x3f;
+      if (!utf_hi_char && (value == 1)) 
+        send(0xa2,HIGH); // 
+      else if ((utf_hi_char == 1) && (value == 0x11)) 
+        send(0xb5,HIGH); // 
+      else 
+        send(pgm_read_byte_near(utf_recode + value + (utf_hi_char<<6) - 0x10), HIGH);
+    }    
+  } else send(out_char, HIGH);
+#if defined(ARDUINO) && ARDUINO >= 100
+  return 1; // assume sucess 
+#endif
+}
+
+/************ low level data pushing commands **********/
+
+// write either command or data, with automatic 4/8-bit selection
+void LiquidCrystalRus::send(uint8_t value, uint8_t mode) {
+  digitalWrite(_rs_pin, mode);
+
+  // if there is a RW pin indicated, set it low to Write
+  if (_rw_pin != 255) { 
+    digitalWrite(_rw_pin, LOW);
+  }
+  
+  if (_displayfunction & LCD_8BITMODE) {
+    writeNbits(value,8); 
+  } else {
+    writeNbits(value>>4,4);
+    writeNbits(value,4);
+  }
+}
+
+// read  data, with automatic 4/8-bit selection
+uint8_t LiquidCrystalRus::recv(uint8_t mode) {
+  uint8_t retval;
+  digitalWrite(_rs_pin, mode);
+
+  // if there is a RW pin indicated, set it low to Write
+  if (_rw_pin != 255) { 
+    digitalWrite(_rw_pin, HIGH);
+  }
+  
+  if (_displayfunction & LCD_8BITMODE) {
+    retval = readNbits(8); 
+  } else {
+    retval = readNbits(4) << 4;
+    retval |= readNbits(4);
+  }
+  return retval;
+}
+void LiquidCrystalRus::pulseEnable() {
+  digitalWrite(_enable_pin, LOW);
+  delayMicroseconds(1);    
+  digitalWrite(_enable_pin, HIGH);
+  delayMicroseconds(1);    // enable pulse must be >450ns
+  digitalWrite(_enable_pin, LOW);
+  delayMicroseconds(100);   // commands need > 37us to settle
+}
+
+void LiquidCrystalRus::writeNbits(uint8_t value, uint8_t n) {
+  for (int i = 0; i < n; i++) {
+    pinMode(_data_pins[i], OUTPUT);
+    digitalWrite(_data_pins[i], (value >> i) & 0x01);
+  }
+
+  pulseEnable();
+}
+
+uint8_t LiquidCrystalRus::readNbits(uint8_t n) {
+  uint8_t retval=0;
+  for (int i = 0; i < n; i++) {
+    pinMode(_data_pins[i], INPUT);
+  }
+
+  digitalWrite(_enable_pin, LOW);
+  delayMicroseconds(1);    
+  digitalWrite(_enable_pin, HIGH);
+  delayMicroseconds(1);    // enable pulse must be >450ns
+  
+  for (int i = 0; i < n; i++) {
+    retval |= (digitalRead(_data_pins[i]) == HIGH)?(1 << i):0;
+  }
+
+  digitalWrite(_enable_pin, LOW);
+
+  return retval;
+}
+
diff --git a/Marlin/LiquidCrystalRus.h b/Marlin/LiquidCrystalRus.h
new file mode 100644
index 0000000..ad85394
--- /dev/null
+++ b/Marlin/LiquidCrystalRus.h
@@ -0,0 +1,129 @@
+//
+// based on LiquidCrystal library from ArduinoIDE, see http://arduino.cc
+//  modified 27 Jul 2011
+// by Ilya V. Danilov http://mk90.ru/
+// 
+
+#ifndef LiquidCrystalRus_h
+#define LiquidCrystalRus_h
+
+#include <inttypes.h>
+#include "Print.h"
+
+// commands
+#define LCD_CLEARDISPLAY 0x01
+#define LCD_RETURNHOME 0x02
+#define LCD_ENTRYMODESET 0x04
+#define LCD_DISPLAYCONTROL 0x08
+#define LCD_CURSORSHIFT 0x10
+#define LCD_FUNCTIONSET 0x20
+#define LCD_SETCGRAMADDR 0x40
+#define LCD_SETDDRAMADDR 0x80
+
+// flags for display entry mode
+#define LCD_ENTRYRIGHT 0x00
+#define LCD_ENTRYLEFT 0x02
+#define LCD_ENTRYSHIFTINCREMENT 0x01
+#define LCD_ENTRYSHIFTDECREMENT 0x00
+
+// flags for display on/off control
+#define LCD_DISPLAYON 0x04
+#define LCD_DISPLAYOFF 0x00
+#define LCD_CURSORON 0x02
+#define LCD_CURSOROFF 0x00
+#define LCD_BLINKON 0x01
+#define LCD_BLINKOFF 0x00
+
+// flags for display/cursor shift
+#define LCD_DISPLAYMOVE 0x08
+#define LCD_CURSORMOVE 0x00
+#define LCD_MOVERIGHT 0x04
+#define LCD_MOVELEFT 0x00
+
+// flags for function set
+#define LCD_8BITMODE 0x10
+#define LCD_4BITMODE 0x00
+#define LCD_2LINE 0x08
+#define LCD_1LINE 0x00
+#define LCD_5x10DOTS 0x04
+#define LCD_5x8DOTS 0x00
+
+// enum for 
+#define LCD_DRAM_Normal 0x00
+#define LCD_DRAM_WH1601 0x01
+
+
+class LiquidCrystalRus : public Print {
+public:
+  LiquidCrystalRus(uint8_t rs, uint8_t enable,
+		uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
+		uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7);
+  LiquidCrystalRus(uint8_t rs, uint8_t rw, uint8_t enable,
+		uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
+		uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7);
+  LiquidCrystalRus(uint8_t rs, uint8_t rw, uint8_t enable,
+		uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3);
+  LiquidCrystalRus(uint8_t rs, uint8_t enable,
+		uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3);
+
+  void init(uint8_t fourbitmode, uint8_t rs, uint8_t rw, uint8_t enable,
+	    uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
+	    uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7);
+    
+  void begin(uint8_t cols, uint8_t rows, uint8_t charsize = LCD_5x8DOTS);
+
+  void clear();
+  void home();
+
+  void noDisplay();
+  void display();
+  void noBlink();
+  void blink();
+  void noCursor();
+  void cursor();
+  void scrollDisplayLeft();
+  void scrollDisplayRight();
+  void leftToRight();
+  void rightToLeft();
+  void autoscroll();
+  void noAutoscroll();
+
+  void createChar(uint8_t, uint8_t[]);
+  void setCursor(uint8_t, uint8_t);
+ 
+#if defined(ARDUINO) && ARDUINO >= 100
+  virtual size_t write(uint8_t);
+  using Print::write;
+#else
+  virtual void write(uint8_t);
+#endif
+
+  void command(uint8_t);
+
+  void setDRAMModel(uint8_t);
+
+private:
+  void send(uint8_t, uint8_t);
+  void writeNbits(uint8_t, uint8_t);
+  uint8_t recv(uint8_t);
+  uint8_t readNbits(uint8_t); 
+  void pulseEnable();
+
+  uint8_t _rs_pin; // LOW: command.  HIGH: character.
+  uint8_t _rw_pin; // LOW: write to LCD.  HIGH: read from LCD.
+  uint8_t _enable_pin; // activated by a HIGH pulse.
+  uint8_t _data_pins[8];
+
+  uint8_t _displayfunction;
+  uint8_t _displaycontrol;
+  uint8_t _displaymode;
+
+  uint8_t _initialized;
+
+  uint8_t _numlines,_currline;
+
+  uint8_t _dram_model;
+  uint8_t utf_hi_char; // UTF-8 high part
+};
+
+#endif
diff --git a/Marlin/Makefile b/Marlin/Makefile
index 940bb16..c5b8ffb 100644
--- a/Marlin/Makefile
+++ b/Marlin/Makefile
@@ -3,6 +3,7 @@
 # Makefile Based on:
 # Arduino 0011 Makefile
 # Arduino adaptation by mellis, eighthave, oli.keller
+# Marlin adaption by Daid
 #
 # This has been tested with Arduino 0022.
 # 
@@ -11,14 +12,14 @@
 #
 # Detailed instructions for using the makefile:
 #
-#  1. Modify the line containg "INSTALL_DIR" to point to the directory that
+#  1. Modify the line containg "ARDUINO_INSTALL_DIR" to point to the directory that
 #     contains the Arduino installation (for example, under Mac OS X, this
 #     might be /Applications/arduino-0012).
 #
-#  2. Modify the line containing "PORT" to refer to the filename
+#  2. Modify the line containing "UPLOAD_PORT" to refer to the filename
 #     representing the USB or serial connection to your Arduino board
-#     (e.g. PORT = /dev/tty.USB0).  If the exact name of this file
-#     changes, you can use * as a wildcard (e.g. PORT = /dev/tty.usb*).
+#     (e.g. UPLOAD_PORT = /dev/tty.USB0).  If the exact name of this file
+#     changes, you can use * as a wildcard (e.g. UPLOAD_PORT = /dev/tty.usb*).
 #
 #  3. Set the line containing "MCU" to match your board's processor. 
 #     Older one's are atmega8 based, newer ones like Arduino Mini, Bluetooth
@@ -32,42 +33,153 @@
 #  5. Type "make upload", reset your Arduino board, and press enter to
 #     upload your program to the Arduino board.
 #
-# $Id$
+# Note that all settings are set with ?=, this means you can override them
+# from the commandline with "make HARDWARE_MOTHERBOARD=71" for example
 
-#For "old" Arduino Mega
-#MCU = atmega1280
-#For Arduino Mega2560
-#MCU = atmega2560
-#For Sanguinololu
-MCU = atmega644p 
+# This defined the board you are compiling for (see Configuration.h for the options)
+HARDWARE_MOTHERBOARD ?= 11
 
-# Here you select "arduino", "Sanguino", "Gen7", ...
-HARDWARE_VARIANT 		= Sanguino
-# This defined the board you are compiling for
-HARDWARE_MOTHERBOARD	= 91
+# Arduino source install directory, and version number
+ARDUINO_INSTALL_DIR  ?= ../../arduino-0022
+ARDUINO_VERSION      ?= 22
 
-# Arduino source install directory
-INSTALL_DIR = ../../arduino-0022
+# You can optionally set a path to the avr-gcc tools. Requires a trailing slash. (ex: /usr/local/avr-gcc/bin)
+AVR_TOOLS_PATH ?= 
+
+#Programmer configuration
+UPLOAD_RATE        ?= 115200
+AVRDUDE_PROGRAMMER ?= arduino
+UPLOAD_PORT        ?= /dev/arduino
+
+#Directory used to build files in, contains all the build files, from object files to the final hex file.
+BUILD_DIR          ?= applet
+
+############################################################################
+# Below here nothing should be changed...
+
+# Here the Arduino variant is selected by the board type
+# HARDWARE_VARIANT = "arduino", "Sanguino", "Gen7", ...
+# MCU = "atmega1280", "Mega2560", "atmega2560", "atmega644p", ...
+
+#Gen7
+ifeq ($(HARDWARE_MOTHERBOARD),10)
+HARDWARE_VARIANT ?= Gen7
+MCU              ?= atmega644
+F_CPU            ?= 20000000
+else ifeq  ($(HARDWARE_MOTHERBOARD),11)
+HARDWARE_VARIANT ?= Gen7
+MCU              ?= atmega644p
+F_CPU            ?= 20000000
+else ifeq  ($(HARDWARE_MOTHERBOARD),12)
+HARDWARE_VARIANT ?= Gen7
+MCU              ?= atmega644p
+F_CPU            ?= 20000000
+else ifeq  ($(HARDWARE_MOTHERBOARD),13)
+HARDWARE_VARIANT ?= Gen7
+MCU              ?= atmega1284p
+F_CPU            ?= 20000000
+
+#RAMPS
+else ifeq  ($(HARDWARE_MOTHERBOARD),3)
+HARDWARE_VARIANT ?= arduino
+MCU              ?= atmega2560
+else ifeq  ($(HARDWARE_MOTHERBOARD),33)
+HARDWARE_VARIANT ?= arduino
+MCU              ?= atmega2560
+else ifeq  ($(HARDWARE_MOTHERBOARD),34)
+HARDWARE_VARIANT ?= arduino
+MCU              ?= atmega2560
+
+#Duemilanove w/ ATMega328P pin assignment
+else ifeq  ($(HARDWARE_MOTHERBOARD),4)
+HARDWARE_VARIANT ?= arduino
+HARDWARE_SUB_VARIANT ?= standard
+MCU              ?= atmega328p
+
+#Gen6
+else ifeq  ($(HARDWARE_MOTHERBOARD),5)
+HARDWARE_VARIANT ?= Gen6
+MCU              ?= atmega644p
+else ifeq  ($(HARDWARE_MOTHERBOARD),51)
+HARDWARE_VARIANT ?= Gen6
+MCU              ?= atmega644p
+
+#Sanguinololu
+else ifeq  ($(HARDWARE_MOTHERBOARD),6)
+HARDWARE_VARIANT ?= Sanguino
+MCU              ?= atmega644p
+else ifeq  ($(HARDWARE_MOTHERBOARD),62)
+HARDWARE_VARIANT ?= Sanguino
+MCU              ?= atmega644p
+else ifeq  ($(HARDWARE_MOTHERBOARD),63)
+HARDWARE_VARIANT ?= Sanguino
+MCU              ?= atmega644p
+
+#Ultimaker
+else ifeq  ($(HARDWARE_MOTHERBOARD),7)
+HARDWARE_VARIANT ?= arduino
+MCU              ?= atmega2560
+else ifeq  ($(HARDWARE_MOTHERBOARD),71)
+HARDWARE_VARIANT ?= arduino
+MCU              ?= atmega1280
+
+#Teensylu
+else ifeq  ($(HARDWARE_MOTHERBOARD),8)
+HARDWARE_VARIANT ?= Teensy
+MCU              ?= at90usb1286
+else ifeq  ($(HARDWARE_MOTHERBOARD),81)
+HARDWARE_VARIANT ?= Teensy
+MCU              ?= at90usb1286
+else ifeq  ($(HARDWARE_MOTHERBOARD),82)
+HARDWARE_VARIANT ?= Teensy
+MCU              ?= at90usb646
+
+#Gen3+
+else ifeq  ($(HARDWARE_MOTHERBOARD),9)
+HARDWARE_VARIANT ?= Sanguino
+MCU              ?= atmega644p
+
+#Megatronics
+else ifeq  ($(HARDWARE_MOTHERBOARD),70)
+HARDWARE_VARIANT ?= arduino
+MCU              ?= atmega2560
+
+#Alpha OMCA board
+else ifeq  ($(HARDWARE_MOTHERBOARD),90)
+HARDWARE_VARIANT ?= SanguinoA
+MCU              ?= atmega644
+
+#Final OMCA board
+else ifeq  ($(HARDWARE_MOTHERBOARD),91)
+HARDWARE_VARIANT ?= Sanguino
+MCU              ?= atmega644p
+
+#Rambo
+else ifeq  ($(HARDWARE_MOTHERBOARD),301)
+HARDWARE_VARIANT ?= arduino
+MCU              ?= atmega2560
+
+endif
+
+# Be sure to regenerate speed_lookuptable.h with create_speed_lookuptable.py
+# if you are setting this to something other than 16MHz
+# Set to 16Mhz if not yet set.
+F_CPU ?= 16000000
 
 # Arduino containd the main source code for the Arduino
 # Libraries, the "hardware variant" are for boards
 # that derives from that, and their source are present in
 # the main Marlin source directory
-ARDUINO = $(INSTALL_DIR)/hardware/arduino/cores/arduino
-
-ifeq (${HARDWARE_VARIANT}, arduino)
-HARDWARE_SRC= $(ARDUINO)
+ifeq ($(HARDWARE_VARIANT), arduino)
+HARDWARE_SRC = $(ARDUINO_INSTALL_DIR)/hardware/arduino/cores/arduino
 else
-HARDWARE_SRC= $(HARDWARE_VARIANT)/cores/arduino
+ifeq ($(shell [ $(ARDUINO_VERSION) -ge 100 ] && echo true), true)
+HARDWARE_SRC = ../ArduinoAddons/Arduino_1.x.x/$(HARDWARE_VARIANT)/cores/arduino
+else
+HARDWARE_SRC = ../ArduinoAddons/Arduino_0.xx/$(HARDWARE_VARIANT)/cores/arduino
+endif
 endif
 
-# Be sure to regenerate speed_lookuptable.h with create_speed_lookuptable.py
-# if you are setting this to something other than 16MHz
-F_CPU = 16000000
-
-UPLOAD_RATE = 115200
-AVRDUDE_PROGRAMMER = arduino
-PORT = /dev/arduino
 
 TARGET = $(notdir $(CURDIR))
 
@@ -76,25 +188,32 @@ TARGET = $(notdir $(CURDIR))
 # directory is added here
 
 VPATH = .
-VPATH += applet
+VPATH += $(BUILD_DIR)
 VPATH += $(HARDWARE_SRC)
-VPATH += $(ARDUINO)
-VPATH += $(INSTALL_DIR)/libraries/LiquidCrystal
-
-############################################################################
-# Below here nothing should be changed...
-
-AVR_TOOLS_PATH = 
-SRC =  pins_arduino.c wiring.c \
+VPATH += $(ARDUINO_INSTALL_DIR)/libraries/LiquidCrystal
+VPATH += $(ARDUINO_INSTALL_DIR)/libraries/SPI
+ifeq ($(HARDWARE_VARIANT), arduino)
+HARDWARE_SUB_VARIANT ?= mega
+VPATH += $(ARDUINO_INSTALL_DIR)/hardware/arduino/variants/$(HARDWARE_SUB_VARIANT)
+endif
+SRC = wiring.c \
 	wiring_analog.c wiring_digital.c \
 	wiring_pulse.c \
 	wiring_shift.c WInterrupts.c
-CXXSRC = WMath.cpp WString.cpp Print.cpp \
-	Marlin.cpp MarlinSerial.cpp Sd2Card.cpp SdBaseFile.cpp \
-	SdFatUtil.cpp SdFile.cpp SdVolume.cpp motion_control.cpp \
-	planner.cpp stepper.cpp temperature.cpp cardreader.cpp
-#CXXSRC += LiquidCrystal.cpp ultralcd.cpp
-#CXXSRC += ultralcd.cpp
+CXXSRC = WMath.cpp WString.cpp Print.cpp Marlin_main.cpp	\
+	MarlinSerial.cpp Sd2Card.cpp SdBaseFile.cpp SdFatUtil.cpp	\
+	SdFile.cpp SdVolume.cpp motion_control.cpp planner.cpp		\
+	stepper.cpp temperature.cpp cardreader.cpp ConfigurationStore.cpp \
+	watchdog.cpp
+CXXSRC += LiquidCrystal.cpp ultralcd.cpp SPI.cpp
+
+#Check for Arduino 1.0.0 or higher and use the correct sourcefiles for that version
+ifeq ($(shell [ $(ARDUINO_VERSION) -ge 100 ] && echo true), true)
+CXXSRC += main.cpp
+else
+SRC += pins_arduino.c main.c
+endif
+
 FORMAT = ihex
 
 # Name of this Makefile (used for "make depend").
@@ -107,9 +226,29 @@ DEBUG = stabs
 
 OPT = s
 
+DEFINES ?=
+
+# Program settings
+CC = $(AVR_TOOLS_PATH)avr-gcc
+CXX = $(AVR_TOOLS_PATH)avr-g++
+OBJCOPY = $(AVR_TOOLS_PATH)avr-objcopy
+OBJDUMP = $(AVR_TOOLS_PATH)avr-objdump
+AR  = $(AVR_TOOLS_PATH)avr-ar
+SIZE = $(AVR_TOOLS_PATH)avr-size
+NM = $(AVR_TOOLS_PATH)avr-nm
+AVRDUDE = avrdude
+REMOVE = rm -f
+MV = mv -f
+
 # Place -D or -U options here
-CDEFS = -DF_CPU=$(F_CPU)
-CXXDEFS = -DF_CPU=$(F_CPU)
+CDEFS    = -DF_CPU=$(F_CPU) ${addprefix -D , $(DEFINES)}
+CXXDEFS  = $(CDEFS)
+
+ifeq ($(HARDWARE_VARIANT), Teensy)
+CDEFS  += -DUSB_SERIAL
+SRC    += usb.c pins_teensy.c
+CXXSRC += usb_api.cpp
+endif
 
 # Add all the source directories as include directories too
 CINCS = ${addprefix -I ,${VPATH}}
@@ -125,41 +264,29 @@ CDEBUG = -g$(DEBUG)
 CWARN = -Wall -Wstrict-prototypes
 CTUNING = -funsigned-char -funsigned-bitfields -fpack-struct \
 	-fshort-enums -w -ffunction-sections -fdata-sections \
-	-DARDUINO=22
-ifneq (${HARDWARE_MOTHERBOARD},)
+	-DARDUINO=$(ARDUINO_VERSION)
+ifneq ($(HARDWARE_MOTHERBOARD),)
 CTUNING += -DMOTHERBOARD=${HARDWARE_MOTHERBOARD}
 endif
 #CEXTRA = -Wa,-adhlns=$(<:.c=.lst)
 
-CFLAGS = $(CDEBUG) $(CDEFS) $(CINCS) -O$(OPT) $(CWARN) $(CEXTRA) $(CTUNING)
-CXXFLAGS =         $(CDEFS) $(CINCS) -O$(OPT) -Wall    $(CEXTRA) $(CTUNING)
-#ASFLAGS = -Wa,-adhlns=$(<:.S=.lst),-gstabs 
+CFLAGS := $(CDEBUG) $(CDEFS) $(CINCS) -O$(OPT) $(CWARN) $(CEXTRA) $(CTUNING)
+CXXFLAGS :=         $(CDEFS) $(CINCS) -O$(OPT) -Wall    $(CEXTRA) $(CTUNING)
+#ASFLAGS = -Wa,-adhlns=$(<:.S=.lst),-gstabs
 LDFLAGS = -lm
 
 
 # Programming support using avrdude. Settings and variables.
-AVRDUDE_PORT = $(PORT)
-AVRDUDE_WRITE_FLASH = -U flash:w:applet/$(TARGET).hex:i
-AVRDUDE_FLAGS = -D -C $(INSTALL_DIR)/hardware/tools/avrdude.conf \
+AVRDUDE_PORT = $(UPLOAD_PORT)
+AVRDUDE_WRITE_FLASH = -U flash:w:$(BUILD_DIR)/$(TARGET).hex:i
+AVRDUDE_FLAGS = -D -C $(ARDUINO_INSTALL_DIR)/hardware/tools/avrdude.conf \
 	-p $(MCU) -P $(AVRDUDE_PORT) -c $(AVRDUDE_PROGRAMMER) \
 	-b $(UPLOAD_RATE)
 
-# Program settings
-CC = $(AVR_TOOLS_PATH)avr-gcc
-CXX = $(AVR_TOOLS_PATH)avr-g++
-OBJCOPY = $(AVR_TOOLS_PATH)avr-objcopy
-OBJDUMP = $(AVR_TOOLS_PATH)avr-objdump
-AR  = $(AVR_TOOLS_PATH)avr-ar
-SIZE = $(AVR_TOOLS_PATH)avr-size
-NM = $(AVR_TOOLS_PATH)avr-nm
-AVRDUDE = avrdude
-REMOVE = rm -f
-MV = mv -f
-
 # Define all object files.
-OBJ = ${patsubst %.c, applet/%.o, ${SRC}}
-OBJ += ${patsubst %.cpp, applet/%.o, ${CXXSRC}}
-OBJ += ${patsubst %.S, applet/%.o, ${ASRC}}
+OBJ = ${patsubst %.c, $(BUILD_DIR)/%.o, ${SRC}}
+OBJ += ${patsubst %.cpp, $(BUILD_DIR)/%.o, ${CXXSRC}}
+OBJ += ${patsubst %.S, $(BUILD_DIR)/%.o, ${ASRC}}
 
 # Define all listing files.
 LST = $(ASRC:.S=.lst) $(CXXSRC:.cpp=.lst) $(SRC:.c=.lst)
@@ -182,52 +309,38 @@ endif
 # Default target.
 all: sizeafter
 
-build: applet elf hex 
+build: $(BUILD_DIR) elf hex 
 
 # Creates the object directory
-applet: 
-	$P mkdir -p applet
-
-# the .cpp for Marlin depends on the .pde
-#applet/$(TARGET).cpp: $(TARGET).pde
-# ..and the .o depends from the .cpp
-#applet/%.o: applet/%.cpp
-
-applet/%.cpp: %.pde $(MAKEFILE)
-# Here is the "preprocessing".
-# It creates a .cpp file based with the same name as the .pde file.
-# On top of the new .cpp file comes the WProgram.h header.
-	$(Pecho) "  WR    $@"
-	$P echo '#include "WProgram.h"' > $@
-	$P echo '#include "$<"' >>$@
-	$P echo '#include "$(ARDUINO)/main.cpp"' >> $@
-
-elf: applet/$(TARGET).elf
-hex: applet/$(TARGET).hex
-eep: applet/$(TARGET).eep
-lss: applet/$(TARGET).lss 
-sym: applet/$(TARGET).sym
+$(BUILD_DIR): 
+	$P mkdir -p $(BUILD_DIR)
+
+elf: $(BUILD_DIR)/$(TARGET).elf
+hex: $(BUILD_DIR)/$(TARGET).hex
+eep: $(BUILD_DIR)/$(TARGET).eep
+lss: $(BUILD_DIR)/$(TARGET).lss 
+sym: $(BUILD_DIR)/$(TARGET).sym
 
 # Program the device.  
 # Do not try to reset an arduino if it's not one
-upload: applet/$(TARGET).hex
+upload: $(BUILD_DIR)/$(TARGET).hex
 ifeq (${AVRDUDE_PROGRAMMER}, arduino)
-	stty hup < $(PORT); true
+	stty hup < $(UPLOAD_PORT); true
 endif
 	$(AVRDUDE) $(AVRDUDE_FLAGS) $(AVRDUDE_WRITE_FLASH)
 ifeq (${AVRDUDE_PROGRAMMER}, arduino)
-	stty -hup < $(PORT); true
+	stty -hup < $(UPLOAD_PORT); true
 endif
 
 	# Display size of file.
-HEXSIZE = $(SIZE) --target=$(FORMAT) applet/$(TARGET).hex
-ELFSIZE = $(SIZE) --mcu=$(MCU) -C applet/$(TARGET).elf; \
-          $(SIZE)  applet/$(TARGET).elf
+HEXSIZE = $(SIZE) --target=$(FORMAT) $(BUILD_DIR)/$(TARGET).hex
+ELFSIZE = $(SIZE) --mcu=$(MCU) -C $(BUILD_DIR)/$(TARGET).elf; \
+          $(SIZE)  $(BUILD_DIR)/$(TARGET).elf
 sizebefore:
-	$P if [ -f applet/$(TARGET).elf ]; then echo; echo $(MSG_SIZE_BEFORE); $(HEXSIZE); echo; fi
+	$P if [ -f $(BUILD_DIR)/$(TARGET).elf ]; then echo; echo $(MSG_SIZE_BEFORE); $(HEXSIZE); echo; fi
 
 sizeafter: build
-	$P if [ -f applet/$(TARGET).elf ]; then echo; echo $(MSG_SIZE_AFTER); $(ELFSIZE); echo; fi
+	$P if [ -f $(BUILD_DIR)/$(TARGET).elf ]; then echo; echo $(MSG_SIZE_AFTER); $(ELFSIZE); echo; fi
 
 
 # Convert ELF to COFF for use in debugging / simulating in AVR Studio or VMLAB.
@@ -238,12 +351,12 @@ COFFCONVERT=$(OBJCOPY) --debugging \
 	--change-section-address .eeprom-0x810000 
 
 
-coff: applet/$(TARGET).elf
-	$(COFFCONVERT) -O coff-avr applet/$(TARGET).elf $(TARGET).cof
+coff: $(BUILD_DIR)/$(TARGET).elf
+	$(COFFCONVERT) -O coff-avr $(BUILD_DIR)/$(TARGET).elf $(TARGET).cof
 
 
 extcoff: $(TARGET).elf
-	$(COFFCONVERT) -O coff-ext-avr applet/$(TARGET).elf $(TARGET).cof
+	$(COFFCONVERT) -O coff-ext-avr $(BUILD_DIR)/$(TARGET).elf $(TARGET).cof
 
 
 .SUFFIXES: .elf .hex .eep .lss .sym
@@ -266,33 +379,34 @@ extcoff: $(TARGET).elf
 	$(NM) -n $< > $@
 
 	# Link: create ELF output file from library.
-applet/$(TARGET).elf: applet/$(TARGET).cpp applet/core.a Configuration.h
+$(BUILD_DIR)/$(TARGET).elf: $(OBJ) Configuration.h
 	$(Pecho) "  CXX   $@"
-	$P $(CC) $(ALL_CXXFLAGS) -Wl,--gc-sections -o $@ applet/$(TARGET).cpp -L. applet/core.a $(LDFLAGS)
-
-applet/core.a: $(OBJ)
-	$P for i in $(OBJ); do echo "  AR    $$i"; $(AR) rcs applet/core.a $$i; done
+	$P $(CC) $(ALL_CXXFLAGS) -Wl,--gc-sections -o $@ -L. $(OBJ) $(LDFLAGS)
 
-applet/%.o: %.c Configuration.h Configuration_adv.h $(MAKEFILE)
-	$(Pecho) "  CC    $@"
+$(BUILD_DIR)/%.o: %.c Configuration.h Configuration_adv.h $(MAKEFILE)
+	$(Pecho) "  CC    $<"
 	$P $(CC) -MMD -c $(ALL_CFLAGS) $< -o $@
 
-applet/%.o: %.cpp Configuration.h Configuration_adv.h $(MAKEFILE)
-	$(Pecho) "  CXX   $@"
+$(BUILD_DIR)/%.o: $(BUILD_DIR)/%.cpp Configuration.h Configuration_adv.h $(MAKEFILE)
+	$(Pecho) "  CXX   $<"
+	$P $(CXX) -MMD -c $(ALL_CXXFLAGS) $< -o $@
+
+$(BUILD_DIR)/%.o: %.cpp Configuration.h Configuration_adv.h $(MAKEFILE)
+	$(Pecho) "  CXX   $<"
 	$P $(CXX) -MMD -c $(ALL_CXXFLAGS) $< -o $@
 
 
 # Target: clean project.
 clean:
-	$(Pecho) "  RM    applet/*"
-	$P $(REMOVE) applet/$(TARGET).hex applet/$(TARGET).eep applet/$(TARGET).cof applet/$(TARGET).elf \
-		applet/$(TARGET).map applet/$(TARGET).sym applet/$(TARGET).lss applet/$(TARGET).cpp applet/core.a \
+	$(Pecho) "  RM    $(BUILD_DIR)/*"
+	$P $(REMOVE) $(BUILD_DIR)/$(TARGET).hex $(BUILD_DIR)/$(TARGET).eep $(BUILD_DIR)/$(TARGET).cof $(BUILD_DIR)/$(TARGET).elf \
+		$(BUILD_DIR)/$(TARGET).map $(BUILD_DIR)/$(TARGET).sym $(BUILD_DIR)/$(TARGET).lss $(BUILD_DIR)/$(TARGET).cpp \
 		$(OBJ) $(LST) $(SRC:.c=.s) $(SRC:.c=.d) $(CXXSRC:.cpp=.s) $(CXXSRC:.cpp=.d)
-	$(Pecho) "  RMDIR applet/"
-	$P rm -rf applet
+	$(Pecho) "  RMDIR $(BUILD_DIR)/"
+	$P rm -rf $(BUILD_DIR)
 
 
-.PHONY:	all build elf hex eep lss sym program coff extcoff clean depend applet_files sizebefore sizeafter
+.PHONY:	all build elf hex eep lss sym program coff extcoff clean depend sizebefore sizeafter
 
 # Automaticaly include the dependency files created by gcc
--include ${wildcard applet/*.d}
+-include ${wildcard $(BUILD_DIR)/*.d}
diff --git a/Marlin/Marlin.h b/Marlin/Marlin.h
index 5b59885..c81c95e 100644
--- a/Marlin/Marlin.h
+++ b/Marlin/Marlin.h
@@ -4,8 +4,6 @@
 #ifndef MARLIN_H
 #define MARLIN_H
 
-#define  HardwareSerial_h // trick to disable the standard HWserial
-
 #define  FORCE_INLINE __attribute__((always_inline)) inline
 
 #include <math.h>
@@ -17,22 +15,23 @@
 #include <util/delay.h>
 #include <avr/pgmspace.h>
 #include <avr/eeprom.h>
-#include  <avr/wdt.h>
-#include  <avr/interrupt.h>
+#include <avr/interrupt.h>
 
 
 #include "fastio.h"
 #include "Configuration.h"
 #include "pins.h"
 
-#if ARDUINO >= 100 
-  #if defined(__AVR_ATmega644P__)
-    #include "WProgram.h"
-  #else
-    #include "Arduino.h"
-  #endif
+#ifndef AT90USB
+#define  HardwareSerial_h // trick to disable the standard HWserial
+#endif
+
+#if (ARDUINO >= 100) && !defined(__AVR_ATmega644P__)
+# include "Arduino.h"
 #else
-   #include "WProgram.h"
+# include "WProgram.h"
+  //Arduino < 1.0.0 does not define this, so we need to do it ourselfs
+# define analogInputToDigitalPin(p) ((p) + A0)
 #endif
 
 #include "MarlinSerial.h"
@@ -46,28 +45,17 @@
 
 #include "WString.h"
 
-#if MOTHERBOARD == 8  // Teensylu
+#ifdef AT90USB
   #define MYSERIAL Serial
 #else
   #define MYSERIAL MSerial
 #endif
 
-//this is a unfinsihed attemp to removes a lot of warning messages, see:
-// http://www.avrfreaks.net/index.php?name=PNphpBB2&file=printview&t=57011
-//typedef char prog_char PROGMEM; 
-// //#define PSTR    (s )        ((const PROGMEM char *)(s))
-// //# define MYPGM(s) (__extension__({static prog_char __c[] = (s); &__c[0];})) 
-// //#define MYPGM(s) ((const prog_char *g PROGMEM=s))
-#define MYPGM(s) PSTR(s)
-//#define MYPGM(s)  (__extension__({static char __c[] __attribute__((__progmem__)) = (s); &__c[0];}))  //This is the normal behaviour
-//#define MYPGM(s)  (__extension__({static prog_char __c[]  = (s); &__c[0];})) //this does not work but hides the warnings
-
-
 #define SERIAL_PROTOCOL(x) MYSERIAL.print(x);
 #define SERIAL_PROTOCOL_F(x,y) MYSERIAL.print(x,y);
-#define SERIAL_PROTOCOLPGM(x) serialprintPGM(MYPGM(x));
+#define SERIAL_PROTOCOLPGM(x) serialprintPGM(PSTR(x));
 #define SERIAL_PROTOCOLLN(x) {MYSERIAL.print(x);MYSERIAL.write('\n');}
-#define SERIAL_PROTOCOLLNPGM(x) {serialprintPGM(MYPGM(x));MYSERIAL.write('\n');}
+#define SERIAL_PROTOCOLLNPGM(x) {serialprintPGM(PSTR(x));MYSERIAL.write('\n');}
 
 
 const char errormagic[] PROGMEM ="Error:";
@@ -92,7 +80,6 @@ void serial_echopair_P(const char *s_P, unsigned long v);
 
 
 //things to write to serial from Programmemory. saves 400 to 2k of RAM.
-#define SerialprintPGM(x) serialprintPGM(MYPGM(x))
 FORCE_INLINE void serialprintPGM(const char *str)
 {
   char ch=pgm_read_byte(str);
@@ -177,6 +164,7 @@ void Stop();
 bool IsStopped();
 
 void enquecommand(const char *cmd); //put an ascii command at the end of the current buffer.
+void enquecommand_P(const char *cmd); //put an ascii command at the end of the current buffer, read from flash
 void prepare_arc_move(char isclockwise);
 void clamp_to_software_endstops(float target[3]);
 
@@ -191,11 +179,23 @@ void setPwmFrequency(uint8_t pin, int val);
 
 extern float homing_feedrate[];
 extern bool axis_relative_modes[];
+extern int feedmultiply;
+extern int extrudemultiply; // Sets extrude multiply factor (in percent)
 extern float current_position[NUM_AXIS] ;
 extern float add_homeing[3];
 extern float min_pos[3];
 extern float max_pos[3];
-extern unsigned char FanSpeed;
+extern int fanSpeed;
+
+#ifdef FWRETRACT
+extern bool autoretract_enabled;
+extern bool retracted;
+extern float retract_length, retract_feedrate, retract_zlift;
+extern float retract_recover_length, retract_recover_feedrate;
+#endif
+
+extern unsigned long starttime;
+extern unsigned long stoptime;
 
 // Handling multiple extruders pins
 extern uint8_t active_extruder;
diff --git a/Marlin/Marlin.pde b/Marlin/Marlin.pde
index 92ed8be..5cd646e 100644
--- a/Marlin/Marlin.pde
+++ b/Marlin/Marlin.pde
@@ -27,1811 +27,16 @@
     http://reprap.org/pipermail/reprap-dev/2011-May/003323.html
  */
 
-#include "Marlin.h"
+/* All the implementation is done in *.cpp files to get better compatibility with avr-gcc without the Arduino IDE */
+/* Use this file to help the Arduino IDE find which Arduino libraries are needed and to keep documentation on GCode */
 
-#include "ultralcd.h"
-#include "planner.h"
-#include "stepper.h"
-#include "temperature.h"
-#include "motion_control.h"
-#include "cardreader.h"
-#include "watchdog.h"
-#include "EEPROMwrite.h"
-#include "language.h"
-#include "pins_arduino.h"
+#include "Configuration.h"
+#include "pins.h"
 
-#define VERSION_STRING  "1.0.0"
-
-// look here for descriptions of gcodes: http://linuxcnc.org/handbook/gcode/g-code.html
-// http://objects.reprap.org/wiki/Mendel_User_Manual:_RepRapGCodes
-
-//Implemented Codes
-//-------------------
-// G0  -> G1
-// G1  - Coordinated Movement X Y Z E
-// G2  - CW ARC
-// G3  - CCW ARC
-// G4  - Dwell S<seconds> or P<milliseconds>
-// G10 - retract filament according to settings of M207
-// G11 - retract recover filament according to settings of M208
-// G28 - Home all Axis
-// G90 - Use Absolute Coordinates
-// G91 - Use Relative Coordinates
-// G92 - Set current position to cordinates given
-
-//RepRap M Codes
-// M0   - Unconditional stop - Wait for user to press a button on the LCD (Only if ULTRA_LCD is enabled)
-// M1   - Same as M0
-// M104 - Set extruder target temp
-// M105 - Read current temp
-// M106 - Fan on
-// M107 - Fan off
-// M109 - Wait for extruder current temp to reach target temp.
-// M114 - Display current position
-
-//Custom M Codes
-// M17  - Enable/Power all stepper motors
-// M18  - Disable all stepper motors; same as M84
-// M20  - List SD card
-// M21  - Init SD card
-// M22  - Release SD card
-// M23  - Select SD file (M23 filename.g)
-// M24  - Start/resume SD print
-// M25  - Pause SD print
-// M26  - Set SD position in bytes (M26 S12345)
-// M27  - Report SD print status
-// M28  - Start SD write (M28 filename.g)
-// M29  - Stop SD write
-// M30  - Delete file from SD (M30 filename.g)
-// M31  - Output time since last M109 or SD card start to serial
-// M42  - Change pin status via gcode
-// M80  - Turn on Power Supply
-// M81  - Turn off Power Supply
-// M82  - Set E codes absolute (default)
-// M83  - Set E codes relative while in Absolute Coordinates (G90) mode
-// M84  - Disable steppers until next move, 
-//        or use S<seconds> to specify an inactivity timeout, after which the steppers will be disabled.  S0 to disable the timeout.
-// M85  - Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
-// M92  - Set axis_steps_per_unit - same syntax as G92
-// M114 - Output current position to serial port 
-// M115	- Capabilities string
-// M117 - display message
-// M119 - Output Endstop status to serial port
-// M140 - Set bed target temp
-// M190 - Wait for bed current temp to reach target temp.
-// M200 - Set filament diameter
-// M201 - Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)
-// M202 - Set max acceleration in units/s^2 for travel moves (M202 X1000 Y1000) Unused in Marlin!!
-// M203 - Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in mm/sec
-// M204 - Set default acceleration: S normal moves T filament only moves (M204 S3000 T7000) im mm/sec^2  also sets minimum segment time in ms (B20000) to prevent buffer underruns and M20 minimum feedrate
-// M205 -  advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk, E=maximum E jerk
-// M206 - set additional homeing offset
-// M207 - set retract length S[positive mm] F[feedrate mm/sec] Z[additional zlift/hop]
-// M208 - set recover=unretract length S[positive mm surplus to the M207 S*] F[feedrate mm/sec]
-// M209 - S<1=true/0=false> enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.
-// M220 S<factor in percent>- set speed factor override percentage
-// M221 S<factor in percent>- set extrude factor override percentage
-// M240 - Trigger a camera to take a photograph
-// M301 - Set PID parameters P I and D
-// M302 - Allow cold extrudes
-// M303 - PID relay autotune S<temperature> sets the target temperature. (default target temperature = 150C)
-// M400 - Finish all moves
-// M500 - stores paramters in EEPROM
-// M501 - reads parameters from EEPROM (if you need reset them after you changed them temporarily).  
-// M502 - reverts to the default "factory settings".  You still need to store them in EEPROM afterwards if you want to.
-// M503 - print the current settings (from memory not from eeprom)
-// M999 - Restart after being stopped by error
-
-//Stepper Movement Variables
-
-//===========================================================================
-//=============================imported variables============================
-//===========================================================================
-
-
-//===========================================================================
-//=============================public variables=============================
-//===========================================================================
-#ifdef SDSUPPORT
-CardReader card;
-#endif
-float homing_feedrate[] = HOMING_FEEDRATE;
-bool axis_relative_modes[] = AXIS_RELATIVE_MODES;
-volatile int feedmultiply=100; //100->1 200->2
-int saved_feedmultiply;
-volatile bool feedmultiplychanged=false;
-volatile int extrudemultiply=100; //100->1 200->2
-float current_position[NUM_AXIS] = { 0.0, 0.0, 0.0, 0.0 };
-float add_homeing[3]={0,0,0};
-float min_pos[3] = { X_MIN_POS, Y_MIN_POS, Z_MIN_POS };
-float max_pos[3] = { X_MAX_POS, Y_MAX_POS, Z_MAX_POS };
-uint8_t active_extruder = 0;
-unsigned char FanSpeed=0;
-
-#ifdef FWRETRACT
-  bool autoretract_enabled=true;
-  bool retracted=false;
-  float retract_length=3, retract_feedrate=17*60, retract_zlift=0.8;
-  float retract_recover_length=0, retract_recover_feedrate=8*60;
-#endif
-
-//===========================================================================
-//=============================private variables=============================
-//===========================================================================
-const char axis_codes[NUM_AXIS] = {'X', 'Y', 'Z', 'E'};
-static float destination[NUM_AXIS] = {  0.0, 0.0, 0.0, 0.0};
-static float offset[3] = {0.0, 0.0, 0.0};
-static bool home_all_axis = true;
-static float feedrate = 1500.0, next_feedrate, saved_feedrate;
-static long gcode_N, gcode_LastN, Stopped_gcode_LastN = 0;
-
-static bool relative_mode = false;  //Determines Absolute or Relative Coordinates
-static bool relative_mode_e = false;  //Determines Absolute or Relative E Codes while in Absolute Coordinates mode. E is always relative in Relative Coordinates mode.
-
-static char cmdbuffer[BUFSIZE][MAX_CMD_SIZE];
-static bool fromsd[BUFSIZE];
-static int bufindr = 0;
-static int bufindw = 0;
-static int buflen = 0;
-//static int i = 0;
-static char serial_char;
-static int serial_count = 0;
-static boolean comment_mode = false;
-static char *strchr_pointer; // just a pointer to find chars in the cmd string like X, Y, Z, E, etc
-
-const int sensitive_pins[] = SENSITIVE_PINS; // Sensitive pin list for M42
-
-//static float tt = 0;
-//static float bt = 0;
-
-//Inactivity shutdown variables
-static unsigned long previous_millis_cmd = 0;
-static unsigned long max_inactive_time = 0;
-static unsigned long stepper_inactive_time = DEFAULT_STEPPER_DEACTIVE_TIME*1000l;
-
-static unsigned long starttime=0;
-static unsigned long stoptime=0;
-
-static uint8_t tmp_extruder;
-
-
-bool Stopped=false;
-
-//===========================================================================
-//=============================ROUTINES=============================
-//===========================================================================
-
-void get_arc_coordinates();
-bool setTargetedHotend(int code);
-
-void serial_echopair_P(const char *s_P, float v)
-    { serialprintPGM(s_P); SERIAL_ECHO(v); }
-void serial_echopair_P(const char *s_P, double v)
-    { serialprintPGM(s_P); SERIAL_ECHO(v); }
-void serial_echopair_P(const char *s_P, unsigned long v)
-    { serialprintPGM(s_P); SERIAL_ECHO(v); }
-
-extern "C"{
-  extern unsigned int __bss_end;
-  extern unsigned int __heap_start;
-  extern void *__brkval;
-
-  int freeMemory() {
-    int free_memory;
-
-    if((int)__brkval == 0)
-      free_memory = ((int)&free_memory) - ((int)&__bss_end);
-    else
-      free_memory = ((int)&free_memory) - ((int)__brkval);
-
-    return free_memory;
-  }
-}
-
-//adds an command to the main command buffer
-//thats really done in a non-safe way.
-//needs overworking someday
-void enquecommand(const char *cmd)
-{
-  if(buflen < BUFSIZE)
-  {
-    //this is dangerous if a mixing of serial and this happsens
-    strcpy(&(cmdbuffer[bufindw][0]),cmd);
-    SERIAL_ECHO_START;
-    SERIAL_ECHOPGM("enqueing \"");
-    SERIAL_ECHO(cmdbuffer[bufindw]);
-    SERIAL_ECHOLNPGM("\"");
-    bufindw= (bufindw + 1)%BUFSIZE;
-    buflen += 1;
-  }
-}
-
-void setup_killpin()
-{
-  #if( KILL_PIN>-1 )
-    pinMode(KILL_PIN,INPUT);
-    WRITE(KILL_PIN,HIGH);
-  #endif
-}
-    
-void setup_photpin()
-{
-  #ifdef PHOTOGRAPH_PIN
-    #if (PHOTOGRAPH_PIN > -1)
-    SET_OUTPUT(PHOTOGRAPH_PIN);
-    WRITE(PHOTOGRAPH_PIN, LOW);
-    #endif
-  #endif 
-}
-
-void setup_powerhold()
-{
- #ifdef SUICIDE_PIN
-   #if (SUICIDE_PIN> -1)
-      SET_OUTPUT(SUICIDE_PIN);
-      WRITE(SUICIDE_PIN, HIGH);
-   #endif
- #endif
-}
-
-void suicide()
-{
- #ifdef SUICIDE_PIN
-    #if (SUICIDE_PIN> -1) 
-      SET_OUTPUT(SUICIDE_PIN);
-      WRITE(SUICIDE_PIN, LOW);
-    #endif
-  #endif
-}
-
-void setup()
-{
-  setup_killpin(); 
-  setup_powerhold();
-  MYSERIAL.begin(BAUDRATE);
-  SERIAL_PROTOCOLLNPGM("start");
-  SERIAL_ECHO_START;
-
-  // Check startup - does nothing if bootloader sets MCUSR to 0
-  byte mcu = MCUSR;
-  if(mcu & 1) SERIAL_ECHOLNPGM(MSG_POWERUP);
-  if(mcu & 2) SERIAL_ECHOLNPGM(MSG_EXTERNAL_RESET);
-  if(mcu & 4) SERIAL_ECHOLNPGM(MSG_BROWNOUT_RESET);
-  if(mcu & 8) SERIAL_ECHOLNPGM(MSG_WATCHDOG_RESET);
-  if(mcu & 32) SERIAL_ECHOLNPGM(MSG_SOFTWARE_RESET);
-  MCUSR=0;
-
-  SERIAL_ECHOPGM(MSG_MARLIN);
-  SERIAL_ECHOLNPGM(VERSION_STRING);
-  #ifdef STRING_VERSION_CONFIG_H
-    #ifdef STRING_CONFIG_H_AUTHOR
-      SERIAL_ECHO_START;
-      SERIAL_ECHOPGM(MSG_CONFIGURATION_VER);
-      SERIAL_ECHOPGM(STRING_VERSION_CONFIG_H);
-      SERIAL_ECHOPGM(MSG_AUTHOR);
-      SERIAL_ECHOLNPGM(STRING_CONFIG_H_AUTHOR);
-    #endif
-  #endif
-  SERIAL_ECHO_START;
-  SERIAL_ECHOPGM(MSG_FREE_MEMORY);
-  SERIAL_ECHO(freeMemory());
-  SERIAL_ECHOPGM(MSG_PLANNER_BUFFER_BYTES);
-  SERIAL_ECHOLN((int)sizeof(block_t)*BLOCK_BUFFER_SIZE);
-  for(int8_t i = 0; i < BUFSIZE; i++)
-  {
-    fromsd[i] = false;
-  }
-  
-  EEPROM_RetrieveSettings(); // loads data from EEPROM if available
-
-  for(int8_t i=0; i < NUM_AXIS; i++)
-  {
-    axis_steps_per_sqr_second[i] = max_acceleration_units_per_sq_second[i] * axis_steps_per_unit[i];
-  }
-
-
-  tp_init();    // Initialize temperature loop 
-  plan_init();  // Initialize planner;
-  st_init();    // Initialize stepper;
-  wd_init();
-  setup_photpin();
-  
-  LCD_INIT;
-}
-
-
-void loop()
-{
-  if(buflen < (BUFSIZE-1))
-    get_command();
-  #ifdef SDSUPPORT
-  card.checkautostart(false);
-  #endif
-  if(buflen)
-  {
-    #ifdef SDSUPPORT
-      if(card.saving)
-      {
-	if(strstr(cmdbuffer[bufindr],"M29") == NULL)
-	{
-	  card.write_command(cmdbuffer[bufindr]);
-	  SERIAL_PROTOCOLLNPGM(MSG_OK);
-	}
-	else
-	{
-	  card.closefile();
-	  SERIAL_PROTOCOLLNPGM(MSG_FILE_SAVED);
-	}
-      }
-      else
-      {
-	process_commands();
-      }
-    #else
-      process_commands();
-    #endif //SDSUPPORT
-    buflen = (buflen-1);
-    bufindr = (bufindr + 1)%BUFSIZE;
-  }
-  //check heater every n milliseconds
-  manage_heater();
-  manage_inactivity();
-  checkHitEndstops();
-  LCD_STATUS;
-}
-
-void get_command() 
-{ 
-  while( MYSERIAL.available() > 0  && buflen < BUFSIZE) {
-    serial_char = MYSERIAL.read();
-    if(serial_char == '\n' || 
-       serial_char == '\r' || 
-       (serial_char == ':' && comment_mode == false) || 
-       serial_count >= (MAX_CMD_SIZE - 1) ) 
-    {
-      if(!serial_count) { //if empty line
-        comment_mode = false; //for new command
-        return;
-      }
-      cmdbuffer[bufindw][serial_count] = 0; //terminate string
-      if(!comment_mode){
-        comment_mode = false; //for new command
-        fromsd[bufindw] = false;
-        if(strstr(cmdbuffer[bufindw], "N") != NULL)
-        {
-          strchr_pointer = strchr(cmdbuffer[bufindw], 'N');
-          gcode_N = (strtol(&cmdbuffer[bufindw][strchr_pointer - cmdbuffer[bufindw] + 1], NULL, 10));
-          if(gcode_N != gcode_LastN+1 && (strstr(cmdbuffer[bufindw], "M110") == NULL) ) {
-            SERIAL_ERROR_START;
-            SERIAL_ERRORPGM(MSG_ERR_LINE_NO);
-            SERIAL_ERRORLN(gcode_LastN);
-            //Serial.println(gcode_N);
-            FlushSerialRequestResend();
-            serial_count = 0;
-            return;
-          }
-
-          if(strstr(cmdbuffer[bufindw], "*") != NULL)
-          {
-            byte checksum = 0;
-            byte count = 0;
-            while(cmdbuffer[bufindw][count] != '*') checksum = checksum^cmdbuffer[bufindw][count++];
-            strchr_pointer = strchr(cmdbuffer[bufindw], '*');
-
-            if( (int)(strtod(&cmdbuffer[bufindw][strchr_pointer - cmdbuffer[bufindw] + 1], NULL)) != checksum) {
-              SERIAL_ERROR_START;
-              SERIAL_ERRORPGM(MSG_ERR_CHECKSUM_MISMATCH);
-              SERIAL_ERRORLN(gcode_LastN);
-              FlushSerialRequestResend();
-              serial_count = 0;
-              return;
-            }
-            //if no errors, continue parsing
-          }
-          else 
-          {
-            SERIAL_ERROR_START;
-            SERIAL_ERRORPGM(MSG_ERR_NO_CHECKSUM);
-            SERIAL_ERRORLN(gcode_LastN);
-            FlushSerialRequestResend();
-            serial_count = 0;
-            return;
-          }
-
-          gcode_LastN = gcode_N;
-          //if no errors, continue parsing
-        }
-        else  // if we don't receive 'N' but still see '*'
-        {
-          if((strstr(cmdbuffer[bufindw], "*") != NULL))
-          {
-            SERIAL_ERROR_START;
-            SERIAL_ERRORPGM(MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM);
-            SERIAL_ERRORLN(gcode_LastN);
-            serial_count = 0;
-            return;
-          }
-        }
-        if((strstr(cmdbuffer[bufindw], "G") != NULL)){
-          strchr_pointer = strchr(cmdbuffer[bufindw], 'G');
-          switch((int)((strtod(&cmdbuffer[bufindw][strchr_pointer - cmdbuffer[bufindw] + 1], NULL)))){
-          case 0:
-          case 1:
-          case 2:
-          case 3:
-            if(Stopped == false) { // If printer is stopped by an error the G[0-3] codes are ignored.
-	      #ifdef SDSUPPORT
-              if(card.saving)
-                break;
-	      #endif //SDSUPPORT
-              SERIAL_PROTOCOLLNPGM(MSG_OK); 
-            }
-            else {
-              SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
-              LCD_MESSAGEPGM(MSG_STOPPED);
-            }
-            break;
-          default:
-            break;
-          }
-
-        }
-        bufindw = (bufindw + 1)%BUFSIZE;
-        buflen += 1;
-      }
-      serial_count = 0; //clear buffer
-    }
-    else
-    {
-      if(serial_char == ';') comment_mode = true;
-      if(!comment_mode) cmdbuffer[bufindw][serial_count++] = serial_char;
-    }
-  }
-  #ifdef SDSUPPORT
-  if(!card.sdprinting || serial_count!=0){
-    return;
-  }
-  while( !card.eof()  && buflen < BUFSIZE) {
-    int16_t n=card.get();
-    serial_char = (char)n;
-    if(serial_char == '\n' || 
-       serial_char == '\r' || 
-       (serial_char == ':' && comment_mode == false) || 
-       serial_count >= (MAX_CMD_SIZE - 1)||n==-1) 
-    {
-      if(card.eof()){
-        SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);
-        stoptime=millis();
-        char time[30];
-        unsigned long t=(stoptime-starttime)/1000;
-        int sec,min;
-        min=t/60;
-        sec=t%60;
-        sprintf(time,"%i min, %i sec",min,sec);
-        SERIAL_ECHO_START;
-        SERIAL_ECHOLN(time);
-        LCD_MESSAGE(time);
-        card.printingHasFinished();
-        card.checkautostart(true);
-        
-      }
-      if(!serial_count)
-      {
-        comment_mode = false; //for new command
-        return; //if empty line
-      }
-      cmdbuffer[bufindw][serial_count] = 0; //terminate string
-//      if(!comment_mode){
-        fromsd[bufindw] = true;
-        buflen += 1;
-        bufindw = (bufindw + 1)%BUFSIZE;
-//      }     
-      comment_mode = false; //for new command
-      serial_count = 0; //clear buffer
-    }
-    else
-    {
-      if(serial_char == ';') comment_mode = true;
-      if(!comment_mode) cmdbuffer[bufindw][serial_count++] = serial_char;
-    }
-  }
-  
-  #endif //SDSUPPORT
-
-}
-
-
-float code_value() 
-{ 
-  return (strtod(&cmdbuffer[bufindr][strchr_pointer - cmdbuffer[bufindr] + 1], NULL)); 
-}
-
-long code_value_long() 
-{ 
-  return (strtol(&cmdbuffer[bufindr][strchr_pointer - cmdbuffer[bufindr] + 1], NULL, 10)); 
-}
-
-bool code_seen(char code_string[]) //Return True if the string was found
-{ 
-  return (strstr(cmdbuffer[bufindr], code_string) != NULL); 
-}  
-
-bool code_seen(char code)
-{
-  strchr_pointer = strchr(cmdbuffer[bufindr], code);
-  return (strchr_pointer != NULL);  //Return True if a character was found
-}
-
-#define DEFINE_PGM_READ_ANY(type, reader)		\
-    static inline type pgm_read_any(const type *p)	\
-	{ return pgm_read_##reader##_near(p); }
-
-DEFINE_PGM_READ_ANY(float,       float);
-DEFINE_PGM_READ_ANY(signed char, byte);
-
-#define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG)	\
-static const PROGMEM type array##_P[3] =		\
-    { X_##CONFIG, Y_##CONFIG, Z_##CONFIG };		\
-static inline type array(int axis)			\
-    { return pgm_read_any(&array##_P[axis]); }
-
-XYZ_CONSTS_FROM_CONFIG(float, base_min_pos,    MIN_POS);
-XYZ_CONSTS_FROM_CONFIG(float, base_max_pos,    MAX_POS);
-XYZ_CONSTS_FROM_CONFIG(float, base_home_pos,   HOME_POS);
-XYZ_CONSTS_FROM_CONFIG(float, max_length,      MAX_LENGTH);
-XYZ_CONSTS_FROM_CONFIG(float, home_retract_mm, HOME_RETRACT_MM);
-XYZ_CONSTS_FROM_CONFIG(signed char, home_dir,  HOME_DIR);
-
-static void axis_is_at_home(int axis) {
-  current_position[axis] = base_home_pos(axis) + add_homeing[axis];
-  min_pos[axis] =          base_min_pos(axis) + add_homeing[axis];
-  max_pos[axis] =          base_max_pos(axis) + add_homeing[axis];
-}
-
-static void homeaxis(int axis) {
-#define HOMEAXIS_DO(LETTER) \
-  ((LETTER##_MIN_PIN > -1 && LETTER##_HOME_DIR==-1) || (LETTER##_MAX_PIN > -1 && LETTER##_HOME_DIR==1))
-
-  if (axis==X_AXIS ? HOMEAXIS_DO(X) :
-      axis==Y_AXIS ? HOMEAXIS_DO(Y) :
-      axis==Z_AXIS ? HOMEAXIS_DO(Z) :
-      0) {
-    current_position[axis] = 0;
-    plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
-    destination[axis] = 1.5 * max_length(axis) * home_dir(axis);
-    feedrate = homing_feedrate[axis];
-    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
-    st_synchronize();
-   
-    current_position[axis] = 0;
-    plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
-    destination[axis] = -home_retract_mm(axis) * home_dir(axis);
-    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
-    st_synchronize();
-   
-    destination[axis] = 2*home_retract_mm(axis) * home_dir(axis);
-    feedrate = homing_feedrate[axis]/2 ; 
-    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
-    st_synchronize();
-   
-    axis_is_at_home(axis);					
-    destination[axis] = current_position[axis];
-    feedrate = 0.0;
-    endstops_hit_on_purpose();
-  }
-}
-#define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)
-
-void process_commands()
-{
-  unsigned long codenum; //throw away variable
-  char *starpos = NULL;
-
-  if(code_seen('G'))
-  {
-    switch((int)code_value())
-    {
-    case 0: // G0 -> G1
-    case 1: // G1
-      if(Stopped == false) {
-        get_coordinates(); // For X Y Z E F
-        prepare_move();
-        //ClearToSend();
-        return;
-      }
-      //break;
-    case 2: // G2  - CW ARC
-      if(Stopped == false) {
-        get_arc_coordinates();
-        prepare_arc_move(true);
-        return;
-      }
-    case 3: // G3  - CCW ARC
-      if(Stopped == false) {
-        get_arc_coordinates();
-        prepare_arc_move(false);
-        return;
-      }
-    case 4: // G4 dwell
-      LCD_MESSAGEPGM(MSG_DWELL);
-      codenum = 0;
-      if(code_seen('P')) codenum = code_value(); // milliseconds to wait
-      if(code_seen('S')) codenum = code_value() * 1000; // seconds to wait
-      
-      st_synchronize();
-      codenum += millis();  // keep track of when we started waiting
-      previous_millis_cmd = millis();
-      while(millis()  < codenum ){
-        manage_heater();
-        manage_inactivity();
-        LCD_STATUS;
-      }
-      break;
-      #ifdef FWRETRACT  
-      case 10: // G10 retract
-      if(!retracted) 
-      {
-        destination[X_AXIS]=current_position[X_AXIS];
-        destination[Y_AXIS]=current_position[Y_AXIS];
-        destination[Z_AXIS]=current_position[Z_AXIS]; 
-        current_position[Z_AXIS]+=-retract_zlift;
-        destination[E_AXIS]=current_position[E_AXIS]-retract_length; 
-        feedrate=retract_feedrate;
-        retracted=true;
-        prepare_move();
-      }
-      
-      break;
-      case 11: // G10 retract_recover
-      if(!retracted) 
-      {
-        destination[X_AXIS]=current_position[X_AXIS];
-        destination[Y_AXIS]=current_position[Y_AXIS];
-        destination[Z_AXIS]=current_position[Z_AXIS]; 
-        
-        current_position[Z_AXIS]+=retract_zlift;
-        current_position[E_AXIS]+=-retract_recover_length; 
-        feedrate=retract_recover_feedrate;
-        retracted=false;
-        prepare_move();
-      }
-      break;
-      #endif //FWRETRACT
-    case 28: //G28 Home all Axis one at a time
-      saved_feedrate = feedrate;
-      saved_feedmultiply = feedmultiply;
-      feedmultiply = 100;
-      previous_millis_cmd = millis();
-      
-      enable_endstops(true);
-      
-      for(int8_t i=0; i < NUM_AXIS; i++) {
-        destination[i] = current_position[i];
-      }
-      feedrate = 0.0;
-      home_all_axis = !((code_seen(axis_codes[0])) || (code_seen(axis_codes[1])) || (code_seen(axis_codes[2])));
-      
-      #if Z_HOME_DIR > 0                      // If homing away from BED do Z first
-      if((home_all_axis) || (code_seen(axis_codes[Z_AXIS]))) {
-        HOMEAXIS(Z);
-      }
-      #endif
-      
-      #ifdef QUICK_HOME
-      if((home_all_axis)||( code_seen(axis_codes[X_AXIS]) && code_seen(axis_codes[Y_AXIS])) )  //first diagonal move
-      {
-        current_position[X_AXIS] = 0;current_position[Y_AXIS] = 0;  
-
-        plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]); 
-        destination[X_AXIS] = 1.5 * X_MAX_LENGTH * X_HOME_DIR;destination[Y_AXIS] = 1.5 * Y_MAX_LENGTH * Y_HOME_DIR;  
-        feedrate = homing_feedrate[X_AXIS]; 
-        if(homing_feedrate[Y_AXIS]<feedrate)
-          feedrate =homing_feedrate[Y_AXIS]; 
-        plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
-        st_synchronize();
-    
-        axis_is_at_home(X_AXIS);
-        axis_is_at_home(Y_AXIS);
-        plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
-        destination[X_AXIS] = current_position[X_AXIS];
-        destination[Y_AXIS] = current_position[Y_AXIS];
-        plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
-        feedrate = 0.0;
-        st_synchronize();
-        endstops_hit_on_purpose();
-      }
-      #endif
-      
-      if((home_all_axis) || (code_seen(axis_codes[X_AXIS]))) 
-      {
-        HOMEAXIS(X);
-      }
-
-      if((home_all_axis) || (code_seen(axis_codes[Y_AXIS]))) {
-        HOMEAXIS(Y);
-      }
-      
-      #if Z_HOME_DIR < 0                      // If homing towards BED do Z last
-      if((home_all_axis) || (code_seen(axis_codes[Z_AXIS]))) {
-        HOMEAXIS(Z);
-      }
-      #endif
-      
-      if(code_seen(axis_codes[X_AXIS])) 
-      {
-        if(code_value_long() != 0) {
-          current_position[X_AXIS]=code_value()+add_homeing[0];
-        }
-      }
-
-      if(code_seen(axis_codes[Y_AXIS])) {
-        if(code_value_long() != 0) {
-          current_position[Y_AXIS]=code_value()+add_homeing[1];
-        }
-      }
-
-      if(code_seen(axis_codes[Z_AXIS])) {
-        if(code_value_long() != 0) {
-          current_position[Z_AXIS]=code_value()+add_homeing[2];
-        }
-      }
-      plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
-      
-      #ifdef ENDSTOPS_ONLY_FOR_HOMING
-        enable_endstops(false);
-      #endif
-      
-      feedrate = saved_feedrate;
-      feedmultiply = saved_feedmultiply;
-      previous_millis_cmd = millis();
-      endstops_hit_on_purpose();
-      break;
-    case 90: // G90
-      relative_mode = false;
-      break;
-    case 91: // G91
-      relative_mode = true;
-      break;
-    case 92: // G92
-      if(!code_seen(axis_codes[E_AXIS]))
-        st_synchronize();
-      for(int8_t i=0; i < NUM_AXIS; i++) {
-        if(code_seen(axis_codes[i])) { 
-           if(i == E_AXIS) {
-             current_position[i] = code_value();  
-             plan_set_e_position(current_position[E_AXIS]);
-           }
-           else {
-             current_position[i] = code_value()+add_homeing[i];  
-             plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
-           }
-        }
-      }
-      break;
-    }
-  }
-
-  else if(code_seen('M'))
-  {
-    switch( (int)code_value() ) 
-    {
 #ifdef ULTRA_LCD
-    case 0: // M0 - Unconditional stop - Wait for user button press on LCD
-    case 1: // M1 - Conditional stop - Wait for user button press on LCD
-    {
-      LCD_MESSAGEPGM(MSG_USERWAIT);
-      codenum = 0;
-      if(code_seen('P')) codenum = code_value(); // milliseconds to wait
-      if(code_seen('S')) codenum = code_value() * 1000; // seconds to wait
-      
-      st_synchronize();
-      previous_millis_cmd = millis();
-      if (codenum > 0){
-        codenum += millis();  // keep track of when we started waiting
-        while(millis()  < codenum && !CLICKED){
-          manage_heater();
-          manage_inactivity();
-          LCD_STATUS;
-        }
-      }else{
-        while(!CLICKED){
-          manage_heater();
-          manage_inactivity();
-          LCD_STATUS;
-        }
-      }
-    }
-    break;
-#endif
-    case 17:
-        LCD_MESSAGEPGM(MSG_NO_MOVE);
-        enable_x(); 
-        enable_y(); 
-        enable_z(); 
-        enable_e0(); 
-        enable_e1(); 
-        enable_e2(); 
-      break;
-
-#ifdef SDSUPPORT
-    case 20: // M20 - list SD card
-      SERIAL_PROTOCOLLNPGM(MSG_BEGIN_FILE_LIST);
-      card.ls();
-      SERIAL_PROTOCOLLNPGM(MSG_END_FILE_LIST);
-      break;
-    case 21: // M21 - init SD card
-      
-      card.initsd();
-      
-      break;
-    case 22: //M22 - release SD card
-      card.release();
-
-      break;
-    case 23: //M23 - Select file
-      starpos = (strchr(strchr_pointer + 4,'*'));
-      if(starpos!=NULL)
-        *(starpos-1)='\0';
-      card.openFile(strchr_pointer + 4,true);
-      break;
-    case 24: //M24 - Start SD print
-      card.startFileprint();
-      starttime=millis();
-      break;
-    case 25: //M25 - Pause SD print
-      card.pauseSDPrint();
-      break;
-    case 26: //M26 - Set SD index
-      if(card.cardOK && code_seen('S')) {
-        card.setIndex(code_value_long());
-      }
-      break;
-    case 27: //M27 - Get SD status
-      card.getStatus();
-      break;
-    case 28: //M28 - Start SD write
-      starpos = (strchr(strchr_pointer + 4,'*'));
-      if(starpos != NULL){
-        char* npos = strchr(cmdbuffer[bufindr], 'N');
-        strchr_pointer = strchr(npos,' ') + 1;
-        *(starpos-1) = '\0';
-      }
-      card.openFile(strchr_pointer+4,false);
-      break;
-    case 29: //M29 - Stop SD write
-      //processed in write to file routine above
-      //card,saving = false;
-      break;
-    case 30: //M30 <filename> Delete File 
-	if (card.cardOK){
-		card.closefile();
-		starpos = (strchr(strchr_pointer + 4,'*'));
-                if(starpos != NULL){
-                char* npos = strchr(cmdbuffer[bufindr], 'N');
-                strchr_pointer = strchr(npos,' ') + 1;
-                *(starpos-1) = '\0';
-         }
-	 card.removeFile(strchr_pointer + 4);
-	}
-	break;
-	
-#endif //SDSUPPORT
-
-    case 31: //M31 take time since the start of the SD print or an M109 command
-      {
-      stoptime=millis();
-      char time[30];
-      unsigned long t=(stoptime-starttime)/1000;
-      int sec,min;
-      min=t/60;
-      sec=t%60;
-      sprintf(time,"%i min, %i sec",min,sec);
-      SERIAL_ECHO_START;
-      SERIAL_ECHOLN(time);
-      LCD_MESSAGE(time);
-      autotempShutdown();
-      }
-      break;
-    case 42: //M42 -Change pin status via gcode
-      if (code_seen('S'))
-      {
-        int pin_status = code_value();
-        if (code_seen('P') && pin_status >= 0 && pin_status <= 255)
-        {
-          int pin_number = code_value();
-          for(int8_t i = 0; i < (int8_t)sizeof(sensitive_pins); i++)
-          {
-            if (sensitive_pins[i] == pin_number)
-            {
-              pin_number = -1;
-              break;
-            }
-          }
-          
-          if (pin_number > -1)
-          {              
-            pinMode(pin_number, OUTPUT);
-            digitalWrite(pin_number, pin_status);
-            analogWrite(pin_number, pin_status);
-          }
-        }
-      }
-     break;
-    case 104: // M104
-      if(setTargetedHotend(104)){
-        break;
-      }
-      if (code_seen('S')) setTargetHotend(code_value(), tmp_extruder);
-      setWatch();
-      break;
-    case 140: // M140 set bed temp
-      if (code_seen('S')) setTargetBed(code_value());
-      break;
-    case 105 : // M105
-      if(setTargetedHotend(105)){
-        break;
-      }
-      #if (TEMP_0_PIN > -1)
-        SERIAL_PROTOCOLPGM("ok T:");
-        SERIAL_PROTOCOL_F(degHotend(tmp_extruder),1); 
-        SERIAL_PROTOCOLPGM(" /");
-        SERIAL_PROTOCOL_F(degTargetHotend(tmp_extruder),1); 
-        #if TEMP_BED_PIN > -1
-          SERIAL_PROTOCOLPGM(" B:");  
-          SERIAL_PROTOCOL_F(degBed(),1);
-          SERIAL_PROTOCOLPGM(" /");
-          SERIAL_PROTOCOL_F(degTargetBed(),1);
-        #endif //TEMP_BED_PIN
-      #else
-        SERIAL_ERROR_START;
-        SERIAL_ERRORLNPGM(MSG_ERR_NO_THERMISTORS);
-      #endif
-      #ifdef PIDTEMP
-        SERIAL_PROTOCOLPGM(" @:");
-        SERIAL_PROTOCOL(getHeaterPower(tmp_extruder));  
-      #endif
-        SERIAL_PROTOCOLLN("");
-      return;
-      break;
-    case 109: 
-    {// M109 - Wait for extruder heater to reach target.
-      if(setTargetedHotend(109)){
-        break;
-      }
-      LCD_MESSAGEPGM(MSG_HEATING);   
-      #ifdef AUTOTEMP
-        autotemp_enabled=false;
-      #endif
-      if (code_seen('S')) setTargetHotend(code_value(), tmp_extruder);
-      #ifdef AUTOTEMP
-        if (code_seen('S')) autotemp_min=code_value();
-        if (code_seen('B')) autotemp_max=code_value();
-        if (code_seen('F')) 
-        {
-          autotemp_factor=code_value();
-          autotemp_enabled=true;
-        }
-      #endif
-      
-      setWatch();
-      codenum = millis(); 
-
-      /* See if we are heating up or cooling down */
-      bool target_direction = isHeatingHotend(tmp_extruder); // true if heating, false if cooling
-
-      #ifdef TEMP_RESIDENCY_TIME
-        long residencyStart;
-        residencyStart = -1;
-        /* continue to loop until we have reached the target temp   
-          _and_ until TEMP_RESIDENCY_TIME hasn't passed since we reached it */
-        while((residencyStart == -1) ||
-              (residencyStart >= 0 && (((unsigned int) (millis() - residencyStart)) < (TEMP_RESIDENCY_TIME * 1000UL))) ) {
-      #else
-        while ( target_direction ? (isHeatingHotend(tmp_extruder)) : (isCoolingHotend(tmp_extruder)&&(CooldownNoWait==false)) ) {
-      #endif //TEMP_RESIDENCY_TIME
-          if( (millis() - codenum) > 1000UL )
-          { //Print Temp Reading and remaining time every 1 second while heating up/cooling down
-            SERIAL_PROTOCOLPGM("T:");
-            SERIAL_PROTOCOL_F(degHotend(tmp_extruder),1); 
-            SERIAL_PROTOCOLPGM(" E:");
-            SERIAL_PROTOCOL((int)tmp_extruder); 
-            #ifdef TEMP_RESIDENCY_TIME
-              SERIAL_PROTOCOLPGM(" W:");
-              if(residencyStart > -1)
-              {
-                 codenum = ((TEMP_RESIDENCY_TIME * 1000UL) - (millis() - residencyStart)) / 1000UL;
-                 SERIAL_PROTOCOLLN( codenum );
-              }
-              else 
-              {
-                 SERIAL_PROTOCOLLN( "?" );
-              }
-            #else
-              SERIAL_PROTOCOLLN("");
-            #endif
-            codenum = millis();
-          }
-          manage_heater();
-          manage_inactivity();
-          LCD_STATUS;
-        #ifdef TEMP_RESIDENCY_TIME
-            /* start/restart the TEMP_RESIDENCY_TIME timer whenever we reach target temp for the first time
-              or when current temp falls outside the hysteresis after target temp was reached */
-          if ((residencyStart == -1 &&  target_direction && (degHotend(tmp_extruder) >= (degTargetHotend(tmp_extruder)-TEMP_WINDOW))) ||
-              (residencyStart == -1 && !target_direction && (degHotend(tmp_extruder) <= (degTargetHotend(tmp_extruder)+TEMP_WINDOW))) ||
-              (residencyStart > -1 && labs(degHotend(tmp_extruder) - degTargetHotend(tmp_extruder)) > TEMP_HYSTERESIS) ) 
-          {
-            residencyStart = millis();
-          }
-        #endif //TEMP_RESIDENCY_TIME
-        }
-        LCD_MESSAGEPGM(MSG_HEATING_COMPLETE);
-        starttime=millis();
-        previous_millis_cmd = millis();
-      }
-      break;
-    case 190: // M190 - Wait for bed heater to reach target.
-    #if TEMP_BED_PIN > -1
-        LCD_MESSAGEPGM(MSG_BED_HEATING);
-        if (code_seen('S')) setTargetBed(code_value());
-        codenum = millis(); 
-        while(isHeatingBed()) 
-        {
-          if(( millis() - codenum) > 1000 ) //Print Temp Reading every 1 second while heating up.
-          {
-            float tt=degHotend(active_extruder);
-            SERIAL_PROTOCOLPGM("T:");
-            SERIAL_PROTOCOL(tt);
-            SERIAL_PROTOCOLPGM(" E:");
-            SERIAL_PROTOCOL((int)active_extruder); 
-            SERIAL_PROTOCOLPGM(" B:");
-            SERIAL_PROTOCOL_F(degBed(),1); 
-            SERIAL_PROTOCOLLN(""); 
-            codenum = millis(); 
-          }
-          manage_heater();
-          manage_inactivity();
-          LCD_STATUS;
-        }
-        LCD_MESSAGEPGM(MSG_BED_DONE);
-        previous_millis_cmd = millis();
-    #endif
-        break;
-
-    #if FAN_PIN > -1
-      case 106: //M106 Fan On
-        if (code_seen('S')){
-           FanSpeed=constrain(code_value(),0,255);
-        }
-        else {
-          FanSpeed=255;			
-        }
-        break;
-      case 107: //M107 Fan Off
-        FanSpeed = 0;
-        break;
-    #endif //FAN_PIN
-
-    #if (PS_ON_PIN > -1)
-      case 80: // M80 - ATX Power On
-        SET_OUTPUT(PS_ON_PIN); //GND
-        WRITE(PS_ON_PIN, LOW);
-        break;
-      #endif
-      
-      case 81: // M81 - ATX Power Off
-      
-      #if defined SUICIDE_PIN && SUICIDE_PIN > -1
-        st_synchronize();
-        suicide();
-      #elif (PS_ON_PIN > -1)
-        SET_OUTPUT(PS_ON_PIN); 
-        WRITE(PS_ON_PIN, HIGH);
-      #endif
-		break;
-        
-    case 82:
-      axis_relative_modes[3] = false;
-      break;
-    case 83:
-      axis_relative_modes[3] = true;
-      break;
-    case 18: //compatibility
-    case 84: // M84
-      if(code_seen('S')){ 
-        stepper_inactive_time = code_value() * 1000; 
-      }
-      else
-      { 
-        bool all_axis = !((code_seen(axis_codes[0])) || (code_seen(axis_codes[1])) || (code_seen(axis_codes[2]))|| (code_seen(axis_codes[3])));
-        if(all_axis)
-        {
-          st_synchronize();
-          disable_e0();
-          disable_e1();
-          disable_e2();
-          finishAndDisableSteppers();
-        }
-        else
-        {
-          st_synchronize();
-          if(code_seen('X')) disable_x();
-          if(code_seen('Y')) disable_y();
-          if(code_seen('Z')) disable_z();
-          #if ((E0_ENABLE_PIN != X_ENABLE_PIN) && (E1_ENABLE_PIN != Y_ENABLE_PIN)) // Only enable on boards that have seperate ENABLE_PINS
-            if(code_seen('E')) {
-              disable_e0();
-              disable_e1();
-              disable_e2();
-            }
-          #endif 
-          LCD_MESSAGEPGM(MSG_PART_RELEASE);
-        }
-      }
-      break;
-    case 85: // M85
-      code_seen('S');
-      max_inactive_time = code_value() * 1000; 
-      break;
-    case 92: // M92
-      for(int8_t i=0; i < NUM_AXIS; i++) 
-      {
-        if(code_seen(axis_codes[i])) 
-          
-          if(i == 3) { // E
-            float value = code_value();
-            if(value < 20.0) {
-              float factor = axis_steps_per_unit[i] / value; // increase e constants if M92 E14 is given for netfab.
-              max_e_jerk *= factor;
-              max_feedrate[i] *= factor;
-              axis_steps_per_sqr_second[i] *= factor;
-            }
-            axis_steps_per_unit[i] = value;
-          }
-          else {
-            axis_steps_per_unit[i] = code_value();
-          }
-      }
-      break;
-    case 115: // M115
-      SerialprintPGM(MSG_M115_REPORT);
-      break;
-    case 117: // M117 display message
-      LCD_MESSAGE(cmdbuffer[bufindr]+5);
-      break;
-    case 114: // M114
-      SERIAL_PROTOCOLPGM("X:");
-      SERIAL_PROTOCOL(current_position[X_AXIS]);
-      SERIAL_PROTOCOLPGM("Y:");
-      SERIAL_PROTOCOL(current_position[Y_AXIS]);
-      SERIAL_PROTOCOLPGM("Z:");
-      SERIAL_PROTOCOL(current_position[Z_AXIS]);
-      SERIAL_PROTOCOLPGM("E:");      
-      SERIAL_PROTOCOL(current_position[E_AXIS]);
-      
-      SERIAL_PROTOCOLPGM(MSG_COUNT_X);
-      SERIAL_PROTOCOL(float(st_get_position(X_AXIS))/axis_steps_per_unit[X_AXIS]);
-      SERIAL_PROTOCOLPGM("Y:");
-      SERIAL_PROTOCOL(float(st_get_position(Y_AXIS))/axis_steps_per_unit[Y_AXIS]);
-      SERIAL_PROTOCOLPGM("Z:");
-      SERIAL_PROTOCOL(float(st_get_position(Z_AXIS))/axis_steps_per_unit[Z_AXIS]);
-      
-      SERIAL_PROTOCOLLN("");
-      break;
-    case 120: // M120
-      enable_endstops(false) ;
-      break;
-    case 121: // M121
-      enable_endstops(true) ;
-      break;
-    case 119: // M119
-    SERIAL_PROTOCOLLN(MSG_M119_REPORT);
-      #if (X_MIN_PIN > -1)
-        SERIAL_PROTOCOLPGM(MSG_X_MIN);
-        SERIAL_PROTOCOLLN(((READ(X_MIN_PIN)^X_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
-      #endif
-      #if (X_MAX_PIN > -1)
-        SERIAL_PROTOCOLPGM(MSG_X_MAX);
-        SERIAL_PROTOCOLLN(((READ(X_MAX_PIN)^X_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
-      #endif
-      #if (Y_MIN_PIN > -1)
-        SERIAL_PROTOCOLPGM(MSG_Y_MIN);
-        SERIAL_PROTOCOLLN(((READ(Y_MIN_PIN)^Y_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
-      #endif
-      #if (Y_MAX_PIN > -1)
-        SERIAL_PROTOCOLPGM(MSG_Y_MAX);
-        SERIAL_PROTOCOLLN(((READ(Y_MAX_PIN)^Y_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
-      #endif
-      #if (Z_MIN_PIN > -1)
-        SERIAL_PROTOCOLPGM(MSG_Z_MIN);
-        SERIAL_PROTOCOLLN(((READ(Z_MIN_PIN)^Z_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
-      #endif
-      #if (Z_MAX_PIN > -1)
-        SERIAL_PROTOCOLPGM(MSG_Z_MAX);
-        SERIAL_PROTOCOLLN(((READ(Z_MAX_PIN)^Z_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
-      #endif
-      break;
-      //TODO: update for all axis, use for loop
-    case 201: // M201
-      for(int8_t i=0; i < NUM_AXIS; i++) 
-      {
-        if(code_seen(axis_codes[i]))
-        {
-          max_acceleration_units_per_sq_second[i] = code_value();
-          axis_steps_per_sqr_second[i] = code_value() * axis_steps_per_unit[i];
-        }
-      }
-      break;
-    #if 0 // Not used for Sprinter/grbl gen6
-    case 202: // M202
-      for(int8_t i=0; i < NUM_AXIS; i++) {
-        if(code_seen(axis_codes[i])) axis_travel_steps_per_sqr_second[i] = code_value() * axis_steps_per_unit[i];
-      }
-      break;
-    #endif
-    case 203: // M203 max feedrate mm/sec
-      for(int8_t i=0; i < NUM_AXIS; i++) {
-        if(code_seen(axis_codes[i])) max_feedrate[i] = code_value();
-      }
-      break;
-    case 204: // M204 acclereration S normal moves T filmanent only moves
-      {
-        if(code_seen('S')) acceleration = code_value() ;
-        if(code_seen('T')) retract_acceleration = code_value() ;
-      }
-      break;
-    case 205: //M205 advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk
-    {
-      if(code_seen('S')) minimumfeedrate = code_value();
-      if(code_seen('T')) mintravelfeedrate = code_value();
-      if(code_seen('B')) minsegmenttime = code_value() ;
-      if(code_seen('X')) max_xy_jerk = code_value() ;
-      if(code_seen('Z')) max_z_jerk = code_value() ;
-      if(code_seen('E')) max_e_jerk = code_value() ;
-    }
-    break;
-    case 206: // M206 additional homeing offset
-      for(int8_t i=0; i < 3; i++) 
-      {
-        if(code_seen(axis_codes[i])) add_homeing[i] = code_value();
-      }
-      break;
-    #ifdef FWRETRACT
-    case 207: //M207 - set retract length S[positive mm] F[feedrate mm/sec] Z[additional zlift/hop]
-    {
-      if(code_seen('S')) 
-      {
-        retract_length = code_value() ;
-      }
-      if(code_seen('F')) 
-      {
-        retract_feedrate = code_value() ;
-      }
-      if(code_seen('Z')) 
-      {
-        retract_zlift = code_value() ;
-      }
-    }break;
-    case 208: // M208 - set retract recover length S[positive mm surplus to the M207 S*] F[feedrate mm/sec]
-    {
-      if(code_seen('S')) 
-      {
-        retract_recover_length = code_value() ;
-      }
-      if(code_seen('F')) 
-      {
-        retract_recover_feedrate = code_value() ;
-      }
-    }break;
-    
-    case 209: // M209 - S<1=true/0=false> enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.
-    {
-      if(code_seen('S')) 
-      {
-        int t= code_value() ;
-        switch(t)
-        {
-          case 0: autoretract_enabled=false;retracted=false;break;
-          case 1: autoretract_enabled=true;retracted=false;break;
-          default: 
-            SERIAL_ECHO_START;
-            SERIAL_ECHOPGM(MSG_UNKNOWN_COMMAND);
-            SERIAL_ECHO(cmdbuffer[bufindr]);
-            SERIAL_ECHOLNPGM("\"");
-        }
-      }
-      
-    }break;
-    #endif
-    case 220: // M220 S<factor in percent>- set speed factor override percentage
-    {
-      if(code_seen('S')) 
-      {
-        feedmultiply = code_value() ;
-        feedmultiplychanged=true;
-      }
-    }
-    break;
-    case 221: // M221 S<factor in percent>- set extrude factor override percentage
-    {
-      if(code_seen('S')) 
-      {
-        extrudemultiply = code_value() ;
-      }
-    }
-    break;
-
-    #ifdef PIDTEMP
-    case 301: // M301
-      {
-        if(code_seen('P')) Kp = code_value();
-        if(code_seen('I')) Ki = code_value()*PID_dT;
-        if(code_seen('D')) Kd = code_value()/PID_dT;
-        #ifdef PID_ADD_EXTRUSION_RATE
-        if(code_seen('C')) Kc = code_value();
-        #endif
-        updatePID();
-        SERIAL_PROTOCOL(MSG_OK);
-		SERIAL_PROTOCOL(" p:");
-        SERIAL_PROTOCOL(Kp);
-        SERIAL_PROTOCOL(" i:");
-        SERIAL_PROTOCOL(Ki/PID_dT);
-        SERIAL_PROTOCOL(" d:");
-        SERIAL_PROTOCOL(Kd*PID_dT);
-        #ifdef PID_ADD_EXTRUSION_RATE
-        SERIAL_PROTOCOL(" c:");
-        SERIAL_PROTOCOL(Kc*PID_dT);
-        #endif
-        SERIAL_PROTOCOLLN("");
-      }
-      break;
-    #endif //PIDTEMP
-    case 240: // M240  Triggers a camera by emulating a Canon RC-1 : http://www.doc-diy.net/photo/rc-1_hacked/
-     {
-      #ifdef PHOTOGRAPH_PIN
-        #if (PHOTOGRAPH_PIN > -1)
-        const uint8_t NUM_PULSES=16;
-        const float PULSE_LENGTH=0.01524;
-        for(int i=0; i < NUM_PULSES; i++) {
-          WRITE(PHOTOGRAPH_PIN, HIGH);
-          _delay_ms(PULSE_LENGTH);
-          WRITE(PHOTOGRAPH_PIN, LOW);
-          _delay_ms(PULSE_LENGTH);
-        }
-        delay(7.33);
-        for(int i=0; i < NUM_PULSES; i++) {
-          WRITE(PHOTOGRAPH_PIN, HIGH);
-          _delay_ms(PULSE_LENGTH);
-          WRITE(PHOTOGRAPH_PIN, LOW);
-          _delay_ms(PULSE_LENGTH);
-        }
-        #endif
-      #endif
-     }
-    break;
-      
-    case 302: // allow cold extrudes
-    {
-      allow_cold_extrudes(true);
-    }
-    break;
-    case 303: // M303 PID autotune
-    {
-      float temp = 150.0;
-      if (code_seen('S')) temp=code_value();
-      PID_autotune(temp);
-    }
-    break;
-    case 400: // M400 finish all moves
-    {
-      st_synchronize();
-    }
-    break;
-    case 500: // Store settings in EEPROM
-    {
-        EEPROM_StoreSettings();
-    }
-    break;
-    case 501: // Read settings from EEPROM
-    {
-      EEPROM_RetrieveSettings();
-    }
-    break;
-    case 502: // Revert to default settings
-    {
-      EEPROM_RetrieveSettings(true);
-    }
-    break;
-    case 503: // print settings currently in memory
-    {
-      EEPROM_printSettings();
-    }
-    break;
-    case 999: // Restart after being stopped
-      Stopped = false;
-      gcode_LastN = Stopped_gcode_LastN;
-      FlushSerialRequestResend();
-    break;
-    }
-  }
-
-  else if(code_seen('T')) 
-  {
-    tmp_extruder = code_value();
-    if(tmp_extruder >= EXTRUDERS) {
-      SERIAL_ECHO_START;
-      SERIAL_ECHO("T");
-      SERIAL_ECHO(tmp_extruder);
-      SERIAL_ECHOLN(MSG_INVALID_EXTRUDER);
-    }
-    else {
-      active_extruder = tmp_extruder;
-      SERIAL_ECHO_START;
-      SERIAL_ECHO(MSG_ACTIVE_EXTRUDER);
-      SERIAL_PROTOCOLLN((int)active_extruder);
-    }
-  }
-
-  else
-  {
-    SERIAL_ECHO_START;
-    SERIAL_ECHOPGM(MSG_UNKNOWN_COMMAND);
-    SERIAL_ECHO(cmdbuffer[bufindr]);
-    SERIAL_ECHOLNPGM("\"");
-  }
-
-  ClearToSend();
-}
-
-void FlushSerialRequestResend()
-{
-  //char cmdbuffer[bufindr][100]="Resend:";
-  MYSERIAL.flush();
-  SERIAL_PROTOCOLPGM(MSG_RESEND);
-  SERIAL_PROTOCOLLN(gcode_LastN + 1);
-  ClearToSend();
-}
-
-void ClearToSend()
-{
-  previous_millis_cmd = millis();
-  #ifdef SDSUPPORT
-  if(fromsd[bufindr])
-    return;
-  #endif //SDSUPPORT
-  SERIAL_PROTOCOLLNPGM(MSG_OK); 
-}
-
-void get_coordinates()
-{
-  bool seen[4]={false,false,false,false};
-  for(int8_t i=0; i < NUM_AXIS; i++) {
-    if(code_seen(axis_codes[i])) 
-    {
-      destination[i] = (float)code_value() + (axis_relative_modes[i] || relative_mode)*current_position[i];
-      seen[i]=true;
-    }
-    else destination[i] = current_position[i]; //Are these else lines really needed?
-  }
-  if(code_seen('F')) {
-    next_feedrate = code_value();
-    if(next_feedrate > 0.0) feedrate = next_feedrate;
-  }
-  #ifdef FWRETRACT
-  if(autoretract_enabled)
-  if( !(seen[X_AXIS] || seen[Y_AXIS] || seen[Z_AXIS]) && seen[E_AXIS])
-  {
-    float echange=destination[E_AXIS]-current_position[E_AXIS];
-    if(echange<-MIN_RETRACT) //retract
-    {
-      if(!retracted) 
-      {
-      
-      destination[Z_AXIS]+=retract_zlift; //not sure why chaninging current_position negatively does not work.
-      //if slicer retracted by echange=-1mm and you want to retract 3mm, corrrectede=-2mm additionally
-      float correctede=-echange-retract_length;
-      //to generate the additional steps, not the destination is changed, but inversely the current position
-      current_position[E_AXIS]+=-correctede; 
-      feedrate=retract_feedrate;
-      retracted=true;
-      }
-      
-    }
-    else 
-      if(echange>MIN_RETRACT) //retract_recover
-    {
-      if(retracted) 
-      {
-      //current_position[Z_AXIS]+=-retract_zlift;
-      //if slicer retracted_recovered by echange=+1mm and you want to retract_recover 3mm, corrrectede=2mm additionally
-      float correctede=-echange+1*retract_length+retract_recover_length; //total unretract=retract_length+retract_recover_length[surplus]
-      current_position[E_AXIS]+=correctede; //to generate the additional steps, not the destination is changed, but inversely the current position
-      feedrate=retract_recover_feedrate;
-      retracted=false;
-      }
-    }
-    
-  }
-  #endif //FWRETRACT
-}
-
-void get_arc_coordinates()
-{
-#ifdef SF_ARC_FIX
-   bool relative_mode_backup = relative_mode;
-   relative_mode = true;
+#include <LiquidCrystal.h>
 #endif
-   get_coordinates();
-#ifdef SF_ARC_FIX
-   relative_mode=relative_mode_backup;
-#endif
-
-   if(code_seen('I')) {
-     offset[0] = code_value();
-   } 
-   else {
-     offset[0] = 0.0;
-   }
-   if(code_seen('J')) {
-     offset[1] = code_value();
-   }
-   else {
-     offset[1] = 0.0;
-   }
-}
-
-void clamp_to_software_endstops(float target[3])
-{
-  if (min_software_endstops) {
-    if (target[X_AXIS] < min_pos[X_AXIS]) target[X_AXIS] = min_pos[X_AXIS];
-    if (target[Y_AXIS] < min_pos[Y_AXIS]) target[Y_AXIS] = min_pos[Y_AXIS];
-    if (target[Z_AXIS] < min_pos[Z_AXIS]) target[Z_AXIS] = min_pos[Z_AXIS];
-  }
-
-  if (max_software_endstops) {
-    if (target[X_AXIS] > max_pos[X_AXIS]) target[X_AXIS] = max_pos[X_AXIS];
-    if (target[Y_AXIS] > max_pos[Y_AXIS]) target[Y_AXIS] = max_pos[Y_AXIS];
-    if (target[Z_AXIS] > max_pos[Z_AXIS]) target[Z_AXIS] = max_pos[Z_AXIS];
-  }
-}
-
-void prepare_move()
-{
-  clamp_to_software_endstops(destination);
 
-  previous_millis_cmd = millis(); 
-  // Do not use feedmultiply for E or Z only moves
-  if( (current_position[X_AXIS] == destination [X_AXIS]) && (current_position[Y_AXIS] == destination [Y_AXIS])) {
-      plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
-  }
-  else {
-    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate*feedmultiply/60/100.0, active_extruder);
-  }
-  for(int8_t i=0; i < NUM_AXIS; i++) {
-    current_position[i] = destination[i];
-  }
-}
-
-void prepare_arc_move(char isclockwise) {
-  float r = hypot(offset[X_AXIS], offset[Y_AXIS]); // Compute arc radius for mc_arc
-
-  // Trace the arc
-  mc_arc(current_position, destination, offset, X_AXIS, Y_AXIS, Z_AXIS, feedrate*feedmultiply/60/100.0, r, isclockwise, active_extruder);
-  
-  // As far as the parser is concerned, the position is now == target. In reality the
-  // motion control system might still be processing the action and the real tool position
-  // in any intermediate location.
-  for(int8_t i=0; i < NUM_AXIS; i++) {
-    current_position[i] = destination[i];
-  }
-  previous_millis_cmd = millis();
-}
-
-#ifdef CONTROLLERFAN_PIN
-unsigned long lastMotor = 0; //Save the time for when a motor was turned on last
-unsigned long lastMotorCheck = 0;
-
-void controllerFan()
-{
-  if ((millis() - lastMotorCheck) >= 2500) //Not a time critical function, so we only check every 2500ms
-  {
-    lastMotorCheck = millis();
-    
-    if(!READ(X_ENABLE_PIN) || !READ(Y_ENABLE_PIN) || !READ(Z_ENABLE_PIN)
-    #if EXTRUDERS > 2
-       || !READ(E2_ENABLE_PIN)
-    #endif
-    #if EXTRUDER > 1
-       || !READ(E2_ENABLE_PIN)
-    #endif
-       || !READ(E0_ENABLE_PIN)) //If any of the drivers are enabled...    
-    {
-      lastMotor = millis(); //... set time to NOW so the fan will turn on
-    }
-    
-    if ((millis() - lastMotor) >= (CONTROLLERFAN_SEC*1000UL) || lastMotor == 0) //If the last time any driver was enabled, is longer since than CONTROLLERSEC...   
-    {
-      WRITE(CONTROLLERFAN_PIN, LOW); //... turn the fan off
-    }
-    else
-    {
-      WRITE(CONTROLLERFAN_PIN, HIGH); //... turn the fan on
-    }
-  }
-}
+#if DIGIPOTSS_PIN > -1
+#include <SPI.h>
 #endif
-
-void manage_inactivity() 
-{ 
-  if( (millis() - previous_millis_cmd) >  max_inactive_time ) 
-    if(max_inactive_time) 
-      kill(); 
-  if(stepper_inactive_time)  {
-    if( (millis() - previous_millis_cmd) >  stepper_inactive_time ) 
-    {
-      if(blocks_queued() == false) {
-        disable_x();
-        disable_y();
-        disable_z();
-        disable_e0();
-        disable_e1();
-        disable_e2();
-      }
-    }
-  }
-  #if( KILL_PIN>-1 )
-    if( 0 == READ(KILL_PIN) )
-      kill();
-  #endif
-  #ifdef CONTROLLERFAN_PIN
-    controllerFan(); //Check if fan should be turned on to cool stepper drivers down
-  #endif
-  #ifdef EXTRUDER_RUNOUT_PREVENT
-    if( (millis() - previous_millis_cmd) >  EXTRUDER_RUNOUT_SECONDS*1000 ) 
-    if(degHotend(active_extruder)>EXTRUDER_RUNOUT_MINTEMP)
-    {
-     bool oldstatus=READ(E0_ENABLE_PIN);
-     enable_e0();
-     float oldepos=current_position[E_AXIS];
-     float oldedes=destination[E_AXIS];
-     plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], 
-                      current_position[E_AXIS]+EXTRUDER_RUNOUT_EXTRUDE*EXTRUDER_RUNOUT_ESTEPS/axis_steps_per_unit[E_AXIS], 
-                      EXTRUDER_RUNOUT_SPEED/60.*EXTRUDER_RUNOUT_ESTEPS/axis_steps_per_unit[E_AXIS], active_extruder);
-     current_position[E_AXIS]=oldepos;
-     destination[E_AXIS]=oldedes;
-     plan_set_e_position(oldepos);
-     previous_millis_cmd=millis();
-     st_synchronize();
-     WRITE(E0_ENABLE_PIN,oldstatus);
-    }
-  #endif
-  check_axes_activity();
-}
-
-void kill()
-{
-  cli(); // Stop interrupts
-  disable_heater();
-
-  disable_x();
-  disable_y();
-  disable_z();
-  disable_e0();
-  disable_e1();
-  disable_e2();
-  
-  if(PS_ON_PIN > -1) pinMode(PS_ON_PIN,INPUT);
-  SERIAL_ERROR_START;
-  SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
-  LCD_ALERTMESSAGEPGM(MSG_KILLED);
-  suicide();
-  while(1); // Wait for reset
-}
-
-void Stop()
-{
-  disable_heater();
-  if(Stopped == false) {
-    Stopped = true;
-    Stopped_gcode_LastN = gcode_LastN; // Save last g_code for restart
-    SERIAL_ERROR_START;
-    SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
-    LCD_MESSAGEPGM(MSG_STOPPED);
-  }
-}
-
-bool IsStopped() { return Stopped; };
-
-#ifdef FAST_PWM_FAN
-void setPwmFrequency(uint8_t pin, int val)
-{
-  val &= 0x07;
-  switch(digitalPinToTimer(pin))
-  {
- 
-    #if defined(TCCR0A)
-    case TIMER0A:
-    case TIMER0B:
-//         TCCR0B &= ~(CS00 | CS01 | CS02);
-//         TCCR0B |= val;
-         break;
-    #endif
-
-    #if defined(TCCR1A)
-    case TIMER1A:
-    case TIMER1B:
-//         TCCR1B &= ~(CS10 | CS11 | CS12);
-//         TCCR1B |= val;
-         break;
-    #endif
-
-    #if defined(TCCR2)
-    case TIMER2:
-    case TIMER2:
-         TCCR2 &= ~(CS10 | CS11 | CS12);
-         TCCR2 |= val;
-         break;
-    #endif
-
-    #if defined(TCCR2A)
-    case TIMER2A:
-    case TIMER2B:
-         TCCR2B &= ~(CS20 | CS21 | CS22);
-         TCCR2B |= val;
-         break;
-    #endif
-
-    #if defined(TCCR3A)
-    case TIMER3A:
-    case TIMER3B:
-    case TIMER3C:
-         TCCR3B &= ~(CS30 | CS31 | CS32);
-         TCCR3B |= val;
-         break;
-    #endif
-
-    #if defined(TCCR4A) 
-    case TIMER4A:
-    case TIMER4B:
-    case TIMER4C:
-         TCCR4B &= ~(CS40 | CS41 | CS42);
-         TCCR4B |= val;
-         break;
-   #endif
-
-    #if defined(TCCR5A) 
-    case TIMER5A:
-    case TIMER5B:
-    case TIMER5C:
-         TCCR5B &= ~(CS50 | CS51 | CS52);
-         TCCR5B |= val;
-         break;
-   #endif
-
-  }
-}
-#endif //FAST_PWM_FAN
-
-bool setTargetedHotend(int code){
-  tmp_extruder = active_extruder;
-  if(code_seen('T')) {
-    tmp_extruder = code_value();
-    if(tmp_extruder >= EXTRUDERS) {
-      SERIAL_ECHO_START;
-      switch(code){
-        case 104:
-          SERIAL_ECHO(MSG_M104_INVALID_EXTRUDER);
-          break;
-        case 105:
-          SERIAL_ECHO(MSG_M105_INVALID_EXTRUDER);
-          break;
-        case 109:
-          SERIAL_ECHO(MSG_M109_INVALID_EXTRUDER);
-          break;
-      }
-      SERIAL_ECHOLN(tmp_extruder);
-      return true;
-    }
-  }
-  return false;
-}
diff --git a/Marlin/MarlinSerial.cpp b/Marlin/MarlinSerial.cpp
index e369800..1358f38 100644
--- a/Marlin/MarlinSerial.cpp
+++ b/Marlin/MarlinSerial.cpp
@@ -23,12 +23,12 @@
 #include "Marlin.h"
 #include "MarlinSerial.h"
 
-#if MOTHERBOARD != 8 // !teensylu
+#ifndef AT90USB
 // this next line disables the entire HardwareSerial.cpp, 
 // this is so I can support Attiny series and any other chip without a uart
 #if defined(UBRRH) || defined(UBRR0H) || defined(UBRR1H) || defined(UBRR2H) || defined(UBRR3H)
 
-#if defined(UBRRH) || defined(UBRR0H)
+#if UART_PRESENT(SERIAL_PORT)
   ring_buffer rx_buffer  =  { { 0 }, 0, 0 };
 #endif
 
@@ -48,18 +48,12 @@ FORCE_INLINE void store_char(unsigned char c)
 
 
 //#elif defined(SIG_USART_RECV)
-#if defined(USART0_RX_vect)
+#if defined(M_USARTx_RX_vect)
   // fixed by Mark Sproul this is on the 644/644p
   //SIGNAL(SIG_USART_RECV)
-  SIGNAL(USART0_RX_vect)
+  SIGNAL(M_USARTx_RX_vect)
   {
-  #if defined(UDR0)
-    unsigned char c  =  UDR0;
-  #elif defined(UDR)
-    unsigned char c  =  UDR;  //  atmega8, atmega32
-  #else
-    #error UDR not defined
-  #endif
+    unsigned char c  =  M_UDRx;
     store_char(c);
   }
 #endif
@@ -76,39 +70,39 @@ MarlinSerial::MarlinSerial()
 void MarlinSerial::begin(long baud)
 {
   uint16_t baud_setting;
-  bool useU2X0 = true;
+  bool useU2X = true;
 
-#if F_CPU == 16000000UL
+#if F_CPU == 16000000UL && SERIAL_PORT == 0
   // hardcoded exception for compatibility with the bootloader shipped
   // with the Duemilanove and previous boards and the firmware on the 8U2
   // on the Uno and Mega 2560.
   if (baud == 57600) {
-    useU2X0 = false;
+    useU2X = false;
   }
 #endif
   
-  if (useU2X0) {
-    UCSR0A = 1 << U2X0;
+  if (useU2X) {
+    M_UCSRxA = 1 << M_U2Xx;
     baud_setting = (F_CPU / 4 / baud - 1) / 2;
   } else {
-    UCSR0A = 0;
+    M_UCSRxA = 0;
     baud_setting = (F_CPU / 8 / baud - 1) / 2;
   }
 
   // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)
-  UBRR0H = baud_setting >> 8;
-  UBRR0L = baud_setting;
+  M_UBRRxH = baud_setting >> 8;
+  M_UBRRxL = baud_setting;
 
-  sbi(UCSR0B, RXEN0);
-  sbi(UCSR0B, TXEN0);
-  sbi(UCSR0B, RXCIE0);
+  sbi(M_UCSRxB, M_RXENx);
+  sbi(M_UCSRxB, M_TXENx);
+  sbi(M_UCSRxB, M_RXCIEx);
 }
 
 void MarlinSerial::end()
 {
-  cbi(UCSR0B, RXEN0);
-  cbi(UCSR0B, TXEN0);
-  cbi(UCSR0B, RXCIE0);  
+  cbi(M_UCSRxB, M_RXENx);
+  cbi(M_UCSRxB, M_TXENx);
+  cbi(M_UCSRxB, M_RXCIEx);  
 }
 
 
@@ -325,5 +319,4 @@ void MarlinSerial::printFloat(double number, uint8_t digits)
 MarlinSerial MSerial;
 
 #endif // whole file
-#endif //teensylu
-
+#endif // !AT90USB
diff --git a/Marlin/MarlinSerial.h b/Marlin/MarlinSerial.h
index 8525cba..9514730 100644
--- a/Marlin/MarlinSerial.h
+++ b/Marlin/MarlinSerial.h
@@ -23,6 +23,40 @@
 #define MarlinSerial_h
 #include "Marlin.h"
 
+#if !defined(SERIAL_PORT) 
+#define SERIAL_PORT 0
+#endif
+
+// The presence of the UBRRH register is used to detect a UART.
+#define UART_PRESENT(port) ((port == 0 && (defined(UBRRH) || defined(UBRR0H))) || \
+						(port == 1 && defined(UBRR1H)) || (port == 2 && defined(UBRR2H)) || \
+						(port == 3 && defined(UBRR3H)))				
+						
+// These are macros to build serial port register names for the selected SERIAL_PORT (C preprocessor
+// requires two levels of indirection to expand macro values properly)
+#define SERIAL_REGNAME(registerbase,number,suffix) SERIAL_REGNAME_INTERNAL(registerbase,number,suffix)
+#if SERIAL_PORT == 0 && (!defined(UBRR0H) || !defined(UDR0)) // use un-numbered registers if necessary
+#define SERIAL_REGNAME_INTERNAL(registerbase,number,suffix) registerbase##suffix
+#else
+#define SERIAL_REGNAME_INTERNAL(registerbase,number,suffix) registerbase##number##suffix
+#endif
+
+// Registers used by MarlinSerial class (these are expanded 
+// depending on selected serial port
+#define M_UCSRxA SERIAL_REGNAME(UCSR,SERIAL_PORT,A) // defines M_UCSRxA to be UCSRnA where n is the serial port number
+#define M_UCSRxB SERIAL_REGNAME(UCSR,SERIAL_PORT,B) 
+#define M_RXENx SERIAL_REGNAME(RXEN,SERIAL_PORT,)    
+#define M_TXENx SERIAL_REGNAME(TXEN,SERIAL_PORT,)    
+#define M_RXCIEx SERIAL_REGNAME(RXCIE,SERIAL_PORT,)    
+#define M_UDREx SERIAL_REGNAME(UDRE,SERIAL_PORT,)    
+#define M_UDRx SERIAL_REGNAME(UDR,SERIAL_PORT,)  
+#define M_UBRRxH SERIAL_REGNAME(UBRR,SERIAL_PORT,H)
+#define M_UBRRxL SERIAL_REGNAME(UBRR,SERIAL_PORT,L)
+#define M_RXCx SERIAL_REGNAME(RXC,SERIAL_PORT,)
+#define M_USARTx_RX_vect SERIAL_REGNAME(USART,SERIAL_PORT,_RX_vect)
+#define M_U2Xx SERIAL_REGNAME(U2X,SERIAL_PORT,)
+
+
 
 #define DEC 10
 #define HEX 16
@@ -31,7 +65,7 @@
 #define BYTE 0
 
 
-#if MOTHERBOARD != 8 // ! teensylu
+#ifndef AT90USB
 // Define constants and variables for buffering incoming serial data.  We're
 // using a ring buffer (I think), in which rx_buffer_head is the index of the
 // location to which to write the next incoming character and rx_buffer_tail
@@ -46,7 +80,7 @@ struct ring_buffer
   int tail;
 };
 
-#if defined(UBRRH) || defined(UBRR0H)
+#if UART_PRESENT(SERIAL_PORT)
   extern ring_buffer rx_buffer;
 #endif
 
@@ -68,17 +102,17 @@ class MarlinSerial //: public Stream
     
     FORCE_INLINE void write(uint8_t c)
     {
-      while (!((UCSR0A) & (1 << UDRE0)))
+      while (!((M_UCSRxA) & (1 << M_UDREx)))
         ;
 
-      UDR0 = c;
+      M_UDRx = c;
     }
     
     
     FORCE_INLINE void checkRx(void)
     {
-      if((UCSR0A & (1<<RXC0)) != 0) {
-        unsigned char c  =  UDR0;
+      if((M_UCSRxA & (1<<M_RXCx)) != 0) {
+        unsigned char c  =  M_UDRx;
         int i = (unsigned int)(rx_buffer.head + 1) % RX_BUFFER_SIZE;
 
         // if we should be storing the received character into the location
@@ -145,6 +179,6 @@ class MarlinSerial //: public Stream
 };
 
 extern MarlinSerial MSerial;
-#endif // ! teensylu
+#endif // !AT90USB
 
 #endif
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
new file mode 100644
index 0000000..b212aa5
--- /dev/null
+++ b/Marlin/Marlin_main.cpp
@@ -0,0 +1,1943 @@
+/* -*- c++ -*- */
+
+/*
+    Reprap firmware based on Sprinter and grbl.
+ Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ 
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+ 
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ This firmware is a mashup between Sprinter and grbl.
+  (https://github.com/kliment/Sprinter)
+  (https://github.com/simen/grbl/tree)
+ 
+ It has preliminary support for Matthew Roberts advance algorithm 
+    http://reprap.org/pipermail/reprap-dev/2011-May/003323.html
+ */
+
+#include "Marlin.h"
+
+#include "ultralcd.h"
+#include "planner.h"
+#include "stepper.h"
+#include "temperature.h"
+#include "motion_control.h"
+#include "cardreader.h"
+#include "watchdog.h"
+#include "ConfigurationStore.h"
+#include "language.h"
+#include "pins_arduino.h"
+
+#if DIGIPOTSS_PIN > -1
+#include <SPI.h>
+#endif
+
+#define VERSION_STRING  "1.0.0"
+
+// look here for descriptions of gcodes: http://linuxcnc.org/handbook/gcode/g-code.html
+// http://objects.reprap.org/wiki/Mendel_User_Manual:_RepRapGCodes
+
+//Implemented Codes
+//-------------------
+// G0  -> G1
+// G1  - Coordinated Movement X Y Z E
+// G2  - CW ARC
+// G3  - CCW ARC
+// G4  - Dwell S<seconds> or P<milliseconds>
+// G10 - retract filament according to settings of M207
+// G11 - retract recover filament according to settings of M208
+// G28 - Home all Axis
+// G90 - Use Absolute Coordinates
+// G91 - Use Relative Coordinates
+// G92 - Set current position to cordinates given
+
+//RepRap M Codes
+// M0   - Unconditional stop - Wait for user to press a button on the LCD (Only if ULTRA_LCD is enabled)
+// M1   - Same as M0
+// M104 - Set extruder target temp
+// M105 - Read current temp
+// M106 - Fan on
+// M107 - Fan off
+// M109 - Wait for extruder current temp to reach target temp.
+// M114 - Display current position
+
+//Custom M Codes
+// M17  - Enable/Power all stepper motors
+// M18  - Disable all stepper motors; same as M84
+// M20  - List SD card
+// M21  - Init SD card
+// M22  - Release SD card
+// M23  - Select SD file (M23 filename.g)
+// M24  - Start/resume SD print
+// M25  - Pause SD print
+// M26  - Set SD position in bytes (M26 S12345)
+// M27  - Report SD print status
+// M28  - Start SD write (M28 filename.g)
+// M29  - Stop SD write
+// M30  - Delete file from SD (M30 filename.g)
+// M31  - Output time since last M109 or SD card start to serial
+// M42  - Change pin status via gcode
+// M80  - Turn on Power Supply
+// M81  - Turn off Power Supply
+// M82  - Set E codes absolute (default)
+// M83  - Set E codes relative while in Absolute Coordinates (G90) mode
+// M84  - Disable steppers until next move, 
+//        or use S<seconds> to specify an inactivity timeout, after which the steppers will be disabled.  S0 to disable the timeout.
+// M85  - Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
+// M92  - Set axis_steps_per_unit - same syntax as G92
+// M114 - Output current position to serial port 
+// M115	- Capabilities string
+// M117 - display message
+// M119 - Output Endstop status to serial port
+// M140 - Set bed target temp
+// M190 - Wait for bed current temp to reach target temp.
+// M200 - Set filament diameter
+// M201 - Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)
+// M202 - Set max acceleration in units/s^2 for travel moves (M202 X1000 Y1000) Unused in Marlin!!
+// M203 - Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in mm/sec
+// M204 - Set default acceleration: S normal moves T filament only moves (M204 S3000 T7000) im mm/sec^2  also sets minimum segment time in ms (B20000) to prevent buffer underruns and M20 minimum feedrate
+// M205 -  advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk, E=maximum E jerk
+// M206 - set additional homeing offset
+// M207 - set retract length S[positive mm] F[feedrate mm/sec] Z[additional zlift/hop]
+// M208 - set recover=unretract length S[positive mm surplus to the M207 S*] F[feedrate mm/sec]
+// M209 - S<1=true/0=false> enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.
+// M220 S<factor in percent>- set speed factor override percentage
+// M221 S<factor in percent>- set extrude factor override percentage
+// M240 - Trigger a camera to take a photograph
+// M301 - Set PID parameters P I and D
+// M302 - Allow cold extrudes
+// M303 - PID relay autotune S<temperature> sets the target temperature. (default target temperature = 150C)
+// M304 - Set bed PID parameters P I and D
+// M400 - Finish all moves
+// M500 - stores paramters in EEPROM
+// M501 - reads parameters from EEPROM (if you need reset them after you changed them temporarily).  
+// M502 - reverts to the default "factory settings".  You still need to store them in EEPROM afterwards if you want to.
+// M503 - print the current settings (from memory not from eeprom)
+// M540 - Use S[0|1] to enable or disable the stop SD card print on endstop hit (requires ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
+// M907 - Set digital trimpot motor current using axis codes.
+// M908 - Control digital trimpot directly.
+// M350 - Set microstepping mode.
+// M351 - Toggle MS1 MS2 pins directly.
+// M999 - Restart after being stopped by error
+
+//Stepper Movement Variables
+
+//===========================================================================
+//=============================imported variables============================
+//===========================================================================
+
+
+//===========================================================================
+//=============================public variables=============================
+//===========================================================================
+#ifdef SDSUPPORT
+CardReader card;
+#endif
+float homing_feedrate[] = HOMING_FEEDRATE;
+bool axis_relative_modes[] = AXIS_RELATIVE_MODES;
+int feedmultiply=100; //100->1 200->2
+int saved_feedmultiply;
+int extrudemultiply=100; //100->1 200->2
+float current_position[NUM_AXIS] = { 0.0, 0.0, 0.0, 0.0 };
+float add_homeing[3]={0,0,0};
+float min_pos[3] = { X_MIN_POS, Y_MIN_POS, Z_MIN_POS };
+float max_pos[3] = { X_MAX_POS, Y_MAX_POS, Z_MAX_POS };
+uint8_t active_extruder = 0;
+int fanSpeed=0;
+
+#ifdef FWRETRACT
+  bool autoretract_enabled=true;
+  bool retracted=false;
+  float retract_length=3, retract_feedrate=17*60, retract_zlift=0.8;
+  float retract_recover_length=0, retract_recover_feedrate=8*60;
+#endif
+
+//===========================================================================
+//=============================private variables=============================
+//===========================================================================
+const char axis_codes[NUM_AXIS] = {'X', 'Y', 'Z', 'E'};
+static float destination[NUM_AXIS] = {  0.0, 0.0, 0.0, 0.0};
+static float offset[3] = {0.0, 0.0, 0.0};
+static bool home_all_axis = true;
+static float feedrate = 1500.0, next_feedrate, saved_feedrate;
+static long gcode_N, gcode_LastN, Stopped_gcode_LastN = 0;
+
+static bool relative_mode = false;  //Determines Absolute or Relative Coordinates
+
+static char cmdbuffer[BUFSIZE][MAX_CMD_SIZE];
+static bool fromsd[BUFSIZE];
+static int bufindr = 0;
+static int bufindw = 0;
+static int buflen = 0;
+//static int i = 0;
+static char serial_char;
+static int serial_count = 0;
+static boolean comment_mode = false;
+static char *strchr_pointer; // just a pointer to find chars in the cmd string like X, Y, Z, E, etc
+
+const int sensitive_pins[] = SENSITIVE_PINS; // Sensitive pin list for M42
+
+//static float tt = 0;
+//static float bt = 0;
+
+//Inactivity shutdown variables
+static unsigned long previous_millis_cmd = 0;
+static unsigned long max_inactive_time = 0;
+static unsigned long stepper_inactive_time = DEFAULT_STEPPER_DEACTIVE_TIME*1000l;
+
+unsigned long starttime=0;
+unsigned long stoptime=0;
+
+static uint8_t tmp_extruder;
+
+
+bool Stopped=false;
+
+//===========================================================================
+//=============================ROUTINES=============================
+//===========================================================================
+
+void get_arc_coordinates();
+bool setTargetedHotend(int code);
+
+void serial_echopair_P(const char *s_P, float v)
+    { serialprintPGM(s_P); SERIAL_ECHO(v); }
+void serial_echopair_P(const char *s_P, double v)
+    { serialprintPGM(s_P); SERIAL_ECHO(v); }
+void serial_echopair_P(const char *s_P, unsigned long v)
+    { serialprintPGM(s_P); SERIAL_ECHO(v); }
+
+extern "C"{
+  extern unsigned int __bss_end;
+  extern unsigned int __heap_start;
+  extern void *__brkval;
+
+  int freeMemory() {
+    int free_memory;
+
+    if((int)__brkval == 0)
+      free_memory = ((int)&free_memory) - ((int)&__bss_end);
+    else
+      free_memory = ((int)&free_memory) - ((int)__brkval);
+
+    return free_memory;
+  }
+}
+
+//adds an command to the main command buffer
+//thats really done in a non-safe way.
+//needs overworking someday
+void enquecommand(const char *cmd)
+{
+  if(buflen < BUFSIZE)
+  {
+    //this is dangerous if a mixing of serial and this happsens
+    strcpy(&(cmdbuffer[bufindw][0]),cmd);
+    SERIAL_ECHO_START;
+    SERIAL_ECHOPGM("enqueing \"");
+    SERIAL_ECHO(cmdbuffer[bufindw]);
+    SERIAL_ECHOLNPGM("\"");
+    bufindw= (bufindw + 1)%BUFSIZE;
+    buflen += 1;
+  }
+}
+
+void enquecommand_P(const char *cmd)
+{
+  if(buflen < BUFSIZE)
+  {
+    //this is dangerous if a mixing of serial and this happsens
+    strcpy_P(&(cmdbuffer[bufindw][0]),cmd);
+    SERIAL_ECHO_START;
+    SERIAL_ECHOPGM("enqueing \"");
+    SERIAL_ECHO(cmdbuffer[bufindw]);
+    SERIAL_ECHOLNPGM("\"");
+    bufindw= (bufindw + 1)%BUFSIZE;
+    buflen += 1;
+  }
+}
+
+void setup_killpin()
+{
+  #if( KILL_PIN>-1 )
+    pinMode(KILL_PIN,INPUT);
+    WRITE(KILL_PIN,HIGH);
+  #endif
+}
+    
+void setup_photpin()
+{
+  #ifdef PHOTOGRAPH_PIN
+    #if (PHOTOGRAPH_PIN > -1)
+    SET_OUTPUT(PHOTOGRAPH_PIN);
+    WRITE(PHOTOGRAPH_PIN, LOW);
+    #endif
+  #endif 
+}
+
+void setup_powerhold()
+{
+ #ifdef SUICIDE_PIN
+   #if (SUICIDE_PIN> -1)
+      SET_OUTPUT(SUICIDE_PIN);
+      WRITE(SUICIDE_PIN, HIGH);
+   #endif
+ #endif
+ #if (PS_ON_PIN > -1)
+   SET_OUTPUT(PS_ON_PIN);
+   WRITE(PS_ON_PIN, PS_ON_AWAKE);
+ #endif
+}
+
+void suicide()
+{
+ #ifdef SUICIDE_PIN
+    #if (SUICIDE_PIN> -1) 
+      SET_OUTPUT(SUICIDE_PIN);
+      WRITE(SUICIDE_PIN, LOW);
+    #endif
+  #endif
+}
+
+void setup()
+{
+  setup_killpin(); 
+  setup_powerhold();
+  MYSERIAL.begin(BAUDRATE);
+  SERIAL_PROTOCOLLNPGM("start");
+  SERIAL_ECHO_START;
+
+  // Check startup - does nothing if bootloader sets MCUSR to 0
+  byte mcu = MCUSR;
+  if(mcu & 1) SERIAL_ECHOLNPGM(MSG_POWERUP);
+  if(mcu & 2) SERIAL_ECHOLNPGM(MSG_EXTERNAL_RESET);
+  if(mcu & 4) SERIAL_ECHOLNPGM(MSG_BROWNOUT_RESET);
+  if(mcu & 8) SERIAL_ECHOLNPGM(MSG_WATCHDOG_RESET);
+  if(mcu & 32) SERIAL_ECHOLNPGM(MSG_SOFTWARE_RESET);
+  MCUSR=0;
+
+  SERIAL_ECHOPGM(MSG_MARLIN);
+  SERIAL_ECHOLNPGM(VERSION_STRING);
+  #ifdef STRING_VERSION_CONFIG_H
+    #ifdef STRING_CONFIG_H_AUTHOR
+      SERIAL_ECHO_START;
+      SERIAL_ECHOPGM(MSG_CONFIGURATION_VER);
+      SERIAL_ECHOPGM(STRING_VERSION_CONFIG_H);
+      SERIAL_ECHOPGM(MSG_AUTHOR);
+      SERIAL_ECHOLNPGM(STRING_CONFIG_H_AUTHOR);
+      SERIAL_ECHOPGM("Compiled: ");
+      SERIAL_ECHOLNPGM(__DATE__);
+    #endif
+  #endif
+  SERIAL_ECHO_START;
+  SERIAL_ECHOPGM(MSG_FREE_MEMORY);
+  SERIAL_ECHO(freeMemory());
+  SERIAL_ECHOPGM(MSG_PLANNER_BUFFER_BYTES);
+  SERIAL_ECHOLN((int)sizeof(block_t)*BLOCK_BUFFER_SIZE);
+  for(int8_t i = 0; i < BUFSIZE; i++)
+  {
+    fromsd[i] = false;
+  }
+  
+  Config_RetrieveSettings(); // loads data from EEPROM if available
+
+  for(int8_t i=0; i < NUM_AXIS; i++)
+  {
+    axis_steps_per_sqr_second[i] = max_acceleration_units_per_sq_second[i] * axis_steps_per_unit[i];
+  }
+
+
+  tp_init();    // Initialize temperature loop 
+  plan_init();  // Initialize planner;
+  watchdog_init();
+  st_init();    // Initialize stepper, this enables interrupts!
+  setup_photpin();
+  
+  lcd_init();
+}
+
+
+void loop()
+{
+  if(buflen < (BUFSIZE-1))
+    get_command();
+  #ifdef SDSUPPORT
+  card.checkautostart(false);
+  #endif
+  if(buflen)
+  {
+    #ifdef SDSUPPORT
+      if(card.saving)
+      {
+	if(strstr_P(cmdbuffer[bufindr], PSTR("M29")) == NULL)
+	{
+	  card.write_command(cmdbuffer[bufindr]);
+	  SERIAL_PROTOCOLLNPGM(MSG_OK);
+	}
+	else
+	{
+	  card.closefile();
+	  SERIAL_PROTOCOLLNPGM(MSG_FILE_SAVED);
+	}
+      }
+      else
+      {
+	process_commands();
+      }
+    #else
+      process_commands();
+    #endif //SDSUPPORT
+    buflen = (buflen-1);
+    bufindr = (bufindr + 1)%BUFSIZE;
+  }
+  //check heater every n milliseconds
+  manage_heater();
+  manage_inactivity();
+  checkHitEndstops();
+  lcd_update();
+}
+
+void get_command() 
+{ 
+  while( MYSERIAL.available() > 0  && buflen < BUFSIZE) {
+    serial_char = MYSERIAL.read();
+    if(serial_char == '\n' || 
+       serial_char == '\r' || 
+       (serial_char == ':' && comment_mode == false) || 
+       serial_count >= (MAX_CMD_SIZE - 1) ) 
+    {
+      if(!serial_count) { //if empty line
+        comment_mode = false; //for new command
+        return;
+      }
+      cmdbuffer[bufindw][serial_count] = 0; //terminate string
+      if(!comment_mode){
+        comment_mode = false; //for new command
+        fromsd[bufindw] = false;
+        if(strchr(cmdbuffer[bufindw], 'N') != NULL)
+        {
+          strchr_pointer = strchr(cmdbuffer[bufindw], 'N');
+          gcode_N = (strtol(&cmdbuffer[bufindw][strchr_pointer - cmdbuffer[bufindw] + 1], NULL, 10));
+          if(gcode_N != gcode_LastN+1 && (strstr_P(cmdbuffer[bufindw], PSTR("M110")) == NULL) ) {
+            SERIAL_ERROR_START;
+            SERIAL_ERRORPGM(MSG_ERR_LINE_NO);
+            SERIAL_ERRORLN(gcode_LastN);
+            //Serial.println(gcode_N);
+            FlushSerialRequestResend();
+            serial_count = 0;
+            return;
+          }
+
+          if(strchr(cmdbuffer[bufindw], '*') != NULL)
+          {
+            byte checksum = 0;
+            byte count = 0;
+            while(cmdbuffer[bufindw][count] != '*') checksum = checksum^cmdbuffer[bufindw][count++];
+            strchr_pointer = strchr(cmdbuffer[bufindw], '*');
+
+            if( (int)(strtod(&cmdbuffer[bufindw][strchr_pointer - cmdbuffer[bufindw] + 1], NULL)) != checksum) {
+              SERIAL_ERROR_START;
+              SERIAL_ERRORPGM(MSG_ERR_CHECKSUM_MISMATCH);
+              SERIAL_ERRORLN(gcode_LastN);
+              FlushSerialRequestResend();
+              serial_count = 0;
+              return;
+            }
+            //if no errors, continue parsing
+          }
+          else 
+          {
+            SERIAL_ERROR_START;
+            SERIAL_ERRORPGM(MSG_ERR_NO_CHECKSUM);
+            SERIAL_ERRORLN(gcode_LastN);
+            FlushSerialRequestResend();
+            serial_count = 0;
+            return;
+          }
+
+          gcode_LastN = gcode_N;
+          //if no errors, continue parsing
+        }
+        else  // if we don't receive 'N' but still see '*'
+        {
+          if((strchr(cmdbuffer[bufindw], '*') != NULL))
+          {
+            SERIAL_ERROR_START;
+            SERIAL_ERRORPGM(MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM);
+            SERIAL_ERRORLN(gcode_LastN);
+            serial_count = 0;
+            return;
+          }
+        }
+        if((strchr(cmdbuffer[bufindw], 'G') != NULL)){
+          strchr_pointer = strchr(cmdbuffer[bufindw], 'G');
+          switch((int)((strtod(&cmdbuffer[bufindw][strchr_pointer - cmdbuffer[bufindw] + 1], NULL)))){
+          case 0:
+          case 1:
+          case 2:
+          case 3:
+            if(Stopped == false) { // If printer is stopped by an error the G[0-3] codes are ignored.
+	      #ifdef SDSUPPORT
+              if(card.saving)
+                break;
+	      #endif //SDSUPPORT
+              SERIAL_PROTOCOLLNPGM(MSG_OK); 
+            }
+            else {
+              SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
+              LCD_MESSAGEPGM(MSG_STOPPED);
+            }
+            break;
+          default:
+            break;
+          }
+
+        }
+        bufindw = (bufindw + 1)%BUFSIZE;
+        buflen += 1;
+      }
+      serial_count = 0; //clear buffer
+    }
+    else
+    {
+      if(serial_char == ';') comment_mode = true;
+      if(!comment_mode) cmdbuffer[bufindw][serial_count++] = serial_char;
+    }
+  }
+  #ifdef SDSUPPORT
+  if(!card.sdprinting || serial_count!=0){
+    return;
+  }
+  while( !card.eof()  && buflen < BUFSIZE) {
+    int16_t n=card.get();
+    serial_char = (char)n;
+    if(serial_char == '\n' || 
+       serial_char == '\r' || 
+       (serial_char == ':' && comment_mode == false) || 
+       serial_count >= (MAX_CMD_SIZE - 1)||n==-1) 
+    {
+      if(card.eof()){
+        SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);
+        stoptime=millis();
+        char time[30];
+        unsigned long t=(stoptime-starttime)/1000;
+        int hours, minutes;
+        minutes=(t/60)%60;
+        hours=t/60/60;
+        sprintf_P(time, PSTR("%i hours %i minutes"),hours, minutes);
+        SERIAL_ECHO_START;
+        SERIAL_ECHOLN(time);
+        lcd_setstatus(time);
+        card.printingHasFinished();
+        card.checkautostart(true);
+        
+      }
+      if(!serial_count)
+      {
+        comment_mode = false; //for new command
+        return; //if empty line
+      }
+      cmdbuffer[bufindw][serial_count] = 0; //terminate string
+//      if(!comment_mode){
+        fromsd[bufindw] = true;
+        buflen += 1;
+        bufindw = (bufindw + 1)%BUFSIZE;
+//      }     
+      comment_mode = false; //for new command
+      serial_count = 0; //clear buffer
+    }
+    else
+    {
+      if(serial_char == ';') comment_mode = true;
+      if(!comment_mode) cmdbuffer[bufindw][serial_count++] = serial_char;
+    }
+  }
+  
+  #endif //SDSUPPORT
+
+}
+
+
+float code_value() 
+{ 
+  return (strtod(&cmdbuffer[bufindr][strchr_pointer - cmdbuffer[bufindr] + 1], NULL)); 
+}
+
+long code_value_long() 
+{ 
+  return (strtol(&cmdbuffer[bufindr][strchr_pointer - cmdbuffer[bufindr] + 1], NULL, 10)); 
+}
+
+bool code_seen(char code)
+{
+  strchr_pointer = strchr(cmdbuffer[bufindr], code);
+  return (strchr_pointer != NULL);  //Return True if a character was found
+}
+
+#define DEFINE_PGM_READ_ANY(type, reader)		\
+    static inline type pgm_read_any(const type *p)	\
+	{ return pgm_read_##reader##_near(p); }
+
+DEFINE_PGM_READ_ANY(float,       float);
+DEFINE_PGM_READ_ANY(signed char, byte);
+
+#define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG)	\
+static const PROGMEM type array##_P[3] =		\
+    { X_##CONFIG, Y_##CONFIG, Z_##CONFIG };		\
+static inline type array(int axis)			\
+    { return pgm_read_any(&array##_P[axis]); }
+
+XYZ_CONSTS_FROM_CONFIG(float, base_min_pos,    MIN_POS);
+XYZ_CONSTS_FROM_CONFIG(float, base_max_pos,    MAX_POS);
+XYZ_CONSTS_FROM_CONFIG(float, base_home_pos,   HOME_POS);
+XYZ_CONSTS_FROM_CONFIG(float, max_length,      MAX_LENGTH);
+XYZ_CONSTS_FROM_CONFIG(float, home_retract_mm, HOME_RETRACT_MM);
+XYZ_CONSTS_FROM_CONFIG(signed char, home_dir,  HOME_DIR);
+
+static void axis_is_at_home(int axis) {
+  current_position[axis] = base_home_pos(axis) + add_homeing[axis];
+  min_pos[axis] =          base_min_pos(axis) + add_homeing[axis];
+  max_pos[axis] =          base_max_pos(axis) + add_homeing[axis];
+}
+
+static void homeaxis(int axis) {
+#define HOMEAXIS_DO(LETTER) \
+  ((LETTER##_MIN_PIN > -1 && LETTER##_HOME_DIR==-1) || (LETTER##_MAX_PIN > -1 && LETTER##_HOME_DIR==1))
+
+  if (axis==X_AXIS ? HOMEAXIS_DO(X) :
+      axis==Y_AXIS ? HOMEAXIS_DO(Y) :
+      axis==Z_AXIS ? HOMEAXIS_DO(Z) :
+      0) {
+    current_position[axis] = 0;
+    plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+    destination[axis] = 1.5 * max_length(axis) * home_dir(axis);
+    feedrate = homing_feedrate[axis];
+    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
+    st_synchronize();
+   
+    current_position[axis] = 0;
+    plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+    destination[axis] = -home_retract_mm(axis) * home_dir(axis);
+    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
+    st_synchronize();
+   
+    destination[axis] = 2*home_retract_mm(axis) * home_dir(axis);
+    feedrate = homing_feedrate[axis]/2 ; 
+    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
+    st_synchronize();
+   
+    axis_is_at_home(axis);					
+    destination[axis] = current_position[axis];
+    feedrate = 0.0;
+    endstops_hit_on_purpose();
+  }
+}
+#define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)
+
+void process_commands()
+{
+  unsigned long codenum; //throw away variable
+  char *starpos = NULL;
+
+  if(code_seen('G'))
+  {
+    switch((int)code_value())
+    {
+    case 0: // G0 -> G1
+    case 1: // G1
+      if(Stopped == false) {
+        get_coordinates(); // For X Y Z E F
+        prepare_move();
+        //ClearToSend();
+        return;
+      }
+      //break;
+    case 2: // G2  - CW ARC
+      if(Stopped == false) {
+        get_arc_coordinates();
+        prepare_arc_move(true);
+        return;
+      }
+    case 3: // G3  - CCW ARC
+      if(Stopped == false) {
+        get_arc_coordinates();
+        prepare_arc_move(false);
+        return;
+      }
+    case 4: // G4 dwell
+      LCD_MESSAGEPGM(MSG_DWELL);
+      codenum = 0;
+      if(code_seen('P')) codenum = code_value(); // milliseconds to wait
+      if(code_seen('S')) codenum = code_value() * 1000; // seconds to wait
+      
+      st_synchronize();
+      codenum += millis();  // keep track of when we started waiting
+      previous_millis_cmd = millis();
+      while(millis()  < codenum ){
+        manage_heater();
+        manage_inactivity();
+        lcd_update();
+      }
+      break;
+      #ifdef FWRETRACT  
+      case 10: // G10 retract
+      if(!retracted) 
+      {
+        destination[X_AXIS]=current_position[X_AXIS];
+        destination[Y_AXIS]=current_position[Y_AXIS];
+        destination[Z_AXIS]=current_position[Z_AXIS]; 
+        current_position[Z_AXIS]+=-retract_zlift;
+        destination[E_AXIS]=current_position[E_AXIS]-retract_length; 
+        feedrate=retract_feedrate;
+        retracted=true;
+        prepare_move();
+      }
+      
+      break;
+      case 11: // G10 retract_recover
+      if(!retracted) 
+      {
+        destination[X_AXIS]=current_position[X_AXIS];
+        destination[Y_AXIS]=current_position[Y_AXIS];
+        destination[Z_AXIS]=current_position[Z_AXIS]; 
+        
+        current_position[Z_AXIS]+=retract_zlift;
+        current_position[E_AXIS]+=-retract_recover_length; 
+        feedrate=retract_recover_feedrate;
+        retracted=false;
+        prepare_move();
+      }
+      break;
+      #endif //FWRETRACT
+    case 28: //G28 Home all Axis one at a time
+      saved_feedrate = feedrate;
+      saved_feedmultiply = feedmultiply;
+      feedmultiply = 100;
+      previous_millis_cmd = millis();
+      
+      enable_endstops(true);
+      
+      for(int8_t i=0; i < NUM_AXIS; i++) {
+        destination[i] = current_position[i];
+      }
+      feedrate = 0.0;
+      home_all_axis = !((code_seen(axis_codes[0])) || (code_seen(axis_codes[1])) || (code_seen(axis_codes[2])));
+      
+      #if Z_HOME_DIR > 0                      // If homing away from BED do Z first
+      if((home_all_axis) || (code_seen(axis_codes[Z_AXIS]))) {
+        HOMEAXIS(Z);
+      }
+      #endif
+      
+      #ifdef QUICK_HOME
+      if((home_all_axis)||( code_seen(axis_codes[X_AXIS]) && code_seen(axis_codes[Y_AXIS])) )  //first diagonal move
+      {
+        current_position[X_AXIS] = 0;current_position[Y_AXIS] = 0;  
+
+        plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]); 
+        destination[X_AXIS] = 1.5 * X_MAX_LENGTH * X_HOME_DIR;destination[Y_AXIS] = 1.5 * Y_MAX_LENGTH * Y_HOME_DIR;  
+        feedrate = homing_feedrate[X_AXIS]; 
+        if(homing_feedrate[Y_AXIS]<feedrate)
+          feedrate =homing_feedrate[Y_AXIS]; 
+        plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
+        st_synchronize();
+    
+        axis_is_at_home(X_AXIS);
+        axis_is_at_home(Y_AXIS);
+        plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+        destination[X_AXIS] = current_position[X_AXIS];
+        destination[Y_AXIS] = current_position[Y_AXIS];
+        plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
+        feedrate = 0.0;
+        st_synchronize();
+        endstops_hit_on_purpose();
+      }
+      #endif
+      
+      if((home_all_axis) || (code_seen(axis_codes[X_AXIS]))) 
+      {
+        HOMEAXIS(X);
+      }
+
+      if((home_all_axis) || (code_seen(axis_codes[Y_AXIS]))) {
+        HOMEAXIS(Y);
+      }
+      
+      #if Z_HOME_DIR < 0                      // If homing towards BED do Z last
+      if((home_all_axis) || (code_seen(axis_codes[Z_AXIS]))) {
+        HOMEAXIS(Z);
+      }
+      #endif
+      
+      if(code_seen(axis_codes[X_AXIS])) 
+      {
+        if(code_value_long() != 0) {
+          current_position[X_AXIS]=code_value()+add_homeing[0];
+        }
+      }
+
+      if(code_seen(axis_codes[Y_AXIS])) {
+        if(code_value_long() != 0) {
+          current_position[Y_AXIS]=code_value()+add_homeing[1];
+        }
+      }
+
+      if(code_seen(axis_codes[Z_AXIS])) {
+        if(code_value_long() != 0) {
+          current_position[Z_AXIS]=code_value()+add_homeing[2];
+        }
+      }
+      plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+      
+      #ifdef ENDSTOPS_ONLY_FOR_HOMING
+        enable_endstops(false);
+      #endif
+      
+      feedrate = saved_feedrate;
+      feedmultiply = saved_feedmultiply;
+      previous_millis_cmd = millis();
+      endstops_hit_on_purpose();
+      break;
+    case 90: // G90
+      relative_mode = false;
+      break;
+    case 91: // G91
+      relative_mode = true;
+      break;
+    case 92: // G92
+      if(!code_seen(axis_codes[E_AXIS]))
+        st_synchronize();
+      for(int8_t i=0; i < NUM_AXIS; i++) {
+        if(code_seen(axis_codes[i])) { 
+           if(i == E_AXIS) {
+             current_position[i] = code_value();  
+             plan_set_e_position(current_position[E_AXIS]);
+           }
+           else {
+             current_position[i] = code_value()+add_homeing[i];  
+             plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+           }
+        }
+      }
+      break;
+    }
+  }
+
+  else if(code_seen('M'))
+  {
+    switch( (int)code_value() ) 
+    {
+#ifdef ULTIPANEL
+    case 0: // M0 - Unconditional stop - Wait for user button press on LCD
+    case 1: // M1 - Conditional stop - Wait for user button press on LCD
+    {
+      LCD_MESSAGEPGM(MSG_USERWAIT);
+      codenum = 0;
+      if(code_seen('P')) codenum = code_value(); // milliseconds to wait
+      if(code_seen('S')) codenum = code_value() * 1000; // seconds to wait
+      
+      st_synchronize();
+      previous_millis_cmd = millis();
+      if (codenum > 0){
+        codenum += millis();  // keep track of when we started waiting
+        while(millis()  < codenum && !LCD_CLICKED){
+          manage_heater();
+          manage_inactivity();
+          lcd_update();
+        }
+      }else{
+        while(!LCD_CLICKED){
+          manage_heater();
+          manage_inactivity();
+          lcd_update();
+        }
+      }
+      LCD_MESSAGEPGM(MSG_RESUMING);
+    }
+    break;
+#endif
+    case 17:
+        LCD_MESSAGEPGM(MSG_NO_MOVE);
+        enable_x(); 
+        enable_y(); 
+        enable_z(); 
+        enable_e0(); 
+        enable_e1(); 
+        enable_e2(); 
+      break;
+
+#ifdef SDSUPPORT
+    case 20: // M20 - list SD card
+      SERIAL_PROTOCOLLNPGM(MSG_BEGIN_FILE_LIST);
+      card.ls();
+      SERIAL_PROTOCOLLNPGM(MSG_END_FILE_LIST);
+      break;
+    case 21: // M21 - init SD card
+      
+      card.initsd();
+      
+      break;
+    case 22: //M22 - release SD card
+      card.release();
+
+      break;
+    case 23: //M23 - Select file
+      starpos = (strchr(strchr_pointer + 4,'*'));
+      if(starpos!=NULL)
+        *(starpos-1)='\0';
+      card.openFile(strchr_pointer + 4,true);
+      break;
+    case 24: //M24 - Start SD print
+      card.startFileprint();
+      starttime=millis();
+      break;
+    case 25: //M25 - Pause SD print
+      card.pauseSDPrint();
+      break;
+    case 26: //M26 - Set SD index
+      if(card.cardOK && code_seen('S')) {
+        card.setIndex(code_value_long());
+      }
+      break;
+    case 27: //M27 - Get SD status
+      card.getStatus();
+      break;
+    case 28: //M28 - Start SD write
+      starpos = (strchr(strchr_pointer + 4,'*'));
+      if(starpos != NULL){
+        char* npos = strchr(cmdbuffer[bufindr], 'N');
+        strchr_pointer = strchr(npos,' ') + 1;
+        *(starpos-1) = '\0';
+      }
+      card.openFile(strchr_pointer+4,false);
+      break;
+    case 29: //M29 - Stop SD write
+      //processed in write to file routine above
+      //card,saving = false;
+      break;
+    case 30: //M30 <filename> Delete File 
+	if (card.cardOK){
+		card.closefile();
+		starpos = (strchr(strchr_pointer + 4,'*'));
+                if(starpos != NULL){
+                char* npos = strchr(cmdbuffer[bufindr], 'N');
+                strchr_pointer = strchr(npos,' ') + 1;
+                *(starpos-1) = '\0';
+         }
+	 card.removeFile(strchr_pointer + 4);
+	}
+	break;
+	
+#endif //SDSUPPORT
+
+    case 31: //M31 take time since the start of the SD print or an M109 command
+      {
+      stoptime=millis();
+      char time[30];
+      unsigned long t=(stoptime-starttime)/1000;
+      int sec,min;
+      min=t/60;
+      sec=t%60;
+      sprintf_P(time, PSTR("%i min, %i sec"), min, sec);
+      SERIAL_ECHO_START;
+      SERIAL_ECHOLN(time);
+      lcd_setstatus(time);
+      autotempShutdown();
+      }
+      break;
+    case 42: //M42 -Change pin status via gcode
+      if (code_seen('S'))
+      {
+        int pin_status = code_value();
+        int pin_number = LED_PIN;
+        if (code_seen('P') && pin_status >= 0 && pin_status <= 255)
+          pin_number = code_value();
+        for(int8_t i = 0; i < (int8_t)sizeof(sensitive_pins); i++)
+        {
+          if (sensitive_pins[i] == pin_number)
+          {
+            pin_number = -1;
+            break;
+          }
+        }
+        if (pin_number > -1)
+        {
+          pinMode(pin_number, OUTPUT);
+          digitalWrite(pin_number, pin_status);
+          analogWrite(pin_number, pin_status);
+        }
+      }
+     break;
+    case 104: // M104
+      if(setTargetedHotend(104)){
+        break;
+      }
+      if (code_seen('S')) setTargetHotend(code_value(), tmp_extruder);
+      setWatch();
+      break;
+    case 140: // M140 set bed temp
+      if (code_seen('S')) setTargetBed(code_value());
+      break;
+    case 105 : // M105
+      if(setTargetedHotend(105)){
+        break;
+      }
+      #if (TEMP_0_PIN > -1)
+        SERIAL_PROTOCOLPGM("ok T:");
+        SERIAL_PROTOCOL_F(degHotend(tmp_extruder),1); 
+        SERIAL_PROTOCOLPGM(" /");
+        SERIAL_PROTOCOL_F(degTargetHotend(tmp_extruder),1); 
+        #if TEMP_BED_PIN > -1
+          SERIAL_PROTOCOLPGM(" B:");  
+          SERIAL_PROTOCOL_F(degBed(),1);
+          SERIAL_PROTOCOLPGM(" /");
+          SERIAL_PROTOCOL_F(degTargetBed(),1);
+        #endif //TEMP_BED_PIN
+      #else
+        SERIAL_ERROR_START;
+        SERIAL_ERRORLNPGM(MSG_ERR_NO_THERMISTORS);
+      #endif
+
+        SERIAL_PROTOCOLPGM(" @:");
+        SERIAL_PROTOCOL(getHeaterPower(tmp_extruder));  
+
+        SERIAL_PROTOCOLPGM(" B@:");
+        SERIAL_PROTOCOL(getHeaterPower(-1));  
+
+        SERIAL_PROTOCOLLN("");
+      return;
+      break;
+    case 109: 
+    {// M109 - Wait for extruder heater to reach target.
+      if(setTargetedHotend(109)){
+        break;
+      }
+      LCD_MESSAGEPGM(MSG_HEATING);   
+      #ifdef AUTOTEMP
+        autotemp_enabled=false;
+      #endif
+      if (code_seen('S')) setTargetHotend(code_value(), tmp_extruder);
+      #ifdef AUTOTEMP
+        if (code_seen('S')) autotemp_min=code_value();
+        if (code_seen('B')) autotemp_max=code_value();
+        if (code_seen('F')) 
+        {
+          autotemp_factor=code_value();
+          autotemp_enabled=true;
+        }
+      #endif
+      
+      setWatch();
+      codenum = millis(); 
+
+      /* See if we are heating up or cooling down */
+      bool target_direction = isHeatingHotend(tmp_extruder); // true if heating, false if cooling
+
+      #ifdef TEMP_RESIDENCY_TIME
+        long residencyStart;
+        residencyStart = -1;
+        /* continue to loop until we have reached the target temp   
+          _and_ until TEMP_RESIDENCY_TIME hasn't passed since we reached it */
+        while((residencyStart == -1) ||
+              (residencyStart >= 0 && (((unsigned int) (millis() - residencyStart)) < (TEMP_RESIDENCY_TIME * 1000UL))) ) {
+      #else
+        while ( target_direction ? (isHeatingHotend(tmp_extruder)) : (isCoolingHotend(tmp_extruder)&&(CooldownNoWait==false)) ) {
+      #endif //TEMP_RESIDENCY_TIME
+          if( (millis() - codenum) > 1000UL )
+          { //Print Temp Reading and remaining time every 1 second while heating up/cooling down
+            SERIAL_PROTOCOLPGM("T:");
+            SERIAL_PROTOCOL_F(degHotend(tmp_extruder),1); 
+            SERIAL_PROTOCOLPGM(" E:");
+            SERIAL_PROTOCOL((int)tmp_extruder); 
+            #ifdef TEMP_RESIDENCY_TIME
+              SERIAL_PROTOCOLPGM(" W:");
+              if(residencyStart > -1)
+              {
+                 codenum = ((TEMP_RESIDENCY_TIME * 1000UL) - (millis() - residencyStart)) / 1000UL;
+                 SERIAL_PROTOCOLLN( codenum );
+              }
+              else 
+              {
+                 SERIAL_PROTOCOLLN( "?" );
+              }
+            #else
+              SERIAL_PROTOCOLLN("");
+            #endif
+            codenum = millis();
+          }
+          manage_heater();
+          manage_inactivity();
+          lcd_update();
+        #ifdef TEMP_RESIDENCY_TIME
+            /* start/restart the TEMP_RESIDENCY_TIME timer whenever we reach target temp for the first time
+              or when current temp falls outside the hysteresis after target temp was reached */
+          if ((residencyStart == -1 &&  target_direction && (degHotend(tmp_extruder) >= (degTargetHotend(tmp_extruder)-TEMP_WINDOW))) ||
+              (residencyStart == -1 && !target_direction && (degHotend(tmp_extruder) <= (degTargetHotend(tmp_extruder)+TEMP_WINDOW))) ||
+              (residencyStart > -1 && labs(degHotend(tmp_extruder) - degTargetHotend(tmp_extruder)) > TEMP_HYSTERESIS) ) 
+          {
+            residencyStart = millis();
+          }
+        #endif //TEMP_RESIDENCY_TIME
+        }
+        LCD_MESSAGEPGM(MSG_HEATING_COMPLETE);
+        starttime=millis();
+        previous_millis_cmd = millis();
+      }
+      break;
+    case 190: // M190 - Wait for bed heater to reach target.
+    #if TEMP_BED_PIN > -1
+        LCD_MESSAGEPGM(MSG_BED_HEATING);
+        if (code_seen('S')) setTargetBed(code_value());
+        codenum = millis(); 
+        while(isHeatingBed()) 
+        {
+          if(( millis() - codenum) > 1000 ) //Print Temp Reading every 1 second while heating up.
+          {
+            float tt=degHotend(active_extruder);
+            SERIAL_PROTOCOLPGM("T:");
+            SERIAL_PROTOCOL(tt);
+            SERIAL_PROTOCOLPGM(" E:");
+            SERIAL_PROTOCOL((int)active_extruder); 
+            SERIAL_PROTOCOLPGM(" B:");
+            SERIAL_PROTOCOL_F(degBed(),1); 
+            SERIAL_PROTOCOLLN(""); 
+            codenum = millis(); 
+          }
+          manage_heater();
+          manage_inactivity();
+          lcd_update();
+        }
+        LCD_MESSAGEPGM(MSG_BED_DONE);
+        previous_millis_cmd = millis();
+    #endif
+        break;
+
+    #if FAN_PIN > -1
+      case 106: //M106 Fan On
+        if (code_seen('S')){
+           fanSpeed=constrain(code_value(),0,255);
+        }
+        else {
+          fanSpeed=255;			
+        }
+        break;
+      case 107: //M107 Fan Off
+        fanSpeed = 0;
+        break;
+    #endif //FAN_PIN
+
+    #if (PS_ON_PIN > -1)
+      case 80: // M80 - ATX Power On
+        SET_OUTPUT(PS_ON_PIN); //GND
+        WRITE(PS_ON_PIN, PS_ON_AWAKE);
+        break;
+      #endif
+      
+      case 81: // M81 - ATX Power Off
+      
+      #if defined SUICIDE_PIN && SUICIDE_PIN > -1
+        st_synchronize();
+        suicide();
+      #elif (PS_ON_PIN > -1)
+        SET_OUTPUT(PS_ON_PIN); 
+        WRITE(PS_ON_PIN, PS_ON_ASLEEP);
+      #endif
+		break;
+        
+    case 82:
+      axis_relative_modes[3] = false;
+      break;
+    case 83:
+      axis_relative_modes[3] = true;
+      break;
+    case 18: //compatibility
+    case 84: // M84
+      if(code_seen('S')){ 
+        stepper_inactive_time = code_value() * 1000; 
+      }
+      else
+      { 
+        bool all_axis = !((code_seen(axis_codes[0])) || (code_seen(axis_codes[1])) || (code_seen(axis_codes[2]))|| (code_seen(axis_codes[3])));
+        if(all_axis)
+        {
+          st_synchronize();
+          disable_e0();
+          disable_e1();
+          disable_e2();
+          finishAndDisableSteppers();
+        }
+        else
+        {
+          st_synchronize();
+          if(code_seen('X')) disable_x();
+          if(code_seen('Y')) disable_y();
+          if(code_seen('Z')) disable_z();
+          #if ((E0_ENABLE_PIN != X_ENABLE_PIN) && (E1_ENABLE_PIN != Y_ENABLE_PIN)) // Only enable on boards that have seperate ENABLE_PINS
+            if(code_seen('E')) {
+              disable_e0();
+              disable_e1();
+              disable_e2();
+            }
+          #endif 
+        }
+      }
+      break;
+    case 85: // M85
+      code_seen('S');
+      max_inactive_time = code_value() * 1000; 
+      break;
+    case 92: // M92
+      for(int8_t i=0; i < NUM_AXIS; i++) 
+      {
+        if(code_seen(axis_codes[i])) 
+        {
+          if(i == 3) { // E
+            float value = code_value();
+            if(value < 20.0) {
+              float factor = axis_steps_per_unit[i] / value; // increase e constants if M92 E14 is given for netfab.
+              max_e_jerk *= factor;
+              max_feedrate[i] *= factor;
+              axis_steps_per_sqr_second[i] *= factor;
+            }
+            axis_steps_per_unit[i] = value;
+          }
+          else {
+            axis_steps_per_unit[i] = code_value();
+          }
+        }
+      }
+      break;
+    case 115: // M115
+      SERIAL_PROTOCOLPGM(MSG_M115_REPORT);
+      break;
+    case 117: // M117 display message
+      starpos = (strchr(strchr_pointer + 5,'*'));
+      if(starpos!=NULL)
+        *(starpos-1)='\0';
+      lcd_setstatus(strchr_pointer + 5);
+      break;
+    case 114: // M114
+      SERIAL_PROTOCOLPGM("X:");
+      SERIAL_PROTOCOL(current_position[X_AXIS]);
+      SERIAL_PROTOCOLPGM("Y:");
+      SERIAL_PROTOCOL(current_position[Y_AXIS]);
+      SERIAL_PROTOCOLPGM("Z:");
+      SERIAL_PROTOCOL(current_position[Z_AXIS]);
+      SERIAL_PROTOCOLPGM("E:");      
+      SERIAL_PROTOCOL(current_position[E_AXIS]);
+      
+      SERIAL_PROTOCOLPGM(MSG_COUNT_X);
+      SERIAL_PROTOCOL(float(st_get_position(X_AXIS))/axis_steps_per_unit[X_AXIS]);
+      SERIAL_PROTOCOLPGM("Y:");
+      SERIAL_PROTOCOL(float(st_get_position(Y_AXIS))/axis_steps_per_unit[Y_AXIS]);
+      SERIAL_PROTOCOLPGM("Z:");
+      SERIAL_PROTOCOL(float(st_get_position(Z_AXIS))/axis_steps_per_unit[Z_AXIS]);
+      
+      SERIAL_PROTOCOLLN("");
+      break;
+    case 120: // M120
+      enable_endstops(false) ;
+      break;
+    case 121: // M121
+      enable_endstops(true) ;
+      break;
+    case 119: // M119
+    SERIAL_PROTOCOLLN(MSG_M119_REPORT);
+      #if (X_MIN_PIN > -1)
+        SERIAL_PROTOCOLPGM(MSG_X_MIN);
+        SERIAL_PROTOCOLLN(((READ(X_MIN_PIN)^X_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
+      #endif
+      #if (X_MAX_PIN > -1)
+        SERIAL_PROTOCOLPGM(MSG_X_MAX);
+        SERIAL_PROTOCOLLN(((READ(X_MAX_PIN)^X_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
+      #endif
+      #if (Y_MIN_PIN > -1)
+        SERIAL_PROTOCOLPGM(MSG_Y_MIN);
+        SERIAL_PROTOCOLLN(((READ(Y_MIN_PIN)^Y_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
+      #endif
+      #if (Y_MAX_PIN > -1)
+        SERIAL_PROTOCOLPGM(MSG_Y_MAX);
+        SERIAL_PROTOCOLLN(((READ(Y_MAX_PIN)^Y_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
+      #endif
+      #if (Z_MIN_PIN > -1)
+        SERIAL_PROTOCOLPGM(MSG_Z_MIN);
+        SERIAL_PROTOCOLLN(((READ(Z_MIN_PIN)^Z_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
+      #endif
+      #if (Z_MAX_PIN > -1)
+        SERIAL_PROTOCOLPGM(MSG_Z_MAX);
+        SERIAL_PROTOCOLLN(((READ(Z_MAX_PIN)^Z_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
+      #endif
+      break;
+      //TODO: update for all axis, use for loop
+    case 201: // M201
+      for(int8_t i=0; i < NUM_AXIS; i++) 
+      {
+        if(code_seen(axis_codes[i]))
+        {
+          max_acceleration_units_per_sq_second[i] = code_value();
+          axis_steps_per_sqr_second[i] = code_value() * axis_steps_per_unit[i];
+        }
+      }
+      break;
+    #if 0 // Not used for Sprinter/grbl gen6
+    case 202: // M202
+      for(int8_t i=0; i < NUM_AXIS; i++) {
+        if(code_seen(axis_codes[i])) axis_travel_steps_per_sqr_second[i] = code_value() * axis_steps_per_unit[i];
+      }
+      break;
+    #endif
+    case 203: // M203 max feedrate mm/sec
+      for(int8_t i=0; i < NUM_AXIS; i++) {
+        if(code_seen(axis_codes[i])) max_feedrate[i] = code_value();
+      }
+      break;
+    case 204: // M204 acclereration S normal moves T filmanent only moves
+      {
+        if(code_seen('S')) acceleration = code_value() ;
+        if(code_seen('T')) retract_acceleration = code_value() ;
+      }
+      break;
+    case 205: //M205 advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk
+    {
+      if(code_seen('S')) minimumfeedrate = code_value();
+      if(code_seen('T')) mintravelfeedrate = code_value();
+      if(code_seen('B')) minsegmenttime = code_value() ;
+      if(code_seen('X')) max_xy_jerk = code_value() ;
+      if(code_seen('Z')) max_z_jerk = code_value() ;
+      if(code_seen('E')) max_e_jerk = code_value() ;
+    }
+    break;
+    case 206: // M206 additional homeing offset
+      for(int8_t i=0; i < 3; i++) 
+      {
+        if(code_seen(axis_codes[i])) add_homeing[i] = code_value();
+      }
+      break;
+    #ifdef FWRETRACT
+    case 207: //M207 - set retract length S[positive mm] F[feedrate mm/sec] Z[additional zlift/hop]
+    {
+      if(code_seen('S')) 
+      {
+        retract_length = code_value() ;
+      }
+      if(code_seen('F')) 
+      {
+        retract_feedrate = code_value() ;
+      }
+      if(code_seen('Z')) 
+      {
+        retract_zlift = code_value() ;
+      }
+    }break;
+    case 208: // M208 - set retract recover length S[positive mm surplus to the M207 S*] F[feedrate mm/sec]
+    {
+      if(code_seen('S')) 
+      {
+        retract_recover_length = code_value() ;
+      }
+      if(code_seen('F')) 
+      {
+        retract_recover_feedrate = code_value() ;
+      }
+    }break;
+    
+    case 209: // M209 - S<1=true/0=false> enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.
+    {
+      if(code_seen('S')) 
+      {
+        int t= code_value() ;
+        switch(t)
+        {
+          case 0: autoretract_enabled=false;retracted=false;break;
+          case 1: autoretract_enabled=true;retracted=false;break;
+          default: 
+            SERIAL_ECHO_START;
+            SERIAL_ECHOPGM(MSG_UNKNOWN_COMMAND);
+            SERIAL_ECHO(cmdbuffer[bufindr]);
+            SERIAL_ECHOLNPGM("\"");
+        }
+      }
+      
+    }break;
+    #endif
+    case 220: // M220 S<factor in percent>- set speed factor override percentage
+    {
+      if(code_seen('S')) 
+      {
+        feedmultiply = code_value() ;
+      }
+    }
+    break;
+    case 221: // M221 S<factor in percent>- set extrude factor override percentage
+    {
+      if(code_seen('S')) 
+      {
+        extrudemultiply = code_value() ;
+      }
+    }
+    break;
+
+    #ifdef PIDTEMP
+    case 301: // M301
+      {
+        if(code_seen('P')) Kp = code_value();
+        if(code_seen('I')) Ki = code_value()*PID_dT;
+        if(code_seen('D')) Kd = code_value()/PID_dT;
+        #ifdef PID_ADD_EXTRUSION_RATE
+        if(code_seen('C')) Kc = code_value();
+        #endif
+        updatePID();
+        SERIAL_PROTOCOL(MSG_OK);
+		SERIAL_PROTOCOL(" p:");
+        SERIAL_PROTOCOL(Kp);
+        SERIAL_PROTOCOL(" i:");
+        SERIAL_PROTOCOL(Ki/PID_dT);
+        SERIAL_PROTOCOL(" d:");
+        SERIAL_PROTOCOL(Kd*PID_dT);
+        #ifdef PID_ADD_EXTRUSION_RATE
+        SERIAL_PROTOCOL(" c:");
+        SERIAL_PROTOCOL(Kc*PID_dT);
+        #endif
+        SERIAL_PROTOCOLLN("");
+      }
+      break;
+    #endif //PIDTEMP
+    #ifdef PIDTEMPBED
+    case 304: // M304
+      {
+        if(code_seen('P')) bedKp = code_value();
+        if(code_seen('I')) bedKi = code_value()*PID_dT;
+        if(code_seen('D')) bedKd = code_value()/PID_dT;
+        updatePID();
+        SERIAL_PROTOCOL(MSG_OK);
+		SERIAL_PROTOCOL(" p:");
+        SERIAL_PROTOCOL(bedKp);
+        SERIAL_PROTOCOL(" i:");
+        SERIAL_PROTOCOL(bedKi/PID_dT);
+        SERIAL_PROTOCOL(" d:");
+        SERIAL_PROTOCOL(bedKd*PID_dT);
+        SERIAL_PROTOCOLLN("");
+      }
+      break;
+    #endif //PIDTEMP
+    case 240: // M240  Triggers a camera by emulating a Canon RC-1 : http://www.doc-diy.net/photo/rc-1_hacked/
+     {
+      #ifdef PHOTOGRAPH_PIN
+        #if (PHOTOGRAPH_PIN > -1)
+        const uint8_t NUM_PULSES=16;
+        const float PULSE_LENGTH=0.01524;
+        for(int i=0; i < NUM_PULSES; i++) {
+          WRITE(PHOTOGRAPH_PIN, HIGH);
+          _delay_ms(PULSE_LENGTH);
+          WRITE(PHOTOGRAPH_PIN, LOW);
+          _delay_ms(PULSE_LENGTH);
+        }
+        delay(7.33);
+        for(int i=0; i < NUM_PULSES; i++) {
+          WRITE(PHOTOGRAPH_PIN, HIGH);
+          _delay_ms(PULSE_LENGTH);
+          WRITE(PHOTOGRAPH_PIN, LOW);
+          _delay_ms(PULSE_LENGTH);
+        }
+        #endif
+      #endif
+     }
+    break;
+      
+    case 302: // allow cold extrudes
+    {
+      allow_cold_extrudes(true);
+    }
+    break;
+    case 303: // M303 PID autotune
+    {
+      float temp = 150.0;
+      int e=0;
+      int c=5;
+      if (code_seen('E')) e=code_value();
+			if (e<0)
+				temp=70;
+      if (code_seen('S')) temp=code_value();
+      if (code_seen('C')) c=code_value();
+      PID_autotune(temp, e, c);
+    }
+    break;
+    case 400: // M400 finish all moves
+    {
+      st_synchronize();
+    }
+    break;
+    case 500: // M500 Store settings in EEPROM
+    {
+        Config_StoreSettings();
+    }
+    break;
+    case 501: // M501 Read settings from EEPROM
+    {
+        Config_RetrieveSettings();
+    }
+    break;
+    case 502: // M502 Revert to default settings
+    {
+        Config_ResetDefault();
+    }
+    break;
+    case 503: // M503 print settings currently in memory
+    {
+        Config_PrintSettings();
+    }
+    break;
+    #ifdef ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
+    case 540:
+    {
+        if(code_seen('S')) abort_on_endstop_hit = code_value() > 0;
+    }
+    break;
+    #endif
+    case 907: // M907 Set digital trimpot motor current using axis codes.
+    {
+      #if DIGIPOTSS_PIN > -1
+        for(int i=0;i<=NUM_AXIS;i++) if(code_seen(axis_codes[i])) digipot_current(i,code_value());
+        if(code_seen('B')) digipot_current(4,code_value());
+        if(code_seen('S')) for(int i=0;i<=4;i++) digipot_current(i,code_value());
+      #endif
+    }
+    case 908: // M908 Control digital trimpot directly.
+    {
+      #if DIGIPOTSS_PIN > -1
+        uint8_t channel,current;
+        if(code_seen('P')) channel=code_value();
+        if(code_seen('S')) current=code_value();
+        digitalPotWrite(channel, current);
+      #endif
+    }
+    break;
+    case 350: // M350 Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
+    {
+      #if X_MS1_PIN > -1
+        if(code_seen('S')) for(int i=0;i<=4;i++) microstep_mode(i,code_value()); 
+        for(int i=0;i<=NUM_AXIS;i++) if(code_seen(axis_codes[i])) microstep_mode(i,(uint8_t)code_value());
+        if(code_seen('B')) microstep_mode(4,code_value());
+        microstep_readings();
+      #endif
+    }
+    break;
+    case 351: // M351 Toggle MS1 MS2 pins directly, S# determines MS1 or MS2, X# sets the pin high/low.
+    {
+      #if X_MS1_PIN > -1
+      if(code_seen('S')) switch((int)code_value())
+      {
+        case 1:
+          for(int i=0;i<=NUM_AXIS;i++) if(code_seen(axis_codes[i])) microstep_ms(i,code_value(),-1);
+          if(code_seen('B')) microstep_ms(4,code_value(),-1);
+          break;
+        case 2:
+          for(int i=0;i<=NUM_AXIS;i++) if(code_seen(axis_codes[i])) microstep_ms(i,-1,code_value());
+          if(code_seen('B')) microstep_ms(4,-1,code_value());
+          break;
+      }
+      microstep_readings();
+      #endif
+    }
+    break;
+    case 999: // M999: Restart after being stopped
+      Stopped = false;
+      lcd_reset_alert_level();
+      gcode_LastN = Stopped_gcode_LastN;
+      FlushSerialRequestResend();
+    break;
+    }
+  }
+
+  else if(code_seen('T')) 
+  {
+    tmp_extruder = code_value();
+    if(tmp_extruder >= EXTRUDERS) {
+      SERIAL_ECHO_START;
+      SERIAL_ECHO("T");
+      SERIAL_ECHO(tmp_extruder);
+      SERIAL_ECHOLN(MSG_INVALID_EXTRUDER);
+    }
+    else {
+      active_extruder = tmp_extruder;
+      SERIAL_ECHO_START;
+      SERIAL_ECHO(MSG_ACTIVE_EXTRUDER);
+      SERIAL_PROTOCOLLN((int)active_extruder);
+    }
+  }
+
+  else
+  {
+    SERIAL_ECHO_START;
+    SERIAL_ECHOPGM(MSG_UNKNOWN_COMMAND);
+    SERIAL_ECHO(cmdbuffer[bufindr]);
+    SERIAL_ECHOLNPGM("\"");
+  }
+
+  ClearToSend();
+}
+
+void FlushSerialRequestResend()
+{
+  //char cmdbuffer[bufindr][100]="Resend:";
+  MYSERIAL.flush();
+  SERIAL_PROTOCOLPGM(MSG_RESEND);
+  SERIAL_PROTOCOLLN(gcode_LastN + 1);
+  ClearToSend();
+}
+
+void ClearToSend()
+{
+  previous_millis_cmd = millis();
+  #ifdef SDSUPPORT
+  if(fromsd[bufindr])
+    return;
+  #endif //SDSUPPORT
+  SERIAL_PROTOCOLLNPGM(MSG_OK); 
+}
+
+void get_coordinates()
+{
+  bool seen[4]={false,false,false,false};
+  for(int8_t i=0; i < NUM_AXIS; i++) {
+    if(code_seen(axis_codes[i])) 
+    {
+      destination[i] = (float)code_value() + (axis_relative_modes[i] || relative_mode)*current_position[i];
+      seen[i]=true;
+    }
+    else destination[i] = current_position[i]; //Are these else lines really needed?
+  }
+  if(code_seen('F')) {
+    next_feedrate = code_value();
+    if(next_feedrate > 0.0) feedrate = next_feedrate;
+  }
+  #ifdef FWRETRACT
+  if(autoretract_enabled)
+  if( !(seen[X_AXIS] || seen[Y_AXIS] || seen[Z_AXIS]) && seen[E_AXIS])
+  {
+    float echange=destination[E_AXIS]-current_position[E_AXIS];
+    if(echange<-MIN_RETRACT) //retract
+    {
+      if(!retracted) 
+      {
+      
+      destination[Z_AXIS]+=retract_zlift; //not sure why chaninging current_position negatively does not work.
+      //if slicer retracted by echange=-1mm and you want to retract 3mm, corrrectede=-2mm additionally
+      float correctede=-echange-retract_length;
+      //to generate the additional steps, not the destination is changed, but inversely the current position
+      current_position[E_AXIS]+=-correctede; 
+      feedrate=retract_feedrate;
+      retracted=true;
+      }
+      
+    }
+    else 
+      if(echange>MIN_RETRACT) //retract_recover
+    {
+      if(retracted) 
+      {
+      //current_position[Z_AXIS]+=-retract_zlift;
+      //if slicer retracted_recovered by echange=+1mm and you want to retract_recover 3mm, corrrectede=2mm additionally
+      float correctede=-echange+1*retract_length+retract_recover_length; //total unretract=retract_length+retract_recover_length[surplus]
+      current_position[E_AXIS]+=correctede; //to generate the additional steps, not the destination is changed, but inversely the current position
+      feedrate=retract_recover_feedrate;
+      retracted=false;
+      }
+    }
+    
+  }
+  #endif //FWRETRACT
+}
+
+void get_arc_coordinates()
+{
+#ifdef SF_ARC_FIX
+   bool relative_mode_backup = relative_mode;
+   relative_mode = true;
+#endif
+   get_coordinates();
+#ifdef SF_ARC_FIX
+   relative_mode=relative_mode_backup;
+#endif
+
+   if(code_seen('I')) {
+     offset[0] = code_value();
+   } 
+   else {
+     offset[0] = 0.0;
+   }
+   if(code_seen('J')) {
+     offset[1] = code_value();
+   }
+   else {
+     offset[1] = 0.0;
+   }
+}
+
+void clamp_to_software_endstops(float target[3])
+{
+  if (min_software_endstops) {
+    if (target[X_AXIS] < min_pos[X_AXIS]) target[X_AXIS] = min_pos[X_AXIS];
+    if (target[Y_AXIS] < min_pos[Y_AXIS]) target[Y_AXIS] = min_pos[Y_AXIS];
+    if (target[Z_AXIS] < min_pos[Z_AXIS]) target[Z_AXIS] = min_pos[Z_AXIS];
+  }
+
+  if (max_software_endstops) {
+    if (target[X_AXIS] > max_pos[X_AXIS]) target[X_AXIS] = max_pos[X_AXIS];
+    if (target[Y_AXIS] > max_pos[Y_AXIS]) target[Y_AXIS] = max_pos[Y_AXIS];
+    if (target[Z_AXIS] > max_pos[Z_AXIS]) target[Z_AXIS] = max_pos[Z_AXIS];
+  }
+}
+
+void prepare_move()
+{
+  clamp_to_software_endstops(destination);
+
+  previous_millis_cmd = millis(); 
+  // Do not use feedmultiply for E or Z only moves
+  if( (current_position[X_AXIS] == destination [X_AXIS]) && (current_position[Y_AXIS] == destination [Y_AXIS])) {
+      plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
+  }
+  else {
+    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate*feedmultiply/60/100.0, active_extruder);
+  }
+  for(int8_t i=0; i < NUM_AXIS; i++) {
+    current_position[i] = destination[i];
+  }
+}
+
+void prepare_arc_move(char isclockwise) {
+  float r = hypot(offset[X_AXIS], offset[Y_AXIS]); // Compute arc radius for mc_arc
+
+  // Trace the arc
+  mc_arc(current_position, destination, offset, X_AXIS, Y_AXIS, Z_AXIS, feedrate*feedmultiply/60/100.0, r, isclockwise, active_extruder);
+  
+  // As far as the parser is concerned, the position is now == target. In reality the
+  // motion control system might still be processing the action and the real tool position
+  // in any intermediate location.
+  for(int8_t i=0; i < NUM_AXIS; i++) {
+    current_position[i] = destination[i];
+  }
+  previous_millis_cmd = millis();
+}
+
+#ifdef CONTROLLERFAN_PIN
+unsigned long lastMotor = 0; //Save the time for when a motor was turned on last
+unsigned long lastMotorCheck = 0;
+
+void controllerFan()
+{
+  if ((millis() - lastMotorCheck) >= 2500) //Not a time critical function, so we only check every 2500ms
+  {
+    lastMotorCheck = millis();
+    
+    if(!READ(X_ENABLE_PIN) || !READ(Y_ENABLE_PIN) || !READ(Z_ENABLE_PIN)
+    #if EXTRUDERS > 2
+       || !READ(E2_ENABLE_PIN)
+    #endif
+    #if EXTRUDER > 1
+       || !READ(E2_ENABLE_PIN)
+    #endif
+       || !READ(E0_ENABLE_PIN)) //If any of the drivers are enabled...    
+    {
+      lastMotor = millis(); //... set time to NOW so the fan will turn on
+    }
+    
+    if ((millis() - lastMotor) >= (CONTROLLERFAN_SEC*1000UL) || lastMotor == 0) //If the last time any driver was enabled, is longer since than CONTROLLERSEC...   
+    {
+      WRITE(CONTROLLERFAN_PIN, LOW); //... turn the fan off
+    }
+    else
+    {
+      WRITE(CONTROLLERFAN_PIN, HIGH); //... turn the fan on
+    }
+  }
+}
+#endif
+
+void manage_inactivity() 
+{ 
+  if( (millis() - previous_millis_cmd) >  max_inactive_time ) 
+    if(max_inactive_time) 
+      kill(); 
+  if(stepper_inactive_time)  {
+    if( (millis() - previous_millis_cmd) >  stepper_inactive_time ) 
+    {
+      if(blocks_queued() == false) {
+        disable_x();
+        disable_y();
+        disable_z();
+        disable_e0();
+        disable_e1();
+        disable_e2();
+      }
+    }
+  }
+  #if( KILL_PIN>-1 )
+    if( 0 == READ(KILL_PIN) )
+      kill();
+  #endif
+  #ifdef CONTROLLERFAN_PIN
+    controllerFan(); //Check if fan should be turned on to cool stepper drivers down
+  #endif
+  #ifdef EXTRUDER_RUNOUT_PREVENT
+    if( (millis() - previous_millis_cmd) >  EXTRUDER_RUNOUT_SECONDS*1000 ) 
+    if(degHotend(active_extruder)>EXTRUDER_RUNOUT_MINTEMP)
+    {
+     bool oldstatus=READ(E0_ENABLE_PIN);
+     enable_e0();
+     float oldepos=current_position[E_AXIS];
+     float oldedes=destination[E_AXIS];
+     plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], 
+                      current_position[E_AXIS]+EXTRUDER_RUNOUT_EXTRUDE*EXTRUDER_RUNOUT_ESTEPS/axis_steps_per_unit[E_AXIS], 
+                      EXTRUDER_RUNOUT_SPEED/60.*EXTRUDER_RUNOUT_ESTEPS/axis_steps_per_unit[E_AXIS], active_extruder);
+     current_position[E_AXIS]=oldepos;
+     destination[E_AXIS]=oldedes;
+     plan_set_e_position(oldepos);
+     previous_millis_cmd=millis();
+     st_synchronize();
+     WRITE(E0_ENABLE_PIN,oldstatus);
+    }
+  #endif
+  check_axes_activity();
+}
+
+void kill()
+{
+  cli(); // Stop interrupts
+  disable_heater();
+
+  disable_x();
+  disable_y();
+  disable_z();
+  disable_e0();
+  disable_e1();
+  disable_e2();
+  
+  if(PS_ON_PIN > -1) pinMode(PS_ON_PIN,INPUT);
+  SERIAL_ERROR_START;
+  SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
+  LCD_ALERTMESSAGEPGM(MSG_KILLED);
+  suicide();
+  while(1) { /* Intentionally left empty */ } // Wait for reset
+}
+
+void Stop()
+{
+  disable_heater();
+  if(Stopped == false) {
+    Stopped = true;
+    Stopped_gcode_LastN = gcode_LastN; // Save last g_code for restart
+    SERIAL_ERROR_START;
+    SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
+    LCD_MESSAGEPGM(MSG_STOPPED);
+  }
+}
+
+bool IsStopped() { return Stopped; };
+
+#ifdef FAST_PWM_FAN
+void setPwmFrequency(uint8_t pin, int val)
+{
+  val &= 0x07;
+  switch(digitalPinToTimer(pin))
+  {
+ 
+    #if defined(TCCR0A)
+    case TIMER0A:
+    case TIMER0B:
+//         TCCR0B &= ~(_BV(CS00) | _BV(CS01) | _BV(CS02));
+//         TCCR0B |= val;
+         break;
+    #endif
+
+    #if defined(TCCR1A)
+    case TIMER1A:
+    case TIMER1B:
+//         TCCR1B &= ~(_BV(CS10) | _BV(CS11) | _BV(CS12));
+//         TCCR1B |= val;
+         break;
+    #endif
+
+    #if defined(TCCR2)
+    case TIMER2:
+    case TIMER2:
+         TCCR2 &= ~(_BV(CS10) | _BV(CS11) | _BV(CS12));
+         TCCR2 |= val;
+         break;
+    #endif
+
+    #if defined(TCCR2A)
+    case TIMER2A:
+    case TIMER2B:
+         TCCR2B &= ~(_BV(CS20) | _BV(CS21) | _BV(CS22));
+         TCCR2B |= val;
+         break;
+    #endif
+
+    #if defined(TCCR3A)
+    case TIMER3A:
+    case TIMER3B:
+    case TIMER3C:
+         TCCR3B &= ~(_BV(CS30) | _BV(CS31) | _BV(CS32));
+         TCCR3B |= val;
+         break;
+    #endif
+
+    #if defined(TCCR4A) 
+    case TIMER4A:
+    case TIMER4B:
+    case TIMER4C:
+         TCCR4B &= ~(_BV(CS40) | _BV(CS41) | _BV(CS42));
+         TCCR4B |= val;
+         break;
+   #endif
+
+    #if defined(TCCR5A) 
+    case TIMER5A:
+    case TIMER5B:
+    case TIMER5C:
+         TCCR5B &= ~(_BV(CS50) | _BV(CS51) | _BV(CS52));
+         TCCR5B |= val;
+         break;
+   #endif
+
+  }
+}
+#endif //FAST_PWM_FAN
+
+bool setTargetedHotend(int code){
+  tmp_extruder = active_extruder;
+  if(code_seen('T')) {
+    tmp_extruder = code_value();
+    if(tmp_extruder >= EXTRUDERS) {
+      SERIAL_ECHO_START;
+      switch(code){
+        case 104:
+          SERIAL_ECHO(MSG_M104_INVALID_EXTRUDER);
+          break;
+        case 105:
+          SERIAL_ECHO(MSG_M105_INVALID_EXTRUDER);
+          break;
+        case 109:
+          SERIAL_ECHO(MSG_M109_INVALID_EXTRUDER);
+          break;
+      }
+      SERIAL_ECHOLN(tmp_extruder);
+      return true;
+    }
+  }
+  return false;
+}
diff --git a/Marlin/Sanguino/boards.txt b/Marlin/Sanguino/boards.txt
deleted file mode 100644
index 4f71b8a..0000000
--- a/Marlin/Sanguino/boards.txt
+++ /dev/null
@@ -1,16 +0,0 @@
-##############################################################
-
-sanguino.name=Sanguino
-sanguino.upload.protocol=stk500
-sanguino.upload.maximum_size=63488
-sanguino.upload.speed=38400
-sanguino.bootloader.low_fuses=0xFF
-sanguino.bootloader.high_fuses=0xDC
-sanguino.bootloader.extended_fuses=0xFD
-sanguino.bootloader.path=atmega644p
-sanguino.bootloader.file=ATmegaBOOT_644P.hex
-sanguino.bootloader.unlock_bits=0x3F
-sanguino.bootloader.lock_bits=0x0F
-sanguino.build.mcu=atmega644p
-sanguino.build.f_cpu=16000000L
-sanguino.build.core=arduino
diff --git a/Marlin/Sanguino/bootloaders/atmega644p/ATmegaBOOT.c b/Marlin/Sanguino/bootloaders/atmega644p/ATmegaBOOT.c
deleted file mode 100644
index 1711014..0000000
--- a/Marlin/Sanguino/bootloaders/atmega644p/ATmegaBOOT.c
+++ /dev/null
@@ -1,713 +0,0 @@
-/**********************************************************/
-/* Serial Bootloader for Atmel megaAVR Controllers        */
-/*                                                        */
-/* tested with ATmega644 and ATmega644P                   */
-/* should work with other mega's, see code for details    */
-/*                                                        */
-/* ATmegaBOOT.c                                           */
-/*                                                        */
-/* 20090131: Added 324P support from Alex Leone           */
-/*           Marius Kintel                                */
-/* 20080915: applied ADABoot mods for Sanguino 644P       */
-/*           Brian Riley                                  */
-/* 20080711: hacked for Sanguino by Zach Smith            */
-/*           and Justin Day                               */
-/* 20070626: hacked for Arduino Diecimila (which auto-    */
-/*           resets when a USB connection is made to it)  */
-/*           by D. Mellis                                 */
-/* 20060802: hacked for Arduino by D. Cuartielles         */
-/*           based on a previous hack by D. Mellis        */
-/*           and D. Cuartielles                           */
-/*                                                        */
-/* Monitor and debug functions were added to the original */
-/* code by Dr. Erik Lins, chip45.com. (See below)         */
-/*                                                        */
-/* Thanks to Karl Pitrich for fixing a bootloader pin     */
-/* problem and more informative LED blinking!             */
-/*                                                        */
-/* For the latest version see:                            */
-/* http://www.chip45.com/                                 */
-/*                                                        */
-/* ------------------------------------------------------ */
-/*                                                        */
-/* based on stk500boot.c                                  */
-/* Copyright (c) 2003, Jason P. Kyle                      */
-/* All rights reserved.                                   */
-/* see avr1.org for original file and information         */
-/*                                                        */
-/* This program is free software; you can redistribute it */
-/* and/or modify it under the terms of the GNU General    */
-/* Public License as published by the Free Software       */
-/* Foundation; either version 2 of the License, or        */
-/* (at your option) any later version.                    */
-/*                                                        */
-/* This program is distributed in the hope that it will   */
-/* be useful, but WITHOUT ANY WARRANTY; without even the  */
-/* implied warranty of MERCHANTABILITY or FITNESS FOR A   */
-/* PARTICULAR PURPOSE.  See the GNU General Public        */
-/* License for more details.                              */
-/*                                                        */
-/* You should have received a copy of the GNU General     */
-/* Public License along with this program; if not, write  */
-/* to the Free Software Foundation, Inc.,                 */
-/* 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA */
-/*                                                        */
-/* Licence can be viewed at                               */
-/* http://www.fsf.org/licenses/gpl.txt                    */
-/*                                                        */
-/* Target = Atmel AVR m128,m64,m32,m16,m8,m162,m163,m169, */
-/* m8515,m8535. ATmega161 has a very small boot block so  */
-/* isn't supported.                                       */
-/*                                                        */
-/* Tested with m168                                       */
-/**********************************************************/
-
-/* $Id$ */
-
-
-/* some includes */
-#include <inttypes.h>
-#include <avr/io.h>
-#include <avr/pgmspace.h>
-#include <avr/interrupt.h>
-#include <avr/wdt.h>
-#include <avr/boot.h>
-
-#ifdef ADABOOT
-    #define NUM_LED_FLASHES 3
-    #define ADABOOT_VER	1
-#endif
-
-
-/* 20070707: hacked by David A. Mellis - after this many errors give up and launch application */
-#define MAX_ERROR_COUNT 5
-
-/* set the UART baud rate */
-/* 20080711: hack by Zach Hoeken */
-#define BAUD_RATE   38400
-
-/* SW_MAJOR and MINOR needs to be updated from time to time to avoid warning message from AVR Studio */
-/* never allow AVR Studio to do an update !!!! */
-#define HW_VER	 0x02
-#define SW_MAJOR 0x01
-#define SW_MINOR 0x10
-
-/* onboard LED is used to indicate, that the bootloader was entered (3x flashing) */
-/* if monitor functions are included, LED goes on after monitor was entered */
-#define LED_DDR  DDRB
-#define LED_PORT PORTB
-#define LED_PIN  PINB
-#define LED      PINB0
-
-/* define various device id's */
-/* manufacturer byte is always the same */
-#define SIG1	0x1E	// Yep, Atmel is the only manufacturer of AVR micros.  Single source :(
-#if defined(__AVR_ATmega644P__)
-#define SIG2	0x96
-#define SIG3	0x0A
-#elif defined(__AVR_ATmega644__)
-#define SIG2	0x96
-#define SIG3	0x09
-#elif defined(__AVR_ATmega324P__)
-#define SIG2	0x95
-#define SIG3	0x08
-#endif
-#define PAGE_SIZE		0x080U   //128 words
-#define PAGE_SIZE_BYTES	0x100U   //256 bytes
-
-/* function prototypes */
-void putch(char);
-char getch(void);
-void getNch(uint8_t);
-void byte_response(uint8_t);
-void nothing_response(void);
-char gethex(void);
-void puthex(char);
-void flash_led(uint8_t);
-
-/* some variables */
-union address_union
-{
-    uint16_t word;
-    uint8_t  byte[2];
-} address;
-
-union length_union
-{
-    uint16_t word;
-    uint8_t  byte[2];
-} length;
-
-struct flags_struct
-{
-    unsigned eeprom : 1;
-    unsigned rampz  : 1;
-} flags;
-
-uint8_t buff[256];
-
-uint8_t error_count = 0;
-uint8_t sreg;
-
-void (*app_start)(void) = 0x0000;
-
-/* main program starts here */
-int main(void)
-{
-    uint8_t ch,ch2;
-    uint16_t w;
-	uint16_t i;
-	
-    asm volatile("nop\n\t");
-
-#ifdef ADABOOT		// BBR/LF 10/8/2007 & 9/13/2008
-    ch = MCUSR;
-    MCUSR = 0;
-
-    WDTCSR |= _BV(WDCE) | _BV(WDE);
-    WDTCSR = 0;
-
-    // Check if the WDT was used to reset, in which case we dont bootload and skip straight to the code. woot.
-    if (! (ch &  _BV(EXTRF))) // if its a not an external reset...
-      app_start();  // skip bootloader
-#endif
-
-
-	//initialize our serial port.
-    UBRR0L = (uint8_t)(F_CPU/(BAUD_RATE*16L)-1);
-    UBRR0H = (F_CPU/(BAUD_RATE*16L)-1) >> 8;
-    UCSR0B = (1<<RXEN0) | (1<<TXEN0);
-    UCSR0C = (1<<UCSZ00) | (1<<UCSZ01);
-
-    /* Enable internal pull-up resistor on pin D0 (RX), in order
-    to supress line noise that prevents the bootloader from
-    timing out (DAM: 20070509) */
-    DDRD &= ~_BV(PIND0);
-    PORTD |= _BV(PIND0);
-
-    /* set LED pin as output */
-    LED_DDR |= _BV(LED);
-
-	    /* flash onboard LED to signal entering of bootloader                   */
-	    /* ADABOOT will do two series of flashes. first 4 - signifying ADABOOT  */
-	    /* then a pause and another flash series signifying ADABOOT sub-version */
-
-
-	flash_led(NUM_LED_FLASHES);
-
-	#ifdef	ADABOOT
-		flash_led(ADABOOT_VER);		// BBR 9/13/2008
-	#endif 
-
-    /* forever loop */
-    for (;;)
-	{
-		/* get character from UART */
-		ch = getch();
-
-		/* A bunch of if...else if... gives smaller code than switch...case ! */
-
-		/* Hello is anyone home ? */ 
-		if(ch=='0')
-		    nothing_response();
-
-
-		/* Request programmer ID */
-		/* Not using PROGMEM string due to boot block in m128 being beyond 64kB boundry  */
-		/* Would need to selectively manipulate RAMPZ, and it's only 9 characters anyway so who cares.  */
-		else if(ch=='1')
-		{
-		    if (getch() == ' ')
-			{
-				putch(0x14);
-				putch('A');
-				putch('V');
-				putch('R');
-				putch(' ');
-				putch('I');
-				putch('S');
-				putch('P');
-				putch(0x10);
-		    }
-			else
-			{
-				if (++error_count == MAX_ERROR_COUNT)
-				    app_start();
-		    }
-		}
-
-
-		/* AVR ISP/STK500 board commands  DON'T CARE so default nothing_response */
-		else if(ch=='@')
-		{
-		    ch2 = getch();
-		    if (ch2 > 0x85)
-				getch();
-		    nothing_response();
-		}
-
-
-		/* AVR ISP/STK500 board requests */
-		else if(ch=='A')
-		{
-		    ch2 = getch();
-		    if(ch2 == 0x80)
-				byte_response(HW_VER);		// Hardware version
-		    else if(ch2==0x81)
-				byte_response(SW_MAJOR);	// Software major version
-		    else if(ch2==0x82)
-				byte_response(SW_MINOR);	// Software minor version
-		    else if(ch2==0x98)
-				byte_response(0x03);		// Unknown but seems to be required by avr studio 3.56
-		    else
-				byte_response(0x00);		// Covers various unnecessary responses we don't care about
-		}
-
-
-		/* Device Parameters  DON'T CARE, DEVICE IS FIXED  */
-		else if(ch=='B')
-		{
-		    getNch(20);
-		    nothing_response();
-		}
-
-
-		/* Parallel programming stuff  DON'T CARE  */
-		else if(ch=='E')
-		{
-		    getNch(5);
-		    nothing_response();
-		}
-
-
-		/* Enter programming mode  */
-		else if(ch=='P')
-		{
-		    nothing_response();
-		}
-
-
-		/* Leave programming mode  */
-		else if(ch=='Q')
-		{
-		    nothing_response();
-#ifdef ADABOOT		
-			// autoreset via watchdog (sneaky!) BBR/LF 9/13/2008
-	  		WDTCSR = _BV(WDE);
-	  		while (1); // 16 ms
-#endif		
-		}
-
-
-		/* Erase device, don't care as we will erase one page at a time anyway.  */
-		else if(ch=='R')
-		{
-		    nothing_response();
-		}
-
-
-		/* Set address, little endian. EEPROM in bytes, FLASH in words  */
-		/* Perhaps extra address bytes may be added in future to support > 128kB FLASH.  */
-		/* This might explain why little endian was used here, big endian used everywhere else.  */
-		else if(ch=='U')
-		{
-		    address.byte[0] = getch();
-		    address.byte[1] = getch();
-		    nothing_response();
-		}
-
-
-		/* Universal SPI programming command, disabled.  Would be used for fuses and lock bits.  */
-		else if(ch=='V')
-		{
-		    getNch(4);
-		    byte_response(0x00);
-		}
-
-
-		/* Write memory, length is big endian and is in bytes  */
-		else if(ch=='d')
-		{
-		    length.byte[1] = getch();
-		    length.byte[0] = getch();
-	
-		    flags.eeprom = 0;
-		    if (getch() == 'E')
-				flags.eeprom = 1;
-
-			for (i=0; i<PAGE_SIZE; i++)
-				buff[i] = 0;
-		
-		    for (w = 0; w < length.word; w++)
-			{
-				// Store data in buffer, can't keep up with serial data stream whilst programming pages
-				buff[w] = getch();
-		    }
-	
-		    if (getch() == ' ')
-			{
-				if (flags.eeprom)
-				{		                
-					//Write to EEPROM one byte at a time
-				    for(w=0;w<length.word;w++)
-					{
-						while(EECR & (1<<EEPE));
-					
-						EEAR = (uint16_t)(void *)address.word;
-						EEDR = buff[w];
-						EECR |= (1<<EEMPE);
-						EECR |= (1<<EEPE);
-
-						address.word++;
-				    }			
-				}
-				else
-				{
-					//address * 2 -> byte location
-				    address.word = address.word << 1;
-			    
-					//Even up an odd number of bytes
-					if ((length.byte[0] & 0x01))
-						length.word++;
-				
-					// HACKME: EEPE used to be EEWE
-				    //Wait for previous EEPROM writes to complete
-					//while(bit_is_set(EECR,EEPE));
-					while(EECR & (1<<EEPE));
-				
-				    asm volatile(
-						 "clr	r17		\n\t"	//page_word_count
-						 "lds	r30,address	\n\t"	//Address of FLASH location (in bytes)
-						 "lds	r31,address+1	\n\t"
-						 "ldi	r28,lo8(buff)	\n\t"	//Start of buffer array in RAM
-						 "ldi	r29,hi8(buff)	\n\t"
-						 "lds	r24,length	\n\t"	//Length of data to be written (in bytes)
-						 "lds	r25,length+1	\n\t"
-						 "length_loop:		\n\t"	//Main loop, repeat for number of words in block							 							 
-						 "cpi	r17,0x00	\n\t"	//If page_word_count=0 then erase page
-						 "brne	no_page_erase	\n\t"						 
-						 "wait_spm1:		\n\t"
-						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
-						 "andi	r16,1           \n\t"
-						 "cpi	r16,1           \n\t"
-						 "breq	wait_spm1       \n\t"
-						 "ldi	r16,0x03	\n\t"	//Erase page pointed to by Z
-						 "sts	%0,r16		\n\t"
-						 "spm			\n\t"							 
-						 "wait_spm2:		\n\t"
-						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
-						 "andi	r16,1           \n\t"
-						 "cpi	r16,1           \n\t"
-						 "breq	wait_spm2       \n\t"									 
-
-						 "ldi	r16,0x11	\n\t"	//Re-enable RWW section
-						 "sts	%0,r16		\n\t"						 			 
-						 "spm			\n\t"
-						 "no_page_erase:		\n\t"							 
-						 "ld	r0,Y+		\n\t"	//Write 2 bytes into page buffer
-						 "ld	r1,Y+		\n\t"							 
-							 
-						 "wait_spm3:		\n\t"
-						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
-						 "andi	r16,1           \n\t"
-						 "cpi	r16,1           \n\t"
-						 "breq	wait_spm3       \n\t"
-						 "ldi	r16,0x01	\n\t"	//Load r0,r1 into FLASH page buffer
-						 "sts	%0,r16		\n\t"
-						 "spm			\n\t"
-							 
-						 "inc	r17		\n\t"	//page_word_count++
-						 "cpi r17,%1	        \n\t"
-						 "brlo	same_page	\n\t"	//Still same page in FLASH
-						 "write_page:		\n\t"
-						 "clr	r17		\n\t"	//New page, write current one first
-						 "wait_spm4:		\n\t"
-						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
-						 "andi	r16,1           \n\t"
-						 "cpi	r16,1           \n\t"
-						 "breq	wait_spm4       \n\t"						 							 
-						 "ldi	r16,0x05	\n\t"	//Write page pointed to by Z
-						 "sts	%0,r16		\n\t"
-						 "spm			\n\t"
-						 "wait_spm5:		\n\t"
-						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
-						 "andi	r16,1           \n\t"
-						 "cpi	r16,1           \n\t"
-						 "breq	wait_spm5       \n\t"									 
-						 "ldi	r16,0x11	\n\t"	//Re-enable RWW section
-						 "sts	%0,r16		\n\t"						 			 
-						 "spm			\n\t"					 		 
-						 "same_page:		\n\t"							 
-						 "adiw	r30,2		\n\t"	//Next word in FLASH
-						 "sbiw	r24,2		\n\t"	//length-2
-						 "breq	final_write	\n\t"	//Finished
-						 "rjmp	length_loop	\n\t"
-						 "final_write:		\n\t"
-						 "cpi	r17,0		\n\t"
-						 "breq	block_done	\n\t"
-						 "adiw	r24,2		\n\t"	//length+2, fool above check on length after short page write
-						 "rjmp	write_page	\n\t"
-						 "block_done:		\n\t"
-						 "clr	__zero_reg__	\n\t"	//restore zero register
-						 : "=m" (SPMCSR) : "M" (PAGE_SIZE) : "r0","r16","r17","r24","r25","r28","r29","r30","r31"
-
-						 );
-				}
-				putch(0x14);
-				putch(0x10);
-		    }
-			else
-			{
-				if (++error_count == MAX_ERROR_COUNT)
-				    app_start();
-		    }		
-		}
-    
-		/* Read memory block mode, length is big endian.  */
-		else if(ch=='t')
-		{
-			length.byte[1] = getch();
-			length.byte[0] = getch();
-
-			if (getch() == 'E')
-				flags.eeprom = 1;
-			else
-			{
-				flags.eeprom = 0;
-				address.word = address.word << 1;	        // address * 2 -> byte location
-			}
-
-			// Command terminator
-			if (getch() == ' ')
-			{
-				putch(0x14);
-				for (w=0; w<length.word; w++)
-				{
-					// Can handle odd and even lengths okay
-				    if (flags.eeprom) 
-					{
-						// Byte access EEPROM read
-						while(EECR & (1<<EEPE));
-						EEAR = (uint16_t)(void *)address.word;
-						EECR |= (1<<EERE);
-						putch(EEDR);
-
-						address.word++;
-				    }
-				    else
-					{
-						if (!flags.rampz)
-							putch(pgm_read_byte_near(address.word));
-
-						address.word++;
-				    }
-				}
-				putch(0x10);
-		    }
-		}
-
-
-		/* Get device signature bytes  */
-		else if(ch=='u')
-		{
-			if (getch() == ' ')
-			{
-				putch(0x14);
-				putch(SIG1);
-				putch(SIG2);
-				putch(SIG3);
-				putch(0x10);
-			}
-			else
-			{
-				if (++error_count == MAX_ERROR_COUNT)
-					app_start();
-			}
-		}
-
-
-		/* Read oscillator calibration byte */
-		else if(ch=='v')
-			byte_response(0x00);
-
-		else if (++error_count == MAX_ERROR_COUNT)
-		    app_start();
-
-	}
-    /* end of forever loop */
-}
-
-
-char gethex(void)
-{
-    char ah,al;
-
-    ah = getch();
-	putch(ah);
-    al = getch();
-	putch(al);
-    
-	if(ah >= 'a')
-		ah = ah - 'a' + 0x0a;
-	else if(ah >= '0')
-		ah -= '0';
-    if(al >= 'a')
-		al = al - 'a' + 0x0a;
-	else if(al >= '0')
-		al -= '0';
-
-    return (ah << 4) + al;
-}
-
-
-void puthex(char ch)
-{
-    char ah,al;
-
-    ah = (ch & 0xf0) >> 4;
-	if(ah >= 0x0a)
-		ah = ah - 0x0a + 'a';
-	else
-		ah += '0';
-
-    al = (ch & 0x0f);
-	if(al >= 0x0a)
-		al = al - 0x0a + 'a';
-	else
-		al += '0';
-
-    putch(ah);
-    putch(al);
-}
-
-
-void putch(char ch)
-{
-    while (!(UCSR0A & _BV(UDRE0)));
-    UDR0 = ch;
-}
-
-
-
-
-char getch(void)
-{
-    uint32_t count = 0;
-
-#ifdef ADABOOT
-	LED_PORT &= ~_BV(LED);          // toggle LED to show activity - BBR/LF 10/3/2007 & 9/13/2008
-#endif
-
-    while(!(UCSR0A & _BV(RXC0)))
-	{
-    	/* 20060803 DojoCorp:: Addon coming from the previous Bootloader*/               
-    	/* HACKME:: here is a good place to count times*/
-    	count++;
-    	if (count > MAX_TIME_COUNT)
-    		app_start();
-     }
-
-#ifdef ADABOOT
-	LED_PORT |= _BV(LED);          // toggle LED to show activity - BBR/LF 10/3/2007 & 9/13/2008
-#endif
-
-    return UDR0;
-}
-
-
-void getNch(uint8_t count)
-{
-    uint8_t i;
-    for(i=0;i<count;i++)
-	{
-		while(!(UCSR0A & _BV(RXC0)));
-		UDR0;
-    }
-}
-
-
-void byte_response(uint8_t val)
-{
-    if (getch() == ' ')
-	{
-		putch(0x14);
-		putch(val);
-		putch(0x10);
-    }
-	else
-	{
-		if (++error_count == MAX_ERROR_COUNT)
-		    app_start();
-    }
-}
-
-
-void nothing_response(void)
-{
-    if (getch() == ' ')
-	{
-		putch(0x14);
-		putch(0x10);
-    }
-	else
-	{
-		if (++error_count == MAX_ERROR_COUNT)
-		    app_start();
-    }
-}
-
-#ifdef ADABOOT
-
-void flash_led(uint8_t count)
-{
-    /* flash onboard LED count times to signal entering of bootloader */
-	/* l needs to be volatile or the delay loops below might get      */
-	/* optimized away if compiling with optimizations (DAM).          */
-	
-    volatile uint32_t l;
-
-    if (count == 0) {
-      count = ADABOOT;
-    }
-    
-
-	int8_t i;
-    for (i = 0; i < count; ++i) {
-		LED_PORT |= _BV(LED);					// LED on
-		for(l = 0; l < (F_CPU / 1000); ++l);		// delay NGvalue was 1000 for both loops - BBR
-		LED_PORT &= ~_BV(LED);					// LED off
-		for(l = 0; l < (F_CPU / 250); ++l);		// delay asymmteric for ADA BOOT BBR 
-	}
-
-	for(l = 0; l < (F_CPU / 100); ++l);		    // pause ADA BOOT BBR 
-		
-}
-
-#else
-
-void flash_led(uint8_t count)
-{
-    /* flash onboard LED three times to signal entering of bootloader */
-	/* l needs to be volatile or the delay loops below might get
-	optimized away if compiling with optimizations (DAM). */
-    volatile uint32_t l;
-
-    if (count == 0) {
-      count = 3;
-    }
-    
-	int8_t i;
-    for (i = 0; i < count; ++i) {
-		LED_PORT |= _BV(LED);
-		for(l = 0; l < (F_CPU / 1000); ++l);
-		LED_PORT &= ~_BV(LED);
-		for(l = 0; l < (F_CPU / 1000); ++l); 
-	}
-		
-}
-
-
-#endif
-
-
-/* end of file ATmegaBOOT.c */
diff --git a/Marlin/Sanguino/bootloaders/atmega644p/ATmegaBOOT_324P.hex b/Marlin/Sanguino/bootloaders/atmega644p/ATmegaBOOT_324P.hex
deleted file mode 100644
index e67fe88..0000000
--- a/Marlin/Sanguino/bootloaders/atmega644p/ATmegaBOOT_324P.hex
+++ /dev/null
@@ -1,121 +0,0 @@
-:10F800000C943E7C0C945B7C0C945B7C0C945B7C39
-:10F810000C945B7C0C945B7C0C945B7C0C945B7C0C
-:10F820000C945B7C0C945B7C0C945B7C0C945B7CFC
-:10F830000C945B7C0C945B7C0C945B7C0C945B7CEC
-:10F840000C945B7C0C945B7C0C945B7C0C945B7CDC
-:10F850000C945B7C0C945B7C0C945B7C0C945B7CCC
-:10F860000C945B7C0C945B7C0C945B7C0C945B7CBC
-:10F870000C945B7C0C945B7C0C945B7C11241FBE11
-:10F88000CFEFD8E0DEBFCDBF11E0A0E0B1E0E6E60B
-:10F89000FFEF02C005900D92A030B107D9F712E03A
-:10F8A000A0E0B1E001C01D92A930B107E1F70E94CC
-:10F8B000537D0C94B27F0C94007CCF93DF93CDB733
-:10F8C000DEB724970FB6F894DEBF0FBECDBF8823F6
-:10F8D00009F481E020E0482F55274115510509F42E
-:10F8E0003DC0289A19821A821B821C820BC0898112
-:10F8F0009A81AB81BC810196A11DB11D89839A8338
-:10F90000AB83BC8389819A81AB81BC8180589E4343
-:10F91000A040B04060F3289819821A821B821C8292
-:10F920000BC089819A81AB81BC810196A11DB11D5B
-:10F9300089839A83AB83BC8389819A81AB81BC81A3
-:10F9400080509A4FA040B04060F32F5F822F9927DC
-:10F9500087FD9095841795070CF4C3CF19821A82FE
-:10F960001B821C8289819A81AB81BC818050914726
-:10F97000A240B040A0F489819A81AB81BC810196FC
-:10F98000A11DB11D89839A83AB83BC8389819A8130
-:10F99000AB81BC8180509147A240B04060F3249677
-:10F9A0000FB6F894DEBF0FBECDBFDF91CF910895A3
-:10F9B000EF92FF920F931F93EE24FF248701289864
-:10F9C0008091C00087FD17C00894E11CF11C011D47
-:10F9D000111D81E0E81689E0F8068DE3080780E054
-:10F9E000180770F3E0910001F091010109958091F1
-:10F9F000C00087FFE9CF289A8091C600992787FD2C
-:10FA000090951F910F91FF90EF900895982F8091FE
-:10FA1000C00085FFFCCF9093C60008950E94D87C5B
-:10FA2000803271F0809102018F5F809302018530F6
-:10FA300009F00895E0910001F09101010995089500
-:10FA400084E10E94067D80E10E94067D0895CF93A7
-:10FA5000C82F0E94D87C803241F0809102018F5FD4
-:10FA600080930201853081F40AC084E10E94067D02
-:10FA70008C2F0E94067D80E10E94067D05C0E091EA
-:10FA80000001F09101010995CF910895282F90E090
-:10FA900007C08091C0008823E4F78091C6009F5F73
-:10FAA0009217B8F30895CFEFD8E0DEBFCDBF0000C6
-:10FAB00094B714BE809160008861809360001092BA
-:10FAC000600091FF74C189E18093C4001092C50069
-:10FAD00088E18093C10086E08093C2005098589AD4
-:10FAE000209A83E00E945D7C81E00E945D7C0E9400
-:10FAF000D87C8033B9F18133C1F1803409F456C028
-:10FB0000813409F45CC0823409F46EC0853409F490
-:10FB100071C0803539F1813509F4F3C0823511F1B6
-:10FB2000853509F4D3C0863509F4CBC0843609F491
-:10FB300065C0843709F4EBC0853709F4D2C0863735
-:10FB400009F44AC0809102018F5F809302018530E1
-:10FB500071F6E0910001F091010109950E94D87CB5
-:10FB6000803349F60E940E7DC2CF0E94D87CC82FF8
-:10FB7000803241F784E10E94067D81E40E94067D87
-:10FB800086E50E94067D82E50E94067D8C2F0E94FC
-:10FB9000067D89E40E94067D83E50E94067D80E55E
-:10FBA0000E94067D80E10E94067DA1CF0E94D87C44
-:10FBB0008638C0F20E94D87C0E940E7D98CF0E94A9
-:10FBC000D87C803809F407C1813809F400C1823833
-:10FBD00009F4F9C0883921F080E00E94277D87CFA1
-:10FBE00083E00E94277D83CF84E10E94467D0E94AE
-:10FBF0000E7D7DCF85E00E94467DF9CF0E94D87CA6
-:10FC0000809306020E94D87C8093050280910802AE
-:10FC10008E7F809308020E94D87C853409F44BC003
-:10FC2000E5E0F1E0119281E0E438F807D9F3D0F390
-:10FC3000C0E0D0E0809105029091060218161906E6
-:10FC400078F405E011E00E94D87CF80181938F01DF
-:10FC500021968091050290910602C817D90798F362
-:10FC60000E94D87C803209F06DCF8091080280FF1D
-:10FC7000B6C0C0E0D0E02091050230910602121615
-:10FC80001306B8F4E0910301F0910401A5E0B1E09E
-:10FC9000F999FECFF2BDE1BD8D9180BDFA9AF99A36
-:10FCA00031962196C217D30798F3F0930401E0939D
-:10FCB000030184E175CF809108028160809308027E
-:10FCC000AFCF84E00E94467D80E087CF0E94D87C41
-:10FCD000809303010E94D87C809304010E940E7DD2
-:10FCE00006CF0E94D87C803209F02CCF84E10E949C
-:10FCF000067D8EE10E94067D85E90E94067D88E0F2
-:10FD00004FCF0E940E7D88E080936000FFCF0E945D
-:10FD1000D87C809306020E94D87C809305020E94C2
-:10FD2000D87C853409F449C0809108028E7F809385
-:10FD300008028091030190910401880F991F90930C
-:10FD40000401809303010E94D87C803209F0CFCE59
-:10FD500084E10E94067DC0E0D0E020910502309150
-:10FD600006021216130608F01DCFE0910301F09170
-:10FD700004018091080280FF96C0F999FECFF2BD80
-:10FD8000E1BDF89A80B50E94067DE0910301F091F3
-:10FD900004013196F0930401E093030120910502E0
-:10FDA000309106022196C217D30718F3FBCEE091DB
-:10FDB0000001F0910101099586CE809108028160D1
-:10FDC00080930802C0CF80E10E94277D90CE81E021
-:10FDD0000E94277D8CCE82E00E94277D88CE809174
-:10FDE000030190910401880F991F9093040180935F
-:10FDF00003018091050280FF09C080910502909166
-:10FE0000060201969093060280930502F999FECFAF
-:10FE10001127E0910301F0910401C5E0D1E0809148
-:10FE2000050290910602103091F400915700017084
-:10FE30000130D9F303E000935700E8950091570093
-:10FE400001700130D9F301E100935700E895099062
-:10FE500019900091570001700130D9F301E000932F
-:10FE60005700E8951395103898F011270091570026
-:10FE700001700130D9F305E000935700E895009137
-:10FE8000570001700130D9F301E100935700E89564
-:10FE90003296029709F0C7CF103011F00296E5CFE5
-:10FEA000112484E17DCE869580FF06C03196F093C3
-:10FEB0000401E093030176CF84910E94067D209196
-:10FEC000050230910602E0910301F0910401EECFAA
-:10FED0001F93CF930E94D87CC82F0E94067D0E945A
-:10FEE000D87C182F0E94067DC1362CF0C7551136DC
-:10FEF0003CF0175508C0C033D4F3C0531136CCF7CB
-:10FF000010330CF01053C295C07FC10F8C2F99276E
-:10FF100087FD9095CF911F910895CF93282F992712
-:10FF200087FD9095807F907095958795959587959D
-:10FF300095958795959587958A303CF0895AC22F7B
-:10FF4000CF70CA303CF0C95A06C0805DC22FCF7056
-:10FF5000CA30CCF7C05D0E94067D8C2F0E94067DC2
-:06FF6000CF910895FFCFD0
-:040000030000F80001
-:00000001FF
diff --git a/Marlin/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644.hex b/Marlin/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644.hex
deleted file mode 100644
index d5557de..0000000
--- a/Marlin/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644.hex
+++ /dev/null
@@ -1,120 +0,0 @@
-:10F800000C94387C0C94557C0C94557C0C94557C51
-:10F810000C94557C0C94557C0C94557C0C94557C24
-:10F820000C94557C0C94557C0C94557C0C94557C14
-:10F830000C94557C0C94557C0C94557C0C94557C04
-:10F840000C94557C0C94557C0C94557C0C94557CF4
-:10F850000C94557C0C94557C0C94557C0C94557CE4
-:10F860000C94557C0C94557C0C94557C0C94557CD4
-:10F8700011241FBECFEFD0E1DEBFCDBF11E0A0E06D
-:10F88000B1E0EAE5FFEF02C005900D92A030B107AC
-:10F89000D9F712E0A0E0B1E001C01D92A930B10794
-:10F8A000E1F70E944D7D0C94AC7F0C94007CCF93CB
-:10F8B000DF93CDB7DEB724970FB6F894DEBF0FBE47
-:10F8C000CDBF882309F481E020E0482F552741155A
-:10F8D000510509F43DC0289A19821A821B821C82A4
-:10F8E0000BC089819A81AB81BC810196A11DB11D9C
-:10F8F00089839A83AB83BC8389819A81AB81BC81E4
-:10F9000080589E43A040B04060F3289819821A8224
-:10F910001B821C820BC089819A81AB81BC810196BC
-:10F92000A11DB11D89839A83AB83BC8389819A8190
-:10F93000AB81BC8180509A4FA040B04060F32F5FF4
-:10F94000822F992787FD9095841795070CF4C3CFD4
-:10F9500019821A821B821C8289819A81AB81BC81A7
-:10F9600080509147A240B040A0F489819A81AB8138
-:10F97000BC810196A11DB11D89839A83AB83BC8391
-:10F9800089819A81AB81BC8180509147A240B0406F
-:10F9900060F324960FB6F894DEBF0FBECDBFDF91A3
-:10F9A000CF910895EF92FF920F931F93EE24FF24BF
-:10F9B000870128988091C00087FD17C00894E11C3A
-:10F9C000F11C011D111D81E0E81689E0F8068DE3A8
-:10F9D000080780E0180770F3E0910001F091010141
-:10F9E00009958091C00087FFE9CF289A8091C600D1
-:10F9F000992787FD90951F910F91FF90EF900895A3
-:10FA0000982F8091C00085FFFCCF9093C600089589
-:10FA10000E94D27C803271F0809102018F5F8093CE
-:10FA20000201853009F00895E0910001F091010193
-:10FA30000995089584E10E94007D80E10E94007D87
-:10FA40000895CF93C82F0E94D27C803241F08091DC
-:10FA500002018F5F80930201853081F40AC084E146
-:10FA60000E94007D8C2F0E94007D80E10E94007D1D
-:10FA700005C0E0910001F09101010995CF91089531
-:10FA8000282F90E007C08091C0008823E4F7809180
-:10FA9000C6009F5F9217B8F30895CFEFD0E1DEBFA5
-:10FAA000CDBF000094B714BE809160008861809340
-:10FAB00060001092600091FF74C189E18093C400DE
-:10FAC0001092C50088E18093C10086E08093C20057
-:10FAD0005098589A209A83E00E94577C81E00E94B7
-:10FAE000577C0E94D27C8033B9F18133C1F18034DC
-:10FAF00009F456C0813409F45CC0823409F46EC044
-:10FB0000853409F471C0803539F1813509F4F3C0C9
-:10FB1000823511F1853509F4D3C0863509F4CBC09F
-:10FB2000843609F465C0843709F4EBC0853709F4DD
-:10FB3000D2C0863709F44AC0809102018F5F80935A
-:10FB40000201853071F6E0910001F0910101099503
-:10FB50000E94D27C803349F60E94087DC2CF0E9469
-:10FB6000D27CC82F803241F784E10E94007D81E47D
-:10FB70000E94007D86E50E94007D82E50E94007D56
-:10FB80008C2F0E94007D89E40E94007D83E50E9405
-:10FB9000007D80E50E94007D80E10E94007DA1CF74
-:10FBA0000E94D27C8638C0F20E94D27C0E94087DDE
-:10FBB00098CF0E94D27C803809F407C1813809F4BB
-:10FBC00000C1823809F4F9C0883921F080E00E9430
-:10FBD000217D87CF83E00E94217D83CF84E10E9435
-:10FBE000407D0E94087D7DCF85E00E94407DF9CF59
-:10FBF0000E94D27C809306020E94D27C80930502F0
-:10FC0000809108028E7F809308020E94D27C853406
-:10FC100009F44BC0E5E0F1E0119281E0E438F80727
-:10FC2000D9F3D0F3C0E0D0E08091050290910602B4
-:10FC30001816190678F405E011E00E94D27CF8014C
-:10FC400081938F0121968091050290910602C81739
-:10FC5000D90798F30E94D27C803209F06DCF809151
-:10FC6000080280FFB6C0C0E0D0E0209105023091CC
-:10FC7000060212161306B8F4E0910301F091040194
-:10FC8000A5E0B1E0F999FECFF2BDE1BD8D9180BD57
-:10FC9000FA9AF99A31962196C217D30798F3F093FE
-:10FCA0000401E093030184E175CF80910802816033
-:10FCB00080930802AFCF84E00E94407D80E087CF30
-:10FCC0000E94D27C809303010E94D27C8093040125
-:10FCD0000E94087D06CF0E94D27C803209F02CCF92
-:10FCE00084E10E94007D8EE10E94007D86E90E94F1
-:10FCF000007D89E04FCF0E94087D88E080936000FE
-:10FD0000FFCF0E94D27C809306020E94D27C809317
-:10FD100005020E94D27C853409F449C08091080212
-:10FD20008E7F809308028091030190910401880FD7
-:10FD3000991F90930401809303010E94D27C80322A
-:10FD400009F0CFCE84E10E94007DC0E0D0E0209198
-:10FD50000502309106021216130608F01DCFE0913D
-:10FD60000301F09104018091080280FF96C0F99987
-:10FD7000FECFF2BDE1BDF89A80B50E94007DE09112
-:10FD80000301F09104013196F0930401E093030123
-:10FD900020910502309106022196C217D30718F36D
-:10FDA000FBCEE0910001F0910101099586CE809192
-:10FDB0000802816080930802C0CF80E10E94217D0B
-:10FDC00090CE81E00E94217D8CCE82E00E94217D38
-:10FDD00088CE8091030190910401880F991F909320
-:10FDE0000401809303018091050280FF09C0809186
-:10FDF00005029091060201969093060280930502F7
-:10FE0000F999FECF1127E0910301F0910401C5E0BB
-:10FE1000D1E08091050290910602103091F400919A
-:10FE2000570001700130D9F303E000935700E895C3
-:10FE30000091570001700130D9F301E100935700A0
-:10FE4000E895099019900091570001700130D9F39D
-:10FE500001E000935700E8951395103898F01127AA
-:10FE60000091570001700130D9F305E0009357006D
-:10FE7000E8950091570001700130D9F301E100933A
-:10FE80005700E8953296029709F0C7CF103011F06D
-:10FE90000296E5CF112484E17DCE869580FF06C0D1
-:10FEA0003196F0930401E093030176CF84910E9490
-:10FEB000007D2091050230910602E0910301F0914E
-:10FEC0000401EECF1F93CF930E94D27CC82F0E94D3
-:10FED000007D0E94D27C182F0E94007DC1362CF03C
-:10FEE000C75511363CF0175508C0C033D4F3C05382
-:10FEF0001136CCF710330CF01053C295C07FC10FF0
-:10FF00008C2F992787FD9095CF911F910895CF93BE
-:10FF1000282F992787FD9095807F907095958795DC
-:10FF20009595879595958795959587958A303CF019
-:10FF3000895AC22FCF70CA303CF0C95A06C0805DC2
-:10FF4000C22FCF70CA30CCF7C05D0E94007D8C2FCD
-:0AFF50000E94007DCF910895FFCFBD
-:040000030000F80001
-:00000001FF
diff --git a/Marlin/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644P.hex b/Marlin/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644P.hex
deleted file mode 100644
index 99a6ae1..0000000
--- a/Marlin/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644P.hex
+++ /dev/null
@@ -1,121 +0,0 @@
-:10F800000C943E7C0C945B7C0C945B7C0C945B7C39
-:10F810000C945B7C0C945B7C0C945B7C0C945B7C0C
-:10F820000C945B7C0C945B7C0C945B7C0C945B7CFC
-:10F830000C945B7C0C945B7C0C945B7C0C945B7CEC
-:10F840000C945B7C0C945B7C0C945B7C0C945B7CDC
-:10F850000C945B7C0C945B7C0C945B7C0C945B7CCC
-:10F860000C945B7C0C945B7C0C945B7C0C945B7CBC
-:10F870000C945B7C0C945B7C0C945B7C11241FBE11
-:10F88000CFEFD0E1DEBFCDBF11E0A0E0B1E0E6E612
-:10F89000FFEF02C005900D92A030B107D9F712E03A
-:10F8A000A0E0B1E001C01D92A930B107E1F70E94CC
-:10F8B000537D0C94B27F0C94007CCF93DF93CDB733
-:10F8C000DEB724970FB6F894DEBF0FBECDBF8823F6
-:10F8D00009F481E020E0482F55274115510509F42E
-:10F8E0003DC0289A19821A821B821C820BC0898112
-:10F8F0009A81AB81BC810196A11DB11D89839A8338
-:10F90000AB83BC8389819A81AB81BC8180589E4343
-:10F91000A040B04060F3289819821A821B821C8292
-:10F920000BC089819A81AB81BC810196A11DB11D5B
-:10F9300089839A83AB83BC8389819A81AB81BC81A3
-:10F9400080509A4FA040B04060F32F5F822F9927DC
-:10F9500087FD9095841795070CF4C3CF19821A82FE
-:10F960001B821C8289819A81AB81BC818050914726
-:10F97000A240B040A0F489819A81AB81BC810196FC
-:10F98000A11DB11D89839A83AB83BC8389819A8130
-:10F99000AB81BC8180509147A240B04060F3249677
-:10F9A0000FB6F894DEBF0FBECDBFDF91CF910895A3
-:10F9B000EF92FF920F931F93EE24FF248701289864
-:10F9C0008091C00087FD17C00894E11CF11C011D47
-:10F9D000111D81E0E81689E0F8068DE3080780E054
-:10F9E000180770F3E0910001F091010109958091F1
-:10F9F000C00087FFE9CF289A8091C600992787FD2C
-:10FA000090951F910F91FF90EF900895982F8091FE
-:10FA1000C00085FFFCCF9093C60008950E94D87C5B
-:10FA2000803271F0809102018F5F809302018530F6
-:10FA300009F00895E0910001F09101010995089500
-:10FA400084E10E94067D80E10E94067D0895CF93A7
-:10FA5000C82F0E94D87C803241F0809102018F5FD4
-:10FA600080930201853081F40AC084E10E94067D02
-:10FA70008C2F0E94067D80E10E94067D05C0E091EA
-:10FA80000001F09101010995CF910895282F90E090
-:10FA900007C08091C0008823E4F78091C6009F5F73
-:10FAA0009217B8F30895CFEFD0E1DEBFCDBF0000CD
-:10FAB00094B714BE809160008861809360001092BA
-:10FAC000600091FF74C189E18093C4001092C50069
-:10FAD00088E18093C10086E08093C2005098589AD4
-:10FAE000209A83E00E945D7C81E00E945D7C0E9400
-:10FAF000D87C8033B9F18133C1F1803409F456C028
-:10FB0000813409F45CC0823409F46EC0853409F490
-:10FB100071C0803539F1813509F4F3C0823511F1B6
-:10FB2000853509F4D3C0863509F4CBC0843609F491
-:10FB300065C0843709F4EBC0853709F4D2C0863735
-:10FB400009F44AC0809102018F5F809302018530E1
-:10FB500071F6E0910001F091010109950E94D87CB5
-:10FB6000803349F60E940E7DC2CF0E94D87CC82FF8
-:10FB7000803241F784E10E94067D81E40E94067D87
-:10FB800086E50E94067D82E50E94067D8C2F0E94FC
-:10FB9000067D89E40E94067D83E50E94067D80E55E
-:10FBA0000E94067D80E10E94067DA1CF0E94D87C44
-:10FBB0008638C0F20E94D87C0E940E7D98CF0E94A9
-:10FBC000D87C803809F407C1813809F400C1823833
-:10FBD00009F4F9C0883921F080E00E94277D87CFA1
-:10FBE00083E00E94277D83CF84E10E94467D0E94AE
-:10FBF0000E7D7DCF85E00E94467DF9CF0E94D87CA6
-:10FC0000809306020E94D87C8093050280910802AE
-:10FC10008E7F809308020E94D87C853409F44BC003
-:10FC2000E5E0F1E0119281E0E438F807D9F3D0F390
-:10FC3000C0E0D0E0809105029091060218161906E6
-:10FC400078F405E011E00E94D87CF80181938F01DF
-:10FC500021968091050290910602C817D90798F362
-:10FC60000E94D87C803209F06DCF8091080280FF1D
-:10FC7000B6C0C0E0D0E02091050230910602121615
-:10FC80001306B8F4E0910301F0910401A5E0B1E09E
-:10FC9000F999FECFF2BDE1BD8D9180BDFA9AF99A36
-:10FCA00031962196C217D30798F3F0930401E0939D
-:10FCB000030184E175CF809108028160809308027E
-:10FCC000AFCF84E00E94467D80E087CF0E94D87C41
-:10FCD000809303010E94D87C809304010E940E7DD2
-:10FCE00006CF0E94D87C803209F02CCF84E10E949C
-:10FCF000067D8EE10E94067D86E90E94067D8AE0EF
-:10FD00004FCF0E940E7D88E080936000FFCF0E945D
-:10FD1000D87C809306020E94D87C809305020E94C2
-:10FD2000D87C853409F449C0809108028E7F809385
-:10FD300008028091030190910401880F991F90930C
-:10FD40000401809303010E94D87C803209F0CFCE59
-:10FD500084E10E94067DC0E0D0E020910502309150
-:10FD600006021216130608F01DCFE0910301F09170
-:10FD700004018091080280FF96C0F999FECFF2BD80
-:10FD8000E1BDF89A80B50E94067DE0910301F091F3
-:10FD900004013196F0930401E093030120910502E0
-:10FDA000309106022196C217D30718F3FBCEE091DB
-:10FDB0000001F0910101099586CE809108028160D1
-:10FDC00080930802C0CF80E10E94277D90CE81E021
-:10FDD0000E94277D8CCE82E00E94277D88CE809174
-:10FDE000030190910401880F991F9093040180935F
-:10FDF00003018091050280FF09C080910502909166
-:10FE0000060201969093060280930502F999FECFAF
-:10FE10001127E0910301F0910401C5E0D1E0809148
-:10FE2000050290910602103091F400915700017084
-:10FE30000130D9F303E000935700E8950091570093
-:10FE400001700130D9F301E100935700E895099062
-:10FE500019900091570001700130D9F301E000932F
-:10FE60005700E8951395103898F011270091570026
-:10FE700001700130D9F305E000935700E895009137
-:10FE8000570001700130D9F301E100935700E89564
-:10FE90003296029709F0C7CF103011F00296E5CFE5
-:10FEA000112484E17DCE869580FF06C03196F093C3
-:10FEB0000401E093030176CF84910E94067D209196
-:10FEC000050230910602E0910301F0910401EECFAA
-:10FED0001F93CF930E94D87CC82F0E94067D0E945A
-:10FEE000D87C182F0E94067DC1362CF0C7551136DC
-:10FEF0003CF0175508C0C033D4F3C0531136CCF7CB
-:10FF000010330CF01053C295C07FC10F8C2F99276E
-:10FF100087FD9095CF911F910895CF93282F992712
-:10FF200087FD9095807F907095958795959587959D
-:10FF300095958795959587958A303CF0895AC22F7B
-:10FF4000CF70CA303CF0C95A06C0805DC22FCF7056
-:10FF5000CA30CCF7C05D0E94067D8C2F0E94067DC2
-:06FF6000CF910895FFCFD0
-:040000030000F80001
-:00000001FF
diff --git a/Marlin/Sanguino/bootloaders/atmega644p/Makefile b/Marlin/Sanguino/bootloaders/atmega644p/Makefile
deleted file mode 100644
index 5714395..0000000
--- a/Marlin/Sanguino/bootloaders/atmega644p/Makefile
+++ /dev/null
@@ -1,56 +0,0 @@
-# Makefile for ATmegaBOOT
-# E.Lins, 18.7.2005
-# $Id$
-
-
-# program name should not be changed...
-PROGRAM    = ATmegaBOOT_644P
-
-# enter the target CPU frequency
-AVR_FREQ   = 16000000L
-
-MCU_TARGET = atmega644p
-LDSECTION  = --section-start=.text=0xF800
-
-OBJ        = $(PROGRAM).o
-OPTIMIZE   = -O2
-
-DEFS       = 
-LIBS       = 
-
-CC         = avr-gcc
-
-
-# Override is only needed by avr-lib build system.
-
-override CFLAGS        = -g -Wall $(OPTIMIZE) -mmcu=$(MCU_TARGET) -DF_CPU=$(AVR_FREQ) $(DEFS)
-override LDFLAGS       = -Wl,$(LDSECTION)
-#override LDFLAGS       = -Wl,-Map,$(PROGRAM).map,$(LDSECTION)
-
-OBJCOPY        = avr-objcopy
-OBJDUMP        = avr-objdump
-
-all: CFLAGS += '-DMAX_TIME_COUNT=8000000L>>1' -DADABOOT
-all: $(PROGRAM).hex
-
-$(PROGRAM).hex: $(PROGRAM).elf
-	$(OBJCOPY) -j .text -j .data -O ihex $< $@
-	
-$(PROGRAM).elf: $(OBJ)
-	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^ $(LIBS)
-	
-$(OBJ): ATmegaBOOT.c
-	avr-gcc $(CFLAGS) $(LDFLAGS) -c -g -O2 -Wall -mmcu=$(MCU_TARGET) ATmegaBOOT.c -o $(PROGRAM).o
-
-%.lst: %.elf
-	$(OBJDUMP) -h -S $< > $@
-
-%.srec: %.elf
-	$(OBJCOPY) -j .text -j .data -O srec $< $@
-
-%.bin: %.elf
-	$(OBJCOPY) -j .text -j .data -O binary $< $@
-
-clean:
-	rm -rf *.o *.elf *.lst *.map *.sym *.lss *.eep *.srec *.bin *.hex
-	
\ No newline at end of file
diff --git a/Marlin/Sanguino/bootloaders/atmega644p/README.txt b/Marlin/Sanguino/bootloaders/atmega644p/README.txt
deleted file mode 100644
index 8286007..0000000
--- a/Marlin/Sanguino/bootloaders/atmega644p/README.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-Note: This bootloader support ATmega644, ATmega644P and ATmega324P.
-To build, set PROGRAM and MCU_TARGET in the Makefile according to your target device.
-
diff --git a/Marlin/Sanguino/cores/arduino/Copy of wiring.h b/Marlin/Sanguino/cores/arduino/Copy of wiring.h
deleted file mode 100644
index e29959b..0000000
--- a/Marlin/Sanguino/cores/arduino/Copy of wiring.h	
+++ /dev/null
@@ -1,135 +0,0 @@
-/*
-  wiring.h - Partial implementation of the Wiring API for the ATmega8.
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id$
-*/
-
-#ifndef Wiring_h
-#define Wiring_h
-
-#include <avr/io.h>
-#include <stdlib.h>
-#include "binary.h"
-
-#ifdef __cplusplus
-extern "C"{
-#endif
-
-#define HIGH 0x1
-#define LOW  0x0
-
-#define INPUT 0x0
-#define OUTPUT 0x1
-
-#define true 0x1
-#define false 0x0
-
-#define PI 3.1415926535897932384626433832795
-#define HALF_PI 1.5707963267948966192313216916398
-#define TWO_PI 6.283185307179586476925286766559
-#define DEG_TO_RAD 0.017453292519943295769236907684886
-#define RAD_TO_DEG 57.295779513082320876798154814105
-
-#define SERIAL  0x0
-#define DISPLAY 0x1
-
-#define LSBFIRST 0
-#define MSBFIRST 1
-
-#define CHANGE 1
-#define FALLING 2
-#define RISING 3
-
-#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
-#define INTERNAL1V1 2
-#define INTERNAL2V56 3
-#else
-#define INTERNAL 3
-#endif
-#define DEFAULT 1
-#define EXTERNAL 0
-
-// undefine stdlib's abs if encountered
-#ifdef abs
-#undef abs
-#endif
-
-#define min(a,b) ((a)<(b)?(a):(b))
-#define max(a,b) ((a)>(b)?(a):(b))
-#define abs(x) ((x)>0?(x):-(x))
-#define constrain(amt,low,high) ((amt)<(low)?(low):((amt)>(high)?(high):(amt)))
-#define round(x)     ((x)>=0?(long)((x)+0.5):(long)((x)-0.5))
-#define radians(deg) ((deg)*DEG_TO_RAD)
-#define degrees(rad) ((rad)*RAD_TO_DEG)
-#define sq(x) ((x)*(x))
-
-#define interrupts() sei()
-#define noInterrupts() cli()
-
-#define clockCyclesPerMicrosecond() ( F_CPU / 1000000L )
-#define clockCyclesToMicroseconds(a) ( ((a) * 1000L) / (F_CPU / 1000L) )
-#define microsecondsToClockCycles(a) ( ((a) * (F_CPU / 1000L)) / 1000L )
-
-#define lowByte(w) ((uint8_t) ((w) & 0xff))
-#define highByte(w) ((uint8_t) ((w) >> 8))
-
-#define bitRead(value, bit) (((value) >> (bit)) & 0x01)
-#define bitSet(value, bit) ((value) |= (1UL << (bit)))
-#define bitClear(value, bit) ((value) &= ~(1UL << (bit)))
-#define bitWrite(value, bit, bitvalue) (bitvalue ? bitSet(value, bit) : bitClear(value, bit))
-
-
-typedef unsigned int word;
-
-#define bit(b) (1UL << (b))
-
-typedef uint8_t boolean;
-typedef uint8_t byte;
-
-void init(void);
-
-void pinMode(uint8_t, uint8_t);
-void digitalWrite(uint8_t, uint8_t);
-int digitalRead(uint8_t);
-int analogRead(uint8_t);
-void analogReference(uint8_t mode);
-void analogWrite(uint8_t, int);
-
-unsigned long millis(void);
-unsigned long micros(void);
-void delay(unsigned long);
-void delayMicroseconds(unsigned int us);
-unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout);
-
-void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val);
-uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder);
-
-void attachInterrupt(uint8_t, void (*)(void), int mode);
-void detachInterrupt(uint8_t);
-
-void setup(void);
-void loop(void);
-
-#ifdef __cplusplus
-} // extern "C"
-#endif
-
-#endif
diff --git a/Marlin/Sanguino/cores/arduino/HardwareSerial.cpp b/Marlin/Sanguino/cores/arduino/HardwareSerial.cpp
deleted file mode 100644
index d4931b4..0000000
--- a/Marlin/Sanguino/cores/arduino/HardwareSerial.cpp
+++ /dev/null
@@ -1,187 +0,0 @@
-/*
-  HardwareSerial.cpp - Hardware serial library for Wiring
-  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-  
-  Modified 23 November 2006 by David A. Mellis
-  Modified 28 September 2010 by Mark Sproul
-*/
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <inttypes.h>
-#include "wiring.h"
-#include "wiring_private.h"
-
-// this next line disables the entire HardwareSerial.cpp, 
-// this is so I can support Attiny series and any other chip without a uart
-#if defined(UBRRH) || defined(UBRR0H) || defined(UBRR1H) || defined(UBRR2H) || defined(UBRR3H)
-
-#include "HardwareSerial.h"
-
-// Define constants and variables for buffering incoming serial data.  We're
-// using a ring buffer (I think), in which rx_buffer_head is the index of the
-// location to which to write the next incoming character and rx_buffer_tail
-// is the index of the location from which to read.
-#define RX_BUFFER_SIZE 128
-
-struct ring_buffer
-{
-  unsigned char buffer[RX_BUFFER_SIZE];
-  int head;
-  int tail;
-};
-
-ring_buffer rx_buffer  =  { { 0 }, 0, 0 };
-
-inline void store_char(unsigned char c, ring_buffer *rx_buffer)
-{
-  int i = (unsigned int)(rx_buffer->head + 1) & (RX_BUFFER_SIZE -1);
-
-  // if we should be storing the received character into the location
-  // just before the tail (meaning that the head would advance to the
-  // current location of the tail), we're about to overflow the buffer
-  // and so we don't write the character or advance the head.
-  if (i != rx_buffer->tail) {
-    rx_buffer->buffer[rx_buffer->head] = c;
-    rx_buffer->head = i;
-  }
-}
-
-// fixed by Mark Sproul this is on the 644/644p
-//SIGNAL(SIG_USART_RECV)
-SIGNAL(USART0_RX_vect)
-{
-  unsigned char c  =  UDR0;
-  store_char(c, &rx_buffer);
-}
-
-
-// Constructors ////////////////////////////////////////////////////////////////
-
-HardwareSerial::HardwareSerial(ring_buffer *rx_buffer,
-  volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
-  volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
-  volatile uint8_t *udr,
-  uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udre, uint8_t u2x)
-{
-  _rx_buffer = rx_buffer;
-  _ubrrh = ubrrh;
-  _ubrrl = ubrrl;
-  _ucsra = ucsra;
-  _ucsrb = ucsrb;
-  _udr = udr;
-  _rxen = rxen;
-  _txen = txen;
-  _rxcie = rxcie;
-  _udre = udre;
-  _u2x = u2x;
-}
-
-// Public Methods //////////////////////////////////////////////////////////////
-
-void HardwareSerial::begin(long baud)
-{
-  uint16_t baud_setting;
-  bool use_u2x = true;
-
-#if F_CPU == 16000000UL
-  // hardcoded exception for compatibility with the bootloader shipped
-  // with the Duemilanove and previous boards and the firmware on the 8U2
-  // on the Uno and Mega 2560.
-  if (baud == 57600) {
-    use_u2x = false;
-  }
-#endif
-  
-  if (use_u2x) {
-    *_ucsra = 1 << _u2x;
-    baud_setting = (F_CPU / 4 / baud - 1) / 2;
-  } else {
-    *_ucsra = 0;
-    baud_setting = (F_CPU / 8 / baud - 1) / 2;
-  }
-
-  // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)
-  *_ubrrh = baud_setting >> 8;
-  *_ubrrl = baud_setting;
-
-  sbi(*_ucsrb, _rxen);
-  sbi(*_ucsrb, _txen);
-  sbi(*_ucsrb, _rxcie);
-}
-
-void HardwareSerial::end()
-{
-  cbi(*_ucsrb, _rxen);
-  cbi(*_ucsrb, _txen);
-  cbi(*_ucsrb, _rxcie);  
-}
-
-int HardwareSerial::available(void)
-{
-  return (unsigned int)(RX_BUFFER_SIZE + _rx_buffer->head - _rx_buffer->tail) & (RX_BUFFER_SIZE-1);
-}
-
-int HardwareSerial::peek(void)
-{
-  if (_rx_buffer->head == _rx_buffer->tail) {
-    return -1;
-  } else {
-    return _rx_buffer->buffer[_rx_buffer->tail];
-  }
-}
-
-int HardwareSerial::read(void)
-{
-  // if the head isn't ahead of the tail, we don't have any characters
-  if (_rx_buffer->head == _rx_buffer->tail) {
-    return -1;
-  } else {
-    unsigned char c = _rx_buffer->buffer[_rx_buffer->tail];
-    _rx_buffer->tail = (unsigned int)(_rx_buffer->tail + 1) & (RX_BUFFER_SIZE-1);
-    return c;
-  }
-}
-
-void HardwareSerial::flush()
-{
-  // don't reverse this or there may be problems if the RX interrupt
-  // occurs after reading the value of rx_buffer_head but before writing
-  // the value to rx_buffer_tail; the previous value of rx_buffer_head
-  // may be written to rx_buffer_tail, making it appear as if the buffer
-  // don't reverse this or there may be problems if the RX interrupt
-  // occurs after reading the value of rx_buffer_head but before writing
-  // the value to rx_buffer_tail; the previous value of rx_buffer_head
-  // may be written to rx_buffer_tail, making it appear as if the buffer
-  // were full, not empty.
-  _rx_buffer->head = _rx_buffer->tail;
-}
-
-void HardwareSerial::write(uint8_t c)
-{
-  while (!((*_ucsra) & (1 << _udre)))
-    ;
-
-  *_udr = c;
-}
-
-// Preinstantiate Objects //////////////////////////////////////////////////////
-HardwareSerial Serial(&rx_buffer, &UBRR0H, &UBRR0L, &UCSR0A, &UCSR0B, &UDR0, RXEN0, TXEN0, RXCIE0, UDRE0, U2X0);
-
-#endif // whole file
-
diff --git a/Marlin/Sanguino/cores/arduino/HardwareSerial.h b/Marlin/Sanguino/cores/arduino/HardwareSerial.h
deleted file mode 100644
index 3efa775..0000000
--- a/Marlin/Sanguino/cores/arduino/HardwareSerial.h
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
-  HardwareSerial.h - Hardware serial library for Wiring
-  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-  Modified 28 September 2010 by Mark Sproul
-*/
-
-#ifndef HardwareSerial_h
-#define HardwareSerial_h
-
-#include <inttypes.h>
-
-#include "Stream.h"
-
-struct ring_buffer;
-
-class HardwareSerial : public Stream
-{
-  private:
-    ring_buffer *_rx_buffer;
-    volatile uint8_t *_ubrrh;
-    volatile uint8_t *_ubrrl;
-    volatile uint8_t *_ucsra;
-    volatile uint8_t *_ucsrb;
-    volatile uint8_t *_udr;
-    uint8_t _rxen;
-    uint8_t _txen;
-    uint8_t _rxcie;
-    uint8_t _udre;
-    uint8_t _u2x;
-  public:
-    HardwareSerial(ring_buffer *rx_buffer,
-      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
-      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
-      volatile uint8_t *udr,
-      uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udre, uint8_t u2x);
-    void begin(long);
-    void end();
-    virtual int available(void);
-    virtual int peek(void);
-    virtual int read(void);
-    virtual void flush(void);
-    virtual void write(uint8_t);
-    using Print::write; // pull in write(str) and write(buf, size) from Print
-};
-
-#if defined(UBRRH) || defined(UBRR0H)
-  extern HardwareSerial Serial;
-#elif defined(USBCON)
-  #include "usb_api.h"
-#endif
-#if defined(UBRR1H)
-  extern HardwareSerial Serial1;
-#endif
-#if defined(UBRR2H)
-  extern HardwareSerial Serial2;
-#endif
-#if defined(UBRR3H)
-  extern HardwareSerial Serial3;
-#endif
-
-#endif
diff --git a/Marlin/Sanguino/cores/arduino/Print.cpp b/Marlin/Sanguino/cores/arduino/Print.cpp
deleted file mode 100644
index 4ee556d..0000000
--- a/Marlin/Sanguino/cores/arduino/Print.cpp
+++ /dev/null
@@ -1,220 +0,0 @@
-/*
- Print.cpp - Base class that provides print() and println()
- Copyright (c) 2008 David A. Mellis.  All right reserved.
- 
- This library is free software; you can redistribute it and/or
- modify it under the terms of the GNU Lesser General Public
- License as published by the Free Software Foundation; either
- version 2.1 of the License, or (at your option) any later version.
- 
- This library is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- Lesser General Public License for more details.
- 
- You should have received a copy of the GNU Lesser General Public
- License along with this library; if not, write to the Free Software
- Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- 
- Modified 23 November 2006 by David A. Mellis
- */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <math.h>
-#include "wiring.h"
-
-#include "Print.h"
-
-// Public Methods //////////////////////////////////////////////////////////////
-
-/* default implementation: may be overridden */
-void Print::write(const char *str)
-{
-  while (*str)
-    write(*str++);
-}
-
-/* default implementation: may be overridden */
-void Print::write(const uint8_t *buffer, size_t size)
-{
-  while (size--)
-    write(*buffer++);
-}
-
-void Print::print(const String &s)
-{
-  for (int i = 0; i < s.length(); i++) {
-    write(s[i]);
-  }
-}
-
-void Print::print(const char str[])
-{
-  write(str);
-}
-
-void Print::print(char c, int base)
-{
-  print((long) c, base);
-}
-
-void Print::print(unsigned char b, int base)
-{
-  print((unsigned long) b, base);
-}
-
-void Print::print(int n, int base)
-{
-  print((long) n, base);
-}
-
-void Print::print(unsigned int n, int base)
-{
-  print((unsigned long) n, base);
-}
-
-void Print::print(long n, int base)
-{
-  if (base == 0) {
-    write(n);
-  } else if (base == 10) {
-    if (n < 0) {
-      print('-');
-      n = -n;
-    }
-    printNumber(n, 10);
-  } else {
-    printNumber(n, base);
-  }
-}
-
-void Print::print(unsigned long n, int base)
-{
-  if (base == 0) write(n);
-  else printNumber(n, base);
-}
-
-void Print::print(double n, int digits)
-{
-  printFloat(n, digits);
-}
-
-void Print::println(void)
-{
-  print('\r');
-  print('\n');  
-}
-
-void Print::println(const String &s)
-{
-  print(s);
-  println();
-}
-
-void Print::println(const char c[])
-{
-  print(c);
-  println();
-}
-
-void Print::println(char c, int base)
-{
-  print(c, base);
-  println();
-}
-
-void Print::println(unsigned char b, int base)
-{
-  print(b, base);
-  println();
-}
-
-void Print::println(int n, int base)
-{
-  print(n, base);
-  println();
-}
-
-void Print::println(unsigned int n, int base)
-{
-  print(n, base);
-  println();
-}
-
-void Print::println(long n, int base)
-{
-  print(n, base);
-  println();
-}
-
-void Print::println(unsigned long n, int base)
-{
-  print(n, base);
-  println();
-}
-
-void Print::println(double n, int digits)
-{
-  print(n, digits);
-  println();
-}
-
-// Private Methods /////////////////////////////////////////////////////////////
-
-void Print::printNumber(unsigned long n, uint8_t base)
-{
-  unsigned char buf[8 * sizeof(long)]; // Assumes 8-bit chars. 
-  unsigned long i = 0;
-
-  if (n == 0) {
-    print('0');
-    return;
-  } 
-
-  while (n > 0) {
-    buf[i++] = n % base;
-    n /= base;
-  }
-
-  for (; i > 0; i--)
-    print((char) (buf[i - 1] < 10 ?
-      '0' + buf[i - 1] :
-      'A' + buf[i - 1] - 10));
-}
-
-void Print::printFloat(double number, uint8_t digits) 
-{ 
-  // Handle negative numbers
-  if (number < 0.0)
-  {
-     print('-');
-     number = -number;
-  }
-
-  // Round correctly so that print(1.999, 2) prints as "2.00"
-  double rounding = 0.5;
-  for (uint8_t i=0; i<digits; ++i)
-    rounding /= 10.0;
-  
-  number += rounding;
-
-  // Extract the integer part of the number and print it
-  unsigned long int_part = (unsigned long)number;
-  double remainder = number - (double)int_part;
-  print(int_part);
-
-  // Print the decimal point, but only if there are digits beyond
-  if (digits > 0)
-    print("."); 
-
-  // Extract digits from the remainder one at a time
-  while (digits-- > 0)
-  {
-    remainder *= 10.0;
-    int toPrint = int(remainder);
-    print(toPrint);
-    remainder -= toPrint; 
-  } 
-}
diff --git a/Marlin/Sanguino/cores/arduino/Print.h b/Marlin/Sanguino/cores/arduino/Print.h
deleted file mode 100644
index b092ae5..0000000
--- a/Marlin/Sanguino/cores/arduino/Print.h
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
-  Print.h - Base class that provides print() and println()
-  Copyright (c) 2008 David A. Mellis.  All right reserved.
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef Print_h
-#define Print_h
-
-#include <inttypes.h>
-#include <stdio.h> // for size_t
-
-#include "WString.h"
-
-#define DEC 10
-#define HEX 16
-#define OCT 8
-#define BIN 2
-#define BYTE 0
-
-class Print
-{
-  private:
-    void printNumber(unsigned long, uint8_t);
-    void printFloat(double, uint8_t);
-  public:
-    virtual void write(uint8_t) = 0;
-    virtual void write(const char *str);
-    virtual void write(const uint8_t *buffer, size_t size);
-    
-    void print(const String &);
-    void print(const char[]);
-    void print(char, int = BYTE);
-    void print(unsigned char, int = BYTE);
-    void print(int, int = DEC);
-    void print(unsigned int, int = DEC);
-    void print(long, int = DEC);
-    void print(unsigned long, int = DEC);
-    void print(double, int = 2);
-
-    void println(const String &s);
-    void println(const char[]);
-    void println(char, int = BYTE);
-    void println(unsigned char, int = BYTE);
-    void println(int, int = DEC);
-    void println(unsigned int, int = DEC);
-    void println(long, int = DEC);
-    void println(unsigned long, int = DEC);
-    void println(double, int = 2);
-    void println(void);
-};
-
-#endif
diff --git a/Marlin/Sanguino/cores/arduino/Stream.h b/Marlin/Sanguino/cores/arduino/Stream.h
deleted file mode 100644
index 93d8275..0000000
--- a/Marlin/Sanguino/cores/arduino/Stream.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
-  Stream.h - base class for character-based streams.
-  Copyright (c) 2010 David A. Mellis.  All right reserved.
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef Stream_h
-#define Stream_h
-
-#include <inttypes.h>
-#include "Print.h"
-
-class Stream : public Print
-{
-  public:
-    virtual int available() = 0;
-    virtual int read() = 0;
-    virtual int peek() = 0;
-    virtual void flush() = 0;
-};
-
-#endif
diff --git a/Marlin/Sanguino/cores/arduino/Tone.cpp b/Marlin/Sanguino/cores/arduino/Tone.cpp
deleted file mode 100644
index c3910e7..0000000
--- a/Marlin/Sanguino/cores/arduino/Tone.cpp
+++ /dev/null
@@ -1,601 +0,0 @@
-/* Tone.cpp
-
-  A Tone Generator Library
-
-  Written by Brett Hagman
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-Version Modified By Date     Comments
-------- ----------- -------- --------
-0001    B Hagman    09/08/02 Initial coding
-0002    B Hagman    09/08/18 Multiple pins
-0003    B Hagman    09/08/18 Moved initialization from constructor to begin()
-0004    B Hagman    09/09/26 Fixed problems with ATmega8
-0005    B Hagman    09/11/23 Scanned prescalars for best fit on 8 bit timers
-                    09/11/25 Changed pin toggle method to XOR
-                    09/11/25 Fixed timer0 from being excluded
-0006    D Mellis    09/12/29 Replaced objects with functions
-0007    M Sproul    10/08/29 Changed #ifdefs from cpu to register
-*************************************************/
-
-#include <avr/interrupt.h>
-#include <avr/pgmspace.h>
-#include "wiring.h"
-#include "pins_arduino.h"
-
-#if defined(__AVR_ATmega8__) || defined(__AVR_ATmega128__)
-#define TCCR2A TCCR2
-#define TCCR2B TCCR2
-#define COM2A1 COM21
-#define COM2A0 COM20
-#define OCR2A OCR2
-#define TIMSK2 TIMSK
-#define OCIE2A OCIE2
-#define TIMER2_COMPA_vect TIMER2_COMP_vect
-#define TIMSK1 TIMSK
-#endif
-
-// timerx_toggle_count:
-//  > 0 - duration specified
-//  = 0 - stopped
-//  < 0 - infinitely (until stop() method called, or new play() called)
-
-#if !defined(__AVR_ATmega8__)
-volatile long timer0_toggle_count;
-volatile uint8_t *timer0_pin_port;
-volatile uint8_t timer0_pin_mask;
-#endif
-
-volatile long timer1_toggle_count;
-volatile uint8_t *timer1_pin_port;
-volatile uint8_t timer1_pin_mask;
-volatile long timer2_toggle_count;
-volatile uint8_t *timer2_pin_port;
-volatile uint8_t timer2_pin_mask;
-
-#if defined(TIMSK3)
-volatile long timer3_toggle_count;
-volatile uint8_t *timer3_pin_port;
-volatile uint8_t timer3_pin_mask;
-#endif
-
-#if defined(TIMSK4)
-volatile long timer4_toggle_count;
-volatile uint8_t *timer4_pin_port;
-volatile uint8_t timer4_pin_mask;
-#endif
-
-#if defined(TIMSK5)
-volatile long timer5_toggle_count;
-volatile uint8_t *timer5_pin_port;
-volatile uint8_t timer5_pin_mask;
-#endif
-
-
-// MLS: This does not make sense, the 3 options are the same
-#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
-
-#define AVAILABLE_TONE_PINS 1
-
-const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 3, 4, 5, 1, 0 */ };
-static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255, 255, 255, 255, 255 */ };
-
-#elif defined(__AVR_ATmega8__)
-
-#define AVAILABLE_TONE_PINS 1
-
-const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 1 */ };
-static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255 */ };
-
-#else
-
-#define AVAILABLE_TONE_PINS 1
-
-// Leave timer 0 to last.
-const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 1, 0 */ };
-static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255, 255 */ };
-
-#endif
-
-
-
-static int8_t toneBegin(uint8_t _pin)
-{
-  int8_t _timer = -1;
-
-  // if we're already using the pin, the timer should be configured.  
-  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
-    if (tone_pins[i] == _pin) {
-      return pgm_read_byte(tone_pin_to_timer_PGM + i);
-    }
-  }
-  
-  // search for an unused timer.
-  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
-    if (tone_pins[i] == 255) {
-      tone_pins[i] = _pin;
-      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
-      break;
-    }
-  }
-  
-  if (_timer != -1)
-  {
-    // Set timer specific stuff
-    // All timers in CTC mode
-    // 8 bit timers will require changing prescalar values,
-    // whereas 16 bit timers are set to either ck/1 or ck/64 prescalar
-    switch (_timer)
-    {
-      #if defined(TCCR0A) && defined(TCCR0B)
-      case 0:
-        // 8 bit timer
-        TCCR0A = 0;
-        TCCR0B = 0;
-        bitWrite(TCCR0A, WGM01, 1);
-        bitWrite(TCCR0B, CS00, 1);
-        timer0_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer0_pin_mask = digitalPinToBitMask(_pin);
-        break;
-      #endif
-
-      #if defined(TCCR1A) && defined(TCCR1B) && defined(WGM12)
-      case 1:
-        // 16 bit timer
-        TCCR1A = 0;
-        TCCR1B = 0;
-        bitWrite(TCCR1B, WGM12, 1);
-        bitWrite(TCCR1B, CS10, 1);
-        timer1_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer1_pin_mask = digitalPinToBitMask(_pin);
-        break;
-      #endif
-
-      #if defined(TCCR2A) && defined(TCCR2B)
-      case 2:
-        // 8 bit timer
-        TCCR2A = 0;
-        TCCR2B = 0;
-        bitWrite(TCCR2A, WGM21, 1);
-        bitWrite(TCCR2B, CS20, 1);
-        timer2_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer2_pin_mask = digitalPinToBitMask(_pin);
-        break;
-      #endif
-
-      #if defined(TCCR3A) && defined(TCCR3B) &&  defined(TIMSK3)
-      case 3:
-        // 16 bit timer
-        TCCR3A = 0;
-        TCCR3B = 0;
-        bitWrite(TCCR3B, WGM32, 1);
-        bitWrite(TCCR3B, CS30, 1);
-        timer3_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer3_pin_mask = digitalPinToBitMask(_pin);
-        break;
-      #endif
-
-      #if defined(TCCR4A) && defined(TCCR4B) &&  defined(TIMSK4)
-      case 4:
-        // 16 bit timer
-        TCCR4A = 0;
-        TCCR4B = 0;
-        #if defined(WGM42)
-          bitWrite(TCCR4B, WGM42, 1);
-        #elif defined(CS43)
-          #warning this may not be correct
-          // atmega32u4
-          bitWrite(TCCR4B, CS43, 1);
-        #endif
-        bitWrite(TCCR4B, CS40, 1);
-        timer4_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer4_pin_mask = digitalPinToBitMask(_pin);
-        break;
-      #endif
-
-      #if defined(TCCR5A) && defined(TCCR5B) &&  defined(TIMSK5)
-      case 5:
-        // 16 bit timer
-        TCCR5A = 0;
-        TCCR5B = 0;
-        bitWrite(TCCR5B, WGM52, 1);
-        bitWrite(TCCR5B, CS50, 1);
-        timer5_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer5_pin_mask = digitalPinToBitMask(_pin);
-        break;
-      #endif
-    }
-  }
-
-  return _timer;
-}
-
-
-
-// frequency (in hertz) and duration (in milliseconds).
-
-void tone(uint8_t _pin, unsigned int frequency, unsigned long duration)
-{
-  uint8_t prescalarbits = 0b001;
-  long toggle_count = 0;
-  uint32_t ocr = 0;
-  int8_t _timer;
-
-  _timer = toneBegin(_pin);
-
-  if (_timer >= 0)
-  {
-    // Set the pinMode as OUTPUT
-    pinMode(_pin, OUTPUT);
-    
-    // if we are using an 8 bit timer, scan through prescalars to find the best fit
-    if (_timer == 0 || _timer == 2)
-    {
-      ocr = F_CPU / frequency / 2 - 1;
-      prescalarbits = 0b001;  // ck/1: same for both timers
-      if (ocr > 255)
-      {
-        ocr = F_CPU / frequency / 2 / 8 - 1;
-        prescalarbits = 0b010;  // ck/8: same for both timers
-
-        if (_timer == 2 && ocr > 255)
-        {
-          ocr = F_CPU / frequency / 2 / 32 - 1;
-          prescalarbits = 0b011;
-        }
-
-        if (ocr > 255)
-        {
-          ocr = F_CPU / frequency / 2 / 64 - 1;
-          prescalarbits = _timer == 0 ? 0b011 : 0b100;
-
-          if (_timer == 2 && ocr > 255)
-          {
-            ocr = F_CPU / frequency / 2 / 128 - 1;
-            prescalarbits = 0b101;
-          }
-
-          if (ocr > 255)
-          {
-            ocr = F_CPU / frequency / 2 / 256 - 1;
-            prescalarbits = _timer == 0 ? 0b100 : 0b110;
-            if (ocr > 255)
-            {
-              // can't do any better than /1024
-              ocr = F_CPU / frequency / 2 / 1024 - 1;
-              prescalarbits = _timer == 0 ? 0b101 : 0b111;
-            }
-          }
-        }
-      }
-
-#if defined(TCCR0B)
-      if (_timer == 0)
-      {
-        TCCR0B = prescalarbits;
-      }
-      else
-#endif
-#if defined(TCCR2B)
-      {
-        TCCR2B = prescalarbits;
-      }
-#else
-      {
-        // dummy place holder to make the above ifdefs work
-      }
-#endif
-    }
-    else
-    {
-      // two choices for the 16 bit timers: ck/1 or ck/64
-      ocr = F_CPU / frequency / 2 - 1;
-
-      prescalarbits = 0b001;
-      if (ocr > 0xffff)
-      {
-        ocr = F_CPU / frequency / 2 / 64 - 1;
-        prescalarbits = 0b011;
-      }
-
-      if (_timer == 1)
-      {
-#if defined(TCCR1B)
-        TCCR1B = (TCCR1B & 0b11111000) | prescalarbits;
-#endif
-      }
-#if defined(TCCR3B)
-      else if (_timer == 3)
-        TCCR3B = (TCCR3B & 0b11111000) | prescalarbits;
-#endif
-#if defined(TCCR4B)
-      else if (_timer == 4)
-        TCCR4B = (TCCR4B & 0b11111000) | prescalarbits;
-#endif
-#if defined(TCCR5B)
-      else if (_timer == 5)
-        TCCR5B = (TCCR5B & 0b11111000) | prescalarbits;
-#endif
-
-    }
-    
-
-    // Calculate the toggle count
-    if (duration > 0)
-    {
-      toggle_count = 2 * frequency * duration / 1000;
-    }
-    else
-    {
-      toggle_count = -1;
-    }
-
-    // Set the OCR for the given timer,
-    // set the toggle count,
-    // then turn on the interrupts
-    switch (_timer)
-    {
-
-#if defined(OCR0A) && defined(TIMSK0) && defined(OCIE0A)
-      case 0:
-        OCR0A = ocr;
-        timer0_toggle_count = toggle_count;
-        bitWrite(TIMSK0, OCIE0A, 1);
-        break;
-#endif
-
-      case 1:
-#if defined(OCR1A) && defined(TIMSK1) && defined(OCIE1A)
-        OCR1A = ocr;
-        timer1_toggle_count = toggle_count;
-        bitWrite(TIMSK1, OCIE1A, 1);
-#elif defined(OCR1A) && defined(TIMSK) && defined(OCIE1A)
-        // this combination is for at least the ATmega32
-        OCR1A = ocr;
-        timer1_toggle_count = toggle_count;
-        bitWrite(TIMSK, OCIE1A, 1);
-#endif
-        break;
-
-#if defined(OCR2A) && defined(TIMSK2) && defined(OCIE2A)
-      case 2:
-        OCR2A = ocr;
-        timer2_toggle_count = toggle_count;
-        bitWrite(TIMSK2, OCIE2A, 1);
-        break;
-#endif
-
-#if defined(TIMSK3)
-      case 3:
-        OCR3A = ocr;
-        timer3_toggle_count = toggle_count;
-        bitWrite(TIMSK3, OCIE3A, 1);
-        break;
-#endif
-
-#if defined(TIMSK4)
-      case 4:
-        OCR4A = ocr;
-        timer4_toggle_count = toggle_count;
-        bitWrite(TIMSK4, OCIE4A, 1);
-        break;
-#endif
-
-#if defined(OCR5A) && defined(TIMSK5) && defined(OCIE5A)
-      case 5:
-        OCR5A = ocr;
-        timer5_toggle_count = toggle_count;
-        bitWrite(TIMSK5, OCIE5A, 1);
-        break;
-#endif
-
-    }
-  }
-}
-
-
-// XXX: this function only works properly for timer 2 (the only one we use
-// currently).  for the others, it should end the tone, but won't restore
-// proper PWM functionality for the timer.
-void disableTimer(uint8_t _timer)
-{
-  switch (_timer)
-  {
-    case 0:
-      #if defined(TIMSK0)
-        TIMSK0 = 0;
-      #elif defined(TIMSK)
-        TIMSK = 0; // atmega32
-      #endif
-      break;
-
-#if defined(TIMSK1) && defined(OCIE1A)
-    case 1:
-      bitWrite(TIMSK1, OCIE1A, 0);
-      break;
-#endif
-
-    case 2:
-      #if defined(TIMSK2) && defined(OCIE2A)
-        bitWrite(TIMSK2, OCIE2A, 0); // disable interrupt
-      #endif
-      #if defined(TCCR2A) && defined(WGM20)
-        TCCR2A = (1 << WGM20);
-      #endif
-      #if defined(TCCR2B) && defined(CS22)
-        TCCR2B = (TCCR2B & 0b11111000) | (1 << CS22);
-      #endif
-      #if defined(OCR2A)
-        OCR2A = 0;
-      #endif
-      break;
-
-#if defined(TIMSK3)
-    case 3:
-      TIMSK3 = 0;
-      break;
-#endif
-
-#if defined(TIMSK4)
-    case 4:
-      TIMSK4 = 0;
-      break;
-#endif
-
-#if defined(TIMSK5)
-    case 5:
-      TIMSK5 = 0;
-      break;
-#endif
-  }
-}
-
-
-void noTone(uint8_t _pin)
-{
-  int8_t _timer = -1;
-  
-  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
-    if (tone_pins[i] == _pin) {
-      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
-      tone_pins[i] = 255;
-    }
-  }
-  
-  disableTimer(_timer);
-
-  digitalWrite(_pin, 0);
-}
-
-#if 0
-#if !defined(__AVR_ATmega8__)
-ISR(TIMER0_COMPA_vect)
-{
-  if (timer0_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer0_pin_port ^= timer0_pin_mask;
-
-    if (timer0_toggle_count > 0)
-      timer0_toggle_count--;
-  }
-  else
-  {
-    disableTimer(0);
-    *timer0_pin_port &= ~(timer0_pin_mask);  // keep pin low after stop
-  }
-}
-#endif
-
-
-ISR(TIMER1_COMPA_vect)
-{
-  if (timer1_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer1_pin_port ^= timer1_pin_mask;
-
-    if (timer1_toggle_count > 0)
-      timer1_toggle_count--;
-  }
-  else
-  {
-    disableTimer(1);
-    *timer1_pin_port &= ~(timer1_pin_mask);  // keep pin low after stop
-  }
-}
-#endif
-
-
-ISR(TIMER2_COMPA_vect)
-{
-
-  if (timer2_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer2_pin_port ^= timer2_pin_mask;
-
-    if (timer2_toggle_count > 0)
-      timer2_toggle_count--;
-  }
-  else
-  {
-    // need to call noTone() so that the tone_pins[] entry is reset, so the
-    // timer gets initialized next time we call tone().
-    // XXX: this assumes timer 2 is always the first one used.
-    noTone(tone_pins[0]);
-//    disableTimer(2);
-//    *timer2_pin_port &= ~(timer2_pin_mask);  // keep pin low after stop
-  }
-}
-
-
-
-//#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
-#if 0
-
-ISR(TIMER3_COMPA_vect)
-{
-  if (timer3_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer3_pin_port ^= timer3_pin_mask;
-
-    if (timer3_toggle_count > 0)
-      timer3_toggle_count--;
-  }
-  else
-  {
-    disableTimer(3);
-    *timer3_pin_port &= ~(timer3_pin_mask);  // keep pin low after stop
-  }
-}
-
-ISR(TIMER4_COMPA_vect)
-{
-  if (timer4_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer4_pin_port ^= timer4_pin_mask;
-
-    if (timer4_toggle_count > 0)
-      timer4_toggle_count--;
-  }
-  else
-  {
-    disableTimer(4);
-    *timer4_pin_port &= ~(timer4_pin_mask);  // keep pin low after stop
-  }
-}
-
-ISR(TIMER5_COMPA_vect)
-{
-  if (timer5_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer5_pin_port ^= timer5_pin_mask;
-
-    if (timer5_toggle_count > 0)
-      timer5_toggle_count--;
-  }
-  else
-  {
-    disableTimer(5);
-    *timer5_pin_port &= ~(timer5_pin_mask);  // keep pin low after stop
-  }
-}
-
-#endif
diff --git a/Marlin/Sanguino/cores/arduino/WCharacter.h b/Marlin/Sanguino/cores/arduino/WCharacter.h
deleted file mode 100644
index 79733b5..0000000
--- a/Marlin/Sanguino/cores/arduino/WCharacter.h
+++ /dev/null
@@ -1,168 +0,0 @@
-/*
- WCharacter.h - Character utility functions for Wiring & Arduino
- Copyright (c) 2010 Hernando Barragan.  All right reserved.
- 
- This library is free software; you can redistribute it and/or
- modify it under the terms of the GNU Lesser General Public
- License as published by the Free Software Foundation; either
- version 2.1 of the License, or (at your option) any later version.
- 
- This library is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- Lesser General Public License for more details.
- 
- You should have received a copy of the GNU Lesser General Public
- License along with this library; if not, write to the Free Software
- Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef Character_h
-#define Character_h
-
-#include <ctype.h>
-
-// WCharacter.h prototypes
-inline boolean isAlphaNumeric(int c) __attribute__((always_inline));
-inline boolean isAlpha(int c) __attribute__((always_inline));
-inline boolean isAscii(int c) __attribute__((always_inline));
-inline boolean isWhitespace(int c) __attribute__((always_inline));
-inline boolean isControl(int c) __attribute__((always_inline));
-inline boolean isDigit(int c) __attribute__((always_inline));
-inline boolean isGraph(int c) __attribute__((always_inline));
-inline boolean isLowerCase(int c) __attribute__((always_inline));
-inline boolean isPrintable(int c) __attribute__((always_inline));
-inline boolean isPunct(int c) __attribute__((always_inline));
-inline boolean isSpace(int c) __attribute__((always_inline));
-inline boolean isUpperCase(int c) __attribute__((always_inline));
-inline boolean isHexadecimalDigit(int c) __attribute__((always_inline));
-inline int toAscii(int c) __attribute__((always_inline));
-inline int toLowerCase(int c) __attribute__((always_inline));
-inline int toUpperCase(int c)__attribute__((always_inline));
-
-
-// Checks for an alphanumeric character. 
-// It is equivalent to (isalpha(c) || isdigit(c)).
-inline boolean isAlphaNumeric(int c) 
-{
-  return ( isalnum(c) == 0 ? false : true);
-}
-
-
-// Checks for an alphabetic character. 
-// It is equivalent to (isupper(c) || islower(c)).
-inline boolean isAlpha(int c)
-{
-  return ( isalpha(c) == 0 ? false : true);
-}
-
-
-// Checks whether c is a 7-bit unsigned char value 
-// that fits into the ASCII character set.
-inline boolean isAscii(int c)
-{
-  return ( isascii (c) == 0 ? false : true);
-}
-
-
-// Checks for a blank character, that is, a space or a tab.
-inline boolean isWhitespace(int c)
-{
-  return ( isblank (c) == 0 ? false : true);
-}
-
-
-// Checks for a control character.
-inline boolean isControl(int c)
-{
-  return ( iscntrl (c) == 0 ? false : true);
-}
-
-
-// Checks for a digit (0 through 9).
-inline boolean isDigit(int c)
-{
-  return ( isdigit (c) == 0 ? false : true);
-}
-
-
-// Checks for any printable character except space.
-inline boolean isGraph(int c)
-{
-  return ( isgraph (c) == 0 ? false : true);
-}
-
-
-// Checks for a lower-case character.
-inline boolean isLowerCase(int c)
-{
-  return (islower (c) == 0 ? false : true);
-}
-
-
-// Checks for any printable character including space.
-inline boolean isPrintable(int c)
-{
-  return ( isprint (c) == 0 ? false : true);
-}
-
-
-// Checks for any printable character which is not a space 
-// or an alphanumeric character.
-inline boolean isPunct(int c)
-{
-  return ( ispunct (c) == 0 ? false : true);
-}
-
-
-// Checks for white-space characters. For the avr-libc library, 
-// these are: space, formfeed ('\f'), newline ('\n'), carriage 
-// return ('\r'), horizontal tab ('\t'), and vertical tab ('\v').
-inline boolean isSpace(int c)
-{
-  return ( isspace (c) == 0 ? false : true);
-}
-
-
-// Checks for an uppercase letter.
-inline boolean isUpperCase(int c)
-{
-  return ( isupper (c) == 0 ? false : true);
-}
-
-
-// Checks for a hexadecimal digits, i.e. one of 0 1 2 3 4 5 6 7 
-// 8 9 a b c d e f A B C D E F.
-inline boolean isHexadecimalDigit(int c)
-{
-  return ( isxdigit (c) == 0 ? false : true);
-}
-
-
-// Converts c to a 7-bit unsigned char value that fits into the 
-// ASCII character set, by clearing the high-order bits.
-inline int toAscii(int c)
-{
-  return toascii (c);
-}
-
-
-// Warning:
-// Many people will be unhappy if you use this function. 
-// This function will convert accented letters into random 
-// characters.
-
-// Converts the letter c to lower case, if possible.
-inline int toLowerCase(int c)
-{
-  return tolower (c);
-}
-
-
-// Converts the letter c to upper case, if possible.
-inline int toUpperCase(int c)
-{
-  return toupper (c);
-}
-
-#endif
\ No newline at end of file
diff --git a/Marlin/Sanguino/cores/arduino/WConstants.h b/Marlin/Sanguino/cores/arduino/WConstants.h
deleted file mode 100644
index 3e19ac4..0000000
--- a/Marlin/Sanguino/cores/arduino/WConstants.h
+++ /dev/null
@@ -1 +0,0 @@
-#include "wiring.h"
diff --git a/Marlin/Sanguino/cores/arduino/WInterrupts.c b/Marlin/Sanguino/cores/arduino/WInterrupts.c
deleted file mode 100644
index 3b3e0c9..0000000
--- a/Marlin/Sanguino/cores/arduino/WInterrupts.c
+++ /dev/null
@@ -1,249 +0,0 @@
-/* -*- mode: jde; c-basic-offset: 2; indent-tabs-mode: nil -*- */
-
-/*
-  Part of the Wiring project - http://wiring.uniandes.edu.co
-
-  Copyright (c) 2004-05 Hernando Barragan
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-  
-  Modified 24 November 2006 by David A. Mellis
-  Modified 1 August 2010 by Mark Sproul
-*/
-
-#include <inttypes.h>
-#include <avr/io.h>
-#include <avr/interrupt.h>
-#include <avr/pgmspace.h>
-#include <stdio.h>
-
-#include "WConstants.h"
-#include "wiring_private.h"
-
-volatile static voidFuncPtr intFunc[EXTERNAL_NUM_INTERRUPTS];
-// volatile static voidFuncPtr twiIntFunc;
-
-void attachInterrupt(uint8_t interruptNum, void (*userFunc)(void), int mode) {
-  if(interruptNum < EXTERNAL_NUM_INTERRUPTS) {
-    intFunc[interruptNum] = userFunc;
-    
-    // Configure the interrupt mode (trigger on low input, any change, rising
-    // edge, or falling edge).  The mode constants were chosen to correspond
-    // to the configuration bits in the hardware register, so we simply shift
-    // the mode into place.
-      
-    // Enable the interrupt.
-      
-    switch (interruptNum) {
-#if defined(EICRA) && defined(EICRB) && defined(EIMSK)
-    case 2:
-      EICRA = (EICRA & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
-      EIMSK |= (1 << INT0);
-      break;
-    case 3:
-      EICRA = (EICRA & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
-      EIMSK |= (1 << INT1);
-      break;
-    case 4:
-      EICRA = (EICRA & ~((1 << ISC20) | (1 << ISC21))) | (mode << ISC20);
-      EIMSK |= (1 << INT2);
-      break;
-    case 5:
-      EICRA = (EICRA & ~((1 << ISC30) | (1 << ISC31))) | (mode << ISC30);
-      EIMSK |= (1 << INT3);
-      break;
-    case 0:
-      EICRB = (EICRB & ~((1 << ISC40) | (1 << ISC41))) | (mode << ISC40);
-      EIMSK |= (1 << INT4);
-      break;
-    case 1:
-      EICRB = (EICRB & ~((1 << ISC50) | (1 << ISC51))) | (mode << ISC50);
-      EIMSK |= (1 << INT5);
-      break;
-    case 6:
-      EICRB = (EICRB & ~((1 << ISC60) | (1 << ISC61))) | (mode << ISC60);
-      EIMSK |= (1 << INT6);
-      break;
-    case 7:
-      EICRB = (EICRB & ~((1 << ISC70) | (1 << ISC71))) | (mode << ISC70);
-      EIMSK |= (1 << INT7);
-      break;
-#else
-    case 0:
-    #if defined(EICRA) && defined(ISC00) && defined(EIMSK)
-      EICRA = (EICRA & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
-      EIMSK |= (1 << INT0);
-    #elif defined(MCUCR) && defined(ISC00) && defined(GICR)
-      MCUCR = (MCUCR & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
-      GICR |= (1 << INT0);
-    #elif defined(MCUCR) && defined(ISC00) && defined(GIMSK)
-      MCUCR = (MCUCR & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
-      GIMSK |= (1 << INT0);
-    #else
-      #error attachInterrupt not finished for this CPU (case 0)
-    #endif
-      break;
-
-    case 1:
-    #if defined(EICRA) && defined(ISC10) && defined(ISC11) && defined(EIMSK)
-      EICRA = (EICRA & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
-      EIMSK |= (1 << INT1);
-    #elif defined(MCUCR) && defined(ISC10) && defined(ISC11) && defined(GICR)
-      MCUCR = (MCUCR & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
-      GICR |= (1 << INT1);
-    #elif defined(MCUCR) && defined(ISC10) && defined(GIMSK) && defined(GIMSK)
-      MCUCR = (MCUCR & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
-      GIMSK |= (1 << INT1);
-    #else
-      #warning attachInterrupt may need some more work for this cpu (case 1)
-    #endif
-      break;
-#endif
-    }
-  }
-}
-
-void detachInterrupt(uint8_t interruptNum) {
-  if(interruptNum < EXTERNAL_NUM_INTERRUPTS) {
-    // Disable the interrupt.  (We can't assume that interruptNum is equal
-    // to the number of the EIMSK bit to clear, as this isn't true on the 
-    // ATmega8.  There, INT0 is 6 and INT1 is 7.)
-    switch (interruptNum) {
-#if defined(EICRA) && defined(EICRB) && defined(EIMSK)
-    case 2:
-      EIMSK &= ~(1 << INT0);
-      break;
-    case 3:
-      EIMSK &= ~(1 << INT1);
-      break;
-    case 4:
-      EIMSK &= ~(1 << INT2);
-      break;
-    case 5:
-      EIMSK &= ~(1 << INT3);
-      break;
-    case 0:
-      EIMSK &= ~(1 << INT4);
-      break;
-    case 1:
-      EIMSK &= ~(1 << INT5);
-      break;
-    case 6:
-      EIMSK &= ~(1 << INT6);
-      break;
-    case 7:
-      EIMSK &= ~(1 << INT7);
-      break;
-#else
-    case 0:
-    #if defined(EIMSK) && defined(INT0)
-      EIMSK &= ~(1 << INT0);
-    #elif defined(GICR) && defined(ISC00)
-      GICR &= ~(1 << INT0); // atmega32
-    #elif defined(GIMSK) && defined(INT0)
-      GIMSK &= ~(1 << INT0);
-    #else
-      #error detachInterrupt not finished for this cpu
-    #endif
-      break;
-
-    case 1:
-    #if defined(EIMSK) && defined(INT1)
-      EIMSK &= ~(1 << INT1);
-    #elif defined(GICR) && defined(INT1)
-      GICR &= ~(1 << INT1); // atmega32
-    #elif defined(GIMSK) && defined(INT1)
-      GIMSK &= ~(1 << INT1);
-    #else
-      #warning detachInterrupt may need some more work for this cpu (case 1)
-    #endif
-      break;
-#endif
-    }
-      
-    intFunc[interruptNum] = 0;
-  }
-}
-
-/*
-void attachInterruptTwi(void (*userFunc)(void) ) {
-  twiIntFunc = userFunc;
-}
-*/
-
-#if defined(EICRA) && defined(EICRB)
-
-SIGNAL(INT0_vect) {
-  if(intFunc[EXTERNAL_INT_2])
-    intFunc[EXTERNAL_INT_2]();
-}
-
-SIGNAL(INT1_vect) {
-  if(intFunc[EXTERNAL_INT_3])
-    intFunc[EXTERNAL_INT_3]();
-}
-
-SIGNAL(INT2_vect) {
-  if(intFunc[EXTERNAL_INT_4])
-    intFunc[EXTERNAL_INT_4]();
-}
-
-SIGNAL(INT3_vect) {
-  if(intFunc[EXTERNAL_INT_5])
-    intFunc[EXTERNAL_INT_5]();
-}
-
-SIGNAL(INT4_vect) {
-  if(intFunc[EXTERNAL_INT_0])
-    intFunc[EXTERNAL_INT_0]();
-}
-
-SIGNAL(INT5_vect) {
-  if(intFunc[EXTERNAL_INT_1])
-    intFunc[EXTERNAL_INT_1]();
-}
-
-SIGNAL(INT6_vect) {
-  if(intFunc[EXTERNAL_INT_6])
-    intFunc[EXTERNAL_INT_6]();
-}
-
-SIGNAL(INT7_vect) {
-  if(intFunc[EXTERNAL_INT_7])
-    intFunc[EXTERNAL_INT_7]();
-}
-
-#else
-
-SIGNAL(INT0_vect) {
-  if(intFunc[EXTERNAL_INT_0])
-    intFunc[EXTERNAL_INT_0]();
-}
-
-SIGNAL(INT1_vect) {
-  if(intFunc[EXTERNAL_INT_1])
-    intFunc[EXTERNAL_INT_1]();
-}
-
-#endif
-
-/*
-SIGNAL(SIG_2WIRE_SERIAL) {
-  if(twiIntFunc)
-    twiIntFunc();
-}
-*/
-
diff --git a/Marlin/Sanguino/cores/arduino/WMath.cpp b/Marlin/Sanguino/cores/arduino/WMath.cpp
deleted file mode 100644
index 2120c4c..0000000
--- a/Marlin/Sanguino/cores/arduino/WMath.cpp
+++ /dev/null
@@ -1,60 +0,0 @@
-/* -*- mode: jde; c-basic-offset: 2; indent-tabs-mode: nil -*- */
-
-/*
-  Part of the Wiring project - http://wiring.org.co
-  Copyright (c) 2004-06 Hernando Barragan
-  Modified 13 August 2006, David A. Mellis for Arduino - http://www.arduino.cc/
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-  
-  $Id$
-*/
-
-extern "C" {
-  #include "stdlib.h"
-}
-
-void randomSeed(unsigned int seed)
-{
-  if (seed != 0) {
-    srandom(seed);
-  }
-}
-
-long random(long howbig)
-{
-  if (howbig == 0) {
-    return 0;
-  }
-  return random() % howbig;
-}
-
-long random(long howsmall, long howbig)
-{
-  if (howsmall >= howbig) {
-    return howsmall;
-  }
-  long diff = howbig - howsmall;
-  return random(diff) + howsmall;
-}
-
-long map(long x, long in_min, long in_max, long out_min, long out_max)
-{
-  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
-}
-
-unsigned int makeWord(unsigned int w) { return w; }
-unsigned int makeWord(unsigned char h, unsigned char l) { return (h << 8) | l; }
\ No newline at end of file
diff --git a/Marlin/Sanguino/cores/arduino/WProgram.h b/Marlin/Sanguino/cores/arduino/WProgram.h
deleted file mode 100644
index f73e760..0000000
--- a/Marlin/Sanguino/cores/arduino/WProgram.h
+++ /dev/null
@@ -1,63 +0,0 @@
-#ifndef WProgram_h
-#define WProgram_h
-
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-
-#include <avr/interrupt.h>
-
-#include "wiring.h"
-
-#ifdef __cplusplus
-#include "WCharacter.h"
-#include "WString.h"
-#include "HardwareSerial.h"
-
-uint16_t makeWord(uint16_t w);
-uint16_t makeWord(byte h, byte l);
-
-#define word(...) makeWord(__VA_ARGS__)
-
-unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout = 1000000L);
-
-void tone(uint8_t _pin, unsigned int frequency, unsigned long duration = 0);
-void noTone(uint8_t _pin);
-
-// WMath prototypes
-long random(long);
-long random(long, long);
-void randomSeed(unsigned int);
-long map(long, long, long, long, long);
-
-#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
-const static uint8_t A0 = 54;
-const static uint8_t A1 = 55;
-const static uint8_t A2 = 56;
-const static uint8_t A3 = 57;
-const static uint8_t A4 = 58;
-const static uint8_t A5 = 59;
-const static uint8_t A6 = 60;
-const static uint8_t A7 = 61;
-const static uint8_t A8 = 62;
-const static uint8_t A9 = 63;
-const static uint8_t A10 = 64;
-const static uint8_t A11 = 65;
-const static uint8_t A12 = 66;
-const static uint8_t A13 = 67;
-const static uint8_t A14 = 68;
-const static uint8_t A15 = 69;
-#else
-const static uint8_t A0 = 14;
-const static uint8_t A1 = 15;
-const static uint8_t A2 = 16;
-const static uint8_t A3 = 17;
-const static uint8_t A4 = 18;
-const static uint8_t A5 = 19;
-const static uint8_t A6 = 20;
-const static uint8_t A7 = 21;
-#endif
-
-#endif
-
-#endif
\ No newline at end of file
diff --git a/Marlin/Sanguino/cores/arduino/WString.cpp b/Marlin/Sanguino/cores/arduino/WString.cpp
deleted file mode 100644
index db5a441..0000000
--- a/Marlin/Sanguino/cores/arduino/WString.cpp
+++ /dev/null
@@ -1,443 +0,0 @@
-/*
-  WString.cpp - String library for Wiring & Arduino
-  Copyright (c) 2009-10 Hernando Barragan.  All rights reserved.
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#include <stdlib.h>
-#include "WProgram.h"
-#include "WString.h"
-
-
-String::String( const char *value )
-{
-  if ( value == NULL )
-    value = "";
-  getBuffer( _length = strlen( value ) );
-  if ( _buffer != NULL )
-    strcpy( _buffer, value );
-}
-
-String::String( const String &value )
-{
-  getBuffer( _length = value._length );
-  if ( _buffer != NULL )
-    strcpy( _buffer, value._buffer );
-}
-
-String::String( const char value )
-{
-  _length = 1;
-  getBuffer(1);
-  if ( _buffer != NULL ) {
-    _buffer[0] = value;
-    _buffer[1] = 0;
-  }
-}
-
-String::String( const unsigned char value )
-{
-  _length = 1;
-  getBuffer(1);
-  if ( _buffer != NULL) {
-    _buffer[0] = value;
-    _buffer[1] = 0;
-  }
-}
-
-String::String( const int value, const int base )
-{
-  char buf[33];   
-  itoa((signed long)value, buf, base);
-  getBuffer( _length = strlen(buf) );
-  if ( _buffer != NULL )
-    strcpy( _buffer, buf );
-}
-
-String::String( const unsigned int value, const int base )
-{
-  char buf[33];   
-  ultoa((unsigned long)value, buf, base);
-  getBuffer( _length = strlen(buf) );
-  if ( _buffer != NULL )
-    strcpy( _buffer, buf );
-}
-
-String::String( const long value, const int base )
-{
-  char buf[33];   
-  ltoa(value, buf, base);
-  getBuffer( _length = strlen(buf) );
-  if ( _buffer != NULL )
-    strcpy( _buffer, buf );
-}
-
-String::String( const unsigned long value, const int base )
-{
-  char buf[33];   
-  ultoa(value, buf, 10);
-  getBuffer( _length = strlen(buf) );
-  if ( _buffer != NULL )
-    strcpy( _buffer, buf );
-}
-
-char String::charAt( unsigned int loc ) const
-{
-  return operator[]( loc );
-}
-
-void String::setCharAt( unsigned int loc, const char aChar ) 
-{
-  if(_buffer == NULL) return;
-  if(_length > loc) {
-    _buffer[loc] = aChar;
-  }
-}
-
-int String::compareTo( const String &s2 ) const
-{
-  return strcmp( _buffer, s2._buffer );
-}
-
-const String & String::concat( const String &s2 )
-{
-  return (*this) += s2;
-}
-
-const String & String::operator=( const String &rhs )
-{
-  if ( this == &rhs )
-    return *this;
-
-  if ( rhs._length > _length )
-  {
-    free(_buffer);
-    getBuffer( rhs._length );
-  }
-  
-  if ( _buffer != NULL ) {
-    _length = rhs._length;
-    strcpy( _buffer, rhs._buffer );
-  }
-  return *this;
-}
-
-//const String & String::operator+=( const char aChar )
-//{
-//  if ( _length == _capacity )
-//    doubleBuffer();
-//
-//  _buffer[ _length++ ] = aChar;
-//  _buffer[ _length ] = '\0';
-//  return *this;
-//}
-
-const String & String::operator+=( const String &other )
-{
-  _length += other._length;
-  if ( _length > _capacity )
-  {
-    char *temp = (char *)realloc(_buffer, _length + 1);
-    if ( temp != NULL ) {
-      _buffer = temp;
-      _capacity = _length;
-    } else {
-      _length -= other._length;
-      return *this;
-    }
-  }
-  strcat( _buffer, other._buffer );
-  return *this;
-}
-
-
-int String::operator==( const String &rhs ) const
-{
-  return ( _length == rhs._length && strcmp( _buffer, rhs._buffer ) == 0 );
-}
-
-int String::operator!=( const String &rhs ) const
-{
-  return ( _length != rhs.length() || strcmp( _buffer, rhs._buffer ) != 0 );
-}
-
-int String::operator<( const String &rhs ) const
-{
-  return strcmp( _buffer, rhs._buffer ) < 0;
-}
-
-int String::operator>( const String &rhs ) const
-{
-  return strcmp( _buffer, rhs._buffer ) > 0;
-}
-
-int String::operator<=( const String &rhs ) const
-{
-  return strcmp( _buffer, rhs._buffer ) <= 0;
-}
-
-int String::operator>=( const String & rhs ) const
-{
-  return strcmp( _buffer, rhs._buffer ) >= 0;
-}
-
-char & String::operator[]( unsigned int index )
-{
-  static char dummy_writable_char;
-  if (index >= _length || !_buffer) {
-    dummy_writable_char = 0;
-    return dummy_writable_char;
-  }
-  return _buffer[ index ];
-}
-
-char String::operator[]( unsigned int index ) const
-{
-  // need to check for valid index, to do later
-  return _buffer[ index ];
-}
-
-boolean String::endsWith( const String &s2 ) const
-{
-  if ( _length < s2._length )
-    return 0;
-
-  return strcmp( &_buffer[ _length - s2._length], s2._buffer ) == 0;
-}
-
-boolean String::equals( const String &s2 ) const
-{
-  return ( _length == s2._length && strcmp( _buffer,s2._buffer ) == 0 );
-}
-
-boolean String::equalsIgnoreCase( const String &s2 ) const
-{
-  if ( this == &s2 )
-    return true; //1;
-  else if ( _length != s2._length )
-    return false; //0;
-
-  return strcmp(toLowerCase()._buffer, s2.toLowerCase()._buffer) == 0;
-}
-
-String String::replace( char findChar, char replaceChar )
-{
-  if ( _buffer == NULL ) return *this;
-  String theReturn = _buffer;
-  char* temp = theReturn._buffer;
-  while( (temp = strchr( temp, findChar )) != 0 )
-    *temp = replaceChar;
-
-  return theReturn;
-}
-
-String String::replace( const String& match, const String& replace )
-{
-  if ( _buffer == NULL ) return *this;
-  String temp = _buffer, newString;
-
-  int loc;
-  while ( (loc = temp.indexOf( match )) != -1 )
-  {
-    newString += temp.substring( 0, loc );
-    newString += replace;
-    temp = temp.substring( loc + match._length );
-  }
-  newString += temp;  
-  return newString;
-}
-
-int String::indexOf( char temp ) const
-{
-  return indexOf( temp, 0 );
-}
-
-int String::indexOf( char ch, unsigned int fromIndex ) const
-{
-  if ( fromIndex >= _length )
-    return -1;
-
-  const char* temp = strchr( &_buffer[fromIndex], ch );
-  if ( temp == NULL )
-    return -1;
-
-  return temp - _buffer;
-}
-
-int String::indexOf( const String &s2 ) const
-{
-  return indexOf( s2, 0 );
-}
-
-int String::indexOf( const String &s2, unsigned int fromIndex ) const
-{
-  if ( fromIndex >= _length )
-    return -1;
-
-  const char *theFind = strstr( &_buffer[ fromIndex ], s2._buffer );
-
-  if ( theFind == NULL )
-    return -1;
-
-  return theFind - _buffer; // pointer subtraction
-}
-
-int String::lastIndexOf( char theChar ) const
-{
-  return lastIndexOf( theChar, _length - 1 );
-}
-
-int String::lastIndexOf( char ch, unsigned int fromIndex ) const
-{
-  if ( fromIndex >= _length )
-    return -1;
-
-  char tempchar = _buffer[fromIndex + 1];
-  _buffer[fromIndex + 1] = '\0';
-  char* temp = strrchr( _buffer, ch );
-  _buffer[fromIndex + 1] = tempchar;
-
-  if ( temp == NULL )
-    return -1;
-
-  return temp - _buffer;
-}
-
-int String::lastIndexOf( const String &s2 ) const
-{
-  return lastIndexOf( s2, _length - s2._length );
-}
-
-int String::lastIndexOf( const String &s2, unsigned int fromIndex ) const
-{
-  // check for empty strings
-  if ( s2._length == 0 || s2._length - 1 > fromIndex || fromIndex >= _length )
-    return -1;
-
-  // matching first character
-  char temp = s2[ 0 ];
-
-  for ( int i = fromIndex; i >= 0; i-- )
-  {
-    if ( _buffer[ i ] == temp && (*this).substring( i, i + s2._length ).equals( s2 ) )
-    return i;
-  }
-  return -1;
-}
-
-boolean String::startsWith( const String &s2 ) const
-{
-  if ( _length < s2._length )
-    return 0;
-
-  return startsWith( s2, 0 );
-}
-
-boolean String::startsWith( const String &s2, unsigned int offset ) const
-{
-  if ( offset > _length - s2._length )
-    return 0;
-
-  return strncmp( &_buffer[offset], s2._buffer, s2._length ) == 0;
-}
-
-String String::substring( unsigned int left ) const
-{
-  return substring( left, _length );
-}
-
-String String::substring( unsigned int left, unsigned int right ) const
-{
-  if ( left > right )
-  {
-    int temp = right;
-    right = left;
-    left = temp;
-  }
-
-  if ( right > _length )
-  {
-    right = _length;
-  } 
-
-  char temp = _buffer[ right ];  // save the replaced character
-  _buffer[ right ] = '\0';	
-  String outPut = ( _buffer + left );  // pointer arithmetic
-  _buffer[ right ] = temp;  //restore character
-  return outPut;
-}
-
-String String::toLowerCase() const
-{
-  String temp = _buffer;
-
-  for ( unsigned int i = 0; i < _length; i++ )
-    temp._buffer[ i ] = (char)tolower( temp._buffer[ i ] );
-  return temp;
-}
-
-String String::toUpperCase() const
-{
-  String temp = _buffer;
-
-  for ( unsigned int i = 0; i < _length; i++ )
-    temp._buffer[ i ] = (char)toupper( temp._buffer[ i ] );
-  return temp;
-}
-
-String String::trim() const
-{
-  if ( _buffer == NULL ) return *this;
-  String temp = _buffer;
-  unsigned int i,j;
-
-  for ( i = 0; i < _length; i++ )
-  {
-    if ( !isspace(_buffer[i]) )
-      break;
-  }
-
-  for ( j = temp._length - 1; j > i; j-- )
-  {
-    if ( !isspace(_buffer[j]) )
-      break;
-  }
-
-  return temp.substring( i, j + 1);
-}
-
-void String::getBytes(unsigned char *buf, unsigned int bufsize)
-{
-  if (!bufsize || !buf) return;
-  unsigned int len = bufsize - 1;
-  if (len > _length) len = _length;
-  strncpy((char *)buf, _buffer, len);
-  buf[len] = 0;
-}
-
-void String::toCharArray(char *buf, unsigned int bufsize)
-{
-  if (!bufsize || !buf) return;
-  unsigned int len = bufsize - 1;
-  if (len > _length) len = _length;
-  strncpy(buf, _buffer, len);
-  buf[len] = 0;
-}
-
-
-long String::toInt() {
-  return atol(_buffer);
-}
diff --git a/Marlin/Sanguino/cores/arduino/WString.h b/Marlin/Sanguino/cores/arduino/WString.h
deleted file mode 100644
index cadddb9..0000000
--- a/Marlin/Sanguino/cores/arduino/WString.h
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
-  WString.h - String library for Wiring & Arduino
-  Copyright (c) 2009-10 Hernando Barragan.  All right reserved.
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef String_h
-#define String_h
-
-//#include "WProgram.h"
-#include <stdlib.h>
-#include <string.h>
-#include <ctype.h>
-
-class String
-{
-  public:
-    // constructors
-    String( const char *value = "" );
-    String( const String &value );
-    String( const char );
-    String( const unsigned char );
-    String( const int, const int base=10);
-    String( const unsigned int, const int base=10 );
-    String( const long, const int base=10 );
-    String( const unsigned long, const int base=10 );
-    ~String() { free(_buffer); _length = _capacity = 0;}     //added _length = _capacity = 0;
-
-    // operators
-    const String & operator = ( const String &rhs );
-    const String & operator +=( const String &rhs );
-    //const String & operator +=( const char );
-    int operator ==( const String &rhs ) const;
-    int	operator !=( const String &rhs ) const;
-    int	operator < ( const String &rhs ) const;
-    int	operator > ( const String &rhs ) const;
-    int	operator <=( const String &rhs ) const;
-    int	operator >=( const String &rhs ) const;
-    char operator []( unsigned int index ) const;
-    char& operator []( unsigned int index );
-    //operator const char *() const { return _buffer; }
-    
-    // general methods
-    char charAt( unsigned int index ) const;
-    int	compareTo( const String &anotherString ) const;
-    unsigned char endsWith( const String &suffix ) const;
-    unsigned char equals( const String &anObject ) const;
-    unsigned char equalsIgnoreCase( const String &anotherString ) const;
-    int	indexOf( char ch ) const;
-    int	indexOf( char ch, unsigned int fromIndex ) const;
-    int	indexOf( const String &str ) const;
-    int	indexOf( const String &str, unsigned int fromIndex ) const;
-    int	lastIndexOf( char ch ) const;
-    int	lastIndexOf( char ch, unsigned int fromIndex ) const;
-    int	lastIndexOf( const String &str ) const;
-    int	lastIndexOf( const String &str, unsigned int fromIndex ) const;
-    const unsigned int length( ) const { return _length; }
-    void setCharAt(unsigned int index, const char ch);
-    unsigned char startsWith( const String &prefix ) const;
-    unsigned char startsWith( const String &prefix, unsigned int toffset ) const;
-    String substring( unsigned int beginIndex ) const;
-    String substring( unsigned int beginIndex, unsigned int endIndex ) const;
-    String toLowerCase( ) const;
-    String toUpperCase( ) const;
-    String trim( ) const;
-    void getBytes(unsigned char *buf, unsigned int bufsize);
-    void toCharArray(char *buf, unsigned int bufsize);
-    long toInt( );
-    const String& concat( const String &str );
-    String replace( char oldChar, char newChar );
-    String replace( const String& match, const String& replace );
-    friend String operator + ( String lhs, const String &rhs );
-
-  protected:
-    char *_buffer;	     // the actual char array
-    unsigned int _capacity;  // the array length minus one (for the '\0')
-    unsigned int _length;    // the String length (not counting the '\0')
-
-    void getBuffer(unsigned int maxStrLen);
-
-  private:
-
-};
-
-// allocate buffer space
-inline void String::getBuffer(unsigned int maxStrLen)
-{
-  _capacity = maxStrLen;
-  _buffer = (char *) malloc(_capacity + 1);
-  if (_buffer == NULL) _length = _capacity = 0;
-}
-
-inline String operator+( String lhs, const String &rhs )
-{
-  return lhs += rhs;
-}
-
-
-#endif
diff --git a/Marlin/Sanguino/cores/arduino/binary.h b/Marlin/Sanguino/cores/arduino/binary.h
deleted file mode 100644
index af14980..0000000
--- a/Marlin/Sanguino/cores/arduino/binary.h
+++ /dev/null
@@ -1,515 +0,0 @@
-#ifndef Binary_h
-#define Binary_h
-
-#define B0 0
-#define B00 0
-#define B000 0
-#define B0000 0
-#define B00000 0
-#define B000000 0
-#define B0000000 0
-#define B00000000 0
-#define B1 1
-#define B01 1
-#define B001 1
-#define B0001 1
-#define B00001 1
-#define B000001 1
-#define B0000001 1
-#define B00000001 1
-#define B10 2
-#define B010 2
-#define B0010 2
-#define B00010 2
-#define B000010 2
-#define B0000010 2
-#define B00000010 2
-#define B11 3
-#define B011 3
-#define B0011 3
-#define B00011 3
-#define B000011 3
-#define B0000011 3
-#define B00000011 3
-#define B100 4
-#define B0100 4
-#define B00100 4
-#define B000100 4
-#define B0000100 4
-#define B00000100 4
-#define B101 5
-#define B0101 5
-#define B00101 5
-#define B000101 5
-#define B0000101 5
-#define B00000101 5
-#define B110 6
-#define B0110 6
-#define B00110 6
-#define B000110 6
-#define B0000110 6
-#define B00000110 6
-#define B111 7
-#define B0111 7
-#define B00111 7
-#define B000111 7
-#define B0000111 7
-#define B00000111 7
-#define B1000 8
-#define B01000 8
-#define B001000 8
-#define B0001000 8
-#define B00001000 8
-#define B1001 9
-#define B01001 9
-#define B001001 9
-#define B0001001 9
-#define B00001001 9
-#define B1010 10
-#define B01010 10
-#define B001010 10
-#define B0001010 10
-#define B00001010 10
-#define B1011 11
-#define B01011 11
-#define B001011 11
-#define B0001011 11
-#define B00001011 11
-#define B1100 12
-#define B01100 12
-#define B001100 12
-#define B0001100 12
-#define B00001100 12
-#define B1101 13
-#define B01101 13
-#define B001101 13
-#define B0001101 13
-#define B00001101 13
-#define B1110 14
-#define B01110 14
-#define B001110 14
-#define B0001110 14
-#define B00001110 14
-#define B1111 15
-#define B01111 15
-#define B001111 15
-#define B0001111 15
-#define B00001111 15
-#define B10000 16
-#define B010000 16
-#define B0010000 16
-#define B00010000 16
-#define B10001 17
-#define B010001 17
-#define B0010001 17
-#define B00010001 17
-#define B10010 18
-#define B010010 18
-#define B0010010 18
-#define B00010010 18
-#define B10011 19
-#define B010011 19
-#define B0010011 19
-#define B00010011 19
-#define B10100 20
-#define B010100 20
-#define B0010100 20
-#define B00010100 20
-#define B10101 21
-#define B010101 21
-#define B0010101 21
-#define B00010101 21
-#define B10110 22
-#define B010110 22
-#define B0010110 22
-#define B00010110 22
-#define B10111 23
-#define B010111 23
-#define B0010111 23
-#define B00010111 23
-#define B11000 24
-#define B011000 24
-#define B0011000 24
-#define B00011000 24
-#define B11001 25
-#define B011001 25
-#define B0011001 25
-#define B00011001 25
-#define B11010 26
-#define B011010 26
-#define B0011010 26
-#define B00011010 26
-#define B11011 27
-#define B011011 27
-#define B0011011 27
-#define B00011011 27
-#define B11100 28
-#define B011100 28
-#define B0011100 28
-#define B00011100 28
-#define B11101 29
-#define B011101 29
-#define B0011101 29
-#define B00011101 29
-#define B11110 30
-#define B011110 30
-#define B0011110 30
-#define B00011110 30
-#define B11111 31
-#define B011111 31
-#define B0011111 31
-#define B00011111 31
-#define B100000 32
-#define B0100000 32
-#define B00100000 32
-#define B100001 33
-#define B0100001 33
-#define B00100001 33
-#define B100010 34
-#define B0100010 34
-#define B00100010 34
-#define B100011 35
-#define B0100011 35
-#define B00100011 35
-#define B100100 36
-#define B0100100 36
-#define B00100100 36
-#define B100101 37
-#define B0100101 37
-#define B00100101 37
-#define B100110 38
-#define B0100110 38
-#define B00100110 38
-#define B100111 39
-#define B0100111 39
-#define B00100111 39
-#define B101000 40
-#define B0101000 40
-#define B00101000 40
-#define B101001 41
-#define B0101001 41
-#define B00101001 41
-#define B101010 42
-#define B0101010 42
-#define B00101010 42
-#define B101011 43
-#define B0101011 43
-#define B00101011 43
-#define B101100 44
-#define B0101100 44
-#define B00101100 44
-#define B101101 45
-#define B0101101 45
-#define B00101101 45
-#define B101110 46
-#define B0101110 46
-#define B00101110 46
-#define B101111 47
-#define B0101111 47
-#define B00101111 47
-#define B110000 48
-#define B0110000 48
-#define B00110000 48
-#define B110001 49
-#define B0110001 49
-#define B00110001 49
-#define B110010 50
-#define B0110010 50
-#define B00110010 50
-#define B110011 51
-#define B0110011 51
-#define B00110011 51
-#define B110100 52
-#define B0110100 52
-#define B00110100 52
-#define B110101 53
-#define B0110101 53
-#define B00110101 53
-#define B110110 54
-#define B0110110 54
-#define B00110110 54
-#define B110111 55
-#define B0110111 55
-#define B00110111 55
-#define B111000 56
-#define B0111000 56
-#define B00111000 56
-#define B111001 57
-#define B0111001 57
-#define B00111001 57
-#define B111010 58
-#define B0111010 58
-#define B00111010 58
-#define B111011 59
-#define B0111011 59
-#define B00111011 59
-#define B111100 60
-#define B0111100 60
-#define B00111100 60
-#define B111101 61
-#define B0111101 61
-#define B00111101 61
-#define B111110 62
-#define B0111110 62
-#define B00111110 62
-#define B111111 63
-#define B0111111 63
-#define B00111111 63
-#define B1000000 64
-#define B01000000 64
-#define B1000001 65
-#define B01000001 65
-#define B1000010 66
-#define B01000010 66
-#define B1000011 67
-#define B01000011 67
-#define B1000100 68
-#define B01000100 68
-#define B1000101 69
-#define B01000101 69
-#define B1000110 70
-#define B01000110 70
-#define B1000111 71
-#define B01000111 71
-#define B1001000 72
-#define B01001000 72
-#define B1001001 73
-#define B01001001 73
-#define B1001010 74
-#define B01001010 74
-#define B1001011 75
-#define B01001011 75
-#define B1001100 76
-#define B01001100 76
-#define B1001101 77
-#define B01001101 77
-#define B1001110 78
-#define B01001110 78
-#define B1001111 79
-#define B01001111 79
-#define B1010000 80
-#define B01010000 80
-#define B1010001 81
-#define B01010001 81
-#define B1010010 82
-#define B01010010 82
-#define B1010011 83
-#define B01010011 83
-#define B1010100 84
-#define B01010100 84
-#define B1010101 85
-#define B01010101 85
-#define B1010110 86
-#define B01010110 86
-#define B1010111 87
-#define B01010111 87
-#define B1011000 88
-#define B01011000 88
-#define B1011001 89
-#define B01011001 89
-#define B1011010 90
-#define B01011010 90
-#define B1011011 91
-#define B01011011 91
-#define B1011100 92
-#define B01011100 92
-#define B1011101 93
-#define B01011101 93
-#define B1011110 94
-#define B01011110 94
-#define B1011111 95
-#define B01011111 95
-#define B1100000 96
-#define B01100000 96
-#define B1100001 97
-#define B01100001 97
-#define B1100010 98
-#define B01100010 98
-#define B1100011 99
-#define B01100011 99
-#define B1100100 100
-#define B01100100 100
-#define B1100101 101
-#define B01100101 101
-#define B1100110 102
-#define B01100110 102
-#define B1100111 103
-#define B01100111 103
-#define B1101000 104
-#define B01101000 104
-#define B1101001 105
-#define B01101001 105
-#define B1101010 106
-#define B01101010 106
-#define B1101011 107
-#define B01101011 107
-#define B1101100 108
-#define B01101100 108
-#define B1101101 109
-#define B01101101 109
-#define B1101110 110
-#define B01101110 110
-#define B1101111 111
-#define B01101111 111
-#define B1110000 112
-#define B01110000 112
-#define B1110001 113
-#define B01110001 113
-#define B1110010 114
-#define B01110010 114
-#define B1110011 115
-#define B01110011 115
-#define B1110100 116
-#define B01110100 116
-#define B1110101 117
-#define B01110101 117
-#define B1110110 118
-#define B01110110 118
-#define B1110111 119
-#define B01110111 119
-#define B1111000 120
-#define B01111000 120
-#define B1111001 121
-#define B01111001 121
-#define B1111010 122
-#define B01111010 122
-#define B1111011 123
-#define B01111011 123
-#define B1111100 124
-#define B01111100 124
-#define B1111101 125
-#define B01111101 125
-#define B1111110 126
-#define B01111110 126
-#define B1111111 127
-#define B01111111 127
-#define B10000000 128
-#define B10000001 129
-#define B10000010 130
-#define B10000011 131
-#define B10000100 132
-#define B10000101 133
-#define B10000110 134
-#define B10000111 135
-#define B10001000 136
-#define B10001001 137
-#define B10001010 138
-#define B10001011 139
-#define B10001100 140
-#define B10001101 141
-#define B10001110 142
-#define B10001111 143
-#define B10010000 144
-#define B10010001 145
-#define B10010010 146
-#define B10010011 147
-#define B10010100 148
-#define B10010101 149
-#define B10010110 150
-#define B10010111 151
-#define B10011000 152
-#define B10011001 153
-#define B10011010 154
-#define B10011011 155
-#define B10011100 156
-#define B10011101 157
-#define B10011110 158
-#define B10011111 159
-#define B10100000 160
-#define B10100001 161
-#define B10100010 162
-#define B10100011 163
-#define B10100100 164
-#define B10100101 165
-#define B10100110 166
-#define B10100111 167
-#define B10101000 168
-#define B10101001 169
-#define B10101010 170
-#define B10101011 171
-#define B10101100 172
-#define B10101101 173
-#define B10101110 174
-#define B10101111 175
-#define B10110000 176
-#define B10110001 177
-#define B10110010 178
-#define B10110011 179
-#define B10110100 180
-#define B10110101 181
-#define B10110110 182
-#define B10110111 183
-#define B10111000 184
-#define B10111001 185
-#define B10111010 186
-#define B10111011 187
-#define B10111100 188
-#define B10111101 189
-#define B10111110 190
-#define B10111111 191
-#define B11000000 192
-#define B11000001 193
-#define B11000010 194
-#define B11000011 195
-#define B11000100 196
-#define B11000101 197
-#define B11000110 198
-#define B11000111 199
-#define B11001000 200
-#define B11001001 201
-#define B11001010 202
-#define B11001011 203
-#define B11001100 204
-#define B11001101 205
-#define B11001110 206
-#define B11001111 207
-#define B11010000 208
-#define B11010001 209
-#define B11010010 210
-#define B11010011 211
-#define B11010100 212
-#define B11010101 213
-#define B11010110 214
-#define B11010111 215
-#define B11011000 216
-#define B11011001 217
-#define B11011010 218
-#define B11011011 219
-#define B11011100 220
-#define B11011101 221
-#define B11011110 222
-#define B11011111 223
-#define B11100000 224
-#define B11100001 225
-#define B11100010 226
-#define B11100011 227
-#define B11100100 228
-#define B11100101 229
-#define B11100110 230
-#define B11100111 231
-#define B11101000 232
-#define B11101001 233
-#define B11101010 234
-#define B11101011 235
-#define B11101100 236
-#define B11101101 237
-#define B11101110 238
-#define B11101111 239
-#define B11110000 240
-#define B11110001 241
-#define B11110010 242
-#define B11110011 243
-#define B11110100 244
-#define B11110101 245
-#define B11110110 246
-#define B11110111 247
-#define B11111000 248
-#define B11111001 249
-#define B11111010 250
-#define B11111011 251
-#define B11111100 252
-#define B11111101 253
-#define B11111110 254
-#define B11111111 255
-
-#endif
diff --git a/Marlin/Sanguino/cores/arduino/main.cpp b/Marlin/Sanguino/cores/arduino/main.cpp
deleted file mode 100644
index cc6e81d..0000000
--- a/Marlin/Sanguino/cores/arduino/main.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-#include <WProgram.h>
-
-int main(void)
-{
-	init();
-
-	setup();
-    
-	for (;;)
-		loop();
-        
-	return 0;
-}
-
diff --git a/Marlin/Sanguino/cores/arduino/pins_arduino.c b/Marlin/Sanguino/cores/arduino/pins_arduino.c
deleted file mode 100644
index d5fa6fe..0000000
--- a/Marlin/Sanguino/cores/arduino/pins_arduino.c
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
-  pins_arduino.c - pin definitions for the Arduino board
-  Part of Arduino / Wiring Lite
-
-  Copyright (c) 2005 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: pins_arduino.c 254 2007-04-20 23:17:38Z mellis $
-*/
-
-#include <avr/io.h>
-#include "wiring_private.h"
-#include "pins_arduino.h"
-
-// On the Sanguino board, digital pins are also used
-// for the analog output (software PWM).  Analog input
-// pins are a separate set.
-
-// ATMEL ATMEGA644P / SANGUINO
-//
-//                   +---\/---+
-//  INT0 (D 0) PB0  1|        |40  PA0 (AI 0 / D31)
-//  INT1 (D 1) PB1  2|        |39  PA1 (AI 1 / D30)
-//  INT2 (D 2) PB2  3|        |38  PA2 (AI 2 / D29)
-//   PWM (D 3) PB3  4|        |37  PA3 (AI 3 / D28)
-//   PWM (D 4) PB4  5|        |36  PA4 (AI 4 / D27)
-//  MOSI (D 5) PB5  6|        |35  PA5 (AI 5 / D26)
-//  MISO (D 6) PB6  7|        |34  PA6 (AI 6 / D25)
-//   SCK (D 7) PB7  8|        |33  PA7 (AI 7 / D24)
-//             RST  9|        |32  AREF
-//             VCC 10|        |31  GND 
-//             GND 11|        |30  AVCC
-//           XTAL2 12|        |29  PC7 (D 23)
-//           XTAL1 13|        |28  PC6 (D 22)
-//  RX0 (D 8)  PD0 14|        |27  PC5 (D 21) TDI
-//  TX0 (D 9)  PD1 15|        |26  PC4 (D 20) TDO
-//  RX1 (D 10) PD2 16|        |25  PC3 (D 19) TMS
-//  TX1 (D 11) PD3 17|        |24  PC2 (D 18) TCK
-//  PWM (D 12) PD4 18|        |23  PC1 (D 17) SDA
-//  PWM (D 13) PD5 19|        |22  PC0 (D 16) SCL
-//  PWM (D 14) PD6 20|        |21  PD7 (D 15) PWM
-//                   +--------+
-//
-
-#define PA 1
-#define PB 2
-#define PC 3
-#define PD 4
-
-// these arrays map port names (e.g. port B) to the
-// appropriate addresses for various functions (e.g. reading
-// and writing)
-const uint8_t PROGMEM port_to_mode_PGM[] =
-{
-	NOT_A_PORT,
-	(uint8_t) (uint16_t) &DDRA,
-	(uint8_t) (uint16_t) &DDRB,
-	(uint8_t) (uint16_t) &DDRC,
-	(uint8_t) (uint16_t) &DDRD,
-};
-
-const uint8_t PROGMEM port_to_output_PGM[] =
-{
-	NOT_A_PORT,
-	(uint8_t) (uint16_t) &PORTA,
-	(uint8_t) (uint16_t) &PORTB,
-	(uint8_t) (uint16_t) &PORTC,
-	(uint8_t) (uint16_t) &PORTD,
-};
-
-const uint8_t PROGMEM port_to_input_PGM[] =
-{
-	NOT_A_PORT,
-	(uint8_t) (uint16_t) &PINA,
-	(uint8_t) (uint16_t) &PINB,
-	(uint8_t) (uint16_t) &PINC,
-	(uint8_t) (uint16_t) &PIND,
-};
-
-const uint8_t PROGMEM digital_pin_to_port_PGM[] =
-{
-	PB, /* 0 */
-	PB,
-	PB,
-	PB,
-	PB,
-	PB,
-	PB,
-	PB,
-	PD, /* 8 */
-	PD,
-	PD,
-	PD,
-	PD,
-	PD,
-	PD,
-	PD,
-	PC, /* 16 */
-	PC,
-	PC,
-	PC,
-	PC,
-	PC,
-   	PC,
-	PC,
-	PA, /* 24 */
-	PA,
-	PA,
-	PA,
-	PA,
-	PA,
-	PA,
-	PA  /* 31 */
-};
-
-const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[] =
-{
-	_BV(0), /* 0, port B */
-	_BV(1),
-	_BV(2),
-	_BV(3),
-	_BV(4),
-	_BV(5),
-	_BV(6),
-	_BV(7),
-	_BV(0), /* 8, port D */
-	_BV(1),
-	_BV(2),
-	_BV(3),
-	_BV(4),
-	_BV(5),
-	_BV(6),
-	_BV(7),
-	_BV(0), /* 16, port C */
-	_BV(1),
-	_BV(2),
-	_BV(3),
-	_BV(4),
-	_BV(5),
-	_BV(6),
-	_BV(7),
-	_BV(7), /* 24, port A */
-	_BV(6),
-	_BV(5),
-	_BV(4),
-	_BV(3),
-	_BV(2),
-	_BV(1),
-	_BV(0)
-};
-
-const uint8_t PROGMEM digital_pin_to_timer_PGM[] =
-{
-	NOT_ON_TIMER, 	/* 0  - PB0 */
-	NOT_ON_TIMER, 	/* 1  - PB1 */
-	NOT_ON_TIMER, 	/* 2  - PB2 */
-	TIMER0A,     	/* 3  - PB3 */
-	TIMER0B, 		/* 4  - PB4 */
-	NOT_ON_TIMER, 	/* 5  - PB5 */
-	NOT_ON_TIMER, 	/* 6  - PB6 */
-	NOT_ON_TIMER,	/* 7  - PB7 */
-	NOT_ON_TIMER, 	/* 8  - PD0 */
-	NOT_ON_TIMER, 	/* 9  - PD1 */
-	NOT_ON_TIMER, 	/* 10 - PD2 */
-	NOT_ON_TIMER, 	/* 11 - PD3 */
-	TIMER1B,     	/* 12 - PD4 */
-	TIMER1A,     	/* 13 - PD5 */
-	TIMER2B,     	/* 14 - PD6 */
-	TIMER2A,     	/* 15 - PD7 */
-	NOT_ON_TIMER, 	/* 16 - PC0 */
-	NOT_ON_TIMER,   /* 17 - PC1 */
-	NOT_ON_TIMER,   /* 18 - PC2 */
-	NOT_ON_TIMER,   /* 19 - PC3 */
-	NOT_ON_TIMER,   /* 20 - PC4 */
-	NOT_ON_TIMER,   /* 21 - PC5 */
-	NOT_ON_TIMER,   /* 22 - PC6 */
-	NOT_ON_TIMER,   /* 23 - PC7 */
-	NOT_ON_TIMER,   /* 24 - PA0 */
-	NOT_ON_TIMER,   /* 25 - PA1 */
-	NOT_ON_TIMER,   /* 26 - PA2 */
-	NOT_ON_TIMER,   /* 27 - PA3 */
-	NOT_ON_TIMER,   /* 28 - PA4 */
-	NOT_ON_TIMER,   /* 29 - PA5 */
-	NOT_ON_TIMER,   /* 30 - PA6 */
-	NOT_ON_TIMER   /* 31 - PA7 */
-};
diff --git a/Marlin/Sanguino/cores/arduino/pins_arduino.h b/Marlin/Sanguino/cores/arduino/pins_arduino.h
deleted file mode 100644
index fd7ee5c..0000000
--- a/Marlin/Sanguino/cores/arduino/pins_arduino.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
-  pins_arduino.h - Pin definition functions for Arduino
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2007 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: wiring.h 249 2007-02-03 16:52:51Z mellis $
-*/
-
-#ifndef Pins_Arduino_h
-#define Pins_Arduino_h
-
-#include <avr/pgmspace.h>
-
-#define NOT_A_PIN 0
-#define NOT_A_PORT 0
-
-#define NOT_ON_TIMER 0
-#define TIMER0A 1
-#define TIMER0B 2
-#define TIMER1A 3
-#define TIMER1B 4
-#define TIMER2  5
-#define TIMER2A 6
-#define TIMER2B 7
-
-extern const uint8_t PROGMEM port_to_mode_PGM[];
-extern const uint8_t PROGMEM port_to_input_PGM[];
-extern const uint8_t PROGMEM port_to_output_PGM[];
-
-extern const uint8_t PROGMEM digital_pin_to_port_PGM[];
-extern const uint8_t PROGMEM digital_pin_to_bit_PGM[];
-extern const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[];
-
-extern const uint8_t PROGMEM digital_pin_to_timer_PGM[];
-
-// Get the bit location within the hardware port of the given virtual pin.
-// This comes from the pins_*.c file for the active board configuration.
-// 
-// These perform slightly better as macros compared to inline functions
-//
-#define digitalPinToPort(P) ( pgm_read_byte( digital_pin_to_port_PGM + (P) ) )
-#define digitalPinToBitMask(P) ( pgm_read_byte( digital_pin_to_bit_mask_PGM + (P) ) )
-#define digitalPinToTimer(P) ( pgm_read_byte( digital_pin_to_timer_PGM + (P) ) )
-#define analogInPinToBit(P) (P)
-#define portOutputRegister(P) ( (volatile uint8_t *)( (uint16_t) pgm_read_byte( port_to_output_PGM + (P))) )
-#define portInputRegister(P) ( (volatile uint8_t *)( (uint16_t) pgm_read_byte( port_to_input_PGM + (P))) )
-#define portModeRegister(P) ( (volatile uint8_t *)( (uint16_t) pgm_read_byte( port_to_mode_PGM + (P))) )
-
-#endif
diff --git a/Marlin/Sanguino/cores/arduino/wiring.c b/Marlin/Sanguino/cores/arduino/wiring.c
deleted file mode 100644
index b90d07e..0000000
--- a/Marlin/Sanguino/cores/arduino/wiring.c
+++ /dev/null
@@ -1,289 +0,0 @@
-/*
-  wiring.c - Partial implementation of the Wiring API for the ATmega8.
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id$
-*/
-
-#include "wiring_private.h"
-
-// the prescaler is set so that timer0 ticks every 64 clock cycles, and the
-// the overflow handler is called every 256 ticks.
-#define MICROSECONDS_PER_TIMER0_OVERFLOW (clockCyclesToMicroseconds(64 * 256))
-
-// the whole number of milliseconds per timer0 overflow
-#define MILLIS_INC (MICROSECONDS_PER_TIMER0_OVERFLOW / 1000)
-
-// the fractional number of milliseconds per timer0 overflow. we shift right
-// by three to fit these numbers into a byte. (for the clock speeds we care
-// about - 8 and 16 MHz - this doesn't lose precision.)
-#define FRACT_INC ((MICROSECONDS_PER_TIMER0_OVERFLOW % 1000) >> 3)
-#define FRACT_MAX (1000 >> 3)
-
-volatile unsigned long timer0_overflow_count = 0;
-volatile unsigned long timer0_millis = 0;
-static unsigned char timer0_fract = 0;
-
-SIGNAL(TIMER0_OVF_vect)
-{
-	// copy these to local variables so they can be stored in registers
-	// (volatile variables must be read from memory on every access)
-	unsigned long m = timer0_millis;
-	unsigned char f = timer0_fract;
-
-	m += MILLIS_INC;
-	f += FRACT_INC;
-	if (f >= FRACT_MAX) {
-		f -= FRACT_MAX;
-		m += 1;
-	}
-
-	timer0_fract = f;
-	timer0_millis = m;
-	timer0_overflow_count++;
-}
-
-unsigned long millis()
-{
-	unsigned long m;
-	uint8_t oldSREG = SREG;
-
-	// disable interrupts while we read timer0_millis or we might get an
-	// inconsistent value (e.g. in the middle of a write to timer0_millis)
-	cli();
-	m = timer0_millis;
-	SREG = oldSREG;
-
-	return m;
-}
-
-unsigned long micros() {
-	unsigned long m;
-	uint8_t oldSREG = SREG, t;
-	
-	cli();
-	m = timer0_overflow_count;
-#if defined(TCNT0)
-	t = TCNT0;
-#elif defined(TCNT0L)
-	t = TCNT0L;
-#else
-	#error TIMER 0 not defined
-#endif
-
-  
-#ifdef TIFR0
-	if ((TIFR0 & _BV(TOV0)) && (t < 255))
-		m++;
-#else
-	if ((TIFR & _BV(TOV0)) && (t < 255))
-		m++;
-#endif
-
-	SREG = oldSREG;
-	
-	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
-}
-
-void delay(unsigned long ms)
-{
-	uint16_t start = (uint16_t)micros();
-
-	while (ms > 0) {
-		if (((uint16_t)micros() - start) >= 1000) {
-			ms--;
-			start += 1000;
-		}
-	}
-}
-
-/* Delay for the given number of microseconds.  Assumes a 8 or 16 MHz clock. */
-void delayMicroseconds(unsigned int us)
-{
-	// calling avrlib's delay_us() function with low values (e.g. 1 or
-	// 2 microseconds) gives delays longer than desired.
-	//delay_us(us);
-
-#if F_CPU >= 16000000L
-	// for the 16 MHz clock on most Arduino boards
-
-	// for a one-microsecond delay, simply return.  the overhead
-	// of the function call yields a delay of approximately 1 1/8 us.
-	if (--us == 0)
-		return;
-
-	// the following loop takes a quarter of a microsecond (4 cycles)
-	// per iteration, so execute it four times for each microsecond of
-	// delay requested.
-	us <<= 2;
-
-	// account for the time taken in the preceeding commands.
-	us -= 2;
-#else
-	// for the 8 MHz internal clock on the ATmega168
-
-	// for a one- or two-microsecond delay, simply return.  the overhead of
-	// the function calls takes more than two microseconds.  can't just
-	// subtract two, since us is unsigned; we'd overflow.
-	if (--us == 0)
-		return;
-	if (--us == 0)
-		return;
-
-	// the following loop takes half of a microsecond (4 cycles)
-	// per iteration, so execute it twice for each microsecond of
-	// delay requested.
-	us <<= 1;
-    
-	// partially compensate for the time taken by the preceeding commands.
-	// we can't subtract any more than this or we'd overflow w/ small delays.
-	us--;
-#endif
-
-	// busy wait
-	__asm__ __volatile__ (
-		"1: sbiw %0,1" "\n\t" // 2 cycles
-		"brne 1b" : "=w" (us) : "0" (us) // 2 cycles
-	);
-}
-
-void init()
-{
-	// this needs to be called before setup() or some functions won't
-	// work there
-	sei();
-	
-	// on the ATmega168, timer 0 is also used for fast hardware pwm
-	// (using phase-correct PWM would mean that timer 0 overflowed half as often
-	// resulting in different millis() behavior on the ATmega8 and ATmega168)
-#if defined(TCCR0A) && defined(WGM01)
-	sbi(TCCR0A, WGM01);
-	sbi(TCCR0A, WGM00);
-#endif  
-
-	// set timer 0 prescale factor to 64
-#if defined(__AVR_ATmega128__)
-	// CPU specific: different values for the ATmega128
-	sbi(TCCR0, CS02);
-#elif defined(TCCR0) && defined(CS01) && defined(CS00)
-	// this combination is for the standard atmega8
-	sbi(TCCR0, CS01);
-	sbi(TCCR0, CS00);
-#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
-	// this combination is for the standard 168/328/1280/2560
-	sbi(TCCR0B, CS01);
-	sbi(TCCR0B, CS00);
-#elif defined(TCCR0A) && defined(CS01) && defined(CS00)
-	// this combination is for the __AVR_ATmega645__ series
-	sbi(TCCR0A, CS01);
-	sbi(TCCR0A, CS00);
-#else
-	#error Timer 0 prescale factor 64 not set correctly
-#endif
-
-	// enable timer 0 overflow interrupt
-#if defined(TIMSK) && defined(TOIE0)
-	sbi(TIMSK, TOIE0);
-#elif defined(TIMSK0) && defined(TOIE0)
-	sbi(TIMSK0, TOIE0);
-#else
-	#error	Timer 0 overflow interrupt not set correctly
-#endif
-
-	// timers 1 and 2 are used for phase-correct hardware pwm
-	// this is better for motors as it ensures an even waveform
-	// note, however, that fast pwm mode can achieve a frequency of up
-	// 8 MHz (with a 16 MHz clock) at 50% duty cycle
-
-	TCCR1B = 0;
-
-	// set timer 1 prescale factor to 64
-#if defined(TCCR1B) && defined(CS11) && defined(CS10)
-	sbi(TCCR1B, CS11);
-	sbi(TCCR1B, CS10);
-#elif defined(TCCR1) && defined(CS11) && defined(CS10)
-	sbi(TCCR1, CS11);
-	sbi(TCCR1, CS10);
-#endif
-	// put timer 1 in 8-bit phase correct pwm mode
-#if defined(TCCR1A) && defined(WGM10)
-	sbi(TCCR1A, WGM10);
-#elif defined(TCCR1)
-	#warning this needs to be finished
-#endif
-
-	// set timer 2 prescale factor to 64
-#if defined(TCCR2) && defined(CS22)
-	sbi(TCCR2, CS22);
-#elif defined(TCCR2B) && defined(CS22)
-	sbi(TCCR2B, CS22);
-#else
-	#warning Timer 2 not finished (may not be present on this CPU)
-#endif
-
-	// configure timer 2 for phase correct pwm (8-bit)
-#if defined(TCCR2) && defined(WGM20)
-	sbi(TCCR2, WGM20);
-#elif defined(TCCR2A) && defined(WGM20)
-	sbi(TCCR2A, WGM20);
-#else
-	#warning Timer 2 not finished (may not be present on this CPU)
-#endif
-
-#if defined(TCCR3B) && defined(CS31) && defined(WGM30)
-	sbi(TCCR3B, CS31);		// set timer 3 prescale factor to 64
-	sbi(TCCR3B, CS30);
-	sbi(TCCR3A, WGM30);		// put timer 3 in 8-bit phase correct pwm mode
-#endif
-	
-#if defined(TCCR4B) && defined(CS41) && defined(WGM40)
-	sbi(TCCR4B, CS41);		// set timer 4 prescale factor to 64
-	sbi(TCCR4B, CS40);
-	sbi(TCCR4A, WGM40);		// put timer 4 in 8-bit phase correct pwm mode
-#endif
-
-#if defined(TCCR5B) && defined(CS51) && defined(WGM50)
-	sbi(TCCR5B, CS51);		// set timer 5 prescale factor to 64
-	sbi(TCCR5B, CS50);
-	sbi(TCCR5A, WGM50);		// put timer 5 in 8-bit phase correct pwm mode
-#endif
-
-#if defined(ADCSRA)
-	// set a2d prescale factor to 128
-	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.
-	// XXX: this will not work properly for other clock speeds, and
-	// this code should use F_CPU to determine the prescale factor.
-	sbi(ADCSRA, ADPS2);
-	sbi(ADCSRA, ADPS1);
-	sbi(ADCSRA, ADPS0);
-
-	// enable a2d conversions
-	sbi(ADCSRA, ADEN);
-#endif
-
-	// the bootloader connects pins 0 and 1 to the USART; disconnect them
-	// here so they can be used as normal digital i/o; they will be
-	// reconnected in Serial.begin()
-#if defined(UCSRB)
-	UCSRB = 0;
-#elif defined(UCSR0B)
-	UCSR0B = 0;
-#endif
-}
diff --git a/Marlin/Sanguino/cores/arduino/wiring.h b/Marlin/Sanguino/cores/arduino/wiring.h
deleted file mode 100644
index 0a93678..0000000
--- a/Marlin/Sanguino/cores/arduino/wiring.h
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
-  wiring.h - Partial implementation of the Wiring API for the ATmega8.
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id$
-*/
-
-#ifndef Wiring_h
-#define Wiring_h
-
-#include <math.h>
-#include <avr/io.h>
-#include <stdlib.h>
-#include "binary.h"
-
-#ifdef __cplusplus
-extern "C"{
-#endif
-
-#define HIGH 0x1
-#define LOW  0x0
-
-#define INPUT 0x0
-#define OUTPUT 0x1
-
-#define true 0x1
-#define false 0x0
-
-#define PI 3.1415926535897932384626433832795
-#define HALF_PI 1.5707963267948966192313216916398
-#define TWO_PI 6.283185307179586476925286766559
-#define DEG_TO_RAD 0.017453292519943295769236907684886
-#define RAD_TO_DEG 57.295779513082320876798154814105
-
-#define SERIAL  0x0
-#define DISPLAY 0x1
-
-#define LSBFIRST 0
-#define MSBFIRST 1
-
-#define CHANGE 1
-#define FALLING 2
-#define RISING 3
-
-#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
-#define INTERNAL1V1 2
-#define INTERNAL2V56 3
-#else
-#define INTERNAL 3
-#endif
-#define DEFAULT 1
-#define EXTERNAL 0
-
-// undefine stdlib's abs if encountered
-#ifdef abs
-#undef abs
-#endif
-
-#define min(a,b) ((a)<(b)?(a):(b))
-#define max(a,b) ((a)>(b)?(a):(b))
-#define abs(x) ((x)>0?(x):-(x))
-#define constrain(amt,low,high) ((amt)<(low)?(low):((amt)>(high)?(high):(amt)))
-#define round(x)     ((x)>=0?(long)((x)+0.5):(long)((x)-0.5))
-#define radians(deg) ((deg)*DEG_TO_RAD)
-#define degrees(rad) ((rad)*RAD_TO_DEG)
-#define sq(x) ((x)*(x))
-
-#define interrupts() sei()
-#define noInterrupts() cli()
-
-#define clockCyclesPerMicrosecond() ( F_CPU / 1000000L )
-#define clockCyclesToMicroseconds(a) ( ((a) * 1000L) / (F_CPU / 1000L) )
-#define microsecondsToClockCycles(a) ( ((a) * (F_CPU / 1000L)) / 1000L )
-
-#define lowByte(w) ((uint8_t) ((w) & 0xff))
-#define highByte(w) ((uint8_t) ((w) >> 8))
-
-#define bitRead(value, bit) (((value) >> (bit)) & 0x01)
-#define bitSet(value, bit) ((value) |= (1UL << (bit)))
-#define bitClear(value, bit) ((value) &= ~(1UL << (bit)))
-#define bitWrite(value, bit, bitvalue) (bitvalue ? bitSet(value, bit) : bitClear(value, bit))
-
-
-typedef unsigned int word;
-
-#define bit(b) (1UL << (b))
-
-typedef uint8_t boolean;
-typedef uint8_t byte;
-
-void init(void);
-
-void pinMode(uint8_t, uint8_t);
-void digitalWrite(uint8_t, uint8_t);
-int digitalRead(uint8_t);
-int analogRead(uint8_t);
-void analogReference(uint8_t mode);
-void analogWrite(uint8_t, int);
-
-unsigned long millis(void);
-unsigned long micros(void);
-void delay(unsigned long);
-void delayMicroseconds(unsigned int us);
-unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout);
-
-void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val);
-uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder);
-
-void attachInterrupt(uint8_t, void (*)(void), int mode);
-void detachInterrupt(uint8_t);
-
-void setup(void);
-void loop(void);
-
-#ifdef __cplusplus
-} // extern "C"
-#endif
-
-#endif
diff --git a/Marlin/Sanguino/cores/arduino/wiring_analog.c b/Marlin/Sanguino/cores/arduino/wiring_analog.c
deleted file mode 100644
index d248f4c..0000000
--- a/Marlin/Sanguino/cores/arduino/wiring_analog.c
+++ /dev/null
@@ -1,259 +0,0 @@
-/*
-  wiring_analog.c - analog input and output
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  Modified 28 September 2010 by Mark Sproul
-
-  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
-*/
-
-#include "wiring_private.h"
-#include "pins_arduino.h"
-
-uint8_t analog_reference = DEFAULT;
-
-void analogReference(uint8_t mode)
-{
-	// can't actually set the register here because the default setting
-	// will connect AVCC and the AREF pin, which would cause a short if
-	// there's something connected to AREF.
-	analog_reference = mode;
-}
-
-int analogRead(uint8_t pin)
-{
-	uint8_t low, high;
-
-#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
-	if (pin >= 54) pin -= 54; // allow for channel or pin numbers
-#else
-	if (pin >= 14) pin -= 14; // allow for channel or pin numbers
-#endif
-
-#if defined(ADCSRB) && defined(MUX5)
-	// the MUX5 bit of ADCSRB selects whether we're reading from channels
-	// 0 to 7 (MUX5 low) or 8 to 15 (MUX5 high).
-	ADCSRB = (ADCSRB & ~(1 << MUX5)) | (((pin >> 3) & 0x01) << MUX5);
-#endif
-  
-	// set the analog reference (high two bits of ADMUX) and select the
-	// channel (low 4 bits).  this also sets ADLAR (left-adjust result)
-	// to 0 (the default).
-#if defined(ADMUX)
-	ADMUX = (analog_reference << 6) | (pin & 0x07);
-#endif
-
-	// without a delay, we seem to read from the wrong channel
-	//delay(1);
-
-#if defined(ADCSRA) && defined(ADCL)
-	// start the conversion
-	sbi(ADCSRA, ADSC);
-
-	// ADSC is cleared when the conversion finishes
-	while (bit_is_set(ADCSRA, ADSC));
-
-	// we have to read ADCL first; doing so locks both ADCL
-	// and ADCH until ADCH is read.  reading ADCL second would
-	// cause the results of each conversion to be discarded,
-	// as ADCL and ADCH would be locked when it completed.
-	low  = ADCL;
-	high = ADCH;
-#else
-	// we dont have an ADC, return 0
-	low  = 0;
-	high = 0;
-#endif
-
-	// combine the two bytes
-	return (high << 8) | low;
-}
-
-// Right now, PWM output only works on the pins with
-// hardware support.  These are defined in the appropriate
-// pins_*.c file.  For the rest of the pins, we default
-// to digital output.
-void analogWrite(uint8_t pin, int val)
-{
-	// We need to make sure the PWM output is enabled for those pins
-	// that support it, as we turn it off when digitally reading or
-	// writing with them.  Also, make sure the pin is in output mode
-	// for consistenty with Wiring, which doesn't require a pinMode
-	// call for the analog output pins.
-	pinMode(pin, OUTPUT);
-	if (val == 0)
-	{
-		digitalWrite(pin, LOW);
-	}
-	else if (val == 255)
-	{
-		digitalWrite(pin, HIGH);
-	}
-	else
-	{
-		switch(digitalPinToTimer(pin))
-		{
-			// XXX fix needed for atmega8
-			#if defined(TCCR0) && defined(COM00) && !defined(__AVR_ATmega8__)
-			case TIMER0A:
-				// connect pwm to pin on timer 0
-				sbi(TCCR0, COM00);
-				OCR0 = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR0A) && defined(COM0A1)
-			case TIMER0A:
-				// connect pwm to pin on timer 0, channel A
-				sbi(TCCR0A, COM0A1);
-				OCR0A = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR0A) && defined(COM0B1)
-			case TIMER0B:
-				// connect pwm to pin on timer 0, channel B
-				sbi(TCCR0A, COM0B1);
-				OCR0B = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR1A) && defined(COM1A1)
-			case TIMER1A:
-				// connect pwm to pin on timer 1, channel A
-				sbi(TCCR1A, COM1A1);
-				OCR1A = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR1A) && defined(COM1B1)
-			case TIMER1B:
-				// connect pwm to pin on timer 1, channel B
-				sbi(TCCR1A, COM1B1);
-				OCR1B = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR2) && defined(COM21)
-			case TIMER2:
-				// connect pwm to pin on timer 2
-				sbi(TCCR2, COM21);
-				OCR2 = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR2A) && defined(COM2A1)
-			case TIMER2A:
-				// connect pwm to pin on timer 2, channel A
-				sbi(TCCR2A, COM2A1);
-				OCR2A = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR2A) && defined(COM2B1)
-			case TIMER2B:
-				// connect pwm to pin on timer 2, channel B
-				sbi(TCCR2A, COM2B1);
-				OCR2B = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR3A) && defined(COM3A1)
-			case TIMER3A:
-				// connect pwm to pin on timer 3, channel A
-				sbi(TCCR3A, COM3A1);
-				OCR3A = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR3A) && defined(COM3B1)
-			case TIMER3B:
-				// connect pwm to pin on timer 3, channel B
-				sbi(TCCR3A, COM3B1);
-				OCR3B = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR3A) && defined(COM3C1)
-			case TIMER3C:
-				// connect pwm to pin on timer 3, channel C
-				sbi(TCCR3A, COM3C1);
-				OCR3C = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR4A) && defined(COM4A1)
-			case TIMER4A:
-				// connect pwm to pin on timer 4, channel A
-				sbi(TCCR4A, COM4A1);
-				OCR4A = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR4A) && defined(COM4B1)
-			case TIMER4B:
-				// connect pwm to pin on timer 4, channel B
-				sbi(TCCR4A, COM4B1);
-				OCR4B = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR4A) && defined(COM4C1)
-			case TIMER4C:
-				// connect pwm to pin on timer 4, channel C
-				sbi(TCCR4A, COM4C1);
-				OCR4C = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR5A) && defined(COM5A1)
-			case TIMER5A:
-				// connect pwm to pin on timer 5, channel A
-				sbi(TCCR5A, COM5A1);
-				OCR5A = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR5A) && defined(COM5B1)
-			case TIMER5B:
-				// connect pwm to pin on timer 5, channel B
-				sbi(TCCR5A, COM5B1);
-				OCR5B = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR5A) && defined(COM5C1)
-			case TIMER5C:
-				// connect pwm to pin on timer 5, channel C
-				sbi(TCCR5A, COM5C1);
-				OCR5C = val; // set pwm duty
-				break;
-			#endif
-
-			case NOT_ON_TIMER:
-			default:
-				if (val < 128) {
-					digitalWrite(pin, LOW);
-				} else {
-					digitalWrite(pin, HIGH);
-				}
-		}
-	}
-}
diff --git a/Marlin/Sanguino/cores/arduino/wiring_digital.c b/Marlin/Sanguino/cores/arduino/wiring_digital.c
deleted file mode 100644
index 0949da4..0000000
--- a/Marlin/Sanguino/cores/arduino/wiring_digital.c
+++ /dev/null
@@ -1,166 +0,0 @@
-/*
-  wiring_digital.c - digital input and output functions
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  Modified 28 September 2010 by Mark Sproul
-
-  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
-*/
-
-#include "wiring_private.h"
-#include "pins_arduino.h"
-
-void pinMode(uint8_t pin, uint8_t mode)
-{
-	uint8_t bit = digitalPinToBitMask(pin);
-	uint8_t port = digitalPinToPort(pin);
-	volatile uint8_t *reg;
-
-	if (port == NOT_A_PIN) return;
-
-	// JWS: can I let the optimizer do this?
-	reg = portModeRegister(port);
-
-	if (mode == INPUT) { 
-		uint8_t oldSREG = SREG;
-                cli();
-		*reg &= ~bit;
-		SREG = oldSREG;
-	} else {
-		uint8_t oldSREG = SREG;
-                cli();
-		*reg |= bit;
-		SREG = oldSREG;
-	}
-}
-
-// Forcing this inline keeps the callers from having to push their own stuff
-// on the stack. It is a good performance win and only takes 1 more byte per
-// user than calling. (It will take more bytes on the 168.)
-//
-// But shouldn't this be moved into pinMode? Seems silly to check and do on
-// each digitalread or write.
-//
-// Mark Sproul:
-// - Removed inline. Save 170 bytes on atmega1280
-// - changed to a switch statment; added 32 bytes but much easier to read and maintain.
-// - Added more #ifdefs, now compiles for atmega645
-//
-//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
-//static inline void turnOffPWM(uint8_t timer)
-static void turnOffPWM(uint8_t timer)
-{
-	switch (timer)
-	{
-		#if defined(TCCR1A) && defined(COM1A1)
-		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
-		#endif
-		#if defined(TCCR1A) && defined(COM1B1)
-		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
-		#endif
-		
-		#if defined(TCCR2) && defined(COM21)
-		case  TIMER2:   cbi(TCCR2, COM21);      break;
-		#endif
-		
-		#if defined(TCCR0A) && defined(COM0A1)
-		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
-		#endif
-		
-		#if defined(TIMER0B) && defined(COM0B1)
-		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
-		#endif
-		#if defined(TCCR2A) && defined(COM2A1)
-		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
-		#endif
-		#if defined(TCCR2A) && defined(COM2B1)
-		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
-		#endif
-		
-		#if defined(TCCR3A) && defined(COM3A1)
-		case  TIMER3A:  cbi(TCCR3A, COM3A1);    break;
-		#endif
-		#if defined(TCCR3A) && defined(COM3B1)
-		case  TIMER3B:  cbi(TCCR3A, COM3B1);    break;
-		#endif
-		#if defined(TCCR3A) && defined(COM3C1)
-		case  TIMER3C:  cbi(TCCR3A, COM3C1);    break;
-		#endif
-
-		#if defined(TCCR4A) && defined(COM4A1)
-		case  TIMER4A:  cbi(TCCR4A, COM4A1);    break;
-		#endif
-		#if defined(TCCR4A) && defined(COM4B1)
-		case  TIMER4B:  cbi(TCCR4A, COM4B1);    break;
-		#endif
-		#if defined(TCCR4A) && defined(COM4C1)
-		case  TIMER4C:  cbi(TCCR4A, COM4C1);    break;
-		#endif
-		#if defined(TCCR5A)
-		case  TIMER5A:  cbi(TCCR5A, COM5A1);    break;
-		case  TIMER5B:  cbi(TCCR5A, COM5B1);    break;
-		case  TIMER5C:  cbi(TCCR5A, COM5C1);    break;
-		#endif
-	}
-}
-
-void digitalWrite(uint8_t pin, uint8_t val)
-{
-	uint8_t timer = digitalPinToTimer(pin);
-	uint8_t bit = digitalPinToBitMask(pin);
-	uint8_t port = digitalPinToPort(pin);
-	volatile uint8_t *out;
-
-	if (port == NOT_A_PIN) return;
-
-	// If the pin that support PWM output, we need to turn it off
-	// before doing a digital write.
-	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
-
-	out = portOutputRegister(port);
-
-	if (val == LOW) {
-		uint8_t oldSREG = SREG;
-                cli();
-		*out &= ~bit;
-		SREG = oldSREG;
-	} else {
-		uint8_t oldSREG = SREG;
-                cli();
-		*out |= bit;
-		SREG = oldSREG;
-	}
-}
-
-int digitalRead(uint8_t pin)
-{
-	uint8_t timer = digitalPinToTimer(pin);
-	uint8_t bit = digitalPinToBitMask(pin);
-	uint8_t port = digitalPinToPort(pin);
-
-	if (port == NOT_A_PIN) return LOW;
-
-	// If the pin that support PWM output, we need to turn it off
-	// before getting a digital reading.
-	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
-
-	if (*portInputRegister(port) & bit) return HIGH;
-	return LOW;
-}
diff --git a/Marlin/Sanguino/cores/arduino/wiring_private.h b/Marlin/Sanguino/cores/arduino/wiring_private.h
deleted file mode 100644
index 7449c76..0000000
--- a/Marlin/Sanguino/cores/arduino/wiring_private.h
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
-  wiring_private.h - Internal header file.
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: wiring.h 239 2007-01-12 17:58:39Z mellis $
-*/
-
-#ifndef WiringPrivate_h
-#define WiringPrivate_h
-#include <math.h>
-#include <avr/io.h>
-#include <avr/interrupt.h>
-#include <util/delay.h>
-#include <stdio.h>
-#include <stdarg.h>
-
-#include "wiring.h"
-
-#ifdef __cplusplus
-extern "C"{
-#endif
-
-#ifndef cbi
-#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
-#endif
-#ifndef sbi
-#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
-#endif
-
-#define EXTERNAL_INT_0 0
-#define EXTERNAL_INT_1 1
-#define EXTERNAL_INT_2 2
-#define EXTERNAL_INT_3 3
-#define EXTERNAL_INT_4 4
-#define EXTERNAL_INT_5 5
-#define EXTERNAL_INT_6 6
-#define EXTERNAL_INT_7 7
-
-#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
-#define EXTERNAL_NUM_INTERRUPTS 8
-#else
-#define EXTERNAL_NUM_INTERRUPTS 2
-#endif
-
-typedef void (*voidFuncPtr)(void);
-
-#ifdef __cplusplus
-} // extern "C"
-#endif
-
-#endif
diff --git a/Marlin/Sanguino/cores/arduino/wiring_pulse.c b/Marlin/Sanguino/cores/arduino/wiring_pulse.c
deleted file mode 100644
index 0d96886..0000000
--- a/Marlin/Sanguino/cores/arduino/wiring_pulse.c
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
-  wiring_pulse.c - pulseIn() function
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
-*/
-
-#include "wiring_private.h"
-#include "pins_arduino.h"
-
-/* Measures the length (in microseconds) of a pulse on the pin; state is HIGH
- * or LOW, the type of pulse to measure.  Works on pulses from 2-3 microseconds
- * to 3 minutes in length, but must be called at least a few dozen microseconds
- * before the start of the pulse. */
-unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout)
-{
-	// cache the port and bit of the pin in order to speed up the
-	// pulse width measuring loop and achieve finer resolution.  calling
-	// digitalRead() instead yields much coarser resolution.
-	uint8_t bit = digitalPinToBitMask(pin);
-	uint8_t port = digitalPinToPort(pin);
-	uint8_t stateMask = (state ? bit : 0);
-	unsigned long width = 0; // keep initialization out of time critical area
-	
-	// convert the timeout from microseconds to a number of times through
-	// the initial loop; it takes 16 clock cycles per iteration.
-	unsigned long numloops = 0;
-	unsigned long maxloops = microsecondsToClockCycles(timeout) / 16;
-	
-	// wait for any previous pulse to end
-	while ((*portInputRegister(port) & bit) == stateMask)
-		if (numloops++ == maxloops)
-			return 0;
-	
-	// wait for the pulse to start
-	while ((*portInputRegister(port) & bit) != stateMask)
-		if (numloops++ == maxloops)
-			return 0;
-	
-	// wait for the pulse to stop
-	while ((*portInputRegister(port) & bit) == stateMask) {
-		if (numloops++ == maxloops)
-			return 0;
-		width++;
-	}
-
-	// convert the reading to microseconds. The loop has been determined
-	// to be 20 clock cycles long and have about 16 clocks between the edge
-	// and the start of the loop. There will be some error introduced by
-	// the interrupt handlers.
-	return clockCyclesToMicroseconds(width * 21 + 16); 
-}
diff --git a/Marlin/Sanguino/cores/arduino/wiring_shift.c b/Marlin/Sanguino/cores/arduino/wiring_shift.c
deleted file mode 100644
index cfe7867..0000000
--- a/Marlin/Sanguino/cores/arduino/wiring_shift.c
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
-  wiring_shift.c - shiftOut() function
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
-*/
-
-#include "wiring_private.h"
-
-uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder) {
-	uint8_t value = 0;
-	uint8_t i;
-
-	for (i = 0; i < 8; ++i) {
-		digitalWrite(clockPin, HIGH);
-		if (bitOrder == LSBFIRST)
-			value |= digitalRead(dataPin) << i;
-		else
-			value |= digitalRead(dataPin) << (7 - i);
-		digitalWrite(clockPin, LOW);
-	}
-	return value;
-}
-
-void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val)
-{
-	uint8_t i;
-
-	for (i = 0; i < 8; i++)  {
-		if (bitOrder == LSBFIRST)
-			digitalWrite(dataPin, !!(val & (1 << i)));
-		else	
-			digitalWrite(dataPin, !!(val & (1 << (7 - i))));
-			
-		digitalWrite(clockPin, HIGH);
-		digitalWrite(clockPin, LOW);		
-	}
-}
diff --git a/Marlin/Sanguino/programmers.txt b/Marlin/Sanguino/programmers.txt
deleted file mode 100644
index 466f602..0000000
--- a/Marlin/Sanguino/programmers.txt
+++ /dev/null
@@ -1,20 +0,0 @@
-avrisp.name=AVR ISP
-avrisp.communication=serial
-avrisp.protocol=stk500v1
-
-avrispmkii.name=AVRISP mkII
-avrispmkii.communication=usb
-avrispmkii.protocol=stk500v2
-
-usbtinyisp.name=USBtinyISP
-usbtinyisp.protocol=usbtiny
-
-parallel.name=Parallel Programmer
-parallel.protocol=dapa
-parallel.force=true
-# parallel.delay=200
-
-arduinoisp.name=Arduino as ISP
-arduinoisp.communication=serial
-arduinoisp.protocol=stk500v1
-arduinoisp.speed=19200
diff --git a/Marlin/Sd2Card.cpp b/Marlin/Sd2Card.cpp
index eb38df6..72f5661 100644
--- a/Marlin/Sd2Card.cpp
+++ b/Marlin/Sd2Card.cpp
@@ -42,28 +42,28 @@ static void spiInit(uint8_t spiRate) {
 /** SPI receive a byte */
 static uint8_t spiRec() {
   SPDR = 0XFF;
-  while (!(SPSR & (1 << SPIF)));
+  while (!(SPSR & (1 << SPIF))) { /* Intentionally left empty */ }
   return SPDR;
 }
 //------------------------------------------------------------------------------
 /** SPI read data - only one call so force inline */
 static inline __attribute__((always_inline))
-  void spiRead(uint8_t* buf, uint16_t nbyte) {
+void spiRead(uint8_t* buf, uint16_t nbyte) {
   if (nbyte-- == 0) return;
   SPDR = 0XFF;
   for (uint16_t i = 0; i < nbyte; i++) {
-    while (!(SPSR & (1 << SPIF)));
+    while (!(SPSR & (1 << SPIF))) { /* Intentionally left empty */ }
     buf[i] = SPDR;
     SPDR = 0XFF;
   }
-  while (!(SPSR & (1 << SPIF)));
+  while (!(SPSR & (1 << SPIF))) { /* Intentionally left empty */ }
   buf[nbyte] = SPDR;
 }
 //------------------------------------------------------------------------------
 /** SPI send a byte */
 static void spiSend(uint8_t b) {
   SPDR = b;
-  while (!(SPSR & (1 << SPIF)));
+  while (!(SPSR & (1 << SPIF))) { /* Intentionally left empty */ }
 }
 //------------------------------------------------------------------------------
 /** SPI send block - only one call so force inline */
@@ -71,12 +71,12 @@ static inline __attribute__((always_inline))
   void spiSendBlock(uint8_t token, const uint8_t* buf) {
   SPDR = token;
   for (uint16_t i = 0; i < 512; i += 2) {
-    while (!(SPSR & (1 << SPIF)));
+    while (!(SPSR & (1 << SPIF))) { /* Intentionally left empty */ }
     SPDR = buf[i];
-    while (!(SPSR & (1 << SPIF)));
+    while (!(SPSR & (1 << SPIF))) { /* Intentionally left empty */ }
     SPDR = buf[i + 1];
   }
-  while (!(SPSR & (1 << SPIF)));
+  while (!(SPSR & (1 << SPIF))) { /* Intentionally left empty */ }
 }
 //------------------------------------------------------------------------------
 #else  // SOFTWARE_SPI
@@ -174,7 +174,7 @@ uint8_t Sd2Card::cardCommand(uint8_t cmd, uint32_t arg) {
   if (cmd == CMD12) spiRec();
 
   // wait for response
-  for (uint8_t i = 0; ((status_ = spiRec()) & 0X80) && i != 0XFF; i++);
+  for (uint8_t i = 0; ((status_ = spiRec()) & 0X80) && i != 0XFF; i++) { /* Intentionally left empty */ }
   return status_;
 }
 //------------------------------------------------------------------------------
diff --git a/Marlin/SdBaseFile.cpp b/Marlin/SdBaseFile.cpp
index c4d5380..dbcf77f 100644
--- a/Marlin/SdBaseFile.cpp
+++ b/Marlin/SdBaseFile.cpp
@@ -400,7 +400,7 @@ bool SdBaseFile::make83Name(const char* str, uint8_t* name, const char** ptr) {
       // check size and only allow ASCII printable characters
       if (i > n || c < 0X21 || c > 0X7E)goto fail;
       // only upper case allowed in 8.3 names - convert lower to upper
-      name[i++] = c < 'a' || c > 'z' ?  c : c + ('A' - 'a');
+      name[i++] = (c < 'a' || c > 'z') ?  (c) : (c + ('A' - 'a'));
     }
   }
   *ptr = str;
@@ -1822,4 +1822,4 @@ void (*SdBaseFile::oldDateTime_)(uint16_t& date, uint16_t& time) = 0;  // NOLINT
 #endif  // ALLOW_DEPRECATED_FUNCTIONS
 
 
-#endif
+#endif
diff --git a/Marlin/SdFile.cpp b/Marlin/SdFile.cpp
index e9439e3..29f5efa 100644
--- a/Marlin/SdFile.cpp
+++ b/Marlin/SdFile.cpp
@@ -55,13 +55,16 @@ int16_t SdFile::write(const void* buf, uint16_t nbyte) {
  * Use writeError to check for errors.
  */
 #if ARDUINO >= 100
-    size_t SdFile::write(uint8_t b)
+size_t SdFile::write(uint8_t b)
+{
+    return SdBaseFile::write(&b, 1);
+}
 #else
-  void SdFile::write(uint8_t b)
-#endif
+void SdFile::write(uint8_t b)
 {
-  SdBaseFile::write(&b, 1);
+    SdBaseFile::write(&b, 1);
 }
+#endif
 //------------------------------------------------------------------------------
 /** Write a string to a file. Used by the Arduino Print class.
  * \param[in] str Pointer to the string.
@@ -89,4 +92,4 @@ void SdFile::writeln_P(PGM_P str) {
 }
 
 
-#endif
\ No newline at end of file
+#endif
diff --git a/Marlin/cardreader.cpp b/Marlin/cardreader.cpp
index 47a3fd0..9711208 100644
--- a/Marlin/cardreader.cpp
+++ b/Marlin/cardreader.cpp
@@ -246,7 +246,9 @@ void CardReader::openFile(char* name,bool read)
           return;
         }
         else
-          ;//SERIAL_ECHOLN("dive ok");
+        {
+          //SERIAL_ECHOLN("dive ok");
+        }
           
         curDir=&myDir; 
         dirname_start=dirname_end+1;
@@ -277,7 +279,7 @@ void CardReader::openFile(char* name,bool read)
       sdpos = 0;
       
       SERIAL_PROTOCOLLNPGM(MSG_SD_FILE_SELECTED);
-      LCD_MESSAGE(fname);
+      lcd_setstatus(fname);
     }
     else
     {
@@ -299,7 +301,7 @@ void CardReader::openFile(char* name,bool read)
       saving = true;
       SERIAL_PROTOCOLPGM(MSG_SD_WRITE_TO_FILE);
       SERIAL_PROTOCOLLN(name);
-      LCD_MESSAGE(fname);
+      lcd_setstatus(fname);
     }
   }
   
@@ -340,7 +342,9 @@ void CardReader::removeFile(char* name)
           return;
         }
         else
-          ;//SERIAL_ECHOLN("dive ok");
+        {
+          //SERIAL_ECHOLN("dive ok");
+        }
           
         curDir=&myDir; 
         dirname_start=dirname_end+1;
@@ -428,7 +432,7 @@ void CardReader::checkautostart(bool force)
   }
   
   char autoname[30];
-  sprintf(autoname,"auto%i.g",lastnr);
+  sprintf_P(autoname, PSTR("auto%i.g"), lastnr);
   for(int8_t i=0;i<(int8_t)strlen(autoname);i++)
     autoname[i]=tolower(autoname[i]);
   dir_t p;
@@ -448,9 +452,9 @@ void CardReader::checkautostart(bool force)
     {
       char cmd[30];
 
-      sprintf(cmd,"M23 %s",autoname);
+      sprintf_P(cmd, PSTR("M23 %s"), autoname);
       enquecommand(cmd);
-      enquecommand("M24");
+      enquecommand_P(PSTR("M24"));
       found=true;
     }
   }
@@ -523,14 +527,15 @@ void CardReader::updir()
 
 void CardReader::printingHasFinished()
 {
- st_synchronize();
- quickStop();
- sdprinting = false;
- if(SD_FINISHED_STEPPERRELEASE)
- {
-   //finishAndDisableSteppers();
-   enquecommand(SD_FINISHED_RELEASECOMMAND);
- }
- autotempShutdown();
+    st_synchronize();
+    quickStop();
+    file.close();
+    sdprinting = false;
+    if(SD_FINISHED_STEPPERRELEASE)
+    {
+        //finishAndDisableSteppers();
+        enquecommand_P(PSTR(SD_FINISHED_RELEASECOMMAND));
+    }
+    autotempShutdown();
 }
 #endif //SDSUPPORT
diff --git a/Marlin/cardreader.h b/Marlin/cardreader.h
index e5c8443..2d00577 100644
--- a/Marlin/cardreader.h
+++ b/Marlin/cardreader.h
@@ -35,10 +35,11 @@ public:
   void setroot();
 
 
+  FORCE_INLINE bool isFileOpen() { return file.isOpen(); }
   FORCE_INLINE bool eof() { return sdpos>=filesize ;};
   FORCE_INLINE int16_t get() {  sdpos = file.curPosition();return (int16_t)file.read();};
   FORCE_INLINE void setIndex(long index) {sdpos = index;file.seekSet(index);};
-  FORCE_INLINE uint8_t percentDone(){if(!sdprinting) return 0; if(filesize) return sdpos*100/filesize; else return 0;};
+  FORCE_INLINE uint8_t percentDone(){if(!isFileOpen()) return 0; if(filesize) return sdpos/((filesize+99)/100); else return 0;};
   FORCE_INLINE char* getWorkDirName(){workDir.getFilename(filename);return filename;};
 
 public:
@@ -66,11 +67,23 @@ private:
   char* diveDirName;
   void lsDive(const char *prepend,SdFile parent);
 };
+extern CardReader card;
 #define IS_SD_PRINTING (card.sdprinting)
 
+#if (SDCARDDETECT > -1)
+# ifdef SDCARDDETECTINVERTED 
+#  define IS_SD_INSERTED (READ(SDCARDDETECT)!=0)
+# else
+#  define IS_SD_INSERTED (READ(SDCARDDETECT)==0)
+# endif //SDCARDTETECTINVERTED
+#else
+//If we don't have a card detect line, aways asume the card is inserted
+# define IS_SD_INSERTED true
+#endif
+
 #else
 
 #define IS_SD_PRINTING (false)
 
 #endif //SDSUPPORT
-#endif
+#endif
diff --git a/Marlin/createTemperatureLookup.py b/Marlin/createTemperatureLookup.py
deleted file mode 100644
index e60a490..0000000
--- a/Marlin/createTemperatureLookup.py
+++ /dev/null
@@ -1,127 +0,0 @@
-#!/usr/bin/python
-#
-# Creates a C code lookup table for doing ADC to temperature conversion
-# on a microcontroller
-# based on: http://hydraraptor.blogspot.com/2007/10/measuring-temperature-easy-way.html
-"""Thermistor Value Lookup Table Generator
-
-Generates lookup to temperature values for use in a microcontroller in C format based on: 
-http://hydraraptor.blogspot.com/2007/10/measuring-temperature-easy-way.html
-
-The main use is for Arduino programs that read data from the circuit board described here:
-http://make.rrrf.org/ts-1.0
-
-Usage: python createTemperatureLookup.py [options]
-
-Options:
-  -h, --help            show this help
-  --r0=...          thermistor rating where # is the ohm rating of the thermistor at t0 (eg: 10K = 10000)
-  --t0=...          thermistor temp rating where # is the temperature in Celsuis to get r0 (from your datasheet)
-  --beta=...            thermistor beta rating. see http://reprap.org/bin/view/Main/MeasuringThermistorBeta
-  --r1=...          R1 rating where # is the ohm rating of R1 (eg: 10K = 10000)
-  --r2=...          R2 rating where # is the ohm rating of R2 (eg: 10K = 10000)
-  --num-temps=...   the number of temperature points to calculate (default: 20)
-  --max-adc=...     the max ADC reading to use.  if you use R1, it limits the top value for the thermistor circuit, and thus the possible range of ADC values
-"""
-
-from math import *
-import sys
-import getopt
-
-class Thermistor:
-    "Class to do the thermistor maths"
-    def __init__(self, r0, t0, beta, r1, r2):
-        self.r0 = r0                        # stated resistance, e.g. 10K
-        self.t0 = t0 + 273.15               # temperature at stated resistance, e.g. 25C
-        self.beta = beta                    # stated beta, e.g. 3500
-        self.vadc = 5.0                     # ADC reference
-        self.vcc = 5.0                      # supply voltage to potential divider
-        self.k = r0 * exp(-beta / self.t0)   # constant part of calculation
-
-        if r1 > 0:
-            self.vs = r1 * self.vcc / (r1 + r2) # effective bias voltage
-            self.rs = r1 * r2 / (r1 + r2)       # effective bias impedance
-        else:
-            self.vs = self.vcc                   # effective bias voltage
-            self.rs = r2                         # effective bias impedance
-
-    def temp(self,adc):
-        "Convert ADC reading into a temperature in Celcius"
-        v = adc * self.vadc / 1024          # convert the 10 bit ADC value to a voltage
-        r = self.rs * v / (self.vs - v)     # resistance of thermistor
-        return (self.beta / log(r / self.k)) - 273.15        # temperature
-
-    def setting(self, t):
-        "Convert a temperature into a ADC value"
-        r = self.r0 * exp(self.beta * (1 / (t + 273.15) - 1 / self.t0)) # resistance of the thermistor
-        v = self.vs * r / (self.rs + r)     # the voltage at the potential divider
-        return round(v / self.vadc * 1024)  # the ADC reading
-
-def main(argv):
-
-    r0 = 10000;
-    t0 = 25;
-    beta = 3947;
-    r1 = 680;
-    r2 = 1600;
-    num_temps = int(20);
-    
-    try:
-        opts, args = getopt.getopt(argv, "h", ["help", "r0=", "t0=", "beta=", "r1=", "r2="])
-    except getopt.GetoptError:
-        usage()
-        sys.exit(2)
-        
-    for opt, arg in opts:
-        if opt in ("-h", "--help"):
-            usage()
-            sys.exit()
-        elif opt == "--r0":
-            r0 = int(arg)
-        elif opt == "--t0":
-            t0 = int(arg)
-        elif opt == "--beta":
-            beta = int(arg)
-        elif opt == "--r1":
-            r1 = int(arg)
-        elif opt == "--r2":
-            r2 = int(arg)
-
-    if r1:
-        max_adc = int(1023 * r1 / (r1 + r2));
-    else:
-        max_adc = 1023
-    increment = int(max_adc/(num_temps-1));
-            
-    t = Thermistor(r0, t0, beta, r1, r2)
-
-    adcs = range(1, max_adc, increment);
-#   adcs = [1, 20, 25, 30, 35, 40, 45, 50, 60, 70, 80, 90, 100, 110, 130, 150, 190, 220,  250, 300]
-    first = 1
-
-    print "// Thermistor lookup table for RepRap Temperature Sensor Boards (http://make.rrrf.org/ts)"
-    print "// Made with createTemperatureLookup.py (http://svn.reprap.org/trunk/reprap/firmware/Arduino/utilities/createTemperatureLookup.py)"
-    print "// ./createTemperatureLookup.py --r0=%s --t0=%s --r1=%s --r2=%s --beta=%s --max-adc=%s" % (r0, t0, r1, r2, beta, max_adc)
-    print "// r0: %s" % (r0)
-    print "// t0: %s" % (t0)
-    print "// r1: %s" % (r1)
-    print "// r2: %s" % (r2)
-    print "// beta: %s" % (beta)
-    print "// max adc: %s" % (max_adc)
-    print "#define NUMTEMPS %s" % (len(adcs))
-    print "short temptable[NUMTEMPS][2] = {"
-
-    counter = 0
-    for adc in adcs:
-        counter = counter +1
-        if counter == len(adcs):
-            print "   {%s, %s}" % (adc, int(t.temp(adc)))
-        else:
-            print "   {%s, %s}," % (adc, int(t.temp(adc)))
-    print "};"
-    
-def usage():
-    print __doc__
-
-if __name__ == "__main__":
-    main(sys.argv[1:])
diff --git a/Marlin/createTemperatureLookupMarlin.py b/Marlin/createTemperatureLookupMarlin.py
new file mode 100644
index 0000000..e09294e
--- /dev/null
+++ b/Marlin/createTemperatureLookupMarlin.py
@@ -0,0 +1,138 @@
+#!/usr/bin/python
+#
+# Creates a C code lookup table for doing ADC to temperature conversion
+# on a microcontroller
+# based on: http://hydraraptor.blogspot.com/2007/10/measuring-temperature-easy-way.html
+"""Thermistor Value Lookup Table Generator
+
+Generates lookup to temperature values for use in a microcontroller in C format based on: 
+http://hydraraptor.blogspot.com/2007/10/measuring-temperature-easy-way.html
+
+The main use is for Arduino programs that read data from the circuit board described here:
+http://make.rrrf.org/ts-1.0
+
+Usage: python createTemperatureLookup.py [options]
+
+Options:
+  -h, --help        show this help
+  --rp=...          pull-up resistor
+  --t0=ttt:rrr      low temperature temperature:resistance point (around 25C)
+  --t1=ttt:rrr      middle temperature temperature:resistance point (around 150C)
+  --t2=ttt:rrr      high temperature temperature:resistance point (around 250C)
+  --num-temps=...   the number of temperature points to calculate (default: 20)
+"""
+
+from math import *
+import sys
+import getopt
+
+class Thermistor:
+    "Class to do the thermistor maths"
+    def __init__(self, rp, t1, r1, t2, r2, t3, r3):
+        t1 = t1 + 273.15               # low temperature (25C)
+        r1 = r1                        # resistance at low temperature
+        t2 = t2 + 273.15               # middle temperature (150C)
+        r2 = r2                        # resistance at middle temperature
+        t3 = t3 + 273.15               # high temperature (250C)
+        r3 = r3                        # resistance at high temperature
+        self.rp = rp                   # pull-up resistance
+        self.vadc = 5.0                # ADC reference
+        self.vcc = 5.0                 # supply voltage to potential divider
+        a1 = log(r1)
+        a2 = log(r2)
+        a3 = log(r3)
+        z = a1 - a2
+        y = a1 - a3
+        x = 1/t1 - 1/t2
+        w = 1/t1 - 1/t3
+        v = pow(a1,3) - pow(a2,3)
+        u = pow(a1,3) - pow(a3,3)
+        c3 = (x-z*w/y)/(v-z*u/y)
+        c2 = (x-c3*v)/z
+        c1 = 1/t1-c3*pow(a1,3)-c2*a1
+        self.c1 = c1
+        self.c2 = c2
+        self.c3 = c3
+
+    def temp(self,adc):
+        "Convert ADC reading into a temperature in Celcius"
+        v = adc * self.vadc / (1024 * 16)   # convert the 10 bit ADC value to a voltage
+        r = self.rp * v / (self.vcc - v)    # resistance of thermistor
+        lnr = log(r)
+        Tinv = self.c1 + (self.c2*lnr) + (self.c3*pow(lnr,3))
+        return (1/Tinv) - 273.15        # temperature
+
+    def adc(self,temp):
+        "Convert temperature into a ADC reading"
+        y = (self.c1 - (1/(temp+273.15))) / (2*self.c3)
+	x = sqrt(pow(self.c2 / (3*self.c3),3) + pow(y,2))
+        r = exp(pow(x-y,1.0/3) - pow(x+y,1.0/3)) # resistance of thermistor
+        return (r / (self.rp + r)) * (1024*16)
+
+def main(argv):
+
+    rp = 4700;
+    t1 = 25;
+    r1 = 100000;
+    t2 = 150;
+    r2 = 1641.9;
+    t3 = 250;
+    r3 = 226.15;
+    num_temps = int(36);
+    
+    try:
+        opts, args = getopt.getopt(argv, "h", ["help", "rp=", "t1=", "t2=", "t3=", "num-temps="])
+    except getopt.GetoptError:
+        usage()
+        sys.exit(2)
+        
+    for opt, arg in opts:
+        if opt in ("-h", "--help"):
+            usage()
+            sys.exit()
+        elif opt == "--rp":
+            rp = int(arg)
+        elif opt == "--t1":
+            arg =  arg.split(':')
+            t1 = float( arg[0])
+            r1 = float( arg[1])
+        elif opt == "--t2":
+            arg =  arg.split(':')
+            t2 = float( arg[0])
+            r2 = float( arg[1])
+        elif opt == "--t3":
+            arg =  arg.split(':')
+            t3 = float( arg[0])
+            r3 = float( arg[1])
+        elif opt == "--num-temps":
+            num_temps =  int(arg)
+
+    max_adc = (1024 * 16) - 1
+    min_temp = 0
+    max_temp = 350
+    increment = int(max_adc/(num_temps-1));
+            
+    t = Thermistor(rp, t1, r1, t2, r2, t3, r3)
+    tmp = (min_temp - max_temp) / (num_temps-1)
+    print tmp
+    temps = range(max_temp, min_temp + tmp, tmp);
+
+    print "// Thermistor lookup table for Marlin"
+    print "// ./createTemperatureLookup.py --rp=%s --t1=%s:%s --t2=%s:%s --t3=%s:%s --num-temps=%s" % (rp, t1, r1, t2, r2, t3, r3, num_temps)
+    print "#define NUMTEMPS %s" % (len(temps))
+    print "short temptable[NUMTEMPS][2] = {"
+
+    counter = 0
+    for temp in temps:
+        counter = counter +1
+        if counter == len(temps):
+            print "   {%s, %s}" % (int(t.adc(temp)), temp)
+        else:
+            print "   {%s, %s}," % (int(t.adc(temp)), temp)
+    print "};"
+    
+def usage():
+    print __doc__
+
+if __name__ == "__main__":
+    main(sys.argv[1:])
diff --git a/Marlin/fastio.h b/Marlin/fastio.h
index cb4399a..ed77b50 100644
--- a/Marlin/fastio.h
+++ b/Marlin/fastio.h
@@ -3,8 +3,8 @@
   why double up on these macros? see http://gcc.gnu.org/onlinedocs/cpp/Stringification.html
 */
 
-#ifndef	_ARDUINO_H
-#define	_ARDUINO_H
+#ifndef	_FASTIO_ARDUINO_H
+#define	_FASTIO_ARDUINO_H
 
 #include <avr/io.h>
 
@@ -1928,7 +1928,7 @@ pins
 
 #endif
 
-#if defined (__AVR_AT90USB1287__) || defined (__AVR_AT90USB1286__)
+#if defined (__AVR_AT90USB1287__) || defined (__AVR_AT90USB1286__) || defined (__AVR_AT90USB646__) || defined(__AVR_AT90USB647__)
 // SPI
 #define	SCK					DIO9
 #define	MISO				DIO11
@@ -2579,4 +2579,4 @@ pins
 #error pins for this chip not defined in arduino.h! If you write an appropriate pin definition and have this firmware work on your chip, please submit a pull request
 #endif
 
-#endif /* _ARDUINO_H */
+#endif /* _FASTIO_ARDUINO_H */
diff --git a/Marlin/hardware/tools/avr/etc/avrdude.conf b/Marlin/hardware/tools/avr/etc/avrdude.conf
deleted file mode 100644
index ec921df..0000000
--- a/Marlin/hardware/tools/avr/etc/avrdude.conf
+++ /dev/null
@@ -1,12104 +0,0 @@
-# $Id: avrdude.conf.in,v 1.122 2007/05/16 21:29:36 joerg_wunsch Exp $
-#
-# AVRDUDE Configuration File
-#
-# This file contains configuration data used by AVRDUDE which describes
-# the programming hardware pinouts and also provides part definitions.
-# AVRDUDE's "-C" command line option specifies the location of the
-# configuration file.  The "-c" option names the programmer configuration
-# which must match one of the entry's "id" parameter.  The "-p" option
-# identifies which part AVRDUDE is going to be programming and must match
-# one of the parts' "id" parameter.
-#
-# Possible entry formats are:
-#
-#   programmer
-#       id       = <id1> [, <id2> [, <id3>] ...] ;  # <idN> are quoted strings
-#       desc     = <description> ;                  # quoted string
-#       type     = par | stk500 | stk500v2 | stk500pp | stk500hvsp | stk500generic |
-#                  avr910 | butterfly | usbasp |
-#                  jtagmki | jtagmkii | jtagmkii_isp | jtagmkii_dw |
-#                  dragon_dw | dragon_jtag | dragon_isp | dragon_pp |
-#                  dragon_hvsp; # programmer type
-#       baudrate = <num> ;                          # baudrate for avr910-programmer
-#       vcc      = <num1> [, <num2> ... ] ;         # pin number(s)
-#       reset    = <num> ;                          # pin number
-#       sck      = <num> ;                          # pin number
-#       mosi     = <num> ;                          # pin number
-#       miso     = <num> ;                          # pin number
-#       errled   = <num> ;                          # pin number
-#       rdyled   = <num> ;                          # pin number
-#       pgmled   = <num> ;                          # pin number
-#       vfyled   = <num> ;                          # pin number
-#     ;
-#
-#   part
-#       id               = <id> ;                 # quoted string
-#       desc             = <description> ;        # quoted string
-#       has_jtag         = <yes/no> ;             # part has JTAG i/f
-#       has_debugwire    = <yes/no> ;             # part has debugWire i/f
-#       devicecode       = <num> ;            # deprecated, use stk500_devcode
-#       stk500_devcode   = <num> ;                # numeric
-#       avr910_devcode   = <num> ;                # numeric
-#       signature        = <num> <num> <num> ;    # signature bytes
-#       chip_erase_delay = <num> ;                # micro-seconds
-#       reset            = dedicated | io;
-#       retry_pulse      = reset | sck;
-#       pgm_enable       = <instruction format> ;
-#       chip_erase       = <instruction format> ;
-#       chip_erase_delay = <num> ;                # chip erase delay (us)
-#       # STK500 parameters (parallel programming IO lines)
-#       pagel            = <num> ;                # pin name in hex, i.e., 0xD7
-#       bs2              = <num> ;                # pin name in hex, i.e., 0xA0
-#       serial           = <yes/no> ;             # can use serial downloading
-#       parallel         = <yes/no/pseudo>;       # can use par. programming
-#       # STK500v2 parameters, to be taken from Atmel's XML files
-#       timeout          = <num> ;
-#       stabdelay        = <num> ;
-#       cmdexedelay      = <num> ;
-#       synchloops       = <num> ;
-#       bytedelay        = <num> ;
-#       pollvalue        = <num> ;
-#       pollindex        = <num> ;
-#       predelay         = <num> ;
-#       postdelay        = <num> ;
-#       pollmethod       = <num> ;
-#       mode             = <num> ;
-#       delay            = <num> ;
-#       blocksize        = <num> ;
-#       readsize         = <num> ;
-#       hvspcmdexedelay  = <num> ;
-#       # STK500v2 HV programming parameters, from XML
-#       pp_controlstack  = <num>, <num>, ...;   # PP only
-#       hvsp_controlstack = <num>, <num>, ...;  # HVSP only
-#       hventerstabdelay = <num>;
-#       progmodedelay    = <num>;               # PP only
-#       latchcycles      = <num>;
-#       togglevtg        = <num>;
-#       poweroffdelay    = <num>;
-#       resetdelayms     = <num>;
-#       resetdelayus     = <num>;
-#       hvleavestabdelay = <num>;
-#       resetdelay       = <num>;
-#       synchcycles      = <num>;               # HVSP only
-#       chiperasepulsewidth = <num>;            # PP only
-#       chiperasepolltimeout = <num>;
-#       chiperasetime    = <num>;               # HVSP only
-#       programfusepulsewidth = <num>;          # PP only
-#       programfusepolltimeout = <num>;
-#       programlockpulsewidth = <num>;          # PP only
-#       programlockpolltimeout = <num>;
-#       # JTAG ICE mkII parameters, also from XML files
-#       allowfullpagebitstream = <yes/no> ;
-#       enablepageprogramming = <yes/no> ;
-#       idr              = <num> ;                # IO addr of IDR (OCD) reg.
-#       rampz            = <num> ;                # IO addr of RAMPZ reg.
-#       spmcr            = <num> ;                # mem addr of SPMC[S]R reg.
-#       eecr             = <num> ;                # mem addr of EECR reg.
-#                                                 # (only when != 0x3c)
-#
-#       memory <memtype>
-#           paged           = <yes/no> ;          # yes / no
-#           size            = <num> ;             # bytes
-#           page_size       = <num> ;             # bytes
-#           num_pages       = <num> ;             # numeric
-#           min_write_delay = <num> ;             # micro-seconds
-#           max_write_delay = <num> ;             # micro-seconds
-#           readback_p1     = <num> ;             # byte value
-#           readback_p2     = <num> ;             # byte value
-#           pwroff_after_write = <yes/no> ;       # yes / no
-#           read            = <instruction format> ;
-#           write           = <instruction format> ;
-#           read_lo         = <instruction format> ;
-#           read_hi         = <instruction format> ;
-#           write_lo        = <instruction format> ;
-#           write_hi        = <instruction format> ;
-#           loadpage_lo     = <instruction format> ;
-#           loadpage_hi     = <instruction format> ;
-#           writepage       = <instruction format> ;
-#         ;
-#     ;
-#
-# If any of the above parameters are not specified, the default value
-# of 0 is used for numerics or the empty string ("") for string
-# values.  If a required parameter is left empty, AVRDUDE will
-# complain.
-#
-# NOTES:
-#   * 'devicecode' is the device code used by the STK500 (see codes 
-#       listed below)
-#   * Not all memory types will implement all instructions.
-#   * AVR Fuse bits and Lock bits are implemented as a type of memory.
-#   * Example memory types are:
-#       "flash", "eeprom", "fuse", "lfuse" (low fuse), "hfuse" (high
-#       fuse), "signature", "calibration", "lock"
-#   * The memory type specified on the avrdude command line must match
-#     one of the memory types defined for the specified chip.
-#   * The pwroff_after_write flag causes avrdude to attempt to
-#     power the device off and back on after an unsuccessful write to
-#     the affected memory area if VCC programmer pins are defined.  If
-#     VCC pins are not defined for the programmer, a message
-#     indicating that the device needs a power-cycle is printed out.
-#     This flag was added to work around a problem with the
-#     at90s4433/2333's; see the at90s4433 errata at:
-#
-#         http://www.atmel.com/atmel/acrobat/doc1280.pdf
-#
-# INSTRUCTION FORMATS
-#
-#    Instruction formats are specified as a comma seperated list of
-#    string values containing information (bit specifiers) about each
-#    of the 32 bits of the instruction.  Bit specifiers may be one of
-#    the following formats:
-#
-#       '1'  = the bit is always set on input as well as output
-#
-#       '0'  = the bit is always clear on input as well as output
-#
-#       'x'  = the bit is ignored on input and output
-#
-#       'a'  = the bit is an address bit, the bit-number matches this bit
-#              specifier's position within the current instruction byte
-#
-#       'aN' = the bit is the Nth address bit, bit-number = N, i.e., a12
-#              is address bit 12 on input, a0 is address bit 0.
-#
-#       'i'  = the bit is an input data bit
-#
-#       'o'  = the bit is an output data bit
-#
-#    Each instruction must be composed of 32 bit specifiers.  The
-#    instruction specification closely follows the instruction data
-#    provided in Atmel's data sheets for their parts.
-#
-# See below for some examples.
-#
-#
-# The following are STK500 part device codes to use for the
-# "devicecode" field of the part.  These came from Atmel's software
-# section avr061.zip which accompanies the application note
-# AVR061 available from:
-#
-#      http://www.atmel.com/atmel/acrobat/doc2525.pdf
-#
-
-#define ATTINY10    0x10
-#define ATTINY11    0x11
-#define ATTINY12    0x12
-#define ATTINY15    0x13
-#define ATTINY13    0x14
-
-#define ATTINY22    0x20
-#define ATTINY26    0x21
-#define ATTINY28    0x22
-#define ATTINY2313  0x23
-
-#define AT90S1200   0x33
-
-#define AT90S2313   0x40
-#define AT90S2323   0x41
-#define AT90S2333   0x42
-#define AT90S2343   0x43
-
-#define AT90S4414   0x50
-#define AT90S4433   0x51
-#define AT90S4434   0x52
-#define ATMEGA48    0x59
-
-#define AT90S8515   0x60
-#define AT90S8535   0x61
-#define AT90C8534   0x62
-#define ATMEGA8515  0x63
-#define ATMEGA8535  0x64
-
-#define ATMEGA8     0x70
-#define ATMEGA88    0x73
-#define ATMEGA168   0x86
-
-#define ATMEGA161   0x80
-#define ATMEGA163   0x81
-#define ATMEGA16    0x82
-#define ATMEGA162   0x83
-#define ATMEGA169   0x84
-
-#define ATMEGA323   0x90
-#define ATMEGA32    0x91
-
-#define ATMEGA64    0xA0
-
-#define ATMEGA103   0xB1
-#define ATMEGA128   0xB2
-#define AT90CAN128  0xB3
-
-#define AT86RF401   0xD0
-
-#define AT89START   0xE0
-#define AT89S51	    0xE0
-#define AT89S52	    0xE1
-
-# The following table lists the devices in the original AVR910
-# appnote:
-# |Device |Signature | Code |
-# +-------+----------+------+
-# |tiny12 | 1E 90 05 | 0x55 |
-# |tiny15 | 1E 90 06 | 0x56 |
-# |       |          |      |
-# | S1200 | 1E 90 01 | 0x13 |
-# |       |          |      |
-# | S2313 | 1E 91 01 | 0x20 |
-# | S2323 | 1E 91 02 | 0x48 |
-# | S2333 | 1E 91 05 | 0x34 |
-# | S2343 | 1E 91 03 | 0x4C |
-# |       |          |      |
-# | S4414 | 1E 92 01 | 0x28 |
-# | S4433 | 1E 92 03 | 0x30 |
-# | S4434 | 1E 92 02 | 0x6C |
-# |       |          |      |
-# | S8515 | 1E 93 01 | 0x38 |
-# | S8535 | 1E 93 03 | 0x68 |
-# |       |          |      |
-# |mega32 | 1E 95 01 | 0x72 |
-# |mega83 | 1E 93 05 | 0x65 |
-# |mega103| 1E 97 01 | 0x41 |
-# |mega161| 1E 94 01 | 0x60 |
-# |mega163| 1E 94 02 | 0x64 |
-
-# Appnote AVR109 also has a table of AVR910 device codes, which
-# lists:
-# dev         avr910   signature
-# ATmega8     0x77     0x1E 0x93 0x07
-# ATmega8515  0x3B     0x1E 0x93 0x06
-# ATmega8535  0x6A     0x1E 0x93 0x08
-# ATmega16    0x75     0x1E 0x94 0x03
-# ATmega162   0x63     0x1E 0x94 0x04
-# ATmega163   0x66     0x1E 0x94 0x02
-# ATmega169   0x79     0x1E 0x94 0x05
-# ATmega32    0x7F     0x1E 0x95 0x02
-# ATmega323   0x73     0x1E 0x95 0x01
-# ATmega64    0x46     0x1E 0x96 0x02
-# ATmega128   0x44     0x1E 0x97 0x02
-#
-# These codes refer to "BOOT" device codes which are apparently
-# different than standard device codes, for whatever reasons
-# (often one above the standard code).
-
-# There are several extended versions of AVR910 implementations around
-# in the Internet.  These add the following codes (only devices that
-# actually exist are listed):
-
-# ATmega8515	0x3A
-# ATmega128	0x43
-# ATmega64	0x45
-# ATtiny26	0x5E
-# ATmega8535	0x69
-# ATmega32	0x72
-# ATmega16	0x74
-# ATmega8	0x76
-# ATmega169	0x78
-
-#
-# Overall avrdude defaults
-#
-default_parallel   = "lpt1";
-default_serial     = "com1";
-
-
-#
-# PROGRAMMER DEFINITIONS
-#
-
-programmer
-  id    = "avrisp";
-  desc  = "Atmel AVR ISP";
-  type  = stk500;
-;
-
-programmer
-  id    = "avrispv2";
-  desc  = "Atmel AVR ISP V2";
-  type  =  stk500v2;
-;
-
-programmer
-  id    = "avrispmkII";
-  desc  = "Atmel AVR ISP mkII";
-  type  =  stk500v2;
-;
-
-programmer
-  id    = "avrisp2";
-  desc  = "Atmel AVR ISP mkII";
-  type  =  stk500v2;
-;
-
-# This is supposed to be the "default" STK500 entry.
-# Attempts to select the correct firmware version
-# by probing for it.  Better use one of the entries
-# below instead.
-programmer
-  id    = "stk500";
-  desc  = "Atmel STK500";
-  type  = stk500generic;
-;
-
-programmer
-  id    = "stk500v1";
-  desc  = "Atmel STK500 Version 1.x firmware";
-  type  = stk500;
-;
-
-programmer
-  id    = "stk500v2";
-  desc  = "Atmel STK500 Version 2.x firmware";
-  type  = stk500v2;
-;
-
-programmer
-  id    = "stk500pp";
-  desc  = "Atmel STK500 V2 in parallel programming mode";
-  type  = stk500pp;
-;
-
-programmer
-  id    = "stk500hvsp";
-  desc  = "Atmel STK500 V2 in high-voltage serial programming mode";
-  type  = stk500hvsp;
-;
-
-programmer
-  id    = "avr910";
-  desc  = "Atmel Low Cost Serial Programmer";
-  type  = avr910;
-;
-
-programmer
-  id    = "usbasp";
-  desc  = "USBasp, http://www.fischl.de/usbasp/";
-  type  = usbasp;
-;
-
-programmer
-  id    = "usbtiny";
-  desc  = "USBtiny simple USB programmer";
-  type  = usbtiny;
-;
-
-programmer
-  id    = "butterfly";
-  desc  = "Atmel Butterfly Development Board";
-  type  = butterfly;
-;
-
-programmer
-  id    = "avr109";
-  desc  = "Atmel AppNote AVR109 Boot Loader";
-  type  = butterfly;
-;
-
-programmer
-  id    = "avr911";
-  desc  = "Atmel AppNote AVR911 AVROSP";
-  type  = butterfly;
-;
-
-programmer
-  id    = "jtagmkI";
-  desc  = "Atmel JTAG ICE (mkI)";
-  baudrate = 115200;    # default is 115200
-  type  = jtagmki;
-;
-
-# easier to type
-programmer
-  id    = "jtag1";
-  desc  = "Atmel JTAG ICE (mkI)";
-  baudrate = 115200;    # default is 115200
-  type  = jtagmki;
-;
-
-# easier to type
-programmer
-  id    = "jtag1slow";
-  desc  = "Atmel JTAG ICE (mkI)";
-  baudrate = 19200;
-  type  = jtagmki;
-;
-
-programmer
-  id    = "jtagmkII";
-  desc  = "Atmel JTAG ICE mkII";
-  baudrate = 19200;    # default is 19200
-  type  = jtagmkii;
-;
-
-# easier to type
-programmer
-  id    = "jtag2slow";
-  desc  = "Atmel JTAG ICE mkII";
-  baudrate = 19200;    # default is 19200
-  type  = jtagmkii;
-;
-
-# JTAG ICE mkII @ 115200 Bd
-programmer
-  id    = "jtag2fast";
-  desc  = "Atmel JTAG ICE mkII";
-  baudrate = 115200;
-  type  = jtagmkii;
-;
-
-# make the fast one the default, people will love that
-programmer
-  id    = "jtag2";
-  desc  = "Atmel JTAG ICE mkII";
-  baudrate = 115200;
-  type  = jtagmkii;
-;
-
-# JTAG ICE mkII in ISP mode
-programmer
-  id    = "jtag2isp";
-  desc  = "Atmel JTAG ICE mkII in ISP mode";
-  baudrate = 115200;
-  type  = jtagmkii_isp;
-;
-
-# JTAG ICE mkII in debugWire mode
-programmer
-  id    = "jtag2dw";
-  desc  = "Atmel JTAG ICE mkII in debugWire mode";
-  baudrate = 115200;
-  type  = jtagmkii_dw;
-;
-
-# AVR Dragon in JTAG mode
-programmer
-  id    = "dragon_jtag";
-  desc  = "Atmel AVR Dragon in JTAG mode";
-  baudrate = 115200;
-  type  = dragon_jtag;
-;
-
-# AVR Dragon in ISP mode
-programmer
-  id    = "dragon_isp";
-  desc  = "Atmel AVR Dragon in ISP mode";
-  baudrate = 115200;
-  type  = dragon_isp;
-;
-
-# AVR Dragon in PP mode
-programmer
-  id    = "dragon_pp";
-  desc  = "Atmel AVR Dragon in PP mode";
-  baudrate = 115200;
-  type  = dragon_pp;
-;
-
-# AVR Dragon in HVSP mode
-programmer
-  id    = "dragon_hvsp";
-  desc  = "Atmel AVR Dragon in HVSP mode";
-  baudrate = 115200;
-  type  = dragon_hvsp;
-;
-
-# AVR Dragon in debugWire mode
-programmer
-  id    = "dragon_dw";
-  desc  = "Atmel AVR Dragon in debugWire mode";
-  baudrate = 115200;
-  type  = dragon_dw;
-;
-
-programmer
-  id    = "pavr";
-  desc  = "Jason Kyle's pAVR Serial Programmer";
-  type  = avr910;
-;
-
-# Parallel port programmers.
-
-programmer
-  id    = "bsd";
-  desc  = "Brian Dean's Programmer, http://www.bsdhome.com/avrdude/";
-  type  = par;
-  vcc   = 2, 3, 4, 5;
-  reset = 7;
-  sck   = 8;
-  mosi  = 9;
-  miso  = 10;
-;
-
-programmer
-  id    = "stk200";
-  desc  = "STK200";
-  type  = par;
-  buff  = 4, 5;
-  sck   = 6;
-  mosi  = 7;
-  reset = 9;
-  miso  = 10;
-;
-
-# The programming dongle used by the popular Ponyprog
-# utility.  It is almost similar to the STK200 one,
-# except that there is a LED indicating that the
-# programming is currently in progress.
-
-programmer
-  id    = "pony-stk200";
-  desc  = "Pony Prog STK200";
-  type  = par;
-  buff  = 4, 5;
-  sck   = 6;
-  mosi  = 7;
-  reset = 9;
-  miso  = 10;
-  pgmled = 8; 
-;
-
-programmer
-  id    = "dt006";
-  desc  = "Dontronics DT006";
-  type  = par;
-  reset = 4;
-  sck   = 5;
-  mosi  = 2;
-  miso  = 11;
-;
-
-programmer
-  id    = "bascom";
-  desc  = "Bascom SAMPLE programming cable";
-  type  = par;
-  reset = 4;
-  sck   = 5;
-  mosi  = 2;
-  miso  = 11;
-;
-
-programmer
-  id     = "alf";
-  desc   = "Nightshade ALF-PgmAVR, http://nightshade.homeip.net/";
-  type   = par;
-  vcc    = 2, 3, 4, 5;
-  buff   = 6;
-  reset  = 7;
-  sck    = 8;
-  mosi   = 9;
-  miso   = 10;
-  errled = 1;
-  rdyled = 14;
-  pgmled = 16;
-  vfyled = 17;
-;
-
-programmer
-  id    = "sp12";
-  desc  = "Steve Bolt's Programmer";
-  type  = par;
-  vcc   = 4,5,6,7,8;
-  reset = 3;
-  sck   = 2;
-  mosi  = 9;
-  miso  = 11;
-;
-
-programmer
-  id     = "picoweb";
-  desc   = "Picoweb Programming Cable, http://www.picoweb.net/";
-  type   = par;
-  reset  = 2;
-  sck    = 3;
-  mosi   = 4;
-  miso   = 13;
-;
-
-programmer
-  id    = "abcmini";
-  desc  = "ABCmini Board, aka Dick Smith HOTCHIP";
-  type  = par;
-  reset = 4;
-  sck   = 3;
-  mosi  = 2;
-  miso  = 10;
-;
-
-programmer
-  id    = "futurlec";
-  desc  = "Futurlec.com programming cable.";
-  type  = par;
-  reset = 3;
-  sck   = 2;
-  mosi  = 1;
-  miso  = 10;
-;
-
-
-# From the contributor of the "xil" jtag cable:
-# The "vcc" definition isn't really vcc (the cable gets its power from
-# the programming circuit) but is necessary to switch one of the
-# buffer lines (trying to add it to the "buff" lines doesn't work).
-# With this, TMS connects to RESET, TDI to MOSI, TDO to MISO and TCK
-# to SCK (plus vcc/gnd of course)
-programmer
-  id    = "xil";
-  desc  = "Xilinx JTAG cable";
-  type  = par;
-  mosi  = 2;
-  sck   = 3;
-  reset = 4;
-  buff  = 5;
-  miso  = 13;
-  vcc   = 6;
-;
-
-
-programmer
-  id = "dapa";
-  desc = "Direct AVR Parallel Access cable";
-  type = par;
-  vcc   = 3;
-  reset = 16;
-  sck = 1;
-  mosi = 2;
-  miso = 11;
-;
-
-programmer
-  id    = "atisp";
-  desc  = "AT-ISP V1.1 programming cable for AVR-SDK1 from <http://micro-research.co.th/> micro-research.co.th";
-  type  = par;
-  reset = ~6;
-  sck   = ~8;
-  mosi  = ~7;
-  miso  = ~10;
-;
-
-programmer
-  id    = "ere-isp-avr";
-  desc  = "ERE ISP-AVR <http://www.ere.co.th/download/sch050713.pdf>";
-  type  = par;
-  reset = ~4;
-  sck   = 3;
-  mosi  = 2;
-  miso  = 10;
-;
-
-programmer
-  id    = "blaster";
-  desc  = "Altera ByteBlaster";
-  type  = par;
-  sck   = 2;
-  miso  = 11;
-  reset = 3;
-  mosi  = 8;
-  buff  = 14;
-;
-
-# It is almost same as pony-stk200, except vcc on pin 5 to auto
-# disconnect port (download on http://electropol.free.fr)
-programmer
-  id    = "frank-stk200";
-  desc  = "Frank STK200";
-  type  = par;
-  vcc   = 5;
-  sck   = 6;
-  mosi  = 7;
-  reset = 9;
-  miso  = 10;
-  pgmled = 8;
-;
-
-
-#
-# some ultra cheap programmers use bitbanging on the 
-# serialport.
-#
-# PC - DB9 - Pins for RS232:
-#
-# GND   5   -- |O
-#              |   O| <-   9   RI
-# DTR   4   <- |O   |
-#              |   O| <-   8   CTS
-# TXD   3   <- |O   |
-#              |   O| ->   7   RTS
-# RXD   2   -> |O   |
-#              |   O| <-   6   DSR
-# DCD   1   -> |O
-#
-# Using RXD is currently not supported.
-# Using RI is not supported under Win32 but is supported under Posix.
-
-# serial ponyprog design (dasa2 in uisp)
-# reset=!txd sck=rts mosi=dtr miso=cts
-
-programmer
-  id    = "ponyser";
-  desc  = "design ponyprog serial, reset=!txd sck=rts mosi=dtr miso=cts";
-  type  = serbb;
-  reset = ~3;
-  sck   = 7;
-  mosi  = 4;
-  miso  = 8;
-;
-
-# Same as above, different name
-# reset=!txd sck=rts mosi=dtr miso=cts
-
-programmer
-  id    = "siprog";
-  desc  = "Lancos SI-Prog <http://www.lancos.com/siprogsch.html>";
-  type  = serbb;
-  reset = ~3;
-  sck   = 7;
-  mosi  = 4;
-  miso  = 8;
-;
-
-# unknown (dasa in uisp)
-# reset=rts sck=dtr mosi=txd miso=cts
-
-programmer
-  id    = "dasa";
-  desc  = "serial port banging, reset=rts sck=dtr mosi=txd miso=cts";
-  type  = serbb;
-  reset = 7;
-  sck   = 4;
-  mosi  = 3;
-  miso  = 8;
-;
-
-# unknown (dasa3 in uisp)
-# reset=!dtr sck=rts mosi=txd miso=cts
-
-programmer
-  id    = "dasa3";
-  desc  = "serial port banging, reset=!dtr sck=rts mosi=txd miso=cts";
-  type  = serbb;
-  reset = ~4;
-  sck   = 7;
-  mosi  = 3;
-  miso  = 8;
-;
-
-#
-# PART DEFINITIONS
-#
-
-#------------------------------------------------------------
-# ATtiny11
-#------------------------------------------------------------
-
-# This is an HVSP-only device.
-
-part
-    id                  = "t11";
-    desc                = "ATtiny11";
-    stk500_devcode      = 0x11;
-    signature           = 0x1e 0x90 0x04;
-    chip_erase_delay    = 20000;
-
-    timeout		= 200;
-    hvsp_controlstack     =
-        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x00,
-        0x68, 0x78, 0x68, 0x68, 0x00, 0x00, 0x68, 0x78,
-        0x78, 0x00, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
-        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    hvspcmdexedelay     = 0;
-    synchcycles         = 6;
-    latchcycles         = 1;
-    togglevtg           = 1;
-    poweroffdelay       = 25;
-    resetdelayms        = 0;
-    resetdelayus        = 50;
-    hvleavestabdelay    = 100;
-    resetdelay          = 25;
-    chiperasepolltimeout = 40;
-    chiperasetime       = 0;
-    programfusepolltimeout = 25;
-    programlockpolltimeout = 25;
-
-    memory "eeprom"
-        size            = 64;
-	blocksize	= 64;
-	readsize	= 256;
-	delay		= 5;
-    ;
-
-    memory "flash"
-        size            = 1024;
-	blocksize	= 128;
-	readsize	= 256;
-	delay		= 3;
-    ;
-
-    memory "signature"
-        size            = 3;
-    ;
-
-    memory "lock"
-        size            = 1;
-    ;
-
-    memory "calibration"
-        size            = 1;
-    ;
-
-    memory "fuse"
-        size            = 1;
-    ;
-;
-
-#------------------------------------------------------------
-# ATtiny12
-#------------------------------------------------------------
-
-part
-    id                  = "t12";
-    desc                = "ATtiny12";
-    stk500_devcode      = 0x12;
-    avr910_devcode      = 0x55;
-    signature           = 0x1e 0x90 0x05;
-    chip_erase_delay    = 20000;
-    pgm_enable          = "1 0 1 0  1 1 0 0   0 1 0 1  0 0 1 1",
-                          "x x x x  x x x x   x x x x  x x x x";
-
-    chip_erase          = "1 0 1 0  1 1 0 0   1 0 0 x  x x x x",
-                          "x x x x  x x x x   x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    hvsp_controlstack   =
-        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x00,
-        0x68, 0x78, 0x68, 0x68, 0x00, 0x00, 0x68, 0x78,
-        0x78, 0x00, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
-        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
-    hventerstabdelay    = 100;
-    hvspcmdexedelay     = 0;
-    synchcycles         = 6;
-    latchcycles         = 1;
-    togglevtg           = 1;
-    poweroffdelay       = 25;
-    resetdelayms        = 0;
-    resetdelayus        = 50;
-    hvleavestabdelay    = 100;
-    resetdelay          = 25;
-    chiperasepolltimeout = 40;
-    chiperasetime       = 0;
-    programfusepolltimeout = 25;
-    programlockpolltimeout = 25;
-
-    memory "eeprom"
-        size            = 64;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read            = "1  0  1  0   0  0  0  0    x x x x  x x x x",
-                          "x  x a5 a4  a3 a2 a1 a0    o o o o  o o o o";
-
-        write           = "1  1  0  0   0  0  0  0    x x x x  x x x x",
-                          "x  x a5 a4  a3 a2 a1 a0    i i i i  i i i i";
-
-	mode		= 0x04;
-	delay		= 8;
-	blocksize	= 64;
-	readsize	= 256;
-    ;
-
-    memory "flash"
-        size            = 1024;
-        min_write_delay = 4500;
-        max_write_delay = 20000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0  0  1  0   0  0  0  0",
-                          "  x  x  x  x   x  x  x a8",
-                          " a7 a6 a5 a4  a3 a2 a1 a0",
-                          "  o  o  o  o   o  o  o  o";
-
-        read_hi         = "  0  0  1  0   1  0  0  0",
-                          "  x  x  x  x   x  x  x a8",
-                          " a7 a6 a5 a4  a3 a2 a1 a0",
-                          "  o  o  o  o   o  o  o  o";
-
-        write_lo        = "  0  1  0  0   0  0  0  0",
-                          "  x  x  x  x   x  x  x a8",
-                          " a7 a6 a5 a4  a3 a2 a1 a0",
-                          "  i  i  i  i   i  i  i  i";
-
-        write_hi        = "  0  1  0  0   1  0  0  0",
-                          "  x  x  x  x   x  x  x a8",
-                          " a7 a6 a5 a4  a3 a2 a1 a0",
-                          "  i  i  i  i   i  i  i  i";
-
-	mode		= 0x04;
-	delay		= 5;
-	blocksize	= 128;
-	readsize	= 256;
-    ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0    x x x x  x x x x",
-                          "0  0  0  0   0  0 a1 a0    o o o o  o o o o";
-    ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0  1  0  1   1  0  0  0    x x x x  x x x x",
-                          "x  x  x  x   x  x  x  x    x x x x  x o o x";
-
-        write           = "1  0  1  0   1  1  0  0    1 1 1 1  1 i i 1",
-                          "x  x  x  x   x  x  x  x    x x x x  x x x x";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-    ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0  0  1  1   1  0  0  0    x x x x  x x x x",
-                          "0  0  0  0   0  0  0  0    o o o o  o o o o";
-    ;
-
-    memory "fuse"
-        size            = 1;
-        read            = "0  1  0  1   0  0  0  0    x x x x  x x x x",
-                          "x  x  x  x   x  x  x  x    o o o o  o o o o";
-
-        write           = "1  0  1  0   1  1  0  0    1 0 1 x  x x x x",
-                          "x  x  x  x   x  x  x  x    i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-    ;
-;
-
-#------------------------------------------------------------
-# ATtiny13
-#------------------------------------------------------------
-
-part
-    id                  = "t13";
-    desc                = "ATtiny13";
-     has_debugwire = yes;
-     flash_instr   = 0xB4, 0x0E, 0x1E;
-     eeprom_instr  = 0xBB, 0xFE, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
-	             0xBC, 0x0E, 0xB4, 0x0E, 0xBA, 0x0D, 0xBB, 0xBC,
-	             0x99, 0xE1, 0xBB, 0xAC;
-    stk500_devcode      = 0x14;
-    signature           = 0x1e 0x90 0x07;
-    chip_erase_delay    = 4000;
-    pgm_enable          = "1 0 1 0  1 1 0 0   0 1 0 1  0 0 1 1",
-                          "x x x x  x x x x   x x x x  x x x x";
-
-    chip_erase          = "1 0 1 0  1 1 0 0   1 0 0 x  x x x x",
-                          "x x x x  x x x x   x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    hvsp_controlstack     =
-	0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
-        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
-        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
-        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    hvspcmdexedelay     = 0;
-    synchcycles         = 6;
-    latchcycles         = 1;
-    togglevtg           = 1;
-    poweroffdelay       = 25;
-    resetdelayms        = 0;
-    resetdelayus        = 90;
-    hvleavestabdelay    = 100;
-    resetdelay          = 25;
-    chiperasepolltimeout = 40;
-    chiperasetime       = 0;
-    programfusepolltimeout = 25;
-    programlockpolltimeout = 25;
-
-    memory "eeprom"
-        size            = 64;
-        page_size       = 4;
-        min_write_delay = 4000;
-        max_write_delay = 4000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read            = "1  0  1  0   0  0  0  0    0 0 0 x  x x x x",
-                          "x  x a5 a4  a3 a2 a1 a0    o o o o  o o o o";
-
-        write           = "1  1  0  0   0  0  0  0    0 0 0 x  x x x x",
-                          "x  x a5 a4  a3 a2 a1 a0    i i i i  i i i i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x   x",
-			  "  x   x  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 5;
-	blocksize	= 4;
-	readsize	= 256;
-    ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 1024;
-        page_size       = 32;
-        num_pages       = 32;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0  0  1  0   0  0  0  0",
-                          "  0  0  0  0   0  0  0 a8",
-                          " a7 a6 a5 a4  a3 a2 a1 a0",
-                          "  o  o  o  o   o  o  o  o";
-
-        read_hi         = "  0  0  1  0   1  0  0  0",
-                          "  0  0  0  0   0  0  0 a8",
-                          " a7 a6 a5 a4  a3 a2 a1 a0",
-                          "  o  o  o  o   o  o  o  o";
-
-        loadpage_lo     = "  0  1  0  0   0  0  0  0",
-                          "  0  0  0  x   x  x  x  x",
-                          "  x  x  x  x  a3 a2 a1 a0",
-                          "  i  i  i  i   i  i  i  i";
-
-        loadpage_hi     = "  0  1  0  0   1  0  0  0",
-                          "  0  0  0  x   x  x  x  x",
-                          "  x  x  x  x  a3 a2 a1 a0",
-                          "  i  i  i  i   i  i  i  i";
-
-        writepage       = "  0  1  0  0   1  1  0  0",
-                          "  0  0  0  0   0  0  0 a8",
-                          " a7 a6 a5 a4   x  x  x  x",
-                          "  x  x  x  x   x  x  x  x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 32;
-	readsize	= 256;
-    ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0    0 0 0 x  x x x x",
-                          "x  x  x  x   x  x a1 a0    o o o o  o o o o";
-    ;
-
-    memory "lock"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-
-	read            = "0  1  0  1   1  0  0  0    0 0 0 0  0 0 0 0",
-                          "x  x  x  x   x  x  x  x    x x o o  o o o o";
-
-        write           = "1  0  1  0   1  1  0  0    1 1 1 x  x x x x",
-                          "x  x  x  x   x  x  x  x    1 1 i i  i i i i";
-    ;
-
-    memory "calibration"
-        size            = 2;
-        read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
-                          "0  0  0  0   0  0  0 a0    o o o o  o o o o";
-    ;
-
-    memory "lfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-      ;
-
-;
-
-
-#------------------------------------------------------------
-# ATtiny15
-#------------------------------------------------------------
-
-part
-    id                  = "t15";
-    desc                = "ATtiny15";
-    stk500_devcode      = 0x13;
-    avr910_devcode      = 0x56;
-    signature           = 0x1e 0x90 0x06;
-    chip_erase_delay    = 8200;
-    pgm_enable          = "1 0 1 0  1 1 0 0   0 1 0 1  0 0 1 1",
-                          "x x x x  x x x x   x x x x  x x x x";
-
-    chip_erase          = "1 0 1 0  1 1 0 0   1 0 0 x  x x x x",
-                          "x x x x  x x x x   x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    hvsp_controlstack   =
-        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x00,
-        0x68, 0x78, 0x68, 0x68, 0x00, 0x00, 0x68, 0x78,
-        0x78, 0x00, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
-        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
-    hventerstabdelay    = 100;
-    hvspcmdexedelay     = 5;
-    synchcycles         = 6;
-    latchcycles         = 16;
-    togglevtg           = 1;
-    poweroffdelay       = 25;
-    resetdelayms        = 0;
-    resetdelayus        = 50;
-    hvleavestabdelay    = 100;
-    resetdelay          = 25;
-    chiperasepolltimeout = 40;
-    chiperasetime       = 0;
-    programfusepolltimeout = 25;
-    programlockpolltimeout = 25;
-
-    memory "eeprom"
-        size            = 64;
-        min_write_delay = 8200;
-        max_write_delay = 8200;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read            = "1  0  1  0   0  0  0  0    x x x x  x x x x",
-                          "x  x a5 a4  a3 a2 a1 a0    o o o o  o o o o";
-
-        write           = "1  1  0  0   0  0  0  0    x x x x  x x x x",
-                          "x  x a5 a4  a3 a2 a1 a0    i i i i  i i i i";
-
-	mode		= 0x04;
-	delay		= 10;
-	blocksize	= 64;
-	readsize	= 256;
-    ;
-
-    memory "flash"
-        size            = 1024;
-        min_write_delay = 4100;
-        max_write_delay = 4100;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0  0  1  0   0  0  0  0",
-                          "  x  x  x  x   x  x  x a8",
-                          " a7 a6 a5 a4  a3 a2 a1 a0",
-                          "  o  o  o  o   o  o  o  o";
-
-        read_hi         = "  0  0  1  0   1  0  0  0",
-                          "  x  x  x  x   x  x  x a8",
-                          " a7 a6 a5 a4  a3 a2 a1 a0",
-                          "  o  o  o  o   o  o  o  o";
-
-        write_lo        = "  0  1  0  0   0  0  0  0",
-                          "  x  x  x  x   x  x  x a8",
-                          " a7 a6 a5 a4  a3 a2 a1 a0",
-                          "  i  i  i  i   i  i  i  i";
-
-        write_hi        = "  0  1  0  0   1  0  0  0",
-                          "  x  x  x  x   x  x  x a8",
-                          " a7 a6 a5 a4  a3 a2 a1 a0",
-                          "  i  i  i  i   i  i  i  i";
-
-	mode		= 0x04;
-	delay		= 5;
-	blocksize	= 128;
-	readsize	= 256;
-    ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0    x x x x  x x x x",
-                          "0  0  0  0   0  0 a1 a0    o o o o  o o o o";
-    ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0  1  0  1   1  0  0  0    x x x x  x x x x",
-                          "x  x  x  x   x  x  x  x    x x x x  x o o x";
-
-        write           = "1  0  1  0   1  1  0  0    1 1 1 1  1 i i 1",
-                          "x  x  x  x   x  x  x  x    x x x x  x x x x";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-    ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0  0  1  1   1  0  0  0    x x x x  x x x x",
-                          "0  0  0  0   0  0  0  0    o o o o  o o o o";
-    ;
-
-    memory "fuse"
-        size            = 1;
-        read            = "0  1  0  1   0  0  0  0    x x x x  x x x x",
-                          "x  x  x  x   x  x  x  x    o o o o  x x o o";
-
-        write           = "1  0  1  0   1  1  0  0    1 0 1 x  x x x x",
-                          "x  x  x  x   x  x  x  x    i i i i  1 1 i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-    ;
-;
-
-#------------------------------------------------------------
-# AT90s1200
-#------------------------------------------------------------
-
-part
-    id               = "1200";
-    desc             = "AT90S1200";
-    stk500_devcode   = 0x33;
-    avr910_devcode   = 0x13;
-    signature        = 0x1e 0x90 0x01;
-    pagel            = 0xd7;
-    bs2              = 0xa0;
-    chip_erase_delay = 20000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 1;
-    bytedelay		= 0;
-    pollindex		= 0;
-    pollvalue		= 0xFF;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 0;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 15;
-    chiperasepolltimeout = 0;
-    programfusepulsewidth = 2;
-    programfusepolltimeout = 0;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 1;
-
-    memory "eeprom"
-        size            = 64;
-        min_write_delay = 4000;
-        max_write_delay = 9000;
-        readback_p1     = 0x00;
-        readback_p2     = 0xff;
-        read            = "1 0  1  0   0  0  0  0   x x x x  x x x x", 
-                          "x x a5 a4  a3 a2 a1 a0   o o o o  o o o o";
-
-        write           = "1 1  0  0   0  0  0  0   x x x x  x x x x",
-                          "x x a5 a4  a3 a2 a1 a0   i i i i  i i i i";
-
-	mode		= 0x04;
-	delay		= 20;
-	blocksize	= 32;
-	readsize	= 256;
-      ;
-    memory "flash"
-        size            = 1024;
-        min_write_delay = 4000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0    0   0   0   0",
-                          "  x   x   x   x    x   x   x  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        read_hi         = "  0   0   1   0    1   0   0   0",
-                          "  x   x   x   x    x   x   x  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        write_lo        = "  0   1   0   0    0   0   0   0",
-                          "  x   x   x   x    x   x   x  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-
-        write_hi        = "  0   1   0   0    1   0   0   0",
-                          "  x   x   x   x    x   x   x  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-
-	mode		= 0x02;
-	delay		= 15;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-    memory "fuse"
-        size            = 1;
-      ;
-    memory "lock"
-        size            = 1;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        write           = "1 0 1 0  1 1 0 0   1 1 1 1  1 i i 1",
-                          "x x x x  x x x x   x x x x  x x x x";
-      ;
-  ;
-
-#------------------------------------------------------------
-# AT90s4414
-#------------------------------------------------------------
-
-part
-    id               = "4414";
-    desc             = "AT90S4414";
-    stk500_devcode   = 0x50;
-    avr910_devcode   = 0x28;
-    signature        = 0x1e 0x92 0x01;
-    chip_erase_delay = 20000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 0;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 15;
-    chiperasepolltimeout = 0;
-    programfusepulsewidth = 2;
-    programfusepolltimeout = 0;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 1;
-
-    memory "eeprom"
-        size            = 256;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        readback_p1     = 0x80;
-        readback_p2     = 0x7f;
-        read            = " 1  0  1  0   0  0  0  0  x x x x  x x x a8", 
-                          "a7 a6 a5 a4 a3 a2 a1 a0   o o o o  o o o o";
-
-        write           = " 1  1  0  0   0  0  0  0   x x x x  x x x a8",
-                          "a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
-
-	mode		= 0x04;
-	delay		= 12;
-	blocksize	= 64;
-	readsize	= 256;
-      ;
-    memory "flash"
-        size            = 4096;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        readback_p1     = 0x7f;
-        readback_p2     = 0x7f;
-        read_lo         = "  0   0   1   0    0   0   0   0",
-                          "  x   x   x   x  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        read_hi         = "  0   0   1   0    1   0   0   0",
-                          "  x   x   x   x  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        write_lo        = "  0   1   0   0    0   0   0   0",
-                          "  x   x   x   x  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-
-        write_hi        = "  0   1   0   0    1   0   0   0",
-                          "  x   x   x   x  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-
-	mode		= 0x04;
-	delay		= 12;
-	blocksize	= 64;
-	readsize	= 256;
-      ;
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-    memory "fuse"
-	size		= 1;
-      ;
-    memory "lock"
-	size		= 1;
-	write		= "1  0  1  0   1  1  0  0   1  1  1  1   1  i  i  1",
-			  "x  x  x  x   x  x  x  x   x  x  x  x   x  x  x  x";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-  ;
-
-#------------------------------------------------------------
-# AT90s2313
-#------------------------------------------------------------
-
-part
-    id               = "2313";
-    desc             = "AT90S2313";
-    stk500_devcode   = 0x40;
-    avr910_devcode   = 0x20;
-    signature        = 0x1e 0x91 0x01;
-    chip_erase_delay = 20000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 0;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 15;
-    chiperasepolltimeout = 0;
-    programfusepulsewidth = 2;
-    programfusepolltimeout = 0;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 1;
-
-    memory "eeprom"
-        size            = 128;
-        min_write_delay = 4000;
-        max_write_delay = 9000;
-        readback_p1     = 0x80;
-        readback_p2     = 0x7f;
-        read            = "1  0  1  0   0  0  0  0   x x x x  x x x x", 
-                          "x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
-
-        write           = "1  1  0  0   0  0  0  0   x x x x  x x x x",
-                          "x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
-
-	mode		= 0x04;
-	delay		= 12;
-	blocksize	= 64;
-	readsize	= 256;
-      ;
-    memory "flash"
-        size            = 2048;
-        min_write_delay = 4000;
-        max_write_delay = 9000;
-        readback_p1     = 0x7f;
-        readback_p2     = 0x7f;
-        read_lo         = "  0   0   1   0    0   0   0   0",
-                          "  x   x   x   x    x   x  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        read_hi         = "  0   0   1   0    1   0   0   0",
-                          "  x   x   x   x    x   x  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        write_lo        = "  0   1   0   0    0   0   0   0",
-                          "  x   x   x   x    x   x  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-
-        write_hi        = "  0   1   0   0    1   0   0   0",
-                          "  x   x   x   x    x   x  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-
-	mode		= 0x04;
-	delay		= 12;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-    memory "fuse"
-        size            = 1;
-      ;
-    memory "lock"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 1 1 x  x i i x",
-                          "x x x x  x x x x  x x x x  x x x x";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-  ;
-
-#------------------------------------------------------------
-# AT90s2333
-#------------------------------------------------------------
-
-part
-    id               = "2333";
-##### WARNING: No XML file for device 'AT90S2333'! #####
-    desc             = "AT90S2333";
-    stk500_devcode   = 0x42;
-    avr910_devcode   = 0x34;
-    signature        = 0x1e 0x91 0x05;
-    chip_erase_delay = 20000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    memory "eeprom"
-        size            = 128;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        readback_p1     = 0x00;
-        readback_p2     = 0xff;
-        read            = "1  0  1  0   0  0  0  0   x x x x  x x x x", 
-                          "x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
-
-        write           = "1  1  0  0   0  0  0  0   x x x x  x x x x",
-                          "x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
-      ;
-    memory "flash"
-        size            = 2048;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0    0   0   0   0",
-                          "  x   x   x   x    x   x  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        read_hi         = "  0   0   1   0    1   0   0   0",
-                          "  x   x   x   x    x   x  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        write_lo        = "  0   1   0   0    0   0   0   0",
-                          "  x   x   x   x    x   x  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-
-        write_hi        = "  0   1   0   0    1   0   0   0",
-                          "  x   x   x   x    x   x  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-      ;
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-    memory "fuse"
-        size            = 1;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        pwroff_after_write = yes;
-        read            = "0 1 0 1  0 0 0 0   x x x x  x x x x",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 i  i i i i",
-                          "x x x x  x x x x   x x x x  x x x x";
-      ;
-    memory "lock"
-        size            = 1;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        read            = "0 1 0 1  1 0 0 0   x x x x  x x x x",
-                          "x x x x  x x x x   x x x x  x o o x";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 1  1 i i 1",
-                          "x x x x  x x x x   x x x x  x x x x";
-      ;
-  ;
-
-#------------------------------------------------------------
-# ATmega1284P
-#------------------------------------------------------------
-
-# similar to ATmega164p
-
-part
-    id               = "m1284p";
-    desc             = "ATMEGA1284P";
-    has_jtag         = yes;
-    stk500_devcode   = 0x82; # no STK500v1 support, use the ATmega16 one
-    avr910_devcode   = 0x74;
-    signature        = 0x1e 0x97 0x05;
-    pagel            = 0xd7;
-    bs2              = 0xa0;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 6;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 4096;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0  a2  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x    a11 a10  a9  a8",
-			  " a7  a6  a5  a4     a3   0   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 131072;
-        page_size       = 256;
-        num_pages       = 512;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  1 1 1 1  1 i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "calibration"
-        size            = 1;
-
-        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-        ;
-  ;
-
-#------------------------------------------------------------
-# AT90s2343 (also AT90s2323 and ATtiny22)
-#------------------------------------------------------------
-
-part
-    id               = "2343";
-    desc             = "AT90S2343";
-    stk500_devcode   = 0x43;
-    avr910_devcode   = 0x4c;
-    signature        = 0x1e 0x91 0x03;
-    chip_erase_delay = 18000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    hvsp_controlstack   =
-        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x00,
-        0x68, 0x78, 0x68, 0x68, 0x00, 0x00, 0x68, 0x78,
-        0x78, 0x00, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
-        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
-    hventerstabdelay    = 100;
-    hvspcmdexedelay     = 0;
-    synchcycles         = 6;
-    latchcycles         = 1;
-    togglevtg           = 0;
-    poweroffdelay       = 25;
-    resetdelayms        = 0;
-    resetdelayus        = 50;
-    hvleavestabdelay    = 100;
-    resetdelay          = 25;
-    chiperasepolltimeout = 40;
-    chiperasetime       = 0;
-    programfusepolltimeout = 25;
-    programlockpolltimeout = 25;
-
-    memory "eeprom"
-        size            = 128;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        readback_p1     = 0x00;
-        readback_p2     = 0xff;
-        read            = "1  0  1  0   0  0  0  0   0 0 0 0  0 0 0 0", 
-                          "x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
-
-        write           = "1  1  0  0   0  0  0  0   0 0 0 0  0 0 0 0",
-                          "x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
-
-	mode		= 0x04;
-	delay		= 12;
-	blocksize	= 64;
-	readsize	= 256;
-      ;
-    memory "flash"
-        size            = 2048;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0    0   0   0   0",
-                          "  x   x   x   x    x   x  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        read_hi         = "  0   0   1   0    1   0   0   0",
-                          "  x   x   x   x    x   x  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        write_lo        = "  0   1   0   0    0   0   0   0",
-                          "  x   x   x   x    x   x  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-
-        write_hi        = "  0   1   0   0    1   0   0   0",
-                          "  x   x   x   x    x   x  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-
-	mode		= 0x04;
-	delay		= 12;
-	blocksize	= 128;
-	readsize	= 128;
-      ;
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-    memory "fuse"
-        size            = 1;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        read            = "0 1 0 1  1 0 0 0   x x x x  x x x x",
-                          "x x x x  x x x x   o o o x  x x x o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 1  1 1 1 i",
-                          "x x x x  x x x x   x x x x  x x x x";
-      ;
-    memory "lock"
-        size            = 1;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        read            = "0 1 0 1  1 0 0 0   x x x x  x x x x",
-                          "x x x x  x x x x   o o o x  x x x o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 1  1 i i 1",
-                          "x x x x  x x x x   x x x x  x x x x";
-      ;
-  ;
-
-
-#------------------------------------------------------------
-# AT90s4433
-#------------------------------------------------------------
-
-part
-    id               = "4433";
-    desc             = "AT90S4433";
-    stk500_devcode   = 0x51;
-    avr910_devcode   = 0x30;
-    signature        = 0x1e 0x92 0x03;
-    chip_erase_delay = 20000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 0;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 15;
-    chiperasepolltimeout = 0;
-    programfusepulsewidth = 2;
-    programfusepolltimeout = 0;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 1;
-
-    memory "eeprom"
-        size            = 256;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        readback_p1     = 0x00;
-        readback_p2     = 0xff;
-        read            = " 1  0  1  0   0  0  0  0   x x x x  x x x x", 
-                          "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
-
-        write           = " 1  1  0  0   0  0  0  0   x x x x  x x x x",
-                          "a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
-
-	mode		= 0x04;
-	delay		= 12;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-    memory "flash"
-        size            = 4096;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0    0   0   0   0",
-                          "  x   x   x   x    x a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        read_hi         = "  0   0   1   0    1   0   0   0",
-                          "  x   x   x   x    x a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        write_lo        = "  0   1   0   0    0   0   0   0",
-                          "  x   x   x   x    x a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-
-        write_hi        = "  0   1   0   0    1   0   0   0",
-                          "  x   x   x   x    x a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-
-	mode		= 0x04;
-	delay		= 12;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-    memory "fuse"
-        size            = 1;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        pwroff_after_write = yes;
-        read            = "0 1 0 1  0 0 0 0   x x x x  x x x x",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 i  i i i i",
-                          "x x x x  x x x x   x x x x  x x x x";
-      ;
-    memory "lock"
-        size            = 1;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        read            = "0 1 0 1  1 0 0 0   x x x x  x x x x",
-                          "x x x x  x x x x   x x x x  x o o x";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 1  1 i i 1",
-                          "x x x x  x x x x   x x x x  x x x x";
-      ;
-  ;
-
-#------------------------------------------------------------
-# AT90s4434
-#------------------------------------------------------------
-
-part
-    id               = "4434";
-##### WARNING: No XML file for device 'AT90S4434'! #####
-    desc             = "AT90S4434";
-    stk500_devcode   = 0x52;
-    avr910_devcode   = 0x6c;
-    signature        = 0x1e 0x92 0x02;
-    chip_erase_delay = 20000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    memory "eeprom"
-        size            = 256;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        readback_p1     = 0x00;
-        readback_p2     = 0xff;
-        read            = " 1  0  1  0   0  0  0  0   x x x x  x x x x", 
-                          "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
-
-        write           = " 1  1  0  0   0  0  0  0   x x x x  x x x x",
-                          "a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
-      ;
-    memory "flash"
-        size            = 4096;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0    0   0   0   0",
-                          "  x   x   x   x    x a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        read_hi         = "  0   0   1   0    1   0   0   0",
-                          "  x   x   x   x    x a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        write_lo        = "  0   1   0   0    0   0   0   0",
-                          "  x   x   x   x    x a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-
-        write_hi        = "  0   1   0   0    1   0   0   0",
-                          "  x   x   x   x    x a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-      ;
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-    memory "fuse"
-        size            = 1;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        read            = "0 1 0 1  0 0 0 0   x x x x  x x x x",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 i  i i i i",
-                          "x x x x  x x x x   x x x x  x x x x";
-      ;
-    memory "lock"
-        size            = 1;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        read            = "0 1 0 1  1 0 0 0   x x x x  x x x x",
-                          "x x x x  x x x x   x x x x  x o o x";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 1  1 i i 1",
-                          "x x x x  x x x x   x x x x  x x x x";
-      ;
-  ;
-
-#------------------------------------------------------------
-# AT90s8515
-#------------------------------------------------------------
-
-part
-    id               = "8515";
-    desc             = "AT90S8515";
-    stk500_devcode   = 0x60;
-    avr910_devcode   = 0x38;
-    signature        = 0x1e 0x93 0x01;
-    chip_erase_delay = 20000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-	0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-	0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-	0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-	0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 0;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    resetdelay          = 15;
-    chiperasepulsewidth = 15;
-    chiperasepolltimeout = 0;
-    programfusepulsewidth = 2;
-    programfusepolltimeout = 0;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 1;
-
-    memory "eeprom"
-        size            = 512;
-        min_write_delay = 4000;
-        max_write_delay = 9000;
-        readback_p1     = 0x80;
-        readback_p2     = 0x7f;
-        read            = " 1  0  1  0   0  0  0  0  x x x x  x x x a8", 
-                          "a7 a6 a5 a4 a3 a2 a1 a0   o o o o  o o o o";
-
-        write           = " 1  1  0  0   0  0  0  0   x x x x  x x x a8",
-                          "a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
-
-	mode		= 0x04;
-	delay		= 12;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-    memory "flash"
-        size            = 8192;
-        min_write_delay = 4000;
-        max_write_delay = 9000;
-        readback_p1     = 0x7f;
-        readback_p2     = 0x7f;
-        read_lo         = "  0   0   1   0    0   0   0   0",
-                          "  x   x   x   x  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        read_hi         = "  0   0   1   0    1   0   0   0",
-                          "  x   x   x   x  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        write_lo        = "  0   1   0   0    0   0   0   0",
-                          "  x   x   x   x  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-
-        write_hi        = "  0   1   0   0    1   0   0   0",
-                          "  x   x   x   x  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-
-	mode		= 0x04;
-	delay		= 12;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-    memory "fuse"
-	size		= 1;
-      ;
-    memory "lock"
-	size		= 1;
-	write		= "1  0  1  0   1  1  0  0   1  1  1  1   1  i  i  1",
-			  "x  x  x  x   x  x  x  x   x  x  x  x   x  x  x  x";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-  ;
-
-#------------------------------------------------------------
-# AT90s8535
-#------------------------------------------------------------
-
-part
-    id               = "8535";
-    desc             = "AT90S8535";
-    stk500_devcode   = 0x61;
-    avr910_devcode   = 0x68;
-    signature        = 0x1e 0x93 0x03;
-    chip_erase_delay = 20000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 0;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 15;
-    chiperasepolltimeout = 0;
-    programfusepulsewidth = 2;
-    programfusepolltimeout = 0;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 1;
-
-    memory "eeprom"
-        size            = 512;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        readback_p1     = 0x00;
-        readback_p2     = 0xff;
-        read            = " 1  0  1  0   0  0  0  0   x x x x  x x x a8", 
-                          "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
-
-        write           = " 1  1  0  0   0  0  0  0   x x x x  x x x a8",
-                          "a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
-
-	mode		= 0x04;
-	delay		= 12;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-    memory "flash"
-        size            = 8192;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0    0   0   0   0",
-                          "  x   x   x   x  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        read_hi         = "  0   0   1   0    1   0   0   0",
-                          "  x   x   x   x  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        write_lo        = "  0   1   0   0    0   0   0   0",
-                          "  x   x   x   x  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-
-        write_hi        = "  0   1   0   0    1   0   0   0",
-                          "  x   x   x   x  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-
-	mode		= 0x04;
-	delay		= 12;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-    memory "fuse"
-	size		= 1;
-	read		= "0  1  0  1   1  0  0  0   x  x  x  x   x  x  x  x",
-			  "x  x  x  x   x  x  x  x   x  x  x  x   x  x  x  o";
-	write		= "1  0  1  0   1  1  0  0   1  0  1  1   1  1  1  i",
-			  "x  x  x  x   x  x  x  x   x  x  x  x   x  x  x  x";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-    memory "lock"
-	size		= 1;
-	read		= "0  1  0  1   1  0  0  0   x  x  x  x   x  x  x  x",
-			  "x  x  x  x   x  x  x  x   o  o  x  x   x  x  x  x";
-	write		= "1  0  1  0   1  1  0  0   1  1  1  1   1  i  i  1",
-			  "x  x  x  x   x  x  x  x   x  x  x  x   x  x  x  x";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-  ;
-
-#------------------------------------------------------------
-# ATmega103
-#------------------------------------------------------------
-
-part
-    id               = "m103";
-    desc             = "ATMEGA103";
-    stk500_devcode   = 0xB1;
-    avr910_devcode   = 0x41;
-    signature        = 0x1e 0x97 0x01;
-    chip_erase_delay = 112000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x8E, 0x9E, 0x2E, 0x3E, 0xAE, 0xBE,
-        0x4E, 0x5E, 0xCE, 0xDE, 0x6E, 0x7E, 0xEE, 0xDE,
-        0x66, 0x76, 0xE6, 0xF6, 0x6A, 0x7A, 0xEA, 0x7A,
-        0x7F, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 0;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 15;
-    chiperasepolltimeout = 0;
-    programfusepulsewidth = 2;
-    programfusepolltimeout = 0;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 10;
-
-    memory "eeprom"
-        size            = 4096;
-        min_write_delay = 4000;
-        max_write_delay = 9000;
-        readback_p1     = 0x80;
-        readback_p2     = 0x7f;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	mode		= 0x04;
-	delay		= 12;
-	blocksize	= 64;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 131072;
-        page_size       = 256;
-        num_pages       = 512;
-        min_write_delay = 22000;
-        max_write_delay = 56000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x11;
-	delay		= 70;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "fuse"
-        size            = 1;
-        read            = "0 1 0 1  0 0 0 0  x x x x  x x x x",
-                          "x x x x  x x x x  x x o x  o 1 o o";
-
-        write           = "1 0 1 0  1 1 0 0  1 0 1 1  i 1 i i",
-                          "x x x x  x x x x  x x x x  x x x x";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   x x x x  x x x x",
-                          "x x x x  x x x x   x x x x  x o o x";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 1  1 i i 1",
-                          "x x x x  x x x x   x x x x  x x x x";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-
-#------------------------------------------------------------
-# ATmega64
-#------------------------------------------------------------
-
-part
-    id               = "m64";
-    desc             = "ATMEGA64";
-    has_jtag         = yes;
-    stk500_devcode   = 0xA0;
-    avr910_devcode   = 0x45;
-    signature        = 0x1e 0x96 0x02;
-    chip_erase_delay = 9000;
-    pagel            = 0xD7;
-    bs2              = 0xA0;
-    reset            = dedicated;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 6;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x22;
-    spmcr               = 0x68;
-    allowfullpagebitstream = yes;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 2048;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	mode		= 0x04;
-	delay		= 20;
-	blocksize	= 64;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 65536;
-        page_size       = 256;
-        num_pages       = 256;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "  x a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "  x a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  x a14 a13 a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x21;
-	delay		= 6;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  x x x x  x x i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "calibration"
-        size            = 4;
-        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
-                          "0 0 0 0  0 0 a1 a0  o o o o  o o o o";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-
-
-
-#------------------------------------------------------------
-# ATmega128
-#------------------------------------------------------------
-
-part
-    id               = "m128";
-    desc             = "ATMEGA128";
-    has_jtag         = yes;
-    stk500_devcode   = 0xB2;
-    avr910_devcode   = 0x43;
-    signature        = 0x1e 0x97 0x02;
-    chip_erase_delay = 9000;
-    pagel            = 0xD7;
-    bs2              = 0xA0;
-    reset            = dedicated;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 6;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x22;
-    spmcr               = 0x68;
-    rampz               = 0x3b;
-    allowfullpagebitstream = yes;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 4096;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	mode		= 0x04;
-	delay		= 12;
-	blocksize	= 64;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 131072;
-        page_size       = 256;
-        num_pages       = 512;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x21;
-	delay		= 6;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  x x x x  x x i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "calibration"
-        size            = 4;
-        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
-                          "0 0 0 0  0 0 a1 a0  o o o o  o o o o";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# AT90CAN128
-#------------------------------------------------------------
-
-part
-    id               = "c128";
-    desc             = "AT90CAN128";
-    has_jtag         = yes;
-    stk500_devcode   = 0xB3;
-#    avr910_devcode   = 0x43;
-    signature        = 0x1e 0x97 0x81;
-    chip_erase_delay = 9000;
-    pagel            = 0xD7;
-    bs2              = 0xA0;
-    reset            = dedicated;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 6;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    rampz               = 0x3b;
-    eecr                = 0x3f;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 4096;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   0   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   0   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0  a2  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x    a11 a10  a9  a8",
-			  " a7  a6  a5  a4     a3   0   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-
-	mode		= 0x41;
-	delay		= 20;
-	blocksize	= 8;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 131072;
-        page_size       = 256;
-        num_pages       = 512;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   0   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   0   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  x x x x  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1  1 0 0 0  0 0 0 x  x x x x",
-                          "0 0 0 0  0 0 0 0  o o o o  o o o o";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-
-#------------------------------------------------------------
-# ATmega16
-#------------------------------------------------------------
-
-part
-    id               = "m16";
-    desc             = "ATMEGA16";
-    has_jtag         = yes;
-    stk500_devcode   = 0x82;
-    avr910_devcode   = 0x74;
-    signature        = 0x1e 0x94 0x03;
-    pagel            = 0xd7;
-    bs2              = 0xa0;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-	0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-	0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-	0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-	0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 100;
-    latchcycles         = 6;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    resetdelay          = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    allowfullpagebitstream = yes;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 4;  /* for parallel programming */
-        size            = 512;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   x   x      x   x  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   x   x      x   x  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x  a9  a8",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x04;
-	delay		= 10;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 16384;
-        page_size       = 128;
-        num_pages       = 128;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "  0   0 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "  0   0 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  0   0 a13 a12    a11 a10  a9  a8",
-                          " a7  a6   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x21;
-	delay		= 6;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-    memory "calibration"
-        size            = 4;
-
-        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
-                          "0 0 0 0  0 0 a1 a0 o o o o  o o o o";
-        ;
-  ;
-
-
-#------------------------------------------------------------
-# ATmega164P
-#------------------------------------------------------------
-
-# close to ATmega16
-
-part
-    id               = "m164p";
-    desc             = "ATMEGA164P";
-    has_jtag         = yes;
-#   stk500_devcode   = 0x82; # no STK500v1 support
-#   avr910_devcode   = 0x?;  # try the ATmega16 one:^
-    avr910_devcode   = 0x74;
-    signature        = 0x1e 0x94 0x0a;
-    pagel            = 0xd7;
-    bs2              = 0xa0;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 4;  /* for parallel programming */
-        size            = 512;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   x   x      x   x  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   x   x      x   x  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x  a9  a8",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 16384;
-        page_size       = 128;
-        num_pages       = 128;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "  0   0 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "  0   0 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  0   0 a13 a12    a11 a10  a9  a8",
-                          " a7  a6   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x21;
-	delay		= 6;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  1 1 1 1  1 i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "calibration"
-        size            = 1;
-
-        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-        ;
-  ;
-
-
-#------------------------------------------------------------
-# ATmega324P
-#------------------------------------------------------------
-
-# similar to ATmega164P
-
-part
-    id               = "m324p";
-    desc             = "ATMEGA324P";
-    has_jtag         = yes;
-#   stk500_devcode   = 0x82; # no STK500v1 support
-#   avr910_devcode   = 0x?;  # try the ATmega16 one:^
-    avr910_devcode   = 0x74;
-    signature        = 0x1e 0x95 0x08;
-    pagel            = 0xd7;
-    bs2              = 0xa0;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 4;  /* for parallel programming */
-        size            = 1024;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   x   x      x a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   x   x      x a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x a10  a9  a8",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 32768;
-        page_size       = 128;
-        num_pages       = 256;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x21;
-	delay		= 6;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  1 1 1 1  1 i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "calibration"
-        size            = 1;
-
-        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-        ;
-  ;
-
-
-#------------------------------------------------------------
-# ATmega644
-#------------------------------------------------------------
-
-# similar to ATmega164
-
-part
-    id               = "m644";
-    desc             = "ATMEGA644";
-    has_jtag         = yes;
-#   stk500_devcode   = 0x82; # no STK500v1 support
-#   avr910_devcode   = 0x?;  # try the ATmega16 one:^
-    avr910_devcode   = 0x74;
-    signature        = 0x1e 0x96 0x09;
-    pagel            = 0xd7;
-    bs2              = 0xa0;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 6;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 2048;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0  a2  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x    a11 a10  a9  a8",
-			  " a7  a6  a5  a4     a3   0   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 65536;
-        page_size       = 256;
-        num_pages       = 256;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x21;
-	delay		= 6;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  1 1 1 1  1 i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "calibration"
-        size            = 1;
-
-        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-        ;
-  ;
-
-#------------------------------------------------------------
-# ATmega644P
-#------------------------------------------------------------
-
-# similar to ATmega164p
-
-part
-    id               = "m644p";
-    desc             = "ATMEGA644P";
-    has_jtag         = yes;
-#   stk500_devcode   = 0x82; # no STK500v1 support
-#   avr910_devcode   = 0x?;  # try the ATmega16 one:^
-    avr910_devcode   = 0x74;
-    signature        = 0x1e 0x96 0x0a;
-    pagel            = 0xd7;
-    bs2              = 0xa0;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 6;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 2048;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0  a2  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x    a11 a10  a9  a8",
-			  " a7  a6  a5  a4     a3   0   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 65536;
-        page_size       = 256;
-        num_pages       = 256;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x21;
-	delay		= 6;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  1 1 1 1  1 i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "calibration"
-        size            = 1;
-
-        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-        ;
-  ;
-
-
-
-#------------------------------------------------------------
-# ATmega162
-#------------------------------------------------------------
-
-part
-    id               = "m162";
-    desc             = "ATMEGA162";
-    has_jtag         = yes;
-    stk500_devcode   = 0x83;
-    avr910_devcode   = 0x63;
-    signature        = 0x1e 0x94 0x04;
-    chip_erase_delay = 9000;
-    pagel            = 0xd7;
-    bs2              = 0xa0;
-
-    idr              = 0x04;
-    spmcr            = 0x57;
-    allowfullpagebitstream = yes;
-
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    memory "flash"
-        paged           = yes;
-        size            = 16384;
-        page_size       = 128;
-        num_pages       = 128;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "  0   0 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "  0   0 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  0   0 a13 a12    a11 a10  a9  a8",
-                          " a7  a6   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-       mode        = 0x41;
-    delay       = 10;
-    blocksize   = 128;
-    readsize    = 256;  
-
-        ;
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 6;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 4;  /* for parallel programming */
-        size            = 512;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-
-                read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   x   x      x   x  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-                write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   x   x      x   x  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x  a9  a8",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 20;
-	blocksize	= 4;
-	readsize	= 256;
-        ;
-
-    memory "lfuse"
-        size            = 1;
-        min_write_delay = 16000;
-        max_write_delay = 16000;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-        ;
-
-    memory "hfuse"
-        size            = 1;
-        min_write_delay = 16000;
-        max_write_delay = 16000;
-
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-        ;
-
-    memory "efuse"
-        size            = 1;
-        min_write_delay = 16000;
-        max_write_delay = 16000;
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  1 1 1 1  1 i i i";
-      ;
-
-    memory "lock"
-        size            = 1;
-        min_write_delay = 16000;
-        max_write_delay = 16000;
-
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        ;
-
-    memory "signature"
-        size            = 3;
-
-        read            = "0  0  1  1   0  0  0  0   0  0  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-        ;
-
-    memory "calibration"
-        size            = 1;
-
-        read            = "0 0 1 1  1 0 0 0   0 0 x x  x x x x",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-        ;
-;
-
-
-
-#------------------------------------------------------------
-# ATmega163
-#------------------------------------------------------------
-
-part
-    id               = "m163";
-    desc             = "ATMEGA163";
-    stk500_devcode   = 0x81;
-    avr910_devcode   = 0x64;
-    signature        = 0x1e 0x94 0x02;
-    chip_erase_delay = 32000;
-    pagel            = 0xd7;
-    bs2              = 0xa0;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 0;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 30;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 2;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 2;
-
-
-   memory "eeprom"
-        size            = 512;
-        min_write_delay = 4000;
-        max_write_delay = 4000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 16384;
-        page_size       = 128;
-        num_pages       = 128;
-        min_write_delay = 16000;
-        max_write_delay = 16000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "  x   x   x a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "  x   x   x a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  x   x   x a12    a11 a10  a9  a8",
-                          " a7  a6   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        min_write_delay = 2000;
-        max_write_delay = 2000;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o x x  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i 1 1  i i i i";
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        min_write_delay = 2000;
-        max_write_delay = 2000;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   x x x x  1 o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   1 1 1 1  1 i i i";
-      ;
-
-    memory "lock"
-        size            = 1;
-        min_write_delay = 2000;
-        max_write_delay = 2000;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  0 x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1  1 0 0 0   x x x x  x x x x",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# ATmega169
-#------------------------------------------------------------
-
-part
-    id               = "m169";
-    desc             = "ATMEGA169";
-    has_jtag         = yes;
-    stk500_devcode   = 0x85;
-    avr910_devcode   = 0x78;
-    signature        = 0x1e 0x94 0x05;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-
-   memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 4;  /* for parallel programming */
-        size            = 512;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x  a8",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 20;
-	blocksize	= 4;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 16384;
-        page_size       = 128;
-        num_pages       = 128;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "  x   x   x a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "  x   x   x a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  x   x   x a12    a11 a10  a9  a8",
-                          " a7  a6   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        min_write_delay = 2000;
-        max_write_delay = 2000;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        min_write_delay = 2000;
-        max_write_delay = 2000;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "efuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  x x x x  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-      ;
-
-    memory "lock"
-        size            = 1;
-        min_write_delay = 2000;
-        max_write_delay = 2000;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# ATmega329
-#------------------------------------------------------------
-
-part
-    id               = "m329";
-    desc             = "ATMEGA329";
-    has_jtag         = yes;
-#    stk500_devcode   = 0x85; # no STK500 support, only STK500v2
-#    avr910_devcode   = 0x?;  # try the ATmega169 one:
-    avr910_devcode   = 0x75;
-    signature        = 0x1e 0x95 0x03;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-
-   memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 4;  /* for parallel programming */
-        size            = 1024;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x      x   x  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x  a9  a8",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 20;
-	blocksize	= 8;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 32768;
-        page_size       = 128;
-        num_pages       = 256;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "  x a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "  x a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  x   x   x a12    a11 a10  a9  a8",
-                          " a7  a6   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "efuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x   x x x x  x i i i";
-      ;
-
-    memory "lock"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# ATmega3290
-#------------------------------------------------------------
-
-# identical to ATmega329
-
-part
-    id               = "m3290";
-    desc             = "ATMEGA3290";
-    has_jtag         = yes;
-#    stk500_devcode   = 0x85; # no STK500 support, only STK500v2
-#    avr910_devcode   = 0x?;  # try the ATmega169 one:
-    avr910_devcode   = 0x75;
-    signature        = 0x1e 0x95 0x04;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-
-   memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 4;  /* for parallel programming */
-        size            = 1024;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x      x   x  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x  a9  a8",
-			  " a7  a6  a5  a4     a3  a3   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 20;
-	blocksize	= 8;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 32768;
-        page_size       = 128;
-        num_pages       = 256;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "  x a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "  x a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  x   x   x a12    a11 a10  a9  a8",
-                          " a7  a6   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "efuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x   x x x x  x i i i";
-      ;
-
-    memory "lock"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# ATmega649
-#------------------------------------------------------------
-
-part
-    id               = "m649";
-    desc             = "ATMEGA649";
-    has_jtag         = yes;
-#    stk500_devcode   = 0x85; # no STK500 support, only STK500v2
-#    avr910_devcode   = 0x?;  # try the ATmega169 one:
-    avr910_devcode   = 0x75;
-    signature        = 0x1e 0x96 0x03;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-
-   memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 2048;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x      x a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0  a2  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x a10  a9  a8",
-			  " a7  a6  a5  a4     a3   0   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 20;
-	blocksize	= 8;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 65536;
-        page_size       = 256;
-        num_pages       = 256;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  x   x   x a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "efuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x   x x x x  x i i i";
-      ;
-
-    memory "lock"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# ATmega6490
-#------------------------------------------------------------
-
-# identical to ATmega649
-
-part
-    id               = "m6490";
-    desc             = "ATMEGA6490";
-    has_jtag         = yes;
-#    stk500_devcode   = 0x85; # no STK500 support, only STK500v2
-#    avr910_devcode   = 0x?;  # try the ATmega169 one:
-    avr910_devcode   = 0x75;
-    signature        = 0x1e 0x96 0x04;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-
-   memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 2048;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x      x a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0  a2  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x  a8",
-			  " a7  a6  a5  a4     a3   0   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0  a2  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x a10  a9  a8",
-			  " a7  a6  a5  a4     a3   0   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 20;
-	blocksize	= 8;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 65536;
-        page_size       = 256;
-        num_pages       = 256;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  x   x   x a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "efuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x   x x x x  x i i i";
-      ;
-
-    memory "lock"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# ATmega32
-#------------------------------------------------------------
-
-part
-    id               = "m32";
-    desc             = "ATMEGA32";
-    has_jtag         = yes;
-    stk500_devcode   = 0x91;
-    avr910_devcode   = 0x72;
-    signature        = 0x1e 0x95 0x02;
-    chip_erase_delay = 9000;
-    pagel            = 0xd7;
-    bs2              = 0xa0;
-    reset            = dedicated;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 6;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    allowfullpagebitstream = yes;
-
-   memory "eeprom"
-        paged           = no;   /* leave this "no" */
-        page_size       = 4;    /* for parallel programming */
-        size            = 1024;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   x   x      x   x  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   x   x      x   x  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x  a9  a8",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x04;
-	delay		= 10;
-	blocksize	= 64;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 32768;
-        page_size       = 128;
-        num_pages       = 256;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "  0   0 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "  0   0 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  0   0 a13 a12    a11 a10  a9  a8",
-                          " a7  a6   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x21;
-	delay		= 6;
-	blocksize	= 64;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        min_write_delay = 2000;
-        max_write_delay = 2000;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        min_write_delay = 2000;
-        max_write_delay = 2000;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "lock"
-        size            = 1;
-        min_write_delay = 2000;
-        max_write_delay = 2000;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o o";
-      ;
-
-    memory "calibration"
-        size            = 4;
-        read            = "0 0 1 1  1 0 0 0    0 0 x x  x x x x",
-                          "0 0 0 0  0 0 a1 a0  o o o o  o o o o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# ATmega161
-#------------------------------------------------------------
-
-part
-    id               = "m161";
-    desc             = "ATMEGA161";
-    stk500_devcode   = 0x80;
-    avr910_devcode   = 0x60;
-    signature        = 0x1e 0x94 0x01;
-    chip_erase_delay = 28000;
-    pagel            = 0xd7;
-    bs2              = 0xa0;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 0;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 30;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 2;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 2;
-
-   memory "eeprom"
-        size            = 512;
-        min_write_delay = 3400;
-        max_write_delay = 3400;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-	mode		= 0x04;
-	delay		= 5;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 16384;
-        page_size       = 128;
-        num_pages       = 128;
-        min_write_delay = 14000;
-        max_write_delay = 14000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "  x   x   x a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "  x   x   x a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  x   x   x a12    a11 a10  a9  a8",
-                          " a7  a6   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x21;
-	delay		= 16;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-
-    memory "fuse"
-        size            = 1;
-        min_write_delay = 2000;
-        max_write_delay = 2000;
-        read            = "0 1 0 1  0 0 0 0   x x x x  x x x x",
-                          "x x x x  x x x x   x o x o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 x  x x x x",
-                          "x x x x  x x x x   1 i 1 i  i i i i";
-      ;
-
-    memory "lock"
-        size            = 1;
-        min_write_delay = 2000;
-        max_write_delay = 2000;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-      ;
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-
-#------------------------------------------------------------
-# ATmega8
-#------------------------------------------------------------
-
-part
-    id               = "m8";
-    desc             = "ATMEGA8";
-    stk500_devcode   = 0x70;
-    avr910_devcode   = 0x76;
-    signature        = 0x1e 0x93 0x07;
-    pagel            = 0xd7;
-    bs2              = 0xc2;
-    chip_erase_delay = 10000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-	0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-	0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-	0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-	0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 2;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    resetdelay          = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    memory "eeprom"
-        size            = 512;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   x   x      x   x   x  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   x   x      x   x   x  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	mode		= 0x04;
-	delay		= 20;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-    memory "flash"
-        paged           = yes;
-        size            = 8192;
-        page_size       = 64;
-        num_pages       = 128;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0x00;
-        read_lo         = "  0   0   1   0    0   0   0   0",
-                          "  0   0   0   0  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        read_hi         = "  0   0   1   0    1   0   0   0",
-                          "  0   0   0   0  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   0   0      x   x   x   x",
-                          "  x   x   x  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   0   0      x   x   x   x",
-                          "  x   x   x  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  0   0   0   0    a11 a10  a9  a8",
-                          " a7  a6  a5   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x21;
-	delay		= 10;
-	blocksize	= 64;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        min_write_delay = 2000;
-        max_write_delay = 2000;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        min_write_delay = 2000;
-        max_write_delay = 2000;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "lock"
-        size            = 1;
-        min_write_delay = 2000;
-        max_write_delay = 2000;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-      ;
-
-    memory "calibration"
-        size            = 4;
-        read            = "0  0  1  1   1  0  0  0   0  0  x  x   x  x  x  x",
-                          "0  0  0  0   0  0 a1 a0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-
-
-#------------------------------------------------------------
-# ATmega8515
-#------------------------------------------------------------
-
-part
-    id               = "m8515";
-    desc             = "ATMEGA8515";
-    stk500_devcode   = 0x63;
-    avr910_devcode   = 0x3A;
-    signature        = 0x1e 0x93 0x06;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 6;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    memory "eeprom"
-        size            = 512;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
- read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   x   x      x   x   x  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
- write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   x   x      x   x   x  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-	mode		= 0x04;
-	delay		= 10;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-    memory "flash"
-        paged           = yes;
-        size            = 8192;
-        page_size       = 64;
-        num_pages       = 128;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0    0   0   0   0",
-                          "  0   0   0   0  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        read_hi         = "  0   0   1   0    1   0   0   0",
-                          "  0   0   0   0  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   0   0      x   x   x   x",
-                          "  x   x   x  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   0   0      x   x   x   x",
-                          "  x   x   x  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  0   0   0   0    a11 a10  a9  a8",
-                          " a7  a6  a5   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x21;
-	delay		= 6;
-	blocksize	= 64;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "lock"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-      ;
-
-    memory "calibration"
-        size            = 4;
-        read            = "0 0 1 1  1 0 0 0     0 0 x x  x x x x",
-                          "0 0 0 0  0 0 a1 a0   o o o o  o o o o";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-
-
-
-#------------------------------------------------------------
-# ATmega8535
-#------------------------------------------------------------
-
-part
-    id               = "m8535";
-    desc             = "ATMEGA8535";
-    stk500_devcode   = 0x64;
-    avr910_devcode   = 0x69;
-    signature        = 0x1e 0x93 0x08;
-    pagel            = 0xd7;
-    bs2              = 0xa0;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 6;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    memory "eeprom"
-        size            = 512;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   x   x      x   x   x  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   x   x      x   x   x  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-	mode		= 0x04;
-	delay		= 10;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-    memory "flash"
-        paged           = yes;
-        size            = 8192;
-        page_size       = 64;
-        num_pages       = 128;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0    0   0   0   0",
-                          "  0   0   0   0  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        read_hi         = "  0   0   1   0    1   0   0   0",
-                          "  0   0   0   0  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   0   0      x   x   x   x",
-                          "  x   x   x  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   0   0      x   x   x   x",
-                          "  x   x   x  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  0   0   0   0    a11 a10  a9  a8",
-                          " a7  a6  a5   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x21;
-	delay		= 6;
-	blocksize	= 64;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        min_write_delay = 2000;
-        max_write_delay = 2000;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        min_write_delay = 2000;
-        max_write_delay = 2000;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "lock"
-        size            = 1;
-        min_write_delay = 2000;
-        max_write_delay = 2000;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-      ;
-
-    memory "calibration"
-        size            = 4;
-        read            = "0 0 1 1  1 0 0 0   0 0 x x  x x x x",
-                          "0 0 0 0  0 0 a1 a0 o o o o  o o o o";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-
-#------------------------------------------------------------
-# ATtiny26
-#------------------------------------------------------------
-
-part
-    id                  = "t26";
-    desc                = "ATTINY26";
-    stk500_devcode      = 0x21;
-    avr910_devcode      = 0x5e;
-    signature           = 0x1e 0x91 0x09;
-    pagel               = 0xb3;
-    bs2                 = 0xb2;
-    chip_erase_delay    = 9000;
-    pgm_enable          = "1 0 1 0  1 1 0 0   0 1 0 1  0 0 1 1",
-                          "x x x x  x x x x   x x x x  x x x x";
-
-    chip_erase          = "1 0 1 0  1 1 0 0   1 0 0 x  x x x x",
-                          "x x x x  x x x x   x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0xC4, 0xE4, 0xC4, 0xE4, 0xCC, 0xEC, 0xCC, 0xEC,
-        0xD4, 0xF4, 0xD4, 0xF4, 0xDC, 0xFC, 0xDC, 0xFC,
-        0xC8, 0xE8, 0xD8, 0xF8, 0x4C, 0x6C, 0x5C, 0x7C,
-        0xEC, 0xBC, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 2;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    memory "eeprom"
-        size            = 128;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read            = "1  0  1  0   0  0  0  0    x x x x  x x x x",
-                          "x a6 a5 a4  a3 a2 a1 a0    o o o o  o o o o";
-
-        write           = "1  1  0  0   0  0  0  0    x x x x  x x x x",
-                          "x a6 a5 a4  a3 a2 a1 a0    i i i i  i i i i";
-
-	mode		= 0x04;
-	delay		= 10;
-	blocksize	= 64;
-	readsize	= 256;
-    ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 2048;
-        page_size       = 32;
-        num_pages       = 64;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0  0  1  0   0  0  0  0",
-                          "  x  x  x  x   x  x a9 a8",
-                          " a7 a6 a5 a4  a3 a2 a1 a0",
-                          "  o  o  o  o   o  o  o  o";
-
-        read_hi         = "  0  0  1  0   1  0  0  0",
-                          "  x  x  x  x   x  x a9 a8",
-                          " a7 a6 a5 a4  a3 a2 a1 a0",
-                          "  o  o  o  o   o  o  o  o";
-
-        loadpage_lo     = "  0  1  0  0   0  0  0  0",
-                          "  x  x  x  x   x  x  x  x",
-                          "  x  x  x  x  a3 a2 a1 a0",
-                          "  i  i  i  i   i  i  i  i";
-
-        loadpage_hi     = "  0  1  0  0   1  0  0  0",
-                          "  x  x  x  x   x  x  x  x",
-                          "  x  x  x  x  a3 a2 a1 a0",
-                          "  i  i  i  i   i  i  i  i";
-
-        writepage       = "  0  1  0  0   1  1  0  0",
-                          "  x  x  x  x   x  x a9 a8",
-                          " a7 a6 a5 a4   x  x  x  x",
-                          "  x  x  x  x   x  x  x  x";
-
-	mode		= 0x21;
-	delay		= 6;
-	blocksize	= 16;
-	readsize	= 256;
-    ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0    x x x x  x x x x",
-                          "0  0  0  0   0  0 a1 a0    o o o o  o o o o";
-    ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0  1  0  1   1  0  0  0    x x x x  x x x x",
-                          "x  x  x  x   x  x  x  x    x x x x  x x o o";
-
-        write           = "1  0  1  0   1  1  0  0    1 1 1 1  1 1 i i",
-                          "x  x  x  x   x  x  x  x    x x x x  x x x x";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-    ;
-
-    memory "lfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x  x x x i  i i i i";
-
-        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  x x x o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "calibration"
-        size            = 4;
-        read            = "0  0  1  1   1  0  0  0    x x x x  x x x x",
-                          "0  0  0  0   0  0 a1 a0    o o o o  o o o o";
-    ;
-
-;
-
-
-#------------------------------------------------------------
-# ATtiny261
-#------------------------------------------------------------
-# Close to ATtiny26
-
-part
-    id                  = "t261";
-    desc                = "ATTINY261";
-     has_debugwire = yes;
-     flash_instr   = 0xB4, 0x00, 0x10;
-     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
-	             0xBC, 0x00, 0xB4, 0x00, 0xBA, 0x0D, 0xBB, 0xBC,
-	             0x99, 0xE1, 0xBB, 0xAC;
-#    stk500_devcode      = 0x21;
-#    avr910_devcode      = 0x5e;
-    signature           = 0x1e 0x91 0x0c;
-    pagel               = 0xb3;
-    bs2                 = 0xb2;
-    chip_erase_delay    = 4000;
-
-    pgm_enable          = "1 0 1 0  1 1 0 0   0 1 0 1  0 0 1 1",
-                          "x x x x  x x x x   x x x x  x x x x";
-
-    chip_erase          = "1 0 1 0  1 1 0 0   1 0 0 x  x x x x",
-                          "x x x x  x x x x   x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0xC4, 0xE4, 0xC4, 0xE4, 0xCC, 0xEC, 0xCC, 0xEC,
-        0xD4, 0xF4, 0xD4, 0xF4, 0xDC, 0xFC, 0xDC, 0xFC,
-        0xC8, 0xE8, 0xD8, 0xF8, 0x4C, 0x6C, 0x5C, 0x7C,
-        0xEC, 0xBC, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 2;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    memory "eeprom"
-        paged           = no;
-        size            = 128;
-        page_size       = 4;
-        num_pages       = 32;
-        min_write_delay = 4000;
-        max_write_delay = 4000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-
-        read            = "1  0  1  0   0  0  0  0    x x x x  x x x x",
-                          "x a6 a5 a4  a3 a2 a1 a0    o o o o  o o o o";
-
-        write           = "1  1  0  0   0  0  0  0    x x x x  x x x x",
-                          "x a6 a5 a4  a3 a2 a1 a0    i i i i  i i i i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x   x",
-			  "  x  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 4;
-	readsize	= 256;
-    ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 2048;
-        page_size       = 32;
-        num_pages       = 64;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-
-        read_lo         = "  0  0  1  0   0  0  0  0",
-                          "  x  x  x  x   x  x a9 a8",
-                          " a7 a6 a5 a4  a3 a2 a1 a0",
-                          "  o  o  o  o   o  o  o  o";
-
-        read_hi         = "  0  0  1  0   1  0  0  0",
-                          "  x  x  x  x   x  x a9 a8",
-                          " a7 a6 a5 a4  a3 a2 a1 a0",
-                          "  o  o  o  o   o  o  o  o";
-
-        loadpage_lo     = "  0  1  0  0   0  0  0  0",
-                          "  x  x  x  x   x  x  x  x",
-                          "  x  x  x  x  a3 a2 a1 a0",
-                          "  i  i  i  i   i  i  i  i";
-
-        loadpage_hi     = "  0  1  0  0   1  0  0  0",
-                          "  x  x  x  x   x  x  x  x",
-                          "  x  x  x  x  a3 a2 a1 a0",
-                          "  i  i  i  i   i  i  i  i";
-
-        writepage       = "  0  1  0  0   1  1  0  0",
-                          "  x  x  x  x   x  x a9 a8",
-                          " a7 a6 a5 a4   x  x  x  x",
-                          "  x  x  x  x   x  x  x  x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 32;
-	readsize	= 256;
-    ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0    x x x x  x x x x",
-                          "0  0  0  0   0  0 a1 a0    o o o o  o o o o";
-    ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0  1  0  1   1  0  0  0    x x x x  x x x x",
-                          "x  x  x  x   x  x  x  x    x x x x  x x o o";
-
-        write           = "1  0  1  0   1  1  0  0    1 1 1 1  1 1 i i",
-                          "x  x  x  x   x  x  x  x    x x x x  x x x x";
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-    ;
-
-    memory "lfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-      ;
-
-    memory "efuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x   x x x x  x x x i";
-
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   x x x x  x x x o";
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0  0  1  1   1  0  0  0    x x x x  x x x x",
-                          "0  0  0  0   0  0  0  0    o o o o  o o o o";
-    ;
-
-;
-
-
-#------------------------------------------------------------
-# ATtiny461
-#------------------------------------------------------------
-# Close to ATtiny261
-
-part
-    id                  = "t461";
-    desc                = "ATTINY461";
-     has_debugwire = yes;
-     flash_instr   = 0xB4, 0x00, 0x10;
-     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
-	             0xBC, 0x00, 0xB4, 0x00, 0xBA, 0x0D, 0xBB, 0xBC,
-	             0x99, 0xE1, 0xBB, 0xAC;
-#    stk500_devcode      = 0x21;
-#    avr910_devcode      = 0x5e;
-    signature           = 0x1e 0x92 0x08;
-    pagel               = 0xb3;
-    bs2                 = 0xb2;
-    chip_erase_delay    = 4000;
-
-    pgm_enable          = "1 0 1 0  1 1 0 0   0 1 0 1  0 0 1 1",
-                          "x x x x  x x x x   x x x x  x x x x";
-
-    chip_erase          = "1 0 1 0  1 1 0 0   1 0 0 x  x x x x",
-                          "x x x x  x x x x   x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0xC4, 0xE4, 0xC4, 0xE4, 0xCC, 0xEC, 0xCC, 0xEC,
-        0xD4, 0xF4, 0xD4, 0xF4, 0xDC, 0xFC, 0xDC, 0xFC,
-        0xC8, 0xE8, 0xD8, 0xF8, 0x4C, 0x6C, 0x5C, 0x7C,
-        0xEC, 0xBC, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 2;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    memory "eeprom"
-        paged           = no;
-        size            = 256;
-        page_size       = 4;
-        num_pages       = 64;
-        min_write_delay = 4000;
-        max_write_delay = 4000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-
-        read            = " 1  0  1  0   0  0  0  0    x x x x  x x x x",
-                          "a7 a6 a5 a4  a3 a2 a1 a0    o o o o  o o o o";
-
-        write           = " 1  1  0  0   0  0  0  0    x x x x  x x x x",
-                          "a7 a6 a5 a4  a3 a2 a1 a0    i i i i  i i i i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x   x",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 4;
-	readsize	= 256;
-    ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 4096;
-        page_size       = 64;
-        num_pages       = 64;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-
-        read_lo         = "  0  0  1  0   0   0  0  0",
-                          "  x  x  x  x   x a10 a9 a8",
-                          " a7 a6 a5 a4  a3  a2 a1 a0",
-                          "  o  o  o  o   o   o  o  o";
-
-        read_hi         = "  0  0  1  0   1   0  0  0",
-                          "  x  x  x  x   x a10 a9 a8",
-                          " a7 a6 a5 a4  a3  a2 a1 a0",
-                          "  o  o  o  o   o   o  o  o";
-
-        loadpage_lo     = "  0  1  0  0   0  0  0  0",
-                          "  x  x  x  x   x  x  x  x",
-                          "  x  x  x a4  a3 a2 a1 a0",
-                          "  i  i  i  i   i  i  i  i";
-
-        loadpage_hi     = "  0  1  0  0   1  0  0  0",
-                          "  x  x  x  x   x  x  x  x",
-                          "  x  x  x a4  a3 a2 a1 a0",
-                          "  i  i  i  i   i  i  i  i";
-
-        writepage       = "  0  1  0  0   1   1  0  0",
-                          "  x  x  x  x   x a10 a9 a8",
-                          " a7 a6 a5  x   x   x  x  x",
-                          "  x  x  x  x   x   x  x  x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 64;
-	readsize	= 256;
-    ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0    x x x x  x x x x",
-                          "0  0  0  0   0  0 a1 a0    o o o o  o o o o";
-    ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0  1  0  1   1  0  0  0    x x x x  x x x x",
-                          "x  x  x  x   x  x  x  x    x x x x  x x o o";
-
-        write           = "1  0  1  0   1  1  0  0    1 1 1 1  1 1 i i",
-                          "x  x  x  x   x  x  x  x    x x x x  x x x x";
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-    ;
-
-    memory "lfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-      ;
-
-    memory "efuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x   x x x x  x x x i";
-
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   x x x x  x x x o";
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0  0  1  1   1  0  0  0    x x x x  x x x x",
-                          "0  0  0  0   0  0  0  0    o o o o  o o o o";
-    ;
-
-;
-
-
-#------------------------------------------------------------
-# ATtiny861
-#------------------------------------------------------------
-# Close to ATtiny461
-
-part
-    id                  = "t861";
-    desc                = "ATTINY861";
-     has_debugwire = yes;
-     flash_instr   = 0xB4, 0x00, 0x10;
-     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
-	             0xBC, 0x00, 0xB4, 0x00, 0xBA, 0x0D, 0xBB, 0xBC,
-	             0x99, 0xE1, 0xBB, 0xAC;
-#    stk500_devcode      = 0x21;
-#    avr910_devcode      = 0x5e;
-    signature           = 0x1e 0x93 0x0d;
-    pagel               = 0xb3;
-    bs2                 = 0xb2;
-    chip_erase_delay    = 4000;
-
-    pgm_enable          = "1 0 1 0  1 1 0 0   0 1 0 1  0 0 1 1",
-                          "x x x x  x x x x   x x x x  x x x x";
-
-    chip_erase          = "1 0 1 0  1 1 0 0   1 0 0 x  x x x x",
-                          "x x x x  x x x x   x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0xC4, 0xE4, 0xC4, 0xE4, 0xCC, 0xEC, 0xCC, 0xEC,
-        0xD4, 0xF4, 0xD4, 0xF4, 0xDC, 0xFC, 0xDC, 0xFC,
-        0xC8, 0xE8, 0xD8, 0xF8, 0x4C, 0x6C, 0x5C, 0x7C,
-        0xEC, 0xBC, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 2;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    memory "eeprom"
-        paged           = no;
-        size            = 512;
-        num_pages       = 128;
-        page_size       = 4;
-        min_write_delay = 4000;
-        max_write_delay = 4000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-
-        read            = " 1  0  1  0   0  0  0  0    x x x x  x x x a8",
-                          "a7 a6 a5 a4  a3 a2 a1 a0    o o o o  o o o  o";
-
-        write           = " 1  1  0  0   0  0  0  0    x x x x  x x x a8",
-                          "a7 a6 a5 a4  a3 a2 a1 a0    i i i i  i i i  i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x  a8",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 4;
-	readsize	= 256;
-    ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 8192;
-        page_size       = 64;
-        num_pages       = 128;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-
-        read_lo         = "  0  0  1  0   0   0  0  0",
-                          "  x  x  x  x a11 a10 a9 a8",
-                          " a7 a6 a5 a4  a3  a2 a1 a0",
-                          "  o  o  o  o   o   o  o  o";
-
-        read_hi         = "  0  0  1  0   1   0  0  0",
-                          "  x  x  x  x a11 a10 a9 a8",
-                          " a7 a6 a5 a4  a3  a2 a1 a0",
-                          "  o  o  o  o   o   o  o  o";
-
-        loadpage_lo     = "  0  1  0  0   0  0  0  0",
-                          "  x  x  x  x   x  x  x  x",
-                          "  x  x  x a4  a3 a2 a1 a0",
-                          "  i  i  i  i   i  i  i  i";
-
-        loadpage_hi     = "  0  1  0  0   1  0  0  0",
-                          "  x  x  x  x   x  x  x  x",
-                          "  x  x  x a4  a3 a2 a1 a0",
-                          "  i  i  i  i   i  i  i  i";
-
-        writepage       = "  0  1  0  0   1   1  0  0",
-                          "  x  x  x  x a11 a10 a9 a8",
-                          " a7 a6 a5  x   x   x  x  x",
-                          "  x  x  x  x   x   x  x  x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 64;
-	readsize	= 256;
-    ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0    x x x x  x x x x",
-                          "0  0  0  0   0  0 a1 a0    o o o o  o o o o";
-    ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0  1  0  1   1  0  0  0    x x x x  x x x x",
-                          "x  x  x  x   x  x  x  x    x x x x  x x o o";
-
-        write           = "1  0  1  0   1  1  0  0    1 1 1 1  1 1 i i",
-                          "x  x  x  x   x  x  x  x    x x x x  x x x x";
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-    ;
-
-    memory "lfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-      ;
-
-    memory "efuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x   x x x x  x x x i";
-
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   x x x x  x x x o";
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0  0  1  1   1  0  0  0    x x x x  x x x x",
-                          "0  0  0  0   0  0  0  0    o o o o  o o o o";
-    ;
-
-;
-
-
-#------------------------------------------------------------
-# ATmega48
-#------------------------------------------------------------
-
-part
-    id               = "m48";
-    desc             = "ATMEGA48";
-     has_debugwire = yes;
-     flash_instr   = 0xB6, 0x01, 0x11;
-     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
-	             0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
-	             0x99, 0xF9, 0xBB, 0xAF;
-    stk500_devcode   = 0x59;
-#    avr910_devcode   = 0x;
-    signature        = 0x1e 0x92 0x05;
-    pagel            = 0xd7;
-    bs2              = 0xc2;
-    chip_erase_delay = 45000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-	0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-	0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-	0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-	0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    resetdelay          = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    memory "eeprom"
-        paged           = no;
-        page_size       = 4;
-        size            = 256;
-        min_write_delay = 3600;
-        max_write_delay = 3600;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   0   x      x   x   x   x",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   0   x      x   x   x   x",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x   x",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 5;
-	blocksize	= 4;
-	readsize	= 256;
-      ;
-    memory "flash"
-        paged           = yes;
-        size            = 4096;
-        page_size       = 64;
-        num_pages       = 64;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read_lo         = "  0   0   1   0    0   0   0   0",
-                          "  0   0   0   0    0 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        read_hi         = "  0   0   1   0    1   0   0   0",
-                          "  0   0   0   0    0 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   0   x      x   x   x   x",
-                          "  x   x   x  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   0   x      x   x   x   x",
-                          "  x   x   x  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  0   0   0   0      0 a10  a9  a8",
-                          " a7  a6  a5   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 64;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "efuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   x x x x  x x x o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x   x x x x  x x x i";
-      ;
-
-    memory "lock"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0  0  1  1   1  0  0  0   0  0  0  x   x  x  x  x",
-                          "0  0  0  0   0  0  0  0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-
-#------------------------------------------------------------
-# ATmega88
-#------------------------------------------------------------
-
-part
-    id               = "m88";
-    desc             = "ATMEGA88";
-     has_debugwire = yes;
-     flash_instr   = 0xB6, 0x01, 0x11;
-     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
-	             0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
-	             0x99, 0xF9, 0xBB, 0xAF;
-    stk500_devcode   = 0x73;
-#    avr910_devcode   = 0x;
-    signature        = 0x1e 0x93 0x0a;
-    pagel            = 0xd7;
-    bs2              = 0xc2;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-	0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-	0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-	0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-	0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    resetdelay          = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    memory "eeprom"
-        paged           = no;
-        page_size       = 4;
-        size            = 512;
-        min_write_delay = 3600;
-        max_write_delay = 3600;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   0   x      x   x   x  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   0   x      x   x   x  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x  a8",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 5;
-	blocksize	= 4;
-	readsize	= 256;
-      ;
-    memory "flash"
-        paged           = yes;
-        size            = 8192;
-        page_size       = 64;
-        num_pages       = 128;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0    0   0   0   0",
-                          "  0   0   0   0  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        read_hi         = "  0   0   1   0    1   0   0   0",
-                          "  0   0   0   0  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   0   x      x   x   x   x",
-                          "  x   x   x  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   0   x      x   x   x   x",
-                          "  x   x   x  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  0   0   0   0    a11 a10  a9  a8",
-                          " a7  a6  a5   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 64;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "efuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   x x x x  x o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x   x x x x  x i i i";
-      ;
-
-    memory "lock"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0  0  1  1   1  0  0  0   0  0  0  x   x  x  x  x",
-                          "0  0  0  0   0  0  0  0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# ATmega168
-#------------------------------------------------------------
-
-part
-    id              = "m168";
-    desc            = "ATMEGA168";
-     has_debugwire = yes;
-     flash_instr   = 0xB6, 0x01, 0x11;
-     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
-	             0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
-	             0x99, 0xF9, 0xBB, 0xAF;
-    stk500_devcode  = 0x86;
-    # avr910_devcode = 0x;
-    signature       = 0x1e 0x94 0x06;
-    pagel           = 0xd7;
-    bs2             = 0xc2;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0 1 1 0 0 0 1 0 1 0 0 1 1",
-                       "x x x x x x x x x x x x x x x x";
-
-    chip_erase       = "1 0 1 0 1 1 0 0 1 0 0 x x x x x",
-                       "x x x x x x x x x x x x x x x x";
-
-    timeout         = 200;
-    stabdelay       = 100;
-    cmdexedelay     = 25;
-    synchloops      = 32;
-    bytedelay       = 0;
-    pollindex       = 3;
-    pollvalue       = 0x53;
-    predelay        = 1;
-    postdelay       = 1;
-    pollmethod      = 1;
-
-    pp_controlstack     =
-	0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-	0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-	0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-	0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    resetdelay          = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    memory "eeprom"
-        paged           = no;
-        page_size       = 4;
-        size            = 512;
-        min_write_delay = 3600;
-        max_write_delay = 3600;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read            = " 1 0 1 0 0 0 0 0",
-                          " 0 0 0 x x x x a8",
-                          " a7 a6 a5 a4 a3 a2 a1 a0",
-                          " o o o o o o o o";
-    
-        write           = " 1 1 0 0 0 0 0 0",
-                          " 0 0 0 x x x x a8",
-                          " a7 a6 a5 a4 a3 a2 a1 a0",
-                          " i i i i i i i i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x  a8",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 5;
-	blocksize	= 4;
-	readsize	= 256;
-        ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 16384;
-        page_size       = 128;
-        num_pages       = 128;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = " 0 0 1 0 0 0 0 0",
-                          " 0 0 0 a12 a11 a10 a9 a8",
-                          " a7 a6 a5 a4 a3 a2 a1 a0",
-                          " o o o o o o o o";
-        
-        read_hi          = " 0 0 1 0 1 0 0 0",
-                           " 0 0 0 a12 a11 a10 a9 a8",
-                           " a7 a6 a5 a4 a3 a2 a1 a0",
-                           " o o o o o o o o";
-        
-        loadpage_lo     = " 0 1 0 0 0 0 0 0",
-                          " 0 0 0 x x x x x",
-                          " x x a5 a4 a3 a2 a1 a0",
-                          " i i i i i i i i";
-        
-        loadpage_hi     = " 0 1 0 0 1 0 0 0",
-                          " 0 0 0 x x x x x",
-                          " x x a5 a4 a3 a2 a1 a0",
-                          " i i i i i i i i";
-        
-        writepage       = " 0 1 0 0 1 1 0 0",
-                          " 0 0 0 a12 a11 a10 a9 a8",
-                          " a7 a6 x x x x x x",
-                          " x x x x x x x x";
-
-        mode        = 0x41;
-        delay       = 6;
-        blocksize   = 128;
-        readsize    = 256;
-
-        ;
-        
-    memory "lfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0",
-                          "x x x x x x x x o o o o o o o o";
-        
-        write           = "1 0 1 0 1 1 0 0 1 0 1 0 0 0 0 0",
-                          "x x x x x x x x i i i i i i i i";
-        ;
-    
-    memory "hfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1 1 0 0 0 0 0 0 0 1 0 0 0",
-                          "x x x x x x x x o o o o o o o o";
-        
-        write           = "1 0 1 0 1 1 0 0 1 0 1 0 1 0 0 0",
-                          "x x x x x x x x i i i i i i i i";
-        ;
-    
-    memory "efuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0",
-                          "x x x x x x x x x x x x x o o o";
-        
-        write           = "1 0 1 0 1 1 0 0 1 0 1 0 0 1 0 0",
-                          "x x x x x x x x x x x x x i i i";
-        ;
-    
-    memory "lock"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0",
-                          "x x x x x x x x x x o o o o o o";
-        
-        write           = "1 0 1 0 1 1 0 0 1 1 1 x x x x x",
-                          "x x x x x x x x 1 1 i i i i i i";
-        ;
-    
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1 1 0 0 0 0 0 0 x x x x x",
-                          "0 0 0 0 0 0 0 0 o o o o o o o o";
-        ;
-    
-    memory "signature"
-        size            = 3;
-        read            = "0 0 1 1 0 0 0 0 0 0 0 x x x x x",
-                          "x x x x x x a1 a0 o o o o o o o o";
-        ;
-;
-
-#------------------------------------------------------------
-# ATmega328
-#------------------------------------------------------------
-
-part
-    id              = "m328p";
-    desc            = "ATMEGA328P";
-     has_debugwire = yes;
-     flash_instr   = 0xB6, 0x01, 0x11;
-     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
-	             0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
-	             0x99, 0xF9, 0xBB, 0xAF;
-    stk500_devcode  = 0x86;
-    # avr910_devcode = 0x;
-    signature       = 0x1e 0x95 0x0F;
-    pagel           = 0xd7;
-    bs2             = 0xc2;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0 1 1 0 0 0 1 0 1 0 0 1 1",
-                       "x x x x x x x x x x x x x x x x";
-
-    chip_erase       = "1 0 1 0 1 1 0 0 1 0 0 x x x x x",
-                       "x x x x x x x x x x x x x x x x";
-
-    timeout         = 200;
-    stabdelay       = 100;
-    cmdexedelay     = 25;
-    synchloops      = 32;
-    bytedelay       = 0;
-    pollindex       = 3;
-    pollvalue       = 0x53;
-    predelay        = 1;
-    postdelay       = 1;
-    pollmethod      = 1;
-
-    pp_controlstack     =
-	0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-	0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-	0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-	0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    resetdelay          = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    memory "eeprom"
-        paged           = no;
-        page_size       = 4;
-        size            = 1024;
-        min_write_delay = 3600;
-        max_write_delay = 3600;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read            = " 1 0 1 0 0 0 0 0",
-                          " 0 0 0 x x x a9 a8",
-                          " a7 a6 a5 a4 a3 a2 a1 a0",
-                          " o o o o o o o o";
-    
-        write           = " 1 1 0 0 0 0 0 0",
-                          " 0 0 0 x x x a9 a8",
-                          " a7 a6 a5 a4 a3 a2 a1 a0",
-                          " i i i i i i i i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   a9  a8",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 5;
-	blocksize	= 4;
-	readsize	= 256;
-        ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 32768;
-        page_size       = 128;
-        num_pages       = 256;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = " 0 0 1 0 0 0 0 0",
-                          " 0 0 a13 a12 a11 a10 a9 a8",
-                          " a7 a6 a5 a4 a3 a2 a1 a0",
-                          " o o o o o o o o";
-        
-        read_hi          = " 0 0 1 0 1 0 0 0",
-                           " 0 0 a13 a12 a11 a10 a9 a8",
-                           " a7 a6 a5 a4 a3 a2 a1 a0",
-                           " o o o o o o o o";
-        
-        loadpage_lo     = " 0 1 0 0 0 0 0 0",
-                          " 0 0 0 x x x x x",
-                          " x x a5 a4 a3 a2 a1 a0",
-                          " i i i i i i i i";
-        
-        loadpage_hi     = " 0 1 0 0 1 0 0 0",
-                          " 0 0 0 x x x x x",
-                          " x x a5 a4 a3 a2 a1 a0",
-                          " i i i i i i i i";
-        
-        writepage       = " 0 1 0 0 1 1 0 0",
-                          " 0 0 a13 a12 a11 a10 a9 a8",
-                          " a7 a6 x x x x x x",
-                          " x x x x x x x x";
-
-        mode        = 0x41;
-        delay       = 6;
-        blocksize   = 128;
-        readsize    = 256;
-
-        ;
-        
-    memory "lfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0",
-                          "x x x x x x x x o o o o o o o o";
-        
-        write           = "1 0 1 0 1 1 0 0 1 0 1 0 0 0 0 0",
-                          "x x x x x x x x i i i i i i i i";
-        ;
-    
-    memory "hfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1 1 0 0 0 0 0 0 0 1 0 0 0",
-                          "x x x x x x x x o o o o o o o o";
-        
-        write           = "1 0 1 0 1 1 0 0 1 0 1 0 1 0 0 0",
-                          "x x x x x x x x i i i i i i i i";
-        ;
-    
-    memory "efuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0",
-                          "x x x x x x x x x x x x x o o o";
-        
-        write           = "1 0 1 0 1 1 0 0 1 0 1 0 0 1 0 0",
-                          "x x x x x x x x x x x x x i i i";
-        ;
-    
-    memory "lock"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0",
-                          "x x x x x x x x x x o o o o o o";
-        
-        write           = "1 0 1 0 1 1 0 0 1 1 1 x x x x x",
-                          "x x x x x x x x 1 1 i i i i i i";
-        ;
-    
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1 1 0 0 0 0 0 0 x x x x x",
-                          "0 0 0 0 0 0 0 0 o o o o o o o o";
-        ;
-    
-    memory "signature"
-        size            = 3;
-        read            = "0 0 1 1 0 0 0 0 0 0 0 x x x x x",
-                          "x x x x x x a1 a0 o o o o o o o o";
-        ;
-;
-
-#------------------------------------------------------------
-# ATtiny2313
-#------------------------------------------------------------
-
-part
-     id            = "t2313";
-     desc          = "ATtiny2313";
-     has_debugwire = yes;
-     flash_instr   = 0xB2, 0x0F, 0x1F;
-     eeprom_instr  = 0xBB, 0xFE, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
-	             0xBA, 0x0F, 0xB2, 0x0F, 0xBA, 0x0D, 0xBB, 0xBC,
-	             0x99, 0xE1, 0xBB, 0xAC;
-     stk500_devcode   = 0x23;
-##   Use the ATtiny26 devcode:
-     avr910_devcode   = 0x5e;
-     signature        = 0x1e 0x91 0x0a;
-     pagel            = 0xD4;
-     bs2              = 0xD6;
-     reset            = io;
-     chip_erase_delay = 9000;
-
-     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0E, 0x1E, 0x2E, 0x3E, 0x2E, 0x3E,
-        0x4E, 0x5E, 0x4E, 0x5E, 0x6E, 0x7E, 0x6E, 0x7E,
-        0x26, 0x36, 0x66, 0x76, 0x2A, 0x3A, 0x6A, 0x7A,
-        0x2E, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-     memory "eeprom"
-         size            = 128;
-        paged           = no;
-        page_size       = 4;
-         min_write_delay = 4000;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read            = "1  0  1  0   0  0  0  0   0 0 0 x  x x x x",
-                           "x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
-
-         write           = "1  1  0  0   0  0  0  0   0 0 0 x  x x x x",
-                           "x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x   x",
-			  "  x  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 4;
-	readsize	= 256;
-       ;
-     memory "flash"
-         paged           = yes;
-         size            = 2048;
-         page_size       = 32;
-         num_pages       = 64;
-         min_write_delay = 4500;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read_lo         = "  0   0   1   0    0   0   0   0",
-                           "  0   0   0   0    0   0  a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         read_hi         = "  0   0   1   0    1   0   0   0",
-                           "  0   0   0   0    0   0  a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-# The information in the data sheet of April/2004 is wrong, this works:
-         loadpage_lo     = "  0   1   0   0    0   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x   x   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-# The information in the data sheet of April/2004 is wrong, this works:
-         loadpage_hi     = "  0   1   0   0    1   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x   x   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-# The information in the data sheet of April/2004 is wrong, this works:
-         writepage       = "  0  1  0  0   1  1  0  0",
-                           "  0  0  0  0   0  0 a9 a8",
-                           " a7 a6 a5 a4   x  x  x  x",
-                           "  x  x  x  x   x  x  x  x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 32;
-	readsize	= 256;
-       ;
-#   ATtiny2313 has Signature Bytes: 0x1E 0x91 0x0A.
-     memory "signature"
-         size            = 3;
-         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
-                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-       ;
-     memory "lock"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
-                           "x x x x  x x x x  1 1 i i  i i i i";
-         read           = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  x x o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "lfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "hfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "efuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                           "x x x x  x x x x  x x x x  x x x i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-     ;
-# The Tiny2313 has calibration data for both 4 MHz and 8 MHz.
-# The information in the data sheet of April/2004 is wrong, this works:
-
-     memory "calibration"
-         size            = 2;
-         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
-                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
-     ;
-  ;
-
-#------------------------------------------------------------
-# AT90PWM2
-#------------------------------------------------------------
-
-part
-     id            = "pwm2";
-     desc          = "AT90PWM2";
-     has_debugwire = yes;
-     flash_instr   = 0xB6, 0x01, 0x11;
-     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
-	             0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
-	             0x99, 0xF9, 0xBB, 0xAF;
-     stk500_devcode   = 0x65;
-##  avr910_devcode   = ?;
-     signature        = 0x1e 0x93 0x81;
-     pagel            = 0xD8;
-     bs2              = 0xE2;
-     reset            = io;
-     chip_erase_delay = 9000;
-
-     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-     memory "eeprom"
-         size            = 512;
-        paged           = no;
-        page_size       = 4;
-         min_write_delay = 4000;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read            = "1  0  1  0   0  0  0  0   0 0 0 x  x x x a8",
-                           "a7 a6 a5 a4  a3 a2 a1 a0  o o o o  o o o o";
-
-         write           = "1  1  0  0   0  0  0  0   0 0 0 x  x x x a8",
-                           "a7 a6 a5 a4  a3 a2 a1 a0  i i i i  i i i i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x   x",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 4;
-	readsize	= 256;
-       ;
-     memory "flash"
-         paged           = yes;
-         size            = 8192;
-         page_size       = 64;
-         num_pages       = 128;
-         min_write_delay = 4500;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read_lo         = "  0   0   1   0    0   0   0   0",
-                           "  0   0   0   0   a11 a10 a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         read_hi         = "  0   0   1   0    1   0   0   0",
-                           "  0   0   0   0   a11 a10 a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         loadpage_lo     = "  0   1   0   0    0   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x  a4   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         loadpage_hi     = "  0   1   0   0    1   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x  a4   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         writepage       = "  0  1  0  0   1   1   0   0",
-                           "  0  0  0  0   a11 a10 a9  a8",
-                           " a7 a6 a5  x   x   x   x   x",
-                           "  x  x  x  x   x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 64;
-	readsize	= 256;
-       ;
-#   AT90PWM2 has Signature Bytes: 0x1E 0x93 0x81.
-     memory "signature"
-         size            = 3;
-         read            = "0  0  1  1   0  0  0  0   0  0  x  x   x  x  x  x",
-                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-       ;
-     memory "lock"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
-                           "x x x x  x x x x  1 1 i i  i i i i";
-
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
-                           "x x x x  x x x x  x x o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "lfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "hfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "efuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                           "x x x x  x x x x  x x x x  x x x i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-     ;
-
-     memory "calibration"
-         size            = 1;
-         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
-                           "0  0  0  0   0  0  0  0    o o o o  o o o o";
-     ;
-  ;
-
-#------------------------------------------------------------
-# AT90PWM3
-#------------------------------------------------------------
-
-# Completely identical to AT90PWM2 (including the signature!)
-
-part
-     id            = "pwm3";
-     desc          = "AT90PWM3";
-     has_debugwire = yes;
-     flash_instr   = 0xB6, 0x01, 0x11;
-     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
-	             0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
-	             0x99, 0xF9, 0xBB, 0xAF;
-     stk500_devcode   = 0x65;
-##  avr910_devcode   = ?;
-     signature        = 0x1e 0x93 0x81;
-     pagel            = 0xD8;
-     bs2              = 0xE2;
-     reset            = io;
-     chip_erase_delay = 9000;
-
-     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-     memory "eeprom"
-         size            = 512;
-        paged           = no;
-        page_size       = 4;
-         min_write_delay = 4000;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read            = "1  0  1  0   0  0  0  0   0 0 0 x  x x x a8",
-                           "a7 a6 a5 a4  a3 a2 a1 a0  o o o o  o o o o";
-
-         write           = "1  1  0  0   0  0  0  0   0 0 0 x  x x x a8",
-                           "a7 a6 a5 a4  a3 a2 a1 a0  i i i i  i i i i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x   x",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 4;
-	readsize	= 256;
-       ;
-     memory "flash"
-         paged           = yes;
-         size            = 8192;
-         page_size       = 64;
-         num_pages       = 128;
-         min_write_delay = 4500;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read_lo         = "  0   0   1   0    0   0   0   0",
-                           "  0   0   0   0   a11 a10 a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         read_hi         = "  0   0   1   0    1   0   0   0",
-                           "  0   0   0   0   a11 a10 a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         loadpage_lo     = "  0   1   0   0    0   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x  a4   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         loadpage_hi     = "  0   1   0   0    1   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x  a4   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         writepage       = "  0  1  0  0   1   1   0   0",
-                           "  0  0  0  0   a11 a10 a9  a8",
-                           " a7 a6 a5  x   x   x   x   x",
-                           "  x  x  x  x   x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 64;
-	readsize	= 256;
-       ;
-#   AT90PWM2 has Signature Bytes: 0x1E 0x93 0x81.
-     memory "signature"
-         size            = 3;
-         read            = "0  0  1  1   0  0  0  0   0  0  x  x   x  x  x  x",
-                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-       ;
-     memory "lock"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
-                           "x x x x  x x x x  1 1 i i  i i i i";
-
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
-                           "x x x x  x x x x  x x o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "lfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "hfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "efuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                           "x x x x  x x x x  x x x x  x x x i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-     ;
-
-     memory "calibration"
-         size            = 1;
-         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
-                           "0  0  0  0   0  0  0  0    o o o o  o o o o";
-     ;
-  ;
-
-#------------------------------------------------------------
-# AT90PWM2B
-#------------------------------------------------------------
-# Same as AT90PWM2 but different signature.
-
-part
-     id            = "pwm2b";
-     desc          = "AT90PWM2B";
-     has_debugwire = yes;
-     flash_instr   = 0xB6, 0x01, 0x11;
-     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
-	             0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
-	             0x99, 0xF9, 0xBB, 0xAF;
-     stk500_devcode   = 0x65;
-##  avr910_devcode   = ?;
-     signature        = 0x1e 0x93 0x83;
-     pagel            = 0xD8;
-     bs2              = 0xE2;
-     reset            = io;
-     chip_erase_delay = 9000;
-
-     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-     memory "eeprom"
-         size            = 512;
-        paged           = no;
-        page_size       = 4;
-         min_write_delay = 4000;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read            = "1  0  1  0   0  0  0  0   0 0 0 x  x x x a8",
-                           "a7 a6 a5 a4  a3 a2 a1 a0  o o o o  o o o o";
-
-         write           = "1  1  0  0   0  0  0  0   0 0 0 x  x x x a8",
-                           "a7 a6 a5 a4  a3 a2 a1 a0  i i i i  i i i i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x   x",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 4;
-	readsize	= 256;
-       ;
-     memory "flash"
-         paged           = yes;
-         size            = 8192;
-         page_size       = 64;
-         num_pages       = 128;
-         min_write_delay = 4500;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read_lo         = "  0   0   1   0    0   0   0   0",
-                           "  0   0   0   0   a11 a10 a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         read_hi         = "  0   0   1   0    1   0   0   0",
-                           "  0   0   0   0   a11 a10 a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         loadpage_lo     = "  0   1   0   0    0   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x  a4   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         loadpage_hi     = "  0   1   0   0    1   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x  a4   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         writepage       = "  0  1  0  0   1   1   0   0",
-                           "  0  0  0  0   a11 a10 a9  a8",
-                           " a7 a6 a5  x   x   x   x   x",
-                           "  x  x  x  x   x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 64;
-	readsize	= 256;
-       ;
-     memory "signature"
-         size            = 3;
-         read            = "0  0  1  1   0  0  0  0   0  0  x  x   x  x  x  x",
-                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-       ;
-     memory "lock"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
-                           "x x x x  x x x x  1 1 i i  i i i i";
-
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
-                           "x x x x  x x x x  x x o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "lfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "hfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "efuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                           "x x x x  x x x x  x x x x  x x x i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-     ;
-
-     memory "calibration"
-         size            = 1;
-         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
-                           "0  0  0  0   0  0  0  0    o o o o  o o o o";
-     ;
-  ;
-
-#------------------------------------------------------------
-# AT90PWM3B
-#------------------------------------------------------------
-
-# Completely identical to AT90PWM2B (including the signature!)
-
-part
-     id            = "pwm3b";
-     desc          = "AT90PWM3B";
-     has_debugwire = yes;
-     flash_instr   = 0xB6, 0x01, 0x11;
-     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
-	             0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
-	             0x99, 0xF9, 0xBB, 0xAF;
-     stk500_devcode   = 0x65;
-##  avr910_devcode   = ?;
-     signature        = 0x1e 0x93 0x83;
-     pagel            = 0xD8;
-     bs2              = 0xE2;
-     reset            = io;
-     chip_erase_delay = 9000;
-
-     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-     memory "eeprom"
-         size            = 512;
-        paged           = no;
-        page_size       = 4;
-         min_write_delay = 4000;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read            = "1  0  1  0   0  0  0  0   0 0 0 x  x x x a8",
-                           "a7 a6 a5 a4  a3 a2 a1 a0  o o o o  o o o o";
-
-         write           = "1  1  0  0   0  0  0  0   0 0 0 x  x x x a8",
-                           "a7 a6 a5 a4  a3 a2 a1 a0  i i i i  i i i i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x   x",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 4;
-	readsize	= 256;
-       ;
-     memory "flash"
-         paged           = yes;
-         size            = 8192;
-         page_size       = 64;
-         num_pages       = 128;
-         min_write_delay = 4500;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read_lo         = "  0   0   1   0    0   0   0   0",
-                           "  0   0   0   0   a11 a10 a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         read_hi         = "  0   0   1   0    1   0   0   0",
-                           "  0   0   0   0   a11 a10 a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         loadpage_lo     = "  0   1   0   0    0   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x  a4   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         loadpage_hi     = "  0   1   0   0    1   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x  a4   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         writepage       = "  0  1  0  0   1   1   0   0",
-                           "  0  0  0  0   a11 a10 a9  a8",
-                           " a7 a6 a5  x   x   x   x   x",
-                           "  x  x  x  x   x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 64;
-	readsize	= 256;
-       ;
-     memory "signature"
-         size            = 3;
-         read            = "0  0  1  1   0  0  0  0   0  0  x  x   x  x  x  x",
-                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-       ;
-     memory "lock"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
-                           "x x x x  x x x x  1 1 i i  i i i i";
-
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
-                           "x x x x  x x x x  x x o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "lfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "hfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "efuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                           "x x x x  x x x x  x x x x  x x x i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-     ;
-
-     memory "calibration"
-         size            = 1;
-         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
-                           "0  0  0  0   0  0  0  0    o o o o  o o o o";
-     ;
-  ;
-
-#------------------------------------------------------------
-# ATtiny25
-#------------------------------------------------------------
-
-part
-     id            = "t25";
-     desc          = "ATtiny25";
-     has_debugwire = yes;
-     flash_instr   = 0xB4, 0x02, 0x12;
-     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
-	             0xBC, 0x02, 0xB4, 0x02, 0xBA, 0x0D, 0xBB, 0xBC,
-	             0x99, 0xE1, 0xBB, 0xAC;
-## no STK500 devcode in XML file, use the ATtiny45 one
-     stk500_devcode   = 0x14;
-##  avr910_devcode   = ?;
-##  Try the AT90S2313 devcode:
-     avr910_devcode   = 0x20;
-     signature        = 0x1e 0x91 0x08;
-     reset            = io;
-     chip_erase_delay = 4500;
-
-     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    hvsp_controlstack   =
-        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
-        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
-        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
-        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
-    hventerstabdelay    = 100;
-    hvspcmdexedelay     = 0;
-    synchcycles         = 6;
-    latchcycles         = 1;
-    togglevtg           = 1;
-    poweroffdelay       = 25;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 100;
-    resetdelay          = 25;
-    chiperasepolltimeout = 40;
-    chiperasetime       = 0;
-    programfusepolltimeout = 25;
-    programlockpolltimeout = 25;
-
-     memory "eeprom"
-         size            = 128;
-        paged           = no;
-        page_size       = 4;
-         min_write_delay = 4000;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read            = "1  0  1  0   0  0  0  0   0 0 0 x  x x x x",
-                           "x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
-
-         write           = "1  1  0  0   0  0  0  0   0 0 0 x  x x x x",
-                           "x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x   x",
-			  "  x  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 4;
-	readsize	= 256;
-       ;
-     memory "flash"
-         paged           = yes;
-         size            = 2048;
-         page_size       = 32;
-         num_pages       = 64;
-         min_write_delay = 4500;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read_lo         = "  0   0   1   0    0   0   0   0",
-                           "  0   0   0   0    0   0  a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         read_hi         = "  0   0   1   0    1   0   0   0",
-                           "  0   0   0   0    0   0  a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         loadpage_lo     = "  0   1   0   0    0   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x   x   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         loadpage_hi     = "  0   1   0   0    1   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x   x   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         writepage       = "  0  1  0  0   1  1  0  0",
-                           "  0  0  0  0   0  0 a9 a8",
-                           " a7 a6 a5 a4   x  x  x  x",
-                           "  x  x  x  x   x  x  x  x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 32;
-	readsize	= 256;
-       ;
-#   ATtiny25 has Signature Bytes: 0x1E 0x91 0x08.
-     memory "signature"
-         size            = 3;
-         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
-                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-       ;
-     memory "lock"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
-                           "x x x x  x x x x  1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "lfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "hfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "efuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                           "x x x x  x x x x  x x x x  x x x i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-     ;
-
-     memory "calibration"
-         size            = 2;
-         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
-                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
-     ;
-  ;
-
-#------------------------------------------------------------
-# ATtiny45
-#------------------------------------------------------------
-
-part
-     id            = "t45";
-     desc          = "ATtiny45";
-     has_debugwire = yes;
-     flash_instr   = 0xB4, 0x02, 0x12;
-     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
-	             0xBC, 0x02, 0xB4, 0x02, 0xBA, 0x0D, 0xBB, 0xBC,
-	             0x99, 0xE1, 0xBB, 0xAC;
-     stk500_devcode   = 0x14;
-##  avr910_devcode   = ?;
-##  Try the AT90S2313 devcode:
-     avr910_devcode   = 0x20;
-     signature        = 0x1e 0x92 0x06;
-     reset            = io;
-     chip_erase_delay = 4500;
-
-     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    hvsp_controlstack     =
-	0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
-        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
-        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
-        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    hvspcmdexedelay     = 0;
-    synchcycles         = 6;
-    latchcycles         = 1;
-    togglevtg           = 1;
-    poweroffdelay       = 25;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 100;
-    resetdelay          = 25;
-    chiperasepolltimeout = 40;
-    chiperasetime       = 0;
-    programfusepolltimeout = 25;
-    programlockpolltimeout = 25;
-
-     memory "eeprom"
-         size            = 256;
-         page_size       = 4;
-         min_write_delay = 4000;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read            = "1  0  1  0   0  0  0  0    0 0 0 x  x x x x",
-                           "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
-
-         write           = "1  1  0  0   0  0  0  0    0 0 0 x  x x x x",
-                           "a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x   x",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 4;
-	readsize	= 256;
-       ;
-     memory "flash"
-         paged           = yes;
-         size            = 4096;
-         page_size       = 64;
-         num_pages       = 64;
-         min_write_delay = 4500;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read_lo         = "  0   0   1   0    0   0   0   0",
-                           "  0   0   0   0    0  a10 a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         read_hi         = "  0   0   1   0    1   0   0   0",
-                           "  0   0   0   0    0  a10 a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         loadpage_lo     = "  0   1   0   0    0   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x  a4   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         loadpage_hi     = "  0   1   0   0    1   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x  a4   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         writepage       = "  0  1  0  0   1  1  0  0",
-                           "  0  0  0  0   0 a10 a9 a8",
-                           " a7 a6 a5  x   x  x  x  x",
-                           "  x  x  x  x   x  x  x  x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 32;
-	readsize	= 256;
-       ;
-#   ATtiny45 has Signature Bytes: 0x1E 0x92 0x08. (Data sheet 2586C-AVR-06/05 (doc2586.pdf) indicates otherwise!)
-     memory "signature"
-         size            = 3;
-         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
-                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-       ;
-     memory "lock"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
-                           "x x x x  x x x x  1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "lfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "hfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "efuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                           "x x x x  x x x x  x x x x  x x x i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-     ;
-
-     memory "calibration"
-         size            = 2;
-         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
-                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
-     ;
-  ;
-
-#------------------------------------------------------------
-# ATtiny85
-#------------------------------------------------------------
-
-part
-     id            = "t85";
-     desc          = "ATtiny85";
-     has_debugwire = yes;
-     flash_instr   = 0xB4, 0x02, 0x12;
-     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
-	             0xBC, 0x02, 0xB4, 0x02, 0xBA, 0x0D, 0xBB, 0xBC,
-	             0x99, 0xE1, 0xBB, 0xAC;
-## no STK500 devcode in XML file, use the ATtiny45 one
-     stk500_devcode   = 0x14;
-##  avr910_devcode   = ?;
-##  Try the AT90S2313 devcode:
-     avr910_devcode   = 0x20;
-     signature        = 0x1e 0x93 0x0b;
-     reset            = io;
-     chip_erase_delay = 4500;
-
-     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    hvsp_controlstack   =
-        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
-        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
-        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
-        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
-    hventerstabdelay    = 100;
-    hvspcmdexedelay     = 0;
-    synchcycles         = 6;
-    latchcycles         = 1;
-    togglevtg           = 1;
-    poweroffdelay       = 25;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 100;
-    resetdelay          = 25;
-    chiperasepolltimeout = 40;
-    chiperasetime       = 0;
-    programfusepolltimeout = 25;
-    programlockpolltimeout = 25;
-
-     memory "eeprom"
-         size            = 512;
-        paged           = no;
-        page_size       = 4;
-         min_write_delay = 4000;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read            = "1  0  1  0   0  0  0  0    0 0 0 x  x x x a8",
-                           "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
-
-         write           = "1  1  0  0   0  0  0  0    0 0 0 x  x x x a8",
-                           "a8 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x  a8",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 4;
-	readsize	= 256;
-       ;
-     memory "flash"
-         paged           = yes;
-         size            = 8192;
-         page_size       = 64;
-         num_pages       = 128;
-         min_write_delay = 4500;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read_lo         = "  0   0   1   0    0   0   0   0",
-                           "  0   0   0   0  a11 a10  a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         read_hi         = "  0   0   1   0    1   0   0   0",
-                           "  0   0   0   0  a11 a10  a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         loadpage_lo     = "  0   1   0   0    0   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x  a4   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         loadpage_hi     = "  0   1   0   0    1   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x  a4   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         writepage       = "  0  1  0  0   1   1   0  0",
-                           "  0  0  0  0  a11 a10 a9 a8",
-                           " a7 a6 a5  x   x  x  x  x",
-                           "  x  x  x  x   x  x  x  x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 32;
-	readsize	= 256;
-       ;
-#   ATtiny85 has Signature Bytes: 0x1E 0x93 0x08.
-     memory "signature"
-         size            = 3;
-         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
-                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-       ;
-     memory "lock"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
-                           "x x x x  x x x x  1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "lfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "hfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "efuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                           "x x x x  x x x x  x x x x  x x x i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-     ;
-
-     memory "calibration"
-         size            = 2;
-         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
-                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
-     ;
-  ;
-
-#------------------------------------------------------------
-# ATmega640
-#------------------------------------------------------------
-# Almost same as ATmega1280, except for different memory sizes
-
-part
-    id               = "m640";
-    desc             = "ATMEGA640";
-    signature        = 0x1e 0x96 0x08;
-    has_jtag         = yes;
-#    stk500_devcode   = 0xB2;
-#    avr910_devcode   = 0x43;
-    chip_erase_delay = 9000;
-    pagel            = 0xD7;
-    bs2              = 0xA0;
-    reset            = dedicated;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    rampz               = 0x3b;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 4096;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0  a2  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x    a11 a10  a9  a8",
-			  " a7  a6  a5  a4     a3   0   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 8;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 65536;
-        page_size       = 256;
-        num_pages       = 256;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  x x x x  x i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
-                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# ATmega1280
-#------------------------------------------------------------
-
-part
-    id               = "m1280";
-    desc             = "ATMEGA1280";
-    signature        = 0x1e 0x97 0x03;
-    has_jtag         = yes;
-#    stk500_devcode   = 0xB2;
-#    avr910_devcode   = 0x43;
-    chip_erase_delay = 9000;
-    pagel            = 0xD7;
-    bs2              = 0xA0;
-    reset            = dedicated;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    rampz               = 0x3b;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 4096;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0  a2  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x    a11 a10  a9  a8",
-			  " a7  a6  a5  a4     a3   0   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 8;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 131072;
-        page_size       = 256;
-        num_pages       = 512;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  x x x x  x i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
-                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# ATmega1281
-#------------------------------------------------------------
-# Identical to ATmega1280
-
-part
-    id               = "m1281";
-    desc             = "ATMEGA1281";
-    signature        = 0x1e 0x97 0x04;
-    has_jtag         = yes;
-#    stk500_devcode   = 0xB2;
-#    avr910_devcode   = 0x43;
-    chip_erase_delay = 9000;
-    pagel            = 0xD7;
-    bs2              = 0xA0;
-    reset            = dedicated;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    rampz               = 0x3b;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 4096;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0  a2  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x    a11 a10  a9  a8",
-			  " a7  a6  a5  a4     a3   0   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 8;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 131072;
-        page_size       = 256;
-        num_pages       = 512;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  x x x x  x i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
-                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# ATmega2560
-#------------------------------------------------------------
-
-part
-    id               = "m2560";
-    desc             = "ATMEGA2560";
-    signature        = 0x1e 0x98 0x01;
-    has_jtag         = yes;
-#    stk500_devcode   = 0xB2;
-#    avr910_devcode   = 0x43;
-    chip_erase_delay = 9000;
-    pagel            = 0xD7;
-    bs2              = 0xA0;
-    reset            = dedicated;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    rampz               = 0x3b;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 4096;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0  a2  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x    a11 a10  a9  a8",
-			  " a7  a6  a5  a4     a3   0   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 8;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 262144;
-        page_size       = 256;
-        num_pages       = 1024;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-        load_ext_addr   = "  0   1   0   0      1   1   0   1",
-                          "  0   0   0   0      0   0   0   0",
-                          "  0   0   0   0      0   0   0 a16",
-                          "  0   0   0   0      0   0   0   0";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  x x x x  x i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
-                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# ATmega2561
-#------------------------------------------------------------
-
-part
-    id               = "m2561";
-    desc             = "ATMEGA2561";
-    signature        = 0x1e 0x98 0x02;
-    has_jtag         = yes;
-#    stk500_devcode   = 0xB2;
-#    avr910_devcode   = 0x43;
-    chip_erase_delay = 9000;
-    pagel            = 0xD7;
-    bs2              = 0xA0;
-    reset            = dedicated;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    rampz               = 0x3b;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 4096;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0  a2  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x    a11 a10  a9  a8",
-			  " a7  a6  a5  a4     a3   0   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 8;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 262144;
-        page_size       = 256;
-        num_pages       = 1024;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-        load_ext_addr   = "  0   1   0   0      1   1   0   1",
-                          "  0   0   0   0      0   0   0   0",
-                          "  0   0   0   0      0   0   0 a16",
-                          "  0   0   0   0      0   0   0   0";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  x x x x  x i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
-                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# ATtiny24
-#------------------------------------------------------------
-
-part
-     id            = "t24";
-     desc          = "ATtiny24";
-     has_debugwire = yes;
-     flash_instr   = 0xB4, 0x07, 0x17;
-     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
-	             0xBC, 0x07, 0xB4, 0x07, 0xBA, 0x0D, 0xBB, 0xBC,
-	             0x99, 0xE1, 0xBB, 0xAC;
-## no STK500 devcode in XML file, use the ATtiny45 one
-     stk500_devcode   = 0x14;
-##  avr910_devcode   = ?;
-##  Try the AT90S2313 devcode:
-     avr910_devcode   = 0x20;
-     signature        = 0x1e 0x91 0x0b;
-     reset            = io;
-     chip_erase_delay = 4500;
-
-     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    hvsp_controlstack   =
-        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
-        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
-        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
-        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x0F;
-    hventerstabdelay    = 100;
-    hvspcmdexedelay     = 0;
-    synchcycles         = 6;
-    latchcycles         = 1;
-    togglevtg           = 1;
-    poweroffdelay       = 25;
-    resetdelayms        = 0;
-    resetdelayus        = 70;
-    hvleavestabdelay    = 100;
-    resetdelay          = 25;
-    chiperasepolltimeout = 40;
-    chiperasetime       = 0;
-    programfusepolltimeout = 25;
-    programlockpolltimeout = 25;
-
-     memory "eeprom"
-         size            = 128;
-        paged           = no;
-        page_size       = 4;
-         min_write_delay = 4000;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read            = "1  0  1  0   0  0  0  0   0 0 0 x  x x x x",
-                           "x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
-
-         write           = "1  1  0  0   0  0  0  0   0 0 0 x  x x x x",
-                           "x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x   x",
-			  "  x  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 4;
-	readsize	= 256;
-       ;
-     memory "flash"
-         paged           = yes;
-         size            = 2048;
-         page_size       = 32;
-         num_pages       = 64;
-         min_write_delay = 4500;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read_lo         = "  0   0   1   0    0   0   0   0",
-                           "  0   0   0   0    0   0  a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         read_hi         = "  0   0   1   0    1   0   0   0",
-                           "  0   0   0   0    0   0  a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         loadpage_lo     = "  0   1   0   0    0   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x   x   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         loadpage_hi     = "  0   1   0   0    1   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x   x   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         writepage       = "  0  1  0  0   1  1  0  0",
-                           "  0  0  0  0   0  0 a9 a8",
-                           " a7 a6 a5 a4   x  x  x  x",
-                           "  x  x  x  x   x  x  x  x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 32;
-	readsize	= 256;
-       ;
-#   ATtiny24 has Signature Bytes: 0x1E 0x91 0x0B.
-     memory "signature"
-         size            = 3;
-         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
-                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-       ;
-     memory "lock"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
-                           "x x x x  x x x x  x x x x  x x i i";
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
-                           "0 0 0 0  0 0 0 0  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "lfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "hfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "efuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                           "x x x x  x x x x  x x x x  x x x i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-     ;
-
-     memory "calibration"
-         size            = 1;
-         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
-                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
-     ;
-  ;
-
-#------------------------------------------------------------
-# ATtiny44
-#------------------------------------------------------------
-
-part
-     id            = "t44";
-     desc          = "ATtiny44";
-     has_debugwire = yes;
-     flash_instr   = 0xB4, 0x07, 0x17;
-     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
-                     0xBC, 0x07, 0xB4, 0x07, 0xBA, 0x0D, 0xBB, 0xBC,
-                     0x99, 0xE1, 0xBB, 0xAC;
-## no STK500 devcode in XML file, use the ATtiny45 one
-     stk500_devcode   = 0x14;
-##  avr910_devcode   = ?;
-##  Try the AT90S2313 devcode:
-     avr910_devcode   = 0x20;
-     signature        = 0x1e 0x92 0x07;
-     reset            = io;
-     chip_erase_delay = 4500;
-
-     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    hvsp_controlstack   =
-        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
-        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
-        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
-        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x0F;
-    hventerstabdelay    = 100;
-    hvspcmdexedelay     = 0;
-    synchcycles         = 6;
-    latchcycles         = 1;
-    togglevtg           = 1;
-    poweroffdelay       = 25;
-    resetdelayms        = 0;
-    resetdelayus        = 70;
-    hvleavestabdelay    = 100;
-    resetdelay          = 25;
-    chiperasepolltimeout = 40;
-    chiperasetime       = 0;
-    programfusepolltimeout = 25;
-    programlockpolltimeout = 25;
-
-     memory "eeprom"
-         size            = 256;
-        paged           = no;
-        page_size       = 4;
-         min_write_delay = 4000;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read            = "1  0  1  0   0  0  0  0    0 0 0 x  x x x x",
-                           "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
-
-         write           = "1  1  0  0   0  0  0  0    0 0 0 x  x x x x",
-                           "a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x   x",
-			  "  x  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 4;
-	readsize	= 256;
-       ;
-     memory "flash"
-         paged           = yes;
-         size            = 4096;
-         page_size       = 64;
-         num_pages       = 64;
-         min_write_delay = 4500;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read_lo         = "  0   0   1   0    0   0   0   0",
-                           "  0   0   0   0    0  a10 a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         read_hi         = "  0   0   1   0    1   0   0   0",
-                           "  0   0   0   0    0  a10 a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         loadpage_lo     = "  0   1   0   0    0   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x  a4   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         loadpage_hi     = "  0   1   0   0    1   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x  a4   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         writepage       = "  0  1  0  0   1  1  0  0",
-                           "  0  0  0  0   0 a10 a9 a8",
-                           " a7 a6 a5  x   x  x  x  x",
-                           "  x  x  x  x   x  x  x  x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 32;
-	readsize	= 256;
-       ;
-#   ATtiny44 has Signature Bytes: 0x1E 0x92 0x07.
-     memory "signature"
-         size            = 3;
-         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
-                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-       ;
-     memory "lock"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
-                           "x x x x  x x x x  x x x x  x x i i";
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
-                           "0 0 0 0  0 0 0 0  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "lfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "hfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "efuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                           "x x x x  x x x x  x x x x  x x x i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-     ;
-
-     memory "calibration"
-         size            = 1;
-         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
-                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
-     ;
-  ;
-
-#------------------------------------------------------------
-# ATtiny84
-#------------------------------------------------------------
-
-part
-     id            = "t84";
-     desc          = "ATtiny84";
-     has_debugwire = yes;
-     flash_instr   = 0xB4, 0x07, 0x17;
-     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
-	             0xBC, 0x07, 0xB4, 0x07, 0xBA, 0x0D, 0xBB, 0xBC,
-	             0x99, 0xE1, 0xBB, 0xAC;
-## no STK500 devcode in XML file, use the ATtiny45 one
-     stk500_devcode   = 0x14;
-##  avr910_devcode   = ?;
-##  Try the AT90S2313 devcode:
-     avr910_devcode   = 0x20;
-     signature        = 0x1e 0x93 0x0c;
-     reset            = io;
-     chip_erase_delay = 4500;
-
-     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    hvsp_controlstack   =
-        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
-        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
-        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
-        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x0F;
-    hventerstabdelay    = 100;
-    hvspcmdexedelay     = 0;
-    synchcycles         = 6;
-    latchcycles         = 1;
-    togglevtg           = 1;
-    poweroffdelay       = 25;
-    resetdelayms        = 0;
-    resetdelayus        = 70;
-    hvleavestabdelay    = 100;
-    resetdelay          = 25;
-    chiperasepolltimeout = 40;
-    chiperasetime       = 0;
-    programfusepolltimeout = 25;
-    programlockpolltimeout = 25;
-
-     memory "eeprom"
-         size            = 512;
-        paged           = no;
-        page_size       = 4;
-         min_write_delay = 4000;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read            = "1  0  1  0   0  0  0  0    0 0 0 x  x x x a8",
-                           "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
-
-         write           = "1  1  0  0   0  0  0  0    0 0 0 x  x x x a8",
-                           "a8 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x   x",
-			  "  x  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 4;
-	readsize	= 256;
-       ;
-     memory "flash"
-         paged           = yes;
-         size            = 8192;
-         page_size       = 64;
-         num_pages       = 128;
-         min_write_delay = 4500;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read_lo         = "  0   0   1   0    0   0   0   0",
-                           "  0   0   0   0  a11 a10  a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         read_hi         = "  0   0   1   0    1   0   0   0",
-                           "  0   0   0   0  a11 a10  a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         loadpage_lo     = "  0   1   0   0    0   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x  a4   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         loadpage_hi     = "  0   1   0   0    1   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x  a4   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         writepage       = "  0  1  0  0   1   1   0  0",
-                           "  0  0  0  0  a11 a10 a9 a8",
-                           " a7 a6 a5  x   x  x  x  x",
-                           "  x  x  x  x   x  x  x  x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 32;
-	readsize	= 256;
-       ;
-#   ATtiny84 has Signature Bytes: 0x1E 0x93 0x0C.
-     memory "signature"
-         size            = 3;
-         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
-                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-       ;
-
-     memory "lock"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
-                           "x x x x  x x x x  x x x x  x x i i";
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
-                           "0 0 0 0  0 0 0 0  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "lfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "hfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "efuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                           "x x x x  x x x x  x x x x  x x x i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-     ;
-
-     memory "calibration"
-         size            = 1;
-         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
-                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
-     ;
-  ;
-
-#------------------------------------------------------------
-# AT90USB646
-#------------------------------------------------------------
-
-part
-    id               = "usb646";
-    desc             = "AT90USB646";
-#    signature        = 0x1e 0x96 0x82; ?
-    signature        = 0x1e 0x97 0x82;
-    has_jtag         = yes;
-#    stk500_devcode   = 0xB2;
-#    avr910_devcode   = 0x43;
-    chip_erase_delay = 9000;
-    pagel            = 0xD7;
-    bs2              = 0xA0;
-    reset            = dedicated;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    rampz               = 0x3b;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 2048;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x      x a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0  a2  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x a10  a9  a8",
-			  " a7  a6  a5  a4     a3   0   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 8;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 65536;
-        page_size       = 256;
-        num_pages       = 256;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  x x x x  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
-                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# AT90USB647
-#------------------------------------------------------------
-# identical to AT90USB646
-
-part
-    id               = "usb647";
-    desc             = "AT90USB647";
-#    signature        = 0x1e 0x96 0x82; ?
-    signature        = 0x1e 0x97 0x82;
-    has_jtag         = yes;
-#    stk500_devcode   = 0xB2;
-#    avr910_devcode   = 0x43;
-    chip_erase_delay = 9000;
-    pagel            = 0xD7;
-    bs2              = 0xA0;
-    reset            = dedicated;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    rampz               = 0x3b;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 2048;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x      x a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0  a2  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x a10  a9  a8",
-			  " a7  a6  a5  a4     a3   0   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 8;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 65536;
-        page_size       = 256;
-        num_pages       = 256;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  x x x x  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
-                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# AT90USB1286
-#------------------------------------------------------------
-
-part
-    id               = "usb1286";
-    desc             = "AT90USB1286";
-    signature        = 0x1e 0x97 0x82;
-    has_jtag         = yes;
-#    stk500_devcode   = 0xB2;
-#    avr910_devcode   = 0x43;
-    chip_erase_delay = 9000;
-    pagel            = 0xD7;
-    bs2              = 0xA0;
-    reset            = dedicated;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    rampz               = 0x3b;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 4096;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0  a2  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x a10  a9  a8",
-			  " a7  a6  a5  a4     a3   0   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 8;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 131072;
-        page_size       = 256;
-        num_pages       = 512;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  x x x x  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
-                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# AT90USB1287
-#------------------------------------------------------------
-# identical to AT90USB1286
-
-part
-    id               = "usb1287";
-    desc             = "AT90USB1287";
-    signature        = 0x1e 0x97 0x82;
-    has_jtag         = yes;
-#    stk500_devcode   = 0xB2;
-#    avr910_devcode   = 0x43;
-    chip_erase_delay = 9000;
-    pagel            = 0xD7;
-    bs2              = 0xA0;
-    reset            = dedicated;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    rampz               = 0x3b;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 4096;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0  a2  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x a10  a9  a8",
-			  " a7  a6  a5  a4     a3   0   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 8;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 131072;
-        page_size       = 256;
-        num_pages       = 512;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  x x x x  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
-                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# ATmega325
-#------------------------------------------------------------
-
-part
-    id               = "m325";
-    desc             = "ATMEGA325";
-    signature        = 0x1e 0x95 0x05;
-    has_jtag         = yes;
-#   stk500_devcode   = 0x??; # No STK500v1 support?
-#   avr910_devcode   = 0x??; # Try the ATmega16 one
-    avr910_devcode   = 0x74;
-    pagel            = 0xd7;
-    bs2              = 0xa0;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "0 0 0 0  0 0 0 0    0 0 0 0  0 0 0 0";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "0 0 0 0  0 0 0 0    0 0 0 0  0 0 0 0";
-
-    timeout             = 200;
-    stabdelay           = 100;
-    cmdexedelay         = 25;
-    synchloops          = 32;
-    bytedelay           = 0;
-    pollindex           = 3;
-    pollvalue           = 0x53;
-    predelay            = 1;
-    postdelay           = 1;
-    pollmethod          = 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 4;  /* for parallel programming */
-        size            = 1024;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   0   0      0   0  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   0   0      0   0  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_lo     = "  1   1   0   0      0   0   0   1",
-                          "  0   0   0   0      0   0   0   0",
-                          "  0   0   0   0      0   0  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  1   1   0   0      0   0   1   0",
-                          "  0   0   0   0      0   0  a9  a8",
-                          " a7  a6  a5  a4     a3  a2   0   0",
-                          "  x   x   x   x      x   x   x   x";
-
-        mode            = 0x41;
-        delay           = 10;
-        blocksize       = 4;
-        readsize        = 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 32768;
-        page_size       = 128;
-        num_pages       = 256;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   0   0      0   0   0   0",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   0   0      0   0   0   0",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  x   x   x   x      x   x   x   x";
-
-        mode            = 0x41;
-        delay           = 10;
-        blocksize       = 128;
-        readsize        = 256;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 0  0 0 0 0",
-                          "0 0 0 0  0 0 0 0   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "0 0 0 0  0 0 0 0   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "0 0 0 0  0 0 0 0   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "0 0 0 0  0 0 0 0  o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "0 0 0 0  0 0 0 0  1 1 1 1  1 i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   0  0  0  0   0  0  0  0",
-                          "0  0  0  0   0  0 a1 a0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "calibration"
-        size            = 1;
-
-        read            = "0 0 1 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-        ;
-  ;
-
-#------------------------------------------------------------
-# ATmega645
-#------------------------------------------------------------
-
-part
-    id               = "m645";
-    desc             = "ATMEGA645";
-    signature        = 0x1E 0x96 0x05;
-    has_jtag         = yes;
-#   stk500_devcode   = 0x??; # No STK500v1 support?
-#   avr910_devcode   = 0x??; # Try the ATmega16 one
-    avr910_devcode   = 0x74;
-    pagel            = 0xd7;
-    bs2              = 0xa0;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "0 0 0 0  0 0 0 0    0 0 0 0  0 0 0 0";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "0 0 0 0  0 0 0 0    0 0 0 0  0 0 0 0";
-
-    timeout             = 200;
-    stabdelay           = 100;
-    cmdexedelay         = 25;
-    synchloops          = 32;
-    bytedelay           = 0;
-    pollindex           = 3;
-    pollvalue           = 0x53;
-    predelay            = 1;
-    postdelay           = 1;
-    pollmethod          = 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 2048;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   0   0      0 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   0   0      0 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_lo     = "  1   1   0   0      0   0   0   1",
-                          "  0   0   0   0      0   0   0   0",
-                          "  0   0   0   0      0  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  1   1   0   0      0   0   1   0",
-                          "  0   0   0   0      0 a10  a9  a8",
-                          " a7  a6  a5  a4     a3   0   0   0",
-                          "  x   x   x   x      x   x   x   x";
-
-        mode            = 0x41;
-        delay           = 10;
-        blocksize       = 8;
-        readsize        = 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 65536;
-        page_size       = 256;
-        num_pages       = 256;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "   0   0   1   0      0   0   0   0",
-                          " a15 a14 a13 a12    a11 a10  a9  a8",
-                          "  a7  a6  a5  a4     a3  a2  a1  a0",
-                          "   o   o   o   o      o   o   o   o";
-
-        read_hi         = "   0   0   1   0      1   0   0   0",
-                          " a15 a14 a13 a12    a11 a10  a9  a8",
-                          "  a7  a6  a5  a4     a3  a2  a1  a0",
-                          "   o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   0   0      0   0   0   0",
-                          "  a7 a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   0   0      0   0   0   0",
-                          "  a7 a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "   0   1   0   0      1   1   0   0",
-                          " a15 a14 a13 a12    a11 a10  a9  a8",
-                          "  a7  a6  a5  a4     a3  a2  a1  a0",
-                          "   0   0   0   0      0   0   0   0";
-
-        mode            = 0x41;
-        delay           = 10;
-        blocksize       = 128;
-        readsize        = 256;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 0  0 0 0 0",
-                          "0 0 0 0  0 0 0 0   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "0 0 0 0  0 0 0 0   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "0 0 0 0  0 0 0 0   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "0 0 0 0  0 0 0 0  o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "0 0 0 0  0 0 0 0  1 1 1 1  1 i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   0  0  0  0   0  0  0  0",
-                          "0  0  0  0   0  0 a1 a0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "calibration"
-        size            = 1;
-
-        read            = "0 0 1 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-        ;
-  ;
-
-#------------------------------------------------------------
-# ATmega3250
-#------------------------------------------------------------
-
-part
-    id               = "m3250";
-    desc             = "ATMEGA3250";
-    signature        = 0x1E 0x95 0x06;
-    has_jtag         = yes;
-#   stk500_devcode   = 0x??; # No STK500v1 support?
-#   avr910_devcode   = 0x??; # Try the ATmega16 one
-    avr910_devcode   = 0x74;
-    pagel            = 0xd7;
-    bs2              = 0xa0;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "0 0 0 0  0 0 0 0    0 0 0 0  0 0 0 0";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "0 0 0 0  0 0 0 0    0 0 0 0  0 0 0 0";
-
-    timeout             = 200;
-    stabdelay           = 100;
-    cmdexedelay         = 25;
-    synchloops          = 32;
-    bytedelay           = 0;
-    pollindex           = 3;
-    pollvalue           = 0x53;
-    predelay            = 1;
-    postdelay           = 1;
-    pollmethod          = 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 4;  /* for parallel programming */
-        size            = 1024;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   0   0      0   0  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   0   0      0   0  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_lo     = "  1   1   0   0      0   0   0   1",
-                          "  0   0   0   0      0   0   0   0",
-                          "  0   0   0   0      0   0  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  1   1   0   0      0   0   1   0",
-                          "  0   0   0   0      0   0  a9  a8",
-                          " a7  a6  a5  a4     a3  a2   0   0",
-                          "  x   x   x   x      x   x   x   x";
-
-        mode            = 0x41;
-        delay           = 10;
-        blocksize       = 4;
-        readsize        = 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 32768;
-        page_size       = 128;
-        num_pages       = 256;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   0   0      0   0   0   0",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   0   0      0   0   0   0",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  x   x   x   x      x   x   x   x";
-
-        mode            = 0x41;
-        delay           = 10;
-        blocksize       = 128;
-        readsize        = 256;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 0  0 0 0 0",
-                          "0 0 0 0  0 0 0 0   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "0 0 0 0  0 0 0 0   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "0 0 0 0  0 0 0 0   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "0 0 0 0  0 0 0 0  o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "0 0 0 0  0 0 0 0  1 1 1 1  1 i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   0  0  0  0   0  0  0  0",
-                          "0  0  0  0   0  0 a1 a0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "calibration"
-        size            = 1;
-
-        read            = "0 0 1 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-        ;
-  ;
-
-#------------------------------------------------------------
-# ATmega6450
-#------------------------------------------------------------
-
-part
-    id               = "m6450";
-    desc             = "ATMEGA6450";
-    signature        = 0x1E 0x96 0x06;
-    has_jtag         = yes;
-#   stk500_devcode   = 0x??; # No STK500v1 support?
-#   avr910_devcode   = 0x??; # Try the ATmega16 one
-    avr910_devcode   = 0x74;
-    pagel            = 0xd7;
-    bs2              = 0xa0;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "0 0 0 0  0 0 0 0    0 0 0 0  0 0 0 0";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "0 0 0 0  0 0 0 0    0 0 0 0  0 0 0 0";
-
-    timeout             = 200;
-    stabdelay           = 100;
-    cmdexedelay         = 25;
-    synchloops          = 32;
-    bytedelay           = 0;
-    pollindex           = 3;
-    pollvalue           = 0x53;
-    predelay            = 1;
-    postdelay           = 1;
-    pollmethod          = 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 2048;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   0   0      0 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   0   0      0 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_lo     = "  1   1   0   0      0   0   0   1",
-                          "  0   0   0   0      0   0   0   0",
-                          "  0   0   0   0      0  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  1   1   0   0      0   0   1   0",
-                          "  0   0   0   0      0 a10  a9  a8",
-                          " a7  a6  a5  a4     a3   0   0   0",
-                          "  x   x   x   x      x   x   x   x";
-
-        mode            = 0x41;
-        delay           = 10;
-        blocksize       = 4;
-        readsize        = 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 65536;
-        page_size       = 256;
-        num_pages       = 256;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "   0   0   1   0      0   0   0   0",
-                          " a15 a14 a13 a12    a11 a10  a9  a8",
-                          "  a7  a6  a5  a4     a3  a2  a1  a0",
-                          "   o   o   o   o      o   o   o   o";
-
-        read_hi         = "   0   0   1   0      1   0   0   0",
-                          " a15 a14 a13 a12    a11 a10  a9  a8",
-                          "  a7  a6  a5  a4     a3  a2  a1  a0",
-                          "   o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   0   0      0   0   0   0",
-                          "  a7 a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   0   0      0   0   0   0",
-                          "  a7 a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "   0   1   0   0      1   1   0   0",
-                          " a15 a14 a13 a12    a11 a10  a9  a8",
-                          "  a7  a6  a5  a4     a3  a2  a1  a0",
-                          "   0   0   0   0      0   0   0   0";
-
-        mode            = 0x41;
-        delay           = 10;
-        blocksize       = 128;
-        readsize        = 256;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 0  0 0 0 0",
-                          "0 0 0 0  0 0 0 0   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "0 0 0 0  0 0 0 0   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "0 0 0 0  0 0 0 0   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "0 0 0 0  0 0 0 0  o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "0 0 0 0  0 0 0 0  1 1 1 1  1 i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   0  0  0  0   0  0  0  0",
-                          "0  0  0  0   0  0 a1 a0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "calibration"
-        size            = 1;
-
-        read            = "0 0 1 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-        ;
-  ;
diff --git a/Marlin/language.h b/Marlin/language.h
index 907a9a5..97e8f9d 100644
--- a/Marlin/language.h
+++ b/Marlin/language.h
@@ -8,13 +8,17 @@
 
 // Languages
 // 1  English
-// 2  -
-// 3  French	(Waiting translation)
+// 2  Polish
+// 3  French	(awaiting translation!)
 // 4  German
 // 5  Spanish
-// 6  Etc
+// 6  Russian
+// 7  Italian
+// 8  Portuguese
 
+#ifndef LANGUAGE_CHOICE
 #define LANGUAGE_CHOICE 1  // Pick your language from the list above
+#endif
 
 #define PROTOCOL_VERSION "1.0"
 
@@ -35,88 +39,79 @@
 	#define WELCOME_MSG MACHINE_NAME " Ready."
 	#define MSG_SD_INSERTED "Card inserted"
 	#define MSG_SD_REMOVED "Card removed"
-	#define MSG_MAIN " Main \003"
-	#define MSG_AUTOSTART " Autostart"
-	#define MSG_DISABLE_STEPPERS " Disable Steppers"
-	#define MSG_AUTO_HOME " Auto Home"
-	#define MSG_SET_ORIGIN " Set Origin"
-	#define MSG_PREHEAT_PLA " Preheat PLA"
-	#define MSG_PREHEAT_PLA_SETTINGS " Preheat PLA Setting"
-	#define MSG_PREHEAT_ABS " Preheat ABS"
-	#define MSG_PREHEAT_ABS_SETTINGS " Preheat ABS Setting"
-	#define MSG_COOLDOWN " Cooldown"
-	#define MSG_EXTRUDE " Extrude"
-	#define MSG_RETRACT " Retract"
-	#define MSG_PREHEAT_PLA " Preheat PLA"
-	#define MSG_PREHEAT_ABS " Preheat ABS"
-	#define MSG_MOVE_AXIS " Move Axis      \x7E"
-	#define MSG_SPEED " Speed:"
-	#define MSG_NOZZLE " \002Nozzle:"
-	#define MSG_NOZZLE1 " \002Nozzle2:"
-	#define MSG_NOZZLE2 " \002Nozzle3:"
-	#define MSG_BED " \002Bed:"
-	#define MSG_FAN_SPEED " Fan speed:"
-	#define MSG_FLOW " Flow:"
-	#define MSG_CONTROL " Control \003"
-	#define MSG_MIN " \002 Min:"
-	#define MSG_MAX " \002 Max:"
-	#define MSG_FACTOR " \002 Fact:"
-	#define MSG_AUTOTEMP " Autotemp:"
+	#define MSG_MAIN "Main"
+	#define MSG_AUTOSTART "Autostart"
+	#define MSG_DISABLE_STEPPERS "Disable Steppers"
+	#define MSG_AUTO_HOME "Auto Home"
+	#define MSG_SET_ORIGIN "Set Origin"
+	#define MSG_PREHEAT_PLA "Preheat PLA"
+	#define MSG_PREHEAT_PLA_SETTINGS "Preheat PLA Conf"
+	#define MSG_PREHEAT_ABS "Preheat ABS"
+	#define MSG_PREHEAT_ABS_SETTINGS "Preheat ABS Conf"
+	#define MSG_COOLDOWN "Cooldown"
+	#define MSG_EXTRUDE "Extrude"
+	#define MSG_RETRACT "Retract"
+	#define MSG_MOVE_AXIS "Move Axis"
+	#define MSG_SPEED "Speed"
+	#define MSG_NOZZLE "Nozzle"
+	#define MSG_NOZZLE1 "Nozzle2"
+	#define MSG_NOZZLE2 "Nozzle3"
+	#define MSG_BED "Bed"
+	#define MSG_FAN_SPEED "Fan speed"
+	#define MSG_FLOW "Flow"
+	#define MSG_CONTROL "Control"
+	#define MSG_MIN " \002 Min"
+	#define MSG_MAX " \002 Max"
+	#define MSG_FACTOR " \002 Fact"
+	#define MSG_AUTOTEMP "Autotemp"
 	#define MSG_ON "On "
 	#define MSG_OFF "Off"
-	#define MSG_PID_P " PID-P: "
-	#define MSG_PID_I " PID-I: "
-	#define MSG_PID_D " PID-D: "
-	#define MSG_PID_C " PID-C: "
-	#define MSG_ACC  " Acc:"
-	#define MSG_VXY_JERK " Vxy-jerk: "
-	#define MSG_VMAX " Vmax "
-	#define MSG_X "x:"
-	#define MSG_Y "y:"
-	#define MSG_Z "z:"
-	#define MSG_E "e:"
-	#define MSG_VMIN " Vmin:"
-	#define MSG_VTRAV_MIN " VTrav min:"
-	#define MSG_AMAX " Amax "
-	#define MSG_A_RETRACT " A-retract:"
-	#define MSG_XSTEPS " Xsteps/mm:"
-	#define MSG_YSTEPS " Ysteps/mm:"
-	#define MSG_ZSTEPS " Zsteps/mm:"
-	#define MSG_ESTEPS " Esteps/mm:"
-	#define MSG_MAIN_WIDE " Main        \003"
-	#define MSG_RECTRACT_WIDE " Rectract    \x7E"
-	#define MSG_TEMPERATURE_WIDE " Temperature \x7E"
-	#define MSG_TEMPERATURE_RTN " Temperature  \003"
-	#define MSG_MOTION_WIDE " Motion      \x7E"
-	#define MSG_STORE_EPROM " Store memory"
-	#define MSG_LOAD_EPROM " Load memory"
-	#define MSG_RESTORE_FAILSAFE " Restore Failsafe"
-	#define MSG_REFRESH "\004Refresh"
-	#define MSG_WATCH " Watch   \003"
-	#define MSG_PREPARE " Prepare \x7E"
-	#define MSG_PREPARE_ALT " Prepare \003"
-	#define MSG_CONTROL_ARROW " Control \x7E"
-	#define MSG_RETRACT_ARROW " Retract \x7E"
-	#define MSG_TUNE " Tune    \x7E"
-	#define MSG_PAUSE_PRINT " Pause Print \x7E"
-	#define MSG_RESUME_PRINT " Resume Print \x7E"
-	#define MSG_STOP_PRINT " Stop Print   \x7E"
-	#define MSG_CARD_MENU " Card Menu    \x7E"
-	#define MSG_NO_CARD " No Card"
+	#define MSG_PID_P "PID-P"
+	#define MSG_PID_I "PID-I"
+	#define MSG_PID_D "PID-D"
+	#define MSG_PID_C "PID-C"
+	#define MSG_ACC  "Accel"
+	#define MSG_VXY_JERK "Vxy-jerk"
+	#define MSG_VMAX "Vmax "
+	#define MSG_X "x"
+	#define MSG_Y "y"
+	#define MSG_Z "z"
+	#define MSG_E "e"
+	#define MSG_VMIN "Vmin"
+	#define MSG_VTRAV_MIN "VTrav min"
+	#define MSG_AMAX "Amax "
+	#define MSG_A_RETRACT "A-retract"
+	#define MSG_XSTEPS "Xsteps/mm"
+	#define MSG_YSTEPS "Ysteps/mm"
+	#define MSG_ZSTEPS "Zsteps/mm"
+	#define MSG_ESTEPS "Esteps/mm"
+	#define MSG_RECTRACT "Rectract"
+	#define MSG_TEMPERATURE "Temperature"
+	#define MSG_MOTION "Motion"
+	#define MSG_STORE_EPROM "Store memory"
+	#define MSG_LOAD_EPROM "Load memory"
+	#define MSG_RESTORE_FAILSAFE "Restore Failsafe"
+	#define MSG_REFRESH "Refresh"
+	#define MSG_WATCH "Watch"
+	#define MSG_PREPARE "Prepare"
+	#define MSG_TUNE "Tune"
+	#define MSG_PAUSE_PRINT "Pause Print"
+	#define MSG_RESUME_PRINT "Resume Print"
+	#define MSG_STOP_PRINT "Stop Print"
+	#define MSG_CARD_MENU "Card Menu"
+	#define MSG_NO_CARD "No Card"
 	#define MSG_DWELL "Sleep..."
 	#define MSG_USERWAIT "Wait for user..."
+	#define MSG_RESUMING "Resuming print"
 	#define MSG_NO_MOVE "No move."
-	#define MSG_PART_RELEASE "Partial Release"
 	#define MSG_KILLED "KILLED. "
 	#define MSG_STOPPED "STOPPED. "
-	#define MSG_STEPPER_RELEASED "Released."
-	#define MSG_CONTROL_RETRACT  " Retract mm:"
-	#define MSG_CONTROL_RETRACTF " Retract  F:"
-	#define MSG_CONTROL_RETRACT_ZLIFT " Hop mm:"
-	#define MSG_CONTROL_RETRACT_RECOVER " UnRet +mm:"
-	#define MSG_CONTROL_RETRACT_RECOVERF " UnRet  F:"
-	#define MSG_AUTORETRACT " AutoRetr.:"
-        #define MSG_SERIAL_ERROR_MENU_STRUCTURE "Something is wrong in the MenuStructure."
+	#define MSG_CONTROL_RETRACT  "Retract mm"
+	#define MSG_CONTROL_RETRACTF "Retract  F"
+	#define MSG_CONTROL_RETRACT_ZLIFT "Hop mm"
+	#define MSG_CONTROL_RETRACT_RECOVER "UnRet +mm"
+	#define MSG_CONTROL_RETRACT_RECOVERF "UnRet  F"
+	#define MSG_AUTORETRACT "AutoRetr."
 
 // Serial Console Messages
 
@@ -133,27 +128,27 @@
 	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
 	#define MSG_OK "ok"
 	#define MSG_FILE_SAVED "Done saving file."
-	#define MSG_ERR_LINE_NO "Line Number is not Last Line Number+1, Last Line:"
-	#define MSG_ERR_CHECKSUM_MISMATCH "checksum mismatch, Last Line:"
-	#define MSG_ERR_NO_CHECKSUM "No Checksum with line number, Last Line:"
-	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "No Line Number with checksum, Last Line:"
+	#define MSG_ERR_LINE_NO "Line Number is not Last Line Number+1, Last Line: "
+	#define MSG_ERR_CHECKSUM_MISMATCH "checksum mismatch, Last Line: "
+	#define MSG_ERR_NO_CHECKSUM "No Checksum with line number, Last Line: "
+	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "No Line Number with checksum, Last Line: "
 	#define MSG_FILE_PRINTED "Done printing file"
 	#define MSG_BEGIN_FILE_LIST "Begin file list"
 	#define MSG_END_FILE_LIST "End file list"
 	#define MSG_M104_INVALID_EXTRUDER "M104 Invalid extruder "
 	#define MSG_M105_INVALID_EXTRUDER "M105 Invalid extruder "
-	#define MSG_ERR_NO_THERMISTORS "No thermistors - no temp"
+	#define MSG_ERR_NO_THERMISTORS "No thermistors - no temperature"
 	#define MSG_M109_INVALID_EXTRUDER "M109 Invalid extruder "
 	#define MSG_HEATING "Heating..."
 	#define MSG_HEATING_COMPLETE "Heating done."
 	#define MSG_BED_HEATING "Bed Heating."
 	#define MSG_BED_DONE "Bed done."
 	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
-	#define MSG_COUNT_X " Count X:"
-	#define MSG_ERR_KILLED "Printer halted. kill() called !!"
-	#define MSG_ERR_STOPPED "Printer stopped due to errors. Fix the error and use M999 to restart!. (Temperature is reset. Set it before restarting)"
-	#define MSG_RESEND "Resend:"
-	#define MSG_UNKNOWN_COMMAND "Unknown command:\""
+	#define MSG_COUNT_X " Count X: "
+	#define MSG_ERR_KILLED "Printer halted. kill() called!"
+	#define MSG_ERR_STOPPED "Printer stopped due to errors. Fix the error and use M999 to restart. (Temperature is reset. Set it after restarting)"
+	#define MSG_RESEND "Resend: "
+	#define MSG_UNKNOWN_COMMAND "Unknown command: \""
 	#define MSG_ACTIVE_EXTRUDER "Active Extruder: "
 	#define MSG_INVALID_EXTRUDER "Invalid extruder"
 	#define MSG_X_MIN "x_min: "
@@ -173,21 +168,336 @@
 	#define MSG_SD_CARD_OK "SD card ok"
 	#define MSG_SD_WORKDIR_FAIL "workDir open failed"
 	#define MSG_SD_OPEN_FILE_FAIL "open failed, File: "
-	#define MSG_SD_FILE_OPENED "File opened:"
-	#define MSG_SD_SIZE " Size:"
+	#define MSG_SD_FILE_OPENED "File opened: "
+	#define MSG_SD_SIZE " Size: "
 	#define MSG_SD_FILE_SELECTED "File selected"
 	#define MSG_SD_WRITE_TO_FILE "Writing to file: "
 	#define MSG_SD_PRINTING_BYTE "SD printing byte "
 	#define MSG_SD_NOT_PRINTING "Not SD printing"
 	#define MSG_SD_ERR_WRITE_TO_FILE "error writing to file"
-	#define MSG_SD_CANT_ENTER_SUBDIR "Cannot enter subdir:"
+	#define MSG_SD_CANT_ENTER_SUBDIR "Cannot enter subdir: "
 
-	#define MSG_STEPPER_TO_HIGH "Steprate to high : "
+	#define MSG_STEPPER_TO_HIGH "Steprate to high: "
 	#define MSG_ENDSTOPS_HIT "endstops hit: "
 	#define MSG_ERR_COLD_EXTRUDE_STOP " cold extrusion prevented"
 	#define MSG_ERR_LONG_EXTRUDE_STOP " too long extrusion prevented"
 
 #endif
+
+
+#if LANGUAGE_CHOICE == 2
+
+// LCD Menu Messages
+	#define WELCOME_MSG MACHINE_NAME " Gotowe."
+	#define MSG_SD_INSERTED "Karta wlozona"
+	#define MSG_SD_REMOVED "Karta usunieta"
+	#define MSG_MAIN "Main"
+	#define MSG_AUTOSTART "Autostart"
+	#define MSG_DISABLE_STEPPERS "Wylacz silniki"
+	#define MSG_AUTO_HOME "Auto. poz. zerowa"
+	#define MSG_SET_ORIGIN "Ustaw punkt zerowy"
+	#define MSG_PREHEAT_PLA "Rozgrzej PLA"
+	#define MSG_PREHEAT_PLA_SETTINGS "Ustawienia roz. PLA"
+	#define MSG_PREHEAT_ABS "Rozgrzej ABS"
+	#define MSG_PREHEAT_ABS_SETTINGS "Ustawienia roz. ABS"
+	#define MSG_COOLDOWN "Chlodzenie"
+	#define MSG_EXTRUDE "Ekstruzja"
+	#define MSG_RETRACT "Cofanie"
+	#define MSG_MOVE_AXIS "Ruch osi"
+	#define MSG_SPEED "Predkosc"
+	#define MSG_NOZZLE "Dysza"
+	#define MSG_NOZZLE1 "Dysza2"
+	#define MSG_NOZZLE2 "Dysza3"
+	#define MSG_BED "Loze"
+	#define MSG_FAN_SPEED "Obroty wiatraka"
+	#define MSG_FLOW "Przeplyw"
+	#define MSG_CONTROL "Kontrola"
+	#define MSG_MIN " \002 Min"
+	#define MSG_MAX " \002 Max"
+	#define MSG_FACTOR " \002 Mnoznik"
+	#define MSG_AUTOTEMP "Auto. temp."
+	#define MSG_ON "Wl. "
+	#define MSG_OFF "Wyl."
+	#define MSG_PID_P "PID-P"
+	#define MSG_PID_I "PID-I"
+	#define MSG_PID_D "PID-D"
+	#define MSG_PID_C "PID-C"
+	#define MSG_ACC  "Acc"
+	#define MSG_VXY_JERK "Zryw Vxy"
+	#define MSG_VMAX "Vmax"
+	#define MSG_X "x"
+	#define MSG_Y "y"
+	#define MSG_Z "z"
+	#define MSG_E "e"
+	#define MSG_VMIN "Vmin"
+	#define MSG_VTRAV_MIN "Vskok min"
+	#define MSG_AMAX "Amax"
+	#define MSG_A_RETRACT "A-wycofanie"
+	#define MSG_XSTEPS "krokiX/mm"
+	#define MSG_YSTEPS "krokiY/mm"
+	#define MSG_ZSTEPS "krokiZ/mm"
+	#define MSG_ESTEPS "krokiE/mm"
+	#define MSG_RECTRACT "Wycofanie"
+	#define MSG_TEMPERATURE "Temperatura"
+	#define MSG_MOTION "Ruch"
+	#define MSG_STORE_EPROM "Zapisz w pamieci"
+	#define MSG_LOAD_EPROM "Wczytaj z pamieci"
+	#define MSG_RESTORE_FAILSAFE " Ustawienia fabryczne"
+	#define MSG_REFRESH "\004Odswiez"
+	#define MSG_WATCH "Obserwuj"
+	#define MSG_PREPARE "Przygotuj"
+	#define MSG_CONTROL "Kontroluj"
+	#define MSG_TUNE "Strojenie"
+	#define MSG_PAUSE_PRINT "Pauza"
+	#define MSG_RESUME_PRINT "Wznowienie"
+	#define MSG_STOP_PRINT "Stop"
+	#define MSG_CARD_MENU "Menu SDCard"
+	#define MSG_NO_CARD "Brak karty"
+	#define MSG_DWELL "Uspij..."
+	#define MSG_USERWAIT "Czekaj na uzytkownika..."
+	#define MSG_NO_MOVE "Brak ruchu."
+	#define MSG_PART_RELEASE "Czesciowe zwolnienie"
+	#define MSG_KILLED "Ubity. "
+	#define MSG_STOPPED "Zatrzymany. "
+	#define MSG_STEPPER_RELEASED "Zwolniony."
+	#define MSG_CONTROL_RETRACT  "Wycofaj mm"
+	#define MSG_CONTROL_RETRACTF "Wycofaj  F"
+	#define MSG_CONTROL_RETRACT_ZLIFT "Skok Z mm:"
+	#define MSG_CONTROL_RETRACT_RECOVER "Cof. wycof. +mm"
+	#define MSG_CONTROL_RETRACT_RECOVERF "Cof. wycof.  F"
+	#define MSG_AUTORETRACT "Auto. wycofanie"
+
+// Serial Console Messages
+
+	#define MSG_Enqueing "Kolejkowanie \""
+	#define MSG_POWERUP "Zasilanie wlaczone"
+	#define MSG_EXTERNAL_RESET " Reset (zewnetrzny)"
+	#define MSG_BROWNOUT_RESET " Reset (spadek napiecia)"
+	#define MSG_WATCHDOG_RESET " Reset (watchdog)"
+	#define MSG_SOFTWARE_RESET " Reset (programowy)"
+	#define MSG_MARLIN "Marlin "
+	#define MSG_AUTHOR " | Autor: "
+	#define MSG_CONFIGURATION_VER " Ostatnia aktualizacja: "
+	#define MSG_FREE_MEMORY " Wolna pamiec: "
+	#define MSG_PLANNER_BUFFER_BYTES "  Bufor planisty krokow (w bajtach): "
+	#define MSG_OK "ok"
+	#define MSG_FILE_SAVED "Plik zapisany."
+	#define MSG_ERR_LINE_NO "Numer linijki nie jest ostatnim numerem linijki+1; ostatnia linijka:"
+	#define MSG_ERR_CHECKSUM_MISMATCH "Niezgodna suma kontrolna; ostatnia linijka: "
+	#define MSG_ERR_NO_CHECKSUM "Brak sumy kontrolnej w linijce; ostatnia linijka:"
+	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Brak numery linijki przy sumie kontrolnej; ostatnia linijka:"
+	#define MSG_FILE_PRINTED "Ukonczono wydruk z pliku"
+	#define MSG_BEGIN_FILE_LIST "Start listy plikow"
+	#define MSG_END_FILE_LIST "Koniec listy plikow"
+	#define MSG_M104_INVALID_EXTRUDER "M104 Niepoprawny ekstruder "
+	#define MSG_M105_INVALID_EXTRUDER "M105 Niepoprawny ekstruder "
+	#define MSG_ERR_NO_THERMISTORS "Brak termistorow - brak temperatury :("
+	#define MSG_M109_INVALID_EXTRUDER "M109 Niepoprawny ekstruder "
+	#define MSG_HEATING "Nagrzewanie ekstrudera..."
+	#define MSG_HEATING_COMPLETE "Nagrzewanie ekstrudera zakonczone."
+	#define MSG_BED_HEATING "Nagrzewanie loza..."
+	#define MSG_BED_DONE "Nagrzewanie loza zakonczone."
+	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
+	#define MSG_COUNT_X " Liczenie X: "
+	#define MSG_ERR_KILLED "Drukarka zatrzymana. Wywolano kill()"
+	#define MSG_ERR_STOPPED "Drukarka zatrzymana z powodu bledu. Usun problem i zrestartuj drukartke komenda M999. (temperatura zostala zresetowana; ustaw temperature po restarcie)"
+	#define MSG_RESEND "Wyslij ponownie: "
+	#define MSG_UNKNOWN_COMMAND "Nieznane polecenie: \""
+	#define MSG_ACTIVE_EXTRUDER "Aktywny ekstruder: "
+	#define MSG_INVALID_EXTRUDER "Niepoprawny ekstruder"
+	#define MSG_X_MIN "x_min: "
+	#define MSG_X_MAX "x_max: "
+	#define MSG_Y_MIN "y_min: "
+	#define MSG_Y_MAX "y_max: "
+	#define MSG_Z_MIN "z_min: "
+	#define MSG_Z_MAX "z_max: "
+	#define MSG_M119_REPORT "Zgloszenie statusu wylacznikow krancowych"
+	#define MSG_ENDSTOP_HIT "WYZWOLONY"
+	#define MSG_ENDSTOP_OPEN "otwarty"
+
+	#define MSG_SD_CANT_OPEN_SUBDIR "Nie mozna otworzyc podkatalogu"
+	#define MSG_SD_INIT_FAIL "Blad inicjalizacji karty SD"
+	#define MSG_SD_VOL_INIT_FAIL "Blad inizjalizacji wolumenu"
+	#define MSG_SD_OPENROOT_FAIL "Blad odczytywania katalogu glownego"
+	#define MSG_SD_CARD_OK "Karta SD zainicjalizowana"
+	#define MSG_SD_WORKDIR_FAIL "Blad odczytywania katalogu roboczego"
+	#define MSG_SD_OPEN_FILE_FAIL "Nie mozna otworzyc pliku: "
+	#define MSG_SD_FILE_OPENED "Otwarto plik:"
+	#define MSG_SD_SIZE " Rozmiar:"
+	#define MSG_SD_FILE_SELECTED "Wybrano plik"
+	#define MSG_SD_WRITE_TO_FILE "Zapisywanie do pliku: "
+	#define MSG_SD_PRINTING_BYTE "Drukowanie z karty SD, bajt "
+	#define MSG_SD_NOT_PRINTING "Nie trwa drukowanie z karty SD"
+	#define MSG_SD_ERR_WRITE_TO_FILE "blad podczas zapisu do pliku"
+	#define MSG_SD_CANT_ENTER_SUBDIR "Nie mozna odczytac podkatalogu: "
+
+	#define MSG_STEPPER_TO_HIGH "Za duza czestotliwosc krokow: "
+	#define MSG_ENDSTOPS_HIT "Wylacznik krancowy zostal wyzwolony na pozycji: "
+	#define MSG_ERR_COLD_EXTRUDE_STOP " uniemozliwiono zimna ekstruzje"
+	#define MSG_ERR_LONG_EXTRUDE_STOP " uniemozliwiono zbyt dluga ekstruzje"
+
+#endif
+
+
+#if LANGUAGE_CHOICE == 3
+
+#define WELCOME_MSG MACHINE_NAME " Pret."
+#define MSG_SD_INSERTED "Carte inseree"
+#define MSG_SD_REMOVED "Carte retiree"
+#define MSG_MAIN " Principal \003"
+#define MSG_AUTOSTART " Demarrage auto."
+#define MSG_DISABLE_STEPPERS " Desactiver moteurs"
+#define MSG_AUTO_HOME " Home auto."
+#define MSG_SET_ORIGIN " Regler origine"
+#define MSG_PREHEAT_PLA " Prechauffage PLA"
+#define MSG_PREHEAT_PLA_SETTINGS " Regl. prechauffe PLA"
+#define MSG_PREHEAT_ABS " Prechauffage ABS"
+#define MSG_PREHEAT_ABS_SETTINGS " Regl. prechauffe ABS"
+#define MSG_COOLDOWN " Refroidissement"
+#define MSG_EXTRUDE " Extrusion"
+#define MSG_RETRACT " Retractation"
+#define MSG_PREHEAT_PLA " Prechauffage PLA"
+#define MSG_PREHEAT_ABS " Prechauffage ABS"
+#define MSG_MOVE_AXIS " Deplacer axe \x7E"
+#define MSG_SPEED " Vitesse:"
+#define MSG_NOZZLE " \002Buse:"
+#define MSG_NOZZLE1 " \002Buse2:"
+#define MSG_NOZZLE2 " \002Buse3:"
+#define MSG_BED " \002Lit:"
+#define MSG_FAN_SPEED " Vitesse ventilateur:"
+#define MSG_FLOW " Flux:"
+#define MSG_CONTROL " Controle \003"
+#define MSG_MIN " \002 Min:"
+#define MSG_MAX " \002 Max:"
+#define MSG_FACTOR " \002 Facteur:"
+#define MSG_AUTOTEMP " Temp. Auto.:"
+#define MSG_ON "Marche "
+#define MSG_OFF "Arret"
+#define MSG_PID_P " PID-P: "
+#define MSG_PID_I " PID-I: "
+#define MSG_PID_D " PID-D: "
+#define MSG_PID_C " PID-C: "
+#define MSG_ACC " Acc:"
+#define MSG_VXY_JERK " Vxy-jerk: "
+#define MSG_VMAX " Vmax "
+#define MSG_X "x:"
+#define MSG_Y "y:"
+#define MSG_Z "z:"
+#define MSG_E "e:"
+#define MSG_VMIN " Vmin:"
+#define MSG_VTRAV_MIN " Vdepl min:"
+#define MSG_AMAX " Amax "
+#define MSG_A_RETRACT " A-retract:"
+#define MSG_XSTEPS " Xpas/mm:"
+#define MSG_YSTEPS " Ypas/mm:"
+#define MSG_ZSTEPS " Zpas/mm:"
+#define MSG_ESTEPS " Epas/mm:"
+#define MSG_MAIN_WIDE " Principal \003"
+#define MSG_RECTRACT_WIDE " Rectractater \x7E"
+#define MSG_TEMPERATURE_WIDE " Temperature \x7E"
+#define MSG_TEMPERATURE_RTN " Temperature \003"
+#define MSG_MOTION_WIDE " Mouvement \x7E"
+#define MSG_STORE_EPROM " Sauvegarder memoire"
+#define MSG_LOAD_EPROM " Lire memoire"
+#define MSG_RESTORE_FAILSAFE " Restaurer memoire"
+#define MSG_REFRESH "\004Actualiser"
+#define MSG_WATCH " Surveiller \003"
+#define MSG_PREPARE " Preparer \x7E"
+#define MSG_PREPARE_ALT " Prepare \003"
+#define MSG_CONTROL_ARROW " Controle \x7E"
+#define MSG_RETRACT_ARROW " Retracter \x7E"
+#define MSG_TUNE " Regler \x7E"
+#define MSG_PAUSE_PRINT " Pause impression \x7E"
+#define MSG_RESUME_PRINT " Reprendre impression \x7E"
+#define MSG_STOP_PRINT " Arreter impression \x7E"
+#define MSG_CARD_MENU " Menu carte \x7E"
+#define MSG_NO_CARD " Pas de carte"
+#define MSG_DWELL "Repos..."
+#define MSG_USERWAIT "Attente de l'utilisateur..."
+#define MSG_NO_MOVE "Aucun mouvement."
+#define MSG_PART_RELEASE "Relache partielle"
+#define MSG_KILLED "TUE."
+#define MSG_STOPPED "STOPPE."
+#define MSG_STEPPER_RELEASED "RELACHE."
+#define MSG_CONTROL_RETRACT " Retractation mm:"
+#define MSG_CONTROL_RETRACTF " Retractation F:"
+#define MSG_CONTROL_RETRACT_ZLIFT " Hop mm:"
+#define MSG_CONTROL_RETRACT_RECOVER " UnRet +mm:"
+#define MSG_CONTROL_RETRACT_RECOVERF " UnRet F:"
+#define MSG_AUTORETRACT " Retract. Auto.:"
+
+// Serial Console Messages
+
+#define MSG_Enqueing "Mise en tampon \""
+#define MSG_POWERUP "Allumage"
+#define MSG_EXTERNAL_RESET " RAZ Externe"
+#define MSG_BROWNOUT_RESET " RAZ defaut alim."
+#define MSG_WATCHDOG_RESET " RAZ Watchdog"
+#define MSG_SOFTWARE_RESET " RAZ logicielle"
+#define MSG_MARLIN "Marlin "
+#define MSG_AUTHOR " | Auteur: "
+#define MSG_CONFIGURATION_VER " Derniere MaJ: "
+#define MSG_FREE_MEMORY " Memoire libre: "
+#define MSG_PLANNER_BUFFER_BYTES " PlannerBufferBytes: "
+#define MSG_OK "ok"
+#define MSG_FILE_SAVED "Fichier enregistre."
+#define MSG_ERR_LINE_NO "Le numero de ligne n'est pas la derniere ligne + 1, derniere ligne: "
+#define MSG_ERR_CHECKSUM_MISMATCH "Erreur somme de controle, derniere ligne: "
+#define MSG_ERR_NO_CHECKSUM "Pas de somme de controle avec le numero de ligne, derniere ligne: "
+#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Pas de numero de ligne avec somme de controle, derniere ligne: "
+#define MSG_FILE_PRINTED "Impression terminee"
+#define MSG_BEGIN_FILE_LIST "Debut de la liste de fichiers"
+#define MSG_END_FILE_LIST "Fin de la liste de fichiers"
+#define MSG_M104_INVALID_EXTRUDER "M104 Extruder invalide"
+#define MSG_M105_INVALID_EXTRUDER "M105 Extruder invalide"
+#define MSG_ERR_NO_THERMISTORS "Pas de thermistor, pas de temperature"
+#define MSG_M109_INVALID_EXTRUDER "M109 Extruder invalide "
+#define MSG_HEATING "En chauffe..."
+#define MSG_HEATING_COMPLETE "Chauffe terminee."
+#define MSG_BED_HEATING "Chauffe du lit."
+#define MSG_BED_DONE "Chauffe du lit terminee."
+#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
+#define MSG_COUNT_X " Compteur X: "
+#define MSG_ERR_KILLED "Impression arretee. kill() appelee!"
+#define MSG_ERR_STOPPED "Impression arretee a cause d'erreurs. Corriger les erreurs et utiliser M999 pour la reprendre. (Temperature remise a zero. Reactivez la apres redemarrage)"
+#define MSG_RESEND "Renvoie: "
+#define MSG_UNKNOWN_COMMAND "Commande inconnue: \""
+#define MSG_ACTIVE_EXTRUDER "Extrudeur actif: "
+#define MSG_INVALID_EXTRUDER "Extrudeur invalide"
+#define MSG_X_MIN "x_min: "
+#define MSG_X_MAX "x_max: "
+#define MSG_Y_MIN "y_min: "
+#define MSG_Y_MAX "y_max: "
+#define MSG_Z_MIN "z_min: "
+#define MSG_Z_MAX "z_max: "
+#define MSG_M119_REPORT "Affichage du status des fin de course"
+#define MSG_ENDSTOP_HIT "DECLENCHE"
+#define MSG_ENDSTOP_OPEN "OUVERT"
+
+#define MSG_SD_CANT_OPEN_SUBDIR "Impossible d'ouvrir le sous-repertoire"
+#define MSG_SD_INIT_FAIL "Echec de l'initialisation de la SD"
+#define MSG_SD_VOL_INIT_FAIL "Echec de volume.init"
+#define MSG_SD_OPENROOT_FAIL "Echec openRoot"
+#define MSG_SD_CARD_OK "Carte SD Ok"
+#define MSG_SD_WORKDIR_FAIL "Echec d'ouverture workDir"
+#define MSG_SD_OPEN_FILE_FAIL "Echec d'ouverture, Fichier: "
+#define MSG_SD_FILE_OPENED "Fichier ouvert: "
+#define MSG_SD_SIZE " Taille: "
+#define MSG_SD_FILE_SELECTED "Fichier selectionne"
+#define MSG_SD_WRITE_TO_FILE "Ecriture dans le fichier: "
+#define MSG_SD_PRINTING_BYTE "Octet impression SD "
+#define MSG_SD_NOT_PRINTING "Pas d'impression SD"
+#define MSG_SD_ERR_WRITE_TO_FILE "Erreur d'ecriture dans le fichier"
+#define MSG_SD_CANT_ENTER_SUBDIR "Impossible d'entrer dans le sous-repertoire: "
+
+#define MSG_STEPPER_TO_HIGH "Steprate trop eleve: "
+#define MSG_ENDSTOPS_HIT "Fin de course atteint: "
+#define MSG_ERR_COLD_EXTRUDE_STOP " Extrusion a froid evitee"
+#define MSG_ERR_LONG_EXTRUDE_STOP " Extrusion longue evitee"
+	
+#endif
+
+
 #if LANGUAGE_CHOICE == 4
 
 // LCD Menu Messages
@@ -196,85 +506,82 @@
 
 	#define MSG_SD_INSERTED      "SDKarte erkannt"
 	#define MSG_SD_REMOVED       "SDKarte entfernt"
-	#define MSG_MAIN             " Hauptmne \003"
-	#define MSG_AUTOSTART        " Autostart"
-	#define MSG_DISABLE_STEPPERS " Stepper abschalten"
-	#define MSG_AUTO_HOME        " Auto Nullpunkt"
-	#define MSG_SET_ORIGIN       " Setze Nullpunkt"
-	#define MSG_PREHEAT_PLA      " Vorwrmen PLA"
-	#define MSG_PREHEAT_PLA_SETTINGS " Vorwrmen PLA Einstellungen"
-	#define MSG_PREHEAT_ABS      " Vorwrmen ABS"
-	#define MSG_PREHEAT_ABS_SETTINGS "  Vorwrmen ABS Einstellungen"
-	#define MSG_COOLDOWN         " Abkhlen"
-	#define MSG_EXTRUDE          " Extrude"
-	#define MSG_RETRACT          " Retract"
-	#define MSG_MOVE_AXIS        " Achsen bewegen\x7E"
-	#define MSG_SPEED            " Geschw:"
-	#define MSG_NOZZLE           " \002Dse:"
-	#define MSG_NOZZLE1          " \002Dse2:"
-	#define MSG_NOZZLE2          " \002Dse3:"
-	#define MSG_BED              " \002Bett:"
-	#define MSG_FAN_SPEED        " Lftergeschw.:"
-	#define MSG_FLOW             " Flu:"
-	#define MSG_CONTROL          " Einstellungen \003"
-	#define MSG_MIN              " \002 Min:"
-	#define MSG_MAX              " \002 Max:"
-	#define MSG_FACTOR           " \002 Faktor:"
-	#define MSG_AUTOTEMP         " AutoTemp:"
-	#define MSG_ON               "Ein "
-	#define MSG_OFF              "Aus "
-	#define MSG_PID_P            " PID-P: "
-	#define MSG_PID_I            " PID-I: "
-	#define MSG_PID_D            " PID-D: "
-	#define MSG_PID_C            " PID-C: "
-	#define MSG_ACC              " Acc:"
-	#define MSG_VXY_JERK         " Vxy-jerk: "
-	#define MSG_VMAX             " Vmax "
-	#define MSG_X                "x:"
-	#define MSG_Y                "y:"
-	#define MSG_Z                "z:"
-	#define MSG_E                "e:"
-	#define MSG_VMIN             " Vmin:"
-	#define MSG_VTRAV_MIN        " VTrav min:"
-	#define MSG_AMAX             " Amax "
-	#define MSG_A_RETRACT        " A-Retract:"
-	#define MSG_XSTEPS           " Xsteps/mm:"
-	#define MSG_YSTEPS           " Ysteps/mm:"
-	#define MSG_ZSTEPS           " Zsteps/mm:"
-	#define MSG_ESTEPS           " Esteps/mm:"
-	#define MSG_MAIN_WIDE        " Hauptmen     \003"
-	#define MSG_RECTRACT_WIDE    " Rectract      \x7E"
-	#define MSG_WATCH            " Beobachten    \003"
-	#define MSG_TEMPERATURE_WIDE " Temperatur    \x7E"
-        #define MSG_TEMPERATURE_RTN  " Temperatur    \003"
-	#define MSG_MOTION_WIDE      " Bewegung      \x7E"
-	#define MSG_STORE_EPROM      " EPROM speichern"
-	#define MSG_LOAD_EPROM       " EPROM laden"
-	#define MSG_RESTORE_FAILSAFE " Standardkonfig."
-	#define MSG_REFRESH          "\004Aktualisieren"
-	#define MSG_PREPARE          " Vorbereitung  \x7E"
-	#define MSG_PREPARE_ALT      " Vorbereitung  \003"
-	#define MSG_CONTROL_ARROW    " Einstellungen \x7E"
-	#define MSG_TUNE             " Justierung    \x7E"
-	#define MSG_PAUSE_PRINT      " Druck anhalten\x7E"
-	#define MSG_RESUME_PRINT     " Druck fortsetz\x7E"
-	#define MSG_STOP_PRINT       " Druck stoppen \x7E"
-	#define MSG_CARD_MENU        " SDKarten Men \x7E"
-	#define MSG_NO_CARD          " Keine SDKarte"
+	#define MSG_MAIN             "Hauptmne"
+	#define MSG_AUTOSTART        "Autostart"
+	#define MSG_DISABLE_STEPPERS "Stepper abschalten"
+	#define MSG_AUTO_HOME        "Auto Nullpunkt"
+	#define MSG_SET_ORIGIN       "Setze Nullpunkt"
+	#define MSG_PREHEAT_PLA      "Vorwrmen PLA"
+	#define MSG_PREHEAT_PLA_SETTINGS "Vorwrmen PLA Einstellungen"
+	#define MSG_PREHEAT_ABS      "Vorwrmen ABS"
+	#define MSG_PREHEAT_ABS_SETTINGS "Vorwrmen ABS Einstellungen"
+	#define MSG_COOLDOWN         "Abkhlen"
+	#define MSG_EXTRUDE          "Extrude"
+	#define MSG_RETRACT          "Retract"
+	#define MSG_MOVE_AXIS        "Achsen bewegen"
+	#define MSG_SPEED            "Geschw"
+	#define MSG_NOZZLE           "Dse"
+	#define MSG_NOZZLE1          "Dse2"
+	#define MSG_NOZZLE2          "Dse3"
+	#define MSG_BED              "Bett"
+	#define MSG_FAN_SPEED        "Lftergeschw."
+	#define MSG_FLOW             "Flu"
+	#define MSG_CONTROL          "Einstellungen"
+	#define MSG_MIN              "\002 Min"
+	#define MSG_MAX              "\002 Max"
+	#define MSG_FACTOR           "\002 Faktor"
+	#define MSG_AUTOTEMP         "AutoTemp"
+	#define MSG_ON               "Ein"
+	#define MSG_OFF              "Aus"
+	#define MSG_PID_P            "PID-P"
+	#define MSG_PID_I            "PID-I"
+	#define MSG_PID_D            "PID-D"
+	#define MSG_PID_C            "PID-C"
+	#define MSG_ACC              "Acc"
+	#define MSG_VXY_JERK         "Vxy-jerk"
+	#define MSG_VMAX             "Vmax "
+	#define MSG_X                "x"
+	#define MSG_Y                "y"
+	#define MSG_Z                "z"
+	#define MSG_E                "e"
+	#define MSG_VMIN             "Vmin"
+	#define MSG_VTRAV_MIN        "VTrav min"
+	#define MSG_AMAX             "Amax "
+	#define MSG_A_RETRACT        "A-Retract"
+	#define MSG_XSTEPS           "Xsteps/mm"
+	#define MSG_YSTEPS           "Ysteps/mm"
+	#define MSG_ZSTEPS           "Zsteps/mm"
+	#define MSG_ESTEPS           "Esteps/mm"
+	#define MSG_RECTRACT_WIDE    "Rectract"
+	#define MSG_WATCH            "Beobachten"
+	#define MSG_TEMPERATURE      "Temperatur"
+	#define MSG_MOTION           "Bewegung"
+	#define MSG_STORE_EPROM      "EPROM speichern"
+	#define MSG_LOAD_EPROM       "EPROM laden"
+	#define MSG_RESTORE_FAILSAFE "Standardkonfig."
+	#define MSG_REFRESH          "Aktualisieren"
+	#define MSG_PREPARE          "Vorbereitung"
+	#define MSG_CONTROL          "Einstellungen"
+	#define MSG_TUNE             "Justierung"
+	#define MSG_PAUSE_PRINT      "Druck anhalten"
+	#define MSG_RESUME_PRINT     "Druck fortsetz"
+	#define MSG_STOP_PRINT       "Druck stoppen"
+	#define MSG_CARD_MENU        "SDKarten Men"
+	#define MSG_NO_CARD          "Keine SDKarte"
 	#define MSG_DWELL            "Warten..."		
 	#define MSG_USERWAIT         "Warte auf Nutzer..."
+    #define MSG_RESUMING         "Druck fortsetzung"
 	#define MSG_NO_MOVE          "Kein Zug."
 	#define MSG_PART_RELEASE     "Stepper tlw frei"
 	#define MSG_KILLED           "KILLED"
 	#define MSG_STOPPED          "GESTOPPT"
 	#define MSG_STEPPER_RELEASED "Stepper frei"
-        #define MSG_CONTROL_RETRACT  " Retract mm:"
-        #define MSG_CONTROL_RETRACTF " Retract  F:"
-        #define MSG_CONTROL_RETRACT_ZLIFT " Hop mm:"
-        #define MSG_CONTROL_RETRACT_RECOVER " UnRet +mm:"
-        #define MSG_CONTROL_RETRACT_RECOVERF " UnRet  F:"
-        #define MSG_AUTORETRACT      " AutoRetr.:"
-	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Fehler in Menstruktur."
+    #define MSG_CONTROL_RETRACT  "Retract mm"
+    #define MSG_CONTROL_RETRACTF "Retract  F"
+    #define MSG_CONTROL_RETRACT_ZLIFT "Hop mm"
+    #define MSG_CONTROL_RETRACT_RECOVER "UnRet +mm"
+    #define MSG_CONTROL_RETRACT_RECOVERF "UnRet  F"
+    #define MSG_AUTORETRACT      "AutoRetr."
 	
 // Serial Console Messages
 
@@ -347,6 +654,7 @@
 
 #endif
 
+
 #if LANGUAGE_CHOICE == 5
 
 // LCD Menu Messages
@@ -360,11 +668,11 @@
 #define MSG_SET_ORIGIN " Establecer Cero"
 #define MSG_COOLDOWN " Enfriar"
 #define MSG_EXTRUDE " Extruir"
-#define MSG_RETRACT " Retract"
+#define MSG_RETRACT " Retraer"
 #define MSG_PREHEAT_PLA " Precalentar PLA"
-#define MSG_PREHEAT_PLA_SETTINGS " Precalentar PLA Setting"
+#define MSG_PREHEAT_PLA_SETTINGS " Ajustar temp. PLA"
 #define MSG_PREHEAT_ABS " Precalentar ABS"
-#define MSG_PREHEAT_ABS_SETTINGS " Precalentar ABS Setting"
+#define MSG_PREHEAT_ABS_SETTINGS " Ajustar temp. ABS"
 #define MSG_MOVE_AXIS " Mover Ejes      \x7E"
 #define MSG_SPEED " Velocidad:"
 #define MSG_NOZZLE " \002Nozzle:"
@@ -412,10 +720,10 @@
 #define MSG_PREPARE " Preparar \x7E"
 #define MSG_PREPARE_ALT " Preparar \003"
 #define MSG_CONTROL_ARROW " Control  \x7E"
-#define MSG_RETRACT_ARROW " Control  \x7E"
+#define MSG_RETRACT_ARROW " Retraer  \x7E"
 #define MSG_TUNE " Ajustar \x7E"
-#define MSG_PAUSE_PRINT " Pause Print \x7E"
-#define MSG_RESUME_PRINT " Resume Print \x7E"
+#define MSG_PAUSE_PRINT " Pausar Impresion \x7E"
+#define MSG_RESUME_PRINT " Reanudar Impresion \x7E"
 #define MSG_STOP_PRINT " Detener Impresion \x7E"
 #define MSG_CARD_MENU " Menu de SD    \x7E"
 #define MSG_NO_CARD " No hay Tarjeta SD"
@@ -432,7 +740,6 @@
 #define MSG_CONTROL_RETRACT_RECOVER " DesRet +mm:"
 #define MSG_CONTROL_RETRACT_RECOVERF " DesRet F:"
 #define MSG_AUTORETRACT " AutoRetr.:"
-#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Hay un error en la estructura del menu"
 
 // Serial Console Messages
 
@@ -477,9 +784,9 @@
 #define MSG_Y_MIN "y_min: "
 #define MSG_Y_MAX "y_max: "
 #define MSG_Z_MIN "z_min: "
-#define MSG_M119_REPORT "Reporting endstop status"
-#define MSG_ENDSTOP_HIT "TRIGGERED"
-#define MSG_ENDSTOP_OPEN "open"
+#define MSG_M119_REPORT "Comprobando fines de carrera."
+#define MSG_ENDSTOP_HIT "PULSADO"
+#define MSG_ENDSTOP_OPEN "abierto"
         
 #define MSG_SD_CANT_OPEN_SUBDIR "No se pudo abrir la subcarpeta."
 #define MSG_SD_INIT_FAIL "Fallo al iniciar la SD"
@@ -495,7 +802,7 @@
 #define MSG_SD_PRINTING_BYTE "SD imprimiendo el byte "
 #define MSG_SD_NOT_PRINTING "No se esta imprimiendo con SD"
 #define MSG_SD_ERR_WRITE_TO_FILE "Error al escribir en el archivo"
-#define MSG_SD_CANT_ENTER_SUBDIR "No se puede entrar en la carpeta:"
+#define MSG_SD_CANT_ENTER_SUBDIR "No se puede abrir la carpeta:"
 
 #define MSG_STEPPER_TO_HIGH "Steprate demasiado alto : "
 #define MSG_ENDSTOPS_HIT "Se ha tocado el fin de carril: "
@@ -503,4 +810,475 @@
 #define MSG_ERR_LONG_EXTRUDE_STOP " extrusion demasiado larga evitada"
 
 #endif
+
+#if LANGUAGE_CHOICE == 6
+
+// LCD Menu Messages
+#define WELCOME_MSG MACHINE_NAME			" "
+#define MSG_SD_INSERTED						" "
+#define MSG_SD_REMOVED						" "
+#define MSG_MAIN							"               \003"
+#define MSG_AUTOSTART						"           "
+#define MSG_DISABLE_STEPPERS				"  "
+#define MSG_AUTO_HOME						"            "
+#define MSG_SET_ORIGIN						"       "
+#define MSG_PREHEAT_PLA						"  PLA     "
+#define MSG_PREHEAT_PLA_SETTINGS			" . .PLA"
+#define MSG_PREHEAT_ABS						"  ABS     "
+#define MSG_PREHEAT_ABS_SETTINGS			" . .ABS"
+#define MSG_COOLDOWN						"          "
+#define MSG_EXTRUDE							"           "
+#define MSG_RETRACT							" "
+#define MSG_MOVE_AXIS						"     \x7E"
+#define MSG_SPEED							" :"
+#define MSG_NOZZLE							" \002 :"
+#define MSG_NOZZLE1							" \002 2:"
+#define MSG_NOZZLE2							" \002 3:"
+#define MSG_BED								" \002 :"
+#define MSG_FAN_SPEED						" :"
+#define MSG_FLOW							" :"
+#define MSG_CONTROL							"  \003"
+#define MSG_MIN								" \002 :"
+#define MSG_MAX								" \002 :"
+#define MSG_FACTOR							" \002 :"
+#define MSG_AUTOTEMP						" Autotemp:"
+#define MSG_ON								". "
+#define MSG_OFF								". "
+#define MSG_PID_P							" PID-P: "
+#define MSG_PID_I							" PID-I: "
+#define MSG_PID_D							" PID-D: "
+#define MSG_PID_C							" PID-C: "
+#define MSG_ACC								" Acc:"
+#define MSG_VXY_JERK						" Vxy-jerk: "
+#define MSG_VMAX							" Vmax "
+#define MSG_X								"x:"
+#define MSG_Y								"y:"
+#define MSG_Z								"z:"
+#define MSG_E								"e:"
+#define MSG_VMIN							" Vmin:"
+#define MSG_VTRAV_MIN						" VTrav min:"
+#define MSG_AMAX							" Amax "
+#define MSG_A_RETRACT						" A-retract:"
+#define MSG_XSTEPS							" X /mm:"
+#define MSG_YSTEPS							" Y /mm:"
+#define MSG_ZSTEPS							" Z /mm:"
+#define MSG_ESTEPS							" E /mm:"
+#define MSG_RECTRACT    					"        \x7E"
+#define MSG_TEMPERATURE  				"        \x7E"
+#define MSG_MOTION						"           \x7E"
+#define MSG_STORE_EPROM						"  "
+#define MSG_LOAD_EPROM						"  "
+#define MSG_RESTORE_FAILSAFE				"       "
+#define MSG_REFRESH							"\004           "
+#define MSG_WATCH							"              \003"
+#define MSG_PREPARE							"           \x7E"
+#define MSG_TUNE					"          \x7E"
+#define MSG_PAUSE_PRINT						"        \x7E"
+#define MSG_RESUME_PRINT					"   \x7E"
+#define MSG_STOP_PRINT						"   \x7E"
+#define MSG_CARD_MENU						"          \x7E"
+#define MSG_NO_CARD							"  "
+#define MSG_DWELL							"..."
+#define MSG_USERWAIT						"  ."
+#define MSG_NO_MOVE							" .       "
+#define MSG_PART_RELEASE					"    "
+#define MSG_KILLED							". "
+#define MSG_STOPPED							". "
+#define MSG_CONTROL_RETRACT					"  mm:"
+#define MSG_CONTROL_RETRACTF				"   F:"
+#define MSG_CONTROL_RETRACT_ZLIFT			"  mm:"
+#define MSG_CONTROL_RETRACT_RECOVER			"  +mm:"
+#define MSG_CONTROL_RETRACT_RECOVERF		"   F:"
+#define MSG_AUTORETRACT						" :"
+
+// Serial Console Messages
+
+#define MSG_Enqueing						" \""
+#define MSG_POWERUP							" "
+#define MSG_EXTERNAL_RESET					"  "
+#define MSG_BROWNOUT_RESET					" Brown out "
+#define MSG_WATCHDOG_RESET					" Watchdog "
+#define MSG_SOFTWARE_RESET					"  "
+#define MSG_MARLIN							"Marlin "
+#define MSG_AUTHOR							" | : "
+#define MSG_CONFIGURATION_VER				"  : "
+#define MSG_FREE_MEMORY						"  : "
+#define MSG_PLANNER_BUFFER_BYTES			"     Bytes: "
+#define MSG_OK								"ok"
+#define MSG_FILE_SAVED						" ."
+#define MSG_ERR_LINE_NO						"     +1,  :"
+#define MSG_ERR_CHECKSUM_MISMATCH			"   ,  :"
+#define MSG_ERR_NO_CHECKSUM					"    ,  :"
+#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM	"    ,  :"
+#define MSG_FILE_PRINTED					"  "
+#define MSG_BEGIN_FILE_LIST					" "
+#define MSG_END_FILE_LIST					"  "
+#define MSG_M104_INVALID_EXTRUDER			"M104   "
+#define MSG_M105_INVALID_EXTRUDER			"M105   "
+#define MSG_ERR_NO_THERMISTORS				"  -  "
+#define MSG_M109_INVALID_EXTRUDER			"M109   "
+#define MSG_HEATING							"...  "
+#define MSG_HEATING_COMPLETE				".    "
+#define MSG_BED_HEATING						" ...     "
+#define MSG_BED_DONE						" .        "
+#define MSG_M115_REPORT						"FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
+#define MSG_COUNT_X							" Count X:"
+#define MSG_ERR_KILLED						" .  kill() !!"
+#define MSG_ERR_STOPPED						" , .     M999  !. ( .  )"
+#define MSG_RESEND							":"
+#define MSG_UNKNOWN_COMMAND					" :\""
+#define MSG_ACTIVE_EXTRUDER					" : "
+#define MSG_INVALID_EXTRUDER				" "
+#define MSG_X_MIN							"x_min:"
+#define MSG_X_MAX							"x_max:"
+#define MSG_Y_MIN							"y_min:"
+#define MSG_Y_MAX							"y_max:"
+#define MSG_Z_MIN							"z_min:"
+#define MSG_Z_MAX							"z_max:"
+#define MSG_M119_REPORT						" "
+#define MSG_ENDSTOP_HIT						" "
+#define MSG_ENDSTOP_OPEN					" "
+#define MSG_SD_CANT_OPEN_SUBDIR				"  "
+#define MSG_SD_INIT_FAIL					"  SD"
+#define MSG_SD_VOL_INIT_FAIL				"  "
+#define MSG_SD_OPENROOT_FAIL				"   "
+#define MSG_SD_CARD_OK						"SD   "
+#define MSG_SD_WORKDIR_FAIL					"   "
+#define MSG_SD_OPEN_FILE_FAIL				" , : "
+#define MSG_SD_FILE_OPENED					" :"
+#define MSG_SD_SIZE							" :"
+#define MSG_SD_FILE_SELECTED				" "
+#define MSG_SD_WRITE_TO_FILE				"  : "
+#define MSG_SD_PRINTING_BYTE				"SD  byte "
+#define MSG_SD_NOT_PRINTING					" SD "
+#define MSG_SD_ERR_WRITE_TO_FILE			"   "
+#define MSG_SD_CANT_ENTER_SUBDIR			"   :"
+#define MSG_STEPPER_TO_HIGH					"    : "
+#define MSG_ENDSTOPS_HIT					" : "
+#define MSG_ERR_COLD_EXTRUDE_STOP			"   "
+#define MSG_ERR_LONG_EXTRUDE_STOP			"    "
+
+#endif
+
+
+#if LANGUAGE_CHOICE == 7
+
+	// LCD Menu Messages
+	#define WELCOME_MSG MACHINE_NAME " Pronto."
+	#define MSG_SD_INSERTED          "SD Card inserita"
+	#define MSG_SD_REMOVED           "SD Card rimossa"
+	#define MSG_MAIN                 " Menu principale \003"
+	#define MSG_AUTOSTART            " Autostart"
+	#define MSG_DISABLE_STEPPERS     " Disabilita Motori Passo-Passo"
+	#define MSG_AUTO_HOME            " Auto Home"
+	#define MSG_SET_ORIGIN           " Imposta Origini Assi"
+	#define MSG_PREHEAT_PLA          " Preriscalda PLA"
+	#define MSG_PREHEAT_PLA_SETTINGS " Impostazioni Preriscaldamento PLA"
+	#define MSG_PREHEAT_ABS          " Preriscalda ABS"
+	#define MSG_PREHEAT_ABS_SETTINGS " Impostazioni Preriscaldamento ABS"
+	#define MSG_COOLDOWN             " Rafredda"
+	#define MSG_EXTRUDE              " Estrudi"
+	#define MSG_RETRACT              " Ritrai"
+	#define MSG_MOVE_AXIS            " Muovi Asse      \x7E"
+	#define MSG_SPEED                " Velcit:"
+	#define MSG_NOZZLE               " \002Ugello:"
+	#define MSG_NOZZLE1              " \002Ugello2:"
+	#define MSG_NOZZLE2              " \002Ugello3:"
+	#define MSG_BED                  " \002Piatto:"
+	#define MSG_FAN_SPEED            " Velocit Ventola:"
+	#define MSG_FLOW                 " Flusso:"
+	#define MSG_CONTROL              " Controllo \003"
+	#define MSG_MIN                  " \002 Min:"
+	#define MSG_MAX                  " \002 Max:"
+	#define MSG_FACTOR               " \002 Fact:"
+	#define MSG_AUTOTEMP             " Autotemp:"
+	#define MSG_ON                   "On "
+	#define MSG_OFF                  "Off"
+	#define MSG_PID_P                " PID-P: "
+	#define MSG_PID_I                " PID-I: "
+	#define MSG_PID_D                " PID-D: "
+	#define MSG_PID_C                " PID-C: "
+	#define MSG_ACC                  " Acc:"
+	#define MSG_VXY_JERK             " Vxy-jerk: "
+	#define MSG_VMAX                 " Vmax "
+	#define MSG_X                    "x:"
+	#define MSG_Y                    "y:"
+	#define MSG_Z                    "z:"
+	#define MSG_E                    "e:"
+	#define MSG_VMIN                 " Vmin:"
+	#define MSG_VTRAV_MIN            " VTrav min:"
+	#define MSG_AMAX                 " Amax "
+	#define MSG_A_RETRACT            " A-ritrai:"
+	#define MSG_XSTEPS               " Xpassi/mm:"
+	#define MSG_YSTEPS               " Ypassi/mm:"
+	#define MSG_ZSTEPS               " Zpassi/mm:"
+	#define MSG_ESTEPS               " Epassi/mm:"
+	#define MSG_MAIN_WIDE            " Menu Principale        \003"
+	#define MSG_RECTRACT_WIDE        " Ritrai    \x7E"
+	#define MSG_TEMPERATURE_WIDE     " Temperatura \x7E"
+	#define MSG_TEMPERATURE_RTN      " Temperatura  \003"
+	#define MSG_MOTION_WIDE          " Movimento      \x7E"
+	#define MSG_STORE_EPROM          " Salva in memoria"
+	#define MSG_LOAD_EPROM           " Carica dalla memoria"
+	#define MSG_RESTORE_FAILSAFE     " Configurazioni di default"
+	#define MSG_REFRESH              "\004Aggiorna"
+	#define MSG_WATCH                " Guarda   \003"
+	#define MSG_PREPARE              " Prepara \x7E"
+	#define MSG_PREPARE_ALT          " Prepara \003"
+	#define MSG_CONTROL_ARROW        " Controllo \x7E"
+	#define MSG_RETRACT_ARROW        " Ritrai \x7E"
+	#define MSG_TUNE                 " Tune    \x7E"
+	#define MSG_PAUSE_PRINT          " Metti in Pausa la Stampa \x7E"
+	#define MSG_RESUME_PRINT         " Riprendi Stampa \x7E"
+	#define MSG_STOP_PRINT           " Arresta Stampa   \x7E"
+	#define MSG_CARD_MENU            " Card Menu    \x7E"
+	#define MSG_NO_CARD              " No Card"
+	#define MSG_DWELL                " Sospensione..."
+	#define MSG_USERWAIT             "Attendi utente..."
+	#define MSG_NO_MOVE              "Nessun movimento."
+	#define MSG_PART_RELEASE         "Rilascio Parziale"
+	#define MSG_KILLED               "UCCISO. "
+	#define MSG_STOPPED              "ARRESTATO. "
+	#define MSG_STEPPER_RELEASED     "Rilasciato."
+	#define MSG_CONTROL_RETRACT      " Ritrai mm:"
+	#define MSG_CONTROL_RETRACTF     " Ritrai  F:"
+	#define MSG_CONTROL_RETRACT_ZLIFT " Salta mm:"
+	#define MSG_CONTROL_RETRACT_RECOVER " UnRet +mm:"
+	#define MSG_CONTROL_RETRACT_RECOVERF " UnRet  F:"
+	#define MSG_AUTORETRACT          " AutoRilascio.:"
+	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Qualcosa non va in MenuStructure."
+
+	// Serial Console Messages
+
+	#define MSG_Enqueing             "accodamento \""
+	#define MSG_POWERUP              "Accensione"
+	#define MSG_EXTERNAL_RESET       " Reset Esterno"
+	#define MSG_BROWNOUT_RESET       " Brown out Reset"
+	#define MSG_WATCHDOG_RESET       " Watchdog Reset"
+	#define MSG_SOFTWARE_RESET       " Software Reset"
+	#define MSG_MARLIN               "Marlin "
+	#define MSG_AUTHOR               " | Autore: "
+	#define MSG_CONFIGURATION_VER    " Ultimo Aggiornamento: "
+	#define MSG_FREE_MEMORY          " Memoria Libera: "
+	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
+	#define MSG_OK                   "ok"
+	#define MSG_FILE_SAVED           "File Salvato."
+	#define MSG_ERR_LINE_NO          "Il Numero della Linea non corrisponde al Numero dell'Ultima Linea+1, Ultima Linea:"
+	#define MSG_ERR_CHECKSUM_MISMATCH "checksum non corrispondente, Ultima Linea:"
+	#define MSG_ERR_NO_CHECKSUM      "Nessun Checksum con Numero di Linea, Ultima Linea:"
+	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Nessun Numero di Linea con Checksum, Ultima Linea:"
+	#define MSG_FILE_PRINTED         "File stampato"
+	#define MSG_BEGIN_FILE_LIST      "Inizio Lista File"
+	#define MSG_END_FILE_LIST        "Fine Lista File"
+	#define MSG_M104_INVALID_EXTRUDER "M104 Estrusore non valido "
+	#define MSG_M105_INVALID_EXTRUDER "M105 Estrusore non valido "
+	#define MSG_ERR_NO_THERMISTORS   "Nessun Termistore - nessuna temperatura"
+	#define MSG_M109_INVALID_EXTRUDER "M109 Estrusore non valido "
+	#define MSG_HEATING              "Riscaldamento..."
+	#define MSG_HEATING_COMPLETE     "Riscaldamento concluso."
+	#define MSG_BED_HEATING          "Riscaldamento Piatto."
+	#define MSG_BED_DONE             "Piatto Pronto."
+	#define MSG_M115_REPORT          "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
+	#define MSG_COUNT_X              " Calcola X:"
+	#define MSG_ERR_KILLED           "Stampante Calda. kill() chiamata !!"
+	#define MSG_ERR_STOPPED          "Stampante fermata a causa di errori. Risolvi l'errore e usa M999 per ripartire!. (Reset temperatura. Impostala prima di ripartire)"
+	#define MSG_RESEND               "Reinviato:"
+	#define MSG_UNKNOWN_COMMAND      "Comando sconosciuto:\""
+	#define MSG_ACTIVE_EXTRUDER      "Attiva Estrusore: "
+	#define MSG_INVALID_EXTRUDER     "Estrusore non valido"
+	#define MSG_X_MIN                "x_min: "
+	#define MSG_X_MAX                "x_max: "
+	#define MSG_Y_MIN                "y_min: "
+	#define MSG_Y_MAX                "y_max: "
+	#define MSG_Z_MIN                "z_min: "
+	#define MSG_Z_MAX                "z_max: "
+	#define MSG_M119_REPORT          "Segnalazione stato degli endstop"
+	#define MSG_ENDSTOP_HIT          "INNESCATO"
+	#define MSG_ENDSTOP_OPEN         "aperto"
+
+	#define MSG_SD_CANT_OPEN_SUBDIR  "Impossibile aprire sottocartella"
+	#define MSG_SD_INIT_FAIL         "Fallita Inizializzazione SD"
+	#define MSG_SD_VOL_INIT_FAIL     "Fallito il montaggio del Volume"
+	#define MSG_SD_OPENROOT_FAIL     "Fallita l'apertura Cartella Principale"
+	#define MSG_SD_CARD_OK           "SD card ok"
+	#define MSG_SD_WORKDIR_FAIL      "Fallita l'apertura Cartella di Lavoro"
+	#define MSG_SD_OPEN_FILE_FAIL    "Fallita l'apertura del File: "
+	#define MSG_SD_FILE_OPENED       "File aperto:"
+	#define MSG_SD_SIZE              " Dimensione:"
+	#define MSG_SD_FILE_SELECTED     "File selezionato"
+	#define MSG_SD_WRITE_TO_FILE     "Scrittura su file: "
+	#define MSG_SD_PRINTING_BYTE     "Si sta scrivendo il byte su SD "
+	#define MSG_SD_NOT_PRINTING      "Non si sta scrivendo su SD"
+	#define MSG_SD_ERR_WRITE_TO_FILE "Errore nella scrittura su file"
+	#define MSG_SD_CANT_ENTER_SUBDIR "Impossibile entrare nella sottocartella:"
+
+	#define MSG_STEPPER_TO_HIGH      "Steprate troppo alto : "
+	#define MSG_ENDSTOPS_HIT         "Raggiunto il fondo carrello: "
+	#define MSG_ERR_COLD_EXTRUDE_STOP " prevenuta estrusione fredda"
+	#define MSG_ERR_LONG_EXTRUDE_STOP " prevenuta estrusione troppo lunga"
+
+#endif
+
+
+#if LANGUAGE_CHOICE == 8
+
+// LCD Menu Messages
+	#define WELCOME_MSG MACHINE_NAME " Pronta."
+	#define MSG_SD_INSERTED "Cartao SD inserido"
+	#define MSG_SD_REMOVED "Cartao SD removido"
+	#define MSG_MAIN " Menu Principal \003"
+	#define MSG_AUTOSTART " Autostart"
+	#define MSG_DISABLE_STEPPERS " Apagar Motores"
+	#define MSG_AUTO_HOME " Ir para Origen"
+	#define MSG_SET_ORIGIN " Estabelecer Origen"
+	#define MSG_PREHEAT_PLA " pre-aquecer PLA"
+	#define MSG_PREHEAT_PLA_SETTINGS " pre-aquecer PLA Setting"
+	#define MSG_PREHEAT_ABS " pre-aquecer ABS"
+	#define MSG_PREHEAT_ABS_SETTINGS " pre-aquecer ABS Setting"
+	#define MSG_COOLDOWN " Esfriar"
+	#define MSG_EXTRUDE " Extrudar"
+	#define MSG_RETRACT " Retrair"
+	#define MSG_PREHEAT_PLA " pre-aquecer PLA"
+	#define MSG_PREHEAT_ABS " pre-aquecer ABS"
+	#define MSG_MOVE_AXIS " Mover eixo      \x7E"
+	#define MSG_SPEED " Velocidade:"
+	#define MSG_NOZZLE " \002Nozzle:"
+	#define MSG_NOZZLE1 " \002Nozzle2:"
+	#define MSG_NOZZLE2 " \002Nozzle3:"
+	#define MSG_BED " \002Base:"
+	#define MSG_FAN_SPEED " Velocidade Ventoinha:"
+	#define MSG_FLOW " Fluxo:"
+	#define MSG_CONTROL " Controle \003"
+	#define MSG_MIN " \002 Min:"
+	#define MSG_MAX " \002 Max:"
+	#define MSG_FACTOR " \002 Fact:"
+	#define MSG_AUTOTEMP " Autotemp:"
+	#define MSG_ON "On "
+	#define MSG_OFF "Off"
+	#define MSG_PID_P " PID-P: "
+	#define MSG_PID_I " PID-I: "
+	#define MSG_PID_D " PID-D: "
+	#define MSG_PID_C " PID-C: "
+	#define MSG_ACC  " Acc:"
+	#define MSG_VXY_JERK " Vxy-jerk: "
+	#define MSG_VMAX " Vmax "
+	#define MSG_X "x:"
+	#define MSG_Y "y:"
+	#define MSG_Z "z:"
+	#define MSG_E "e:"
+	#define MSG_VMIN " Vmin:"
+	#define MSG_VTRAV_MIN " VTrav min:"
+	#define MSG_AMAX " Amax "
+	#define MSG_A_RETRACT " A-retract:"
+	#define MSG_XSTEPS " Xpasso/mm:"
+	#define MSG_YSTEPS " Ypasso/mm:"
+	#define MSG_ZSTEPS " Zpasso/mm:"
+	#define MSG_ESTEPS " Epasso/mm:"
+	#define MSG_MAIN_WIDE " Menu Principal  \003"
+	#define MSG_RECTRACT_WIDE " Retrair    \x7E"
+	#define MSG_TEMPERATURE_WIDE " Temperatura \x7E"
+	#define MSG_TEMPERATURE_RTN " Temperatura  \003"
+	#define MSG_MOTION_WIDE " Movimento     \x7E"
+	#define MSG_STORE_EPROM " Guardar memoria"
+	#define MSG_LOAD_EPROM " Carregar memoria"
+	#define MSG_RESTORE_FAILSAFE " Rest. de emergencia"
+	#define MSG_REFRESH "\004Recarregar"
+	#define MSG_WATCH " Monitorar   \003"
+	#define MSG_PREPARE " Preparar \x7E"
+	#define MSG_PREPARE_ALT " Preparar \003"
+	#define MSG_CONTROL_ARROW " Controle \x7E"
+	#define MSG_RETRACT_ARROW " Retrair \x7E"
+	#define MSG_TUNE " Tune    \x7E"
+	#define MSG_PAUSE_PRINT " Pausar Impressao \x7E"
+	#define MSG_RESUME_PRINT " Resumir Impressao \x7E"
+	#define MSG_STOP_PRINT " Parar Impressao   \x7E"
+	#define MSG_CARD_MENU " Menu cartao SD    \x7E"
+	#define MSG_NO_CARD " Sem cartao SD"
+	#define MSG_DWELL "Repouso..."
+	#define MSG_USERWAIT "Esperando Ordem..."
+	#define MSG_NO_MOVE "Sem movimento."
+	#define MSG_PART_RELEASE "Lancamento Parcial"
+	#define MSG_KILLED "PARADA DE EMERGENCIA. "
+	#define MSG_STOPPED "PARADA. "
+	#define MSG_STEPPER_RELEASED "Lancado."
+	#define MSG_CONTROL_RETRACT  " Retrair mm:"
+	#define MSG_CONTROL_RETRACTF " Retrair  F:"
+	#define MSG_CONTROL_RETRACT_ZLIFT " Levantar mm:"
+	#define MSG_CONTROL_RETRACT_RECOVER " DesRet +mm:"
+	#define MSG_CONTROL_RETRACT_RECOVERF " DesRet  F:"
+	#define MSG_AUTORETRACT " AutoRetr.:"
+        #define MSG_SERIAL_ERROR_MENU_STRUCTURE "Algo esta errado na estrutura do Menu."
+
+// Serial Console Messages
+
+	#define MSG_Enqueing "enqueing \""
+	#define MSG_POWERUP "PowerUp"
+	#define MSG_EXTERNAL_RESET " Reset Externo"
+	#define MSG_BROWNOUT_RESET " Reset por voltagem incorreta"
+	#define MSG_WATCHDOG_RESET " Reset por Bloqueio"
+	#define MSG_SOFTWARE_RESET " Reset por Software"
+	#define MSG_MARLIN "Marlin "
+	#define MSG_AUTHOR " | Author: "
+	#define MSG_CONFIGURATION_VER " Ultima atualizacao: "
+	#define MSG_FREE_MEMORY " memoria Livre: "
+	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
+	#define MSG_OK "ok"
+	#define MSG_FILE_SAVED "Guardado."
+	#define MSG_ERR_LINE_NO "O Numero da linha Nao e igual ao ultimo Numero da linha+1, Ultima linha:"
+	#define MSG_ERR_CHECKSUM_MISMATCH "O checksum Nao coincide, Ultima linha:"
+	#define MSG_ERR_NO_CHECKSUM "Nao foi possivel encontrar o checksum com o numero da linha, Ultima linha :"
+	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Nao ha o numero da linha com o checksum, Ultima linha:"
+	#define MSG_FILE_PRINTED "Impressao terminada"
+	#define MSG_BEGIN_FILE_LIST "Comeo da lista de arquivos"
+	#define MSG_END_FILE_LIST "Fim da lista de arquivos"
+	#define MSG_M104_INVALID_EXTRUDER "M104 Extrusor invlido "
+	#define MSG_M105_INVALID_EXTRUDER "M105 Extrusor invlido "
+	#define MSG_ERR_NO_THERMISTORS "Nao ha termistor - no temp"
+	#define MSG_M109_INVALID_EXTRUDER "M109 Extrusor invlido "
+	#define MSG_HEATING "Aquecendo..."
+	#define MSG_HEATING_COMPLETE "Aquecido."
+	#define MSG_BED_HEATING "Aquecendo a Base."
+	#define MSG_BED_DONE "Base quente."
+	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
+	#define MSG_COUNT_X " Conta X:"
+	#define MSG_ERR_KILLED "Impressora parada com kill() !!"
+	#define MSG_ERR_STOPPED "Impressora parada por erros. Coserte o erro e use M999 para recomear!. (Temperatura reiniciada. Ajuste antes de recomear)"
+	#define MSG_RESEND "Reenviar:"
+	#define MSG_UNKNOWN_COMMAND "Comando desconhecido:\""
+	#define MSG_ACTIVE_EXTRUDER "Extrusor ativo: "
+	#define MSG_INVALID_EXTRUDER "Extrusor invalido"
+	#define MSG_X_MIN "x_min: "
+	#define MSG_X_MAX "x_max: "
+	#define MSG_Y_MIN "y_min: "
+	#define MSG_Y_MAX "y_max: "
+	#define MSG_Z_MIN "z_min: "
+	#define MSG_Z_MAX "z_max: "
+	#define MSG_M119_REPORT "Relatando estado do ponto final"
+	#define MSG_ENDSTOP_HIT "PULSADO"
+	#define MSG_ENDSTOP_OPEN "Aberto"
+
+	#define MSG_SD_CANT_OPEN_SUBDIR "Nao pode abrir sub diretorio"
+	#define MSG_SD_INIT_FAIL "Falha ao iniciar SD"
+	#define MSG_SD_VOL_INIT_FAIL "Falha ao montar volume"
+	#define MSG_SD_OPENROOT_FAIL "Falha ao abrir diretorio raiz"
+	#define MSG_SD_CARD_OK "cartao SD ok"
+	#define MSG_SD_WORKDIR_FAIL "Falha ao abrir diretorio de trabalho"
+	#define MSG_SD_OPEN_FILE_FAIL "Erro ao abrir, Arquivo: "
+	#define MSG_SD_FILE_OPENED "Arquivo aberto:"
+	#define MSG_SD_SIZE " Size:"
+	#define MSG_SD_FILE_SELECTED "Arquivo selecionado"
+	#define MSG_SD_WRITE_TO_FILE "Escrevendo no arquivo: "
+	#define MSG_SD_PRINTING_BYTE "SD imprimindo o byte "
+	#define MSG_SD_NOT_PRINTING "Nao esta se imprimindo com o SD"
+	#define MSG_SD_ERR_WRITE_TO_FILE "Erro ao escrever no arquivo"
+	#define MSG_SD_CANT_ENTER_SUBDIR "Nao pode abrir o sub diretorio:"
+
+	#define MSG_STEPPER_TO_HIGH "Steprate muito alto : "
+	#define MSG_ENDSTOPS_HIT "O ponto final foi tocado: "
+	#define MSG_ERR_COLD_EXTRUDE_STOP " Extrusao a frio evitada"
+	#define MSG_ERR_LONG_EXTRUDE_STOP " Extrusao muito larga evitada"
+
+
+#endif
+
 #endif // ifndef LANGUAGE_H
diff --git a/Marlin/pins.h b/Marlin/pins.h
index 403ff41..4518dad 100644
--- a/Marlin/pins.h
+++ b/Marlin/pins.h
@@ -1,26 +1,35 @@
 #ifndef PINS_H
 #define PINS_H
 
+#define X_MS1_PIN -1
+#define X_MS2_PIN -1
+#define Y_MS1_PIN -1
+#define Y_MS2_PIN -1
+#define Z_MS1_PIN -1
+#define Z_MS2_PIN -1
+#define E0_MS1_PIN -1
+#define E0_MS2_PIN -1
+#define E1_MS1_PIN -1
+#define E1_MS2_PIN -1
+#define DIGIPOTSS_PIN -1
+
 #if MOTHERBOARD == 99
 #define	KNOWN_BOARD 1
 
 #define X_STEP_PIN          2
 #define X_DIR_PIN           3
 #define X_ENABLE_PIN        -1
-#define X_MIN_PIN           -1
-#define X_MAX_PIN           16
+#define X_STOP_PIN          16
 
 #define Y_STEP_PIN          5
 #define Y_DIR_PIN           6
 #define Y_ENABLE_PIN       -1
-#define Y_MIN_PIN           67
-#define Y_MAX_PIN          -1
+#define Y_STOP_PIN          67
 
 #define Z_STEP_PIN          62
 #define Z_DIR_PIN           63
 #define Z_ENABLE_PIN       -1
-#define Z_MIN_PIN           59
-#define Z_MAX_PIN          -1
+#define Z_STOP_PIN          59
 
 #define E0_STEP_PIN         65
 #define E0_DIR_PIN          66
@@ -45,16 +54,11 @@
 #endif /* 99 */
 
 /****************************************************************************************
-* Gen7 v1.1, v1.2, v1.3, v1.4 pin assignment
+* Gen7 v1.1, v1.2, v1.3 pin assignment
 *
 ****************************************************************************************/
 
 
-#if MOTHERBOARD == 13
-#define MOTHERBOARD 11
-#define GEN7_VERSION 14 // v1.4
-#endif
-
 #if MOTHERBOARD == 12
 #define MOTHERBOARD 11
 #define GEN7_VERSION 13 // v1.3
@@ -76,15 +80,13 @@
 #define X_STEP_PIN 19
 #define X_DIR_PIN 18
 #define X_ENABLE_PIN 24
-#define X_MIN_PIN 7
-#define X_MAX_PIN -1
+#define X_STOP_PIN 7
 
 //y axis pins
 #define Y_STEP_PIN 23
 #define Y_DIR_PIN 22
 #define Y_ENABLE_PIN 24
-#define Y_MIN_PIN 5
-#define Y_MAX_PIN -1
+#define Y_STOP_PIN 5
 
 //z axis pins
 #define Z_STEP_PIN 26
@@ -122,12 +124,83 @@
 #endif
 #define PS_ON_PIN 15
 
-#if (GEN7_VERSION < 14)
-// Gen 1.3 and earlier supplied thermistor power via PS_ON
-// Need to ignore the bad thermistor readings on those units
+//All these generations of Gen7 supply thermistor power
+//via PS_ON, so ignore bad thermistor readings
 #define BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE
+
+//our pin for debugging.
+#define DEBUG_PIN 0
+
+//our RS485 pins
+#define TX_ENABLE_PIN 12
+#define RX_ENABLE_PIN 13
+
+#endif
+
+/****************************************************************************************
+* Gen7 v1.4 pin assignment
+*
+****************************************************************************************/
+
+#if MOTHERBOARD == 13
+#define GEN7_VERSION 14 // v1.4
+#endif
+
+#if MOTHERBOARD == 13
+#define KNOWN_BOARD
+
+#if !defined(__AVR_ATmega644P__) && !defined(__AVR_ATmega644__) && !defined(__AVR_ATmega1284P__)
+#error Oops! Make sure you have 'Gen7' selected from the 'Tools -> Boards' menu.
+
 #endif
 
+#ifndef GEN7_VERSION
+#define GEN7_VERSION 14 // v1.x
+#endif
+
+//x axis pins
+#define X_STEP_PIN 29
+#define X_DIR_PIN 28
+#define X_ENABLE_PIN 25
+#define X_STOP_PIN 0
+
+//y axis pins
+#define Y_STEP_PIN 27
+#define Y_DIR_PIN 26
+#define Y_ENABLE_PIN 25
+#define Y_STOP_PIN 1
+
+//z axis pins
+#define Z_STEP_PIN 23
+#define Z_DIR_PIN 22
+#define Z_ENABLE_PIN 25
+#define Z_STOP_PIN 2
+
+//extruder pins
+#define E0_STEP_PIN 19
+#define E0_DIR_PIN 18
+#define E0_ENABLE_PIN 25
+
+#define TEMP_0_PIN 0
+#define TEMP_1_PIN -1
+#define TEMP_2_PIN -1
+#define TEMP_BED_PIN 1
+
+#define HEATER_0_PIN 4
+#define HEATER_1_PIN -1
+#define HEATER_2_PIN -1
+#define HEATER_BED_PIN 3
+
+#define KILL_PIN -1
+
+#define SDPOWER -1
+#define SDSS -1 // SCL pin of I2C header
+#define LED_PIN -1
+
+#define FAN_PIN -1
+
+#define PS_ON_PIN 15
+
 //our pin for debugging.
 #define DEBUG_PIN 0
 
@@ -157,22 +230,19 @@
     #define X_STEP_PIN      21                  //different from stanard GEN7
     #define X_DIR_PIN       20				    //different from stanard GEN7
     #define X_ENABLE_PIN    24
-    #define X_MIN_PIN       0
-    #define X_MAX_PIN       -1
+    #define X_STOP_PIN      0
 
     //y axis pins
     #define Y_STEP_PIN      23
     #define Y_DIR_PIN       22
     #define Y_ENABLE_PIN    24
-    #define Y_MIN_PIN       1
-    #define Y_MAX_PIN       -1
+    #define Y_STOP_PIN      1
 
     //z axis pins
     #define Z_STEP_PIN      26
     #define Z_DIR_PIN       25
     #define Z_ENABLE_PIN    24
-    #define Z_MIN_PIN       2
-    #define Z_MAX_PIN       -1
+    #define Z_STOP_PIN      2
 
     //extruder pins
     #define E0_STEP_PIN      28
@@ -255,13 +325,13 @@
 #define X_DIR_PIN          55
 #define X_ENABLE_PIN       38
 #define X_MIN_PIN           3
-#define X_MAX_PIN           2   //2 //Max endstops default to disabled "-1", set to commented value to enable.
+#define X_MAX_PIN           2
 
 #define Y_STEP_PIN         60
 #define Y_DIR_PIN          61
 #define Y_ENABLE_PIN       56
 #define Y_MIN_PIN          14
-#define Y_MAX_PIN          15   //15
+#define Y_MAX_PIN          15
 
 #define Z_STEP_PIN         46
 #define Z_DIR_PIN          48
@@ -291,7 +361,12 @@
 #define FAN_PIN            4 // IO pin. Buffer needed
 #endif
 #define PS_ON_PIN          12
+
+#ifdef REPRAP_DISCOUNT_SMART_CONTROLLER
+#define KILL_PIN           41
+#else
 #define KILL_PIN           -1
+#endif
 
 #define HEATER_0_PIN       10   // EXTRUDER 1
 #if MOTHERBOARD == 33
@@ -309,8 +384,15 @@
 #ifdef ULTRA_LCD
 
   #ifdef NEWPANEL
-  //arduino pin which triggers an piezzo beeper
-    #define BEEPER 33			// Beeper on AUX-4
+     //encoder rotation values
+    #define encrot0 0
+    #define encrot1 2
+    #define encrot2 3
+    #define encrot3 1
+
+    #define BLEN_A 0
+    #define BLEN_B 1
+    #define BLEN_C 2
 
     #define LCD_PINS_RS 16 
     #define LCD_PINS_ENABLE 17
@@ -319,22 +401,25 @@
     #define LCD_PINS_D6 27
     #define LCD_PINS_D7 29
     
-    //buttons are directly attached using AUX-2
-    #define BTN_EN1 37
-    #define BTN_EN2 35
-    #define BTN_ENC 31  //the click
-    
-    #define BLEN_C 2
-    #define BLEN_B 1
-    #define BLEN_A 0
-    
-    #define SDCARDDETECT -1		// Ramps does not use this port
-    
-      //encoder rotation values
-    #define encrot0 0
-    #define encrot1 2
-    #define encrot2 3
-    #define encrot3 1
+    #ifdef REPRAP_DISCOUNT_SMART_CONTROLLER
+      #define BEEPER 37
+
+      #define BTN_EN1 31
+      #define BTN_EN2 33
+      #define BTN_ENC 35
+
+      #define SDCARDDETECT 49
+    #else
+      //arduino pin which triggers an piezzo beeper
+      #define BEEPER 33	 // Beeper on AUX-4
+
+      //buttons are directly attached using AUX-2
+      #define BTN_EN1 37
+      #define BTN_EN2 35
+      #define BTN_ENC 31  //the click
+
+      #define SDCARDDETECT -1  // Ramps does not use this port
+    #endif
 
   #else //old style panel with shift register
     //arduino pin witch triggers an piezzo beeper
@@ -375,7 +460,7 @@
   #endif 
 #endif //ULTRA_LCD
 
-#else // RAMPS_V_1_1 or RAMPS_V_1_2 as default
+#else // RAMPS_V_1_1 or RAMPS_V_1_2 as default (MOTHERBOARD == 3)
 
 #define X_STEP_PIN         26
 #define X_DIR_PIN          28
@@ -420,7 +505,7 @@
 #define TEMP_1_PIN          -1   
 #define TEMP_2_PIN          -1   
 #define TEMP_BED_PIN        1    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
-#endif
+#endif// MOTHERBOARD == 33 || MOTHERBOARD == 34
 
 // SPI for Max6675 Thermocouple 
 
@@ -434,7 +519,7 @@
   #define MAX6675_SS       49
 #endif
 
-#endif
+#endif//MOTHERBOARD == 3 || MOTHERBOARD == 33 || MOTHERBOARD == 34
 
 /****************************************************************************************
 * Duemilanove w/ ATMega328P pin assignment
@@ -450,20 +535,17 @@
 #define X_STEP_PIN         19
 #define X_DIR_PIN          18
 #define X_ENABLE_PIN       -1
-#define X_MIN_PIN          17
-#define X_MAX_PIN          -1
+#define X_STOP_PIN         17
 
 #define Y_STEP_PIN         10
 #define Y_DIR_PIN           7
 #define Y_ENABLE_PIN       -1
-#define Y_MIN_PIN           8
-#define Y_MAX_PIN          -1
+#define Y_STOP_PIN          8
 
 #define Z_STEP_PIN         13
 #define Z_DIR_PIN           3
 #define Z_ENABLE_PIN        2
-#define Z_MIN_PIN           4
-#define Z_MAX_PIN          -1
+#define Z_STOP_PIN          4
 
 #define E0_STEP_PIN         11
 #define E0_DIR_PIN          12
@@ -504,23 +586,20 @@
     #define X_STEP_PIN      15
     #define X_DIR_PIN       18
     #define X_ENABLE_PIN    19
-    #define X_MIN_PIN       20
-    #define X_MAX_PIN       -1
-    
+    #define X_STOP_PIN      20
+
     //y axis pins
     #define Y_STEP_PIN      23
     #define Y_DIR_PIN       22
     #define Y_ENABLE_PIN    24
-    #define Y_MIN_PIN       25
-    #define Y_MAX_PIN       -1
-    
+    #define Y_STOP_PIN      25
+
     //z axis pins
     #define Z_STEP_PIN      27
     #define Z_DIR_PIN       28
     #define Z_ENABLE_PIN    29
-    #define Z_MIN_PIN       30
-    #define Z_MAX_PIN       -1
-    
+    #define Z_STOP_PIN      30
+
     //extruder pins
     #define E0_STEP_PIN      4    //Edited @ EJE Electronics 20100715
     #define E0_DIR_PIN       2    //Edited @ EJE Electronics 20100715
@@ -579,33 +658,15 @@
 
 #define X_STEP_PIN         15
 #define X_DIR_PIN          21
-#if X_HOME_DIR < 0
-# define X_MIN_PIN          18 
-# define X_MAX_PIN          -1
-#else
-# define X_MIN_PIN          -1
-# define X_MAX_PIN          18
-#endif
+#define X_STOP_PIN         18
 
 #define Y_STEP_PIN         22
 #define Y_DIR_PIN          23
-#if Y_HOME_DIR < 0
-# define Y_MIN_PIN          19 
-# define Y_MAX_PIN          -1
-#else
-# define Y_MIN_PIN          -1
-# define Y_MAX_PIN          19
-#endif
+#define Y_STOP_PIN         19
 
 #define Z_STEP_PIN         3
 #define Z_DIR_PIN          2
-#if Z_HOME_DIR < 0
-# define Z_MIN_PIN          20 
-# define Z_MAX_PIN          -1
-#else
-# define Z_MIN_PIN          -1
-# define Z_MAX_PIN          20
-#endif
+#define Z_STOP_PIN         20
 
 #define E0_STEP_PIN         1
 #define E0_DIR_PIN          0
@@ -613,6 +674,9 @@
 #define LED_PIN            -1
 
 #define FAN_PIN            -1 
+#if FAN_PIN == 12 || FAN_PIN ==13
+#define FAN_SOFT_PWM
+#endif
 
 #ifdef MELZI
 #define LED_PIN            28
@@ -861,70 +925,145 @@
 #endif
 
 /****************************************************************************************
-* Teensylu 0.7 pin assingments (ATMEGA90USB)
-* Requires the Teensyduino software with Teensy2.0++ selected in arduino IDE!
+* Teensylu 0.7 / Printrboard pin assignments (AT90USB1286)
+* Requires the Teensyduino software with Teensy++ 2.0 selected in Arduino IDE!
+  http://www.pjrc.com/teensy/teensyduino.html
+* See http://reprap.org/wiki/Printrboard for more info
 ****************************************************************************************/
-#if MOTHERBOARD == 8
-#define MOTHERBOARD 8
+#if MOTHERBOARD == 8 || MOTHERBOARD == 81
 #define KNOWN_BOARD 1
+#define AT90USB 1286  // Disable MarlinSerial etc.
 
+#ifndef __AVR_AT90USB1286__
+#error Oops!  Make sure you have 'Teensy++ 2.0' selected from the 'Tools -> Boards' menu.
+#endif
 
-#define X_STEP_PIN          0  
-#define X_DIR_PIN           1  
-#define X_ENABLE_PIN       39 
-#define X_MIN_PIN          13 
-#define X_MAX_PIN          -1    
+#define X_STEP_PIN          0
+#define X_DIR_PIN           1
+#define X_ENABLE_PIN       39
 
-#define Y_STEP_PIN          2  
-#define Y_DIR_PIN           3 
-#define Y_ENABLE_PIN       38 
-#define Y_MIN_PIN          14 
-#define Y_MAX_PIN          -1    
+#define Y_STEP_PIN          2
+#define Y_DIR_PIN           3
+#define Y_ENABLE_PIN       38
 
 #define Z_STEP_PIN          4
-#define Z_DIR_PIN           5 
-#define Z_ENABLE_PIN       23 
-#define Z_MIN_PIN          15 
-#define Z_MAX_PIN          -1    
-
-#define E0_STEP_PIN         6  
-#define E0_DIR_PIN          7 
-#define E0_ENABLE_PIN       19 
-
+#define Z_DIR_PIN           5
+#define Z_ENABLE_PIN       23
 
+#define E0_STEP_PIN         6
+#define E0_DIR_PIN          7
+#define E0_ENABLE_PIN      19
 
 #define HEATER_0_PIN       21  // Extruder
 #define HEATER_1_PIN       -1
 #define HEATER_2_PIN       -1
 #define HEATER_BED_PIN     20  // Bed
-#define FAN_PIN            22  // Fan   
+#define FAN_PIN            22  // Fan
+// You may need to change FAN_PIN to 16 because Marlin isn't using fastio.h
+// for the fan and Teensyduino uses a different pin mapping.
+
+#if MOTHERBOARD == 8  // Teensylu
+  #define X_STOP_PIN         13
+  #define Y_STOP_PIN         14
+  #define Z_STOP_PIN         15
+  #define TEMP_0_PIN          7  // Extruder / Analog pin numbering
+  #define TEMP_BED_PIN        6  // Bed / Analog pin numbering
+#else  // Printrboard
+  #define X_STOP_PIN         35
+  #define Y_STOP_PIN          8
+  #define Z_STOP_PIN         36
+  #define TEMP_0_PIN          1  // Extruder / Analog pin numbering
+  #define TEMP_BED_PIN        0  // Bed / Analog pin numbering
+#endif
 
-#define TEMP_0_PIN          7  // Extruder
 #define TEMP_1_PIN         -1
 #define TEMP_2_PIN         -1
-#define TEMP_BED_PIN        6  // Bed
 
 #define SDPOWER            -1
 #define SDSS                8
 #define LED_PIN            -1
 #define PS_ON_PIN          -1
-#define KILL_PIN           -1 
+#define KILL_PIN           -1
 #define ALARM_PIN          -1
 
 #ifndef SDSUPPORT
-// these pins are defined in the SD library if building with SD support  
-  #define SCK_PIN           9 
-  #define MISO_PIN         11 
-  #define MOSI_PIN         10 
+// these pins are defined in the SD library if building with SD support
+  #define SCK_PIN           9
+  #define MISO_PIN         11
+  #define MOSI_PIN         10
 #endif
+
+#endif  // MOTHERBOARD == 8 (Teensylu) or 81 (Printrboard)
+
+/****************************************************************************************
+ * Brainwave 1.0 pin assignments (AT90USB646)
+ * Requires hardware bundle for Arduino:
+   https://github.com/unrepentantgeek/brainwave-arduino
+ ****************************************************************************************/
+#if MOTHERBOARD == 82
+#define KNOWN_BOARD 1
+#define AT90USB 646  // Disable MarlinSerial etc.
+
+#ifndef __AVR_AT90USB646__
+#error Oops!  Make sure you have 'Brainwave' selected from the 'Tools -> Boards' menu.
+#endif
+
+#define X_STEP_PIN         27
+#define X_DIR_PIN          29
+#define X_ENABLE_PIN       28
+#define X_STOP_PIN          7
+#define X_ATT_PIN          26
+
+#define Y_STEP_PIN         31
+#define Y_DIR_PIN          33
+#define Y_ENABLE_PIN       32
+#define Y_STOP_PIN          6
+#define Y_ATT_PIN          30
+
+#define Z_STEP_PIN         17
+#define Z_DIR_PIN          19
+#define Z_ENABLE_PIN       18
+#define Z_STOP_PIN          5
+#define Z_ATT_PIN          16
+
+#define E0_STEP_PIN        21
+#define E0_DIR_PIN         23
+#define E0_ENABLE_PIN      22
+#define E0_ATT_PIN         20
+
+#define HEATER_0_PIN        4  // Extruder
+#define HEATER_1_PIN       -1
+#define HEATER_2_PIN       -1
+#define HEATER_BED_PIN     38  // Bed
+#define FAN_PIN             3  // Fan
+
+#define TEMP_0_PIN          7  // Extruder / Analog pin numbering
+#define TEMP_1_PIN         -1
+#define TEMP_2_PIN         -1
+#define TEMP_BED_PIN        6  // Bed / Analog pin numbering
+
+#define SDPOWER            -1
+#define SDSS               -1
+#define LED_PIN            39
+#define PS_ON_PIN          -1
+#define KILL_PIN           -1
+#define ALARM_PIN          -1
+
+#ifndef SDSUPPORT
+// these pins are defined in the SD library if building with SD support
+  #define SCK_PIN           9
+  #define MISO_PIN         11
+  #define MOSI_PIN         10
 #endif
 
+#endif  // MOTHERBOARD == 82 (Brainwave)
+
 /****************************************************************************************
 * Gen3+ pin assignment
 *
 ****************************************************************************************/
 #if MOTHERBOARD == 9
-#define MOTHERBOARD 6
+#define MOTHERBOARD 6   /*TODO: Figure out, Why is this done?*/
 #define KNOWN_BOARD 1
 #ifndef __AVR_ATmega644P__
 #ifndef __AVR_ATmega1284P__
@@ -934,18 +1073,15 @@
 
 #define X_STEP_PIN         15
 #define X_DIR_PIN          18
-#define X_MIN_PIN          20
-#define X_MAX_PIN           -1
+#define X_STOP_PIN         20
 
 #define Y_STEP_PIN         23
 #define Y_DIR_PIN          22
-#define Y_MIN_PIN          25
-#define Y_MAX_PIN          -1
+#define Y_STOP_PIN         25
 
 #define Z_STEP_PIN         27
 #define Z_DIR_PIN          28
-#define Z_MIN_PIN          30
-#define Z_MAX_PIN          -1
+#define Z_STOP_PIN         30
 
 #define E_STEP_PIN         17
 #define E_DIR_PIN          21
@@ -1015,20 +1151,17 @@
 #define X_STEP_PIN         21
 #define X_DIR_PIN          20
 #define X_ENABLE_PIN       24
-#define X_MIN_PIN          0
-#define X_MAX_PIN          -1
+#define X_STOP_PIN         0
 
 #define Y_STEP_PIN         23
 #define Y_DIR_PIN          22
 #define Y_ENABLE_PIN       24
-#define Y_MIN_PIN          1
-#define Y_MAX_PIN          -1
+#define Y_STOP_PIN         1
 
 #define Z_STEP_PIN         26
 #define Z_DIR_PIN          25
 #define Z_ENABLE_PIN       24
-#define Z_MIN_PIN          2
-#define Z_MAX_PIN          -1
+#define Z_STOP_PIN         2
 
 #define E0_STEP_PIN         28
 #define E0_DIR_PIN          27
@@ -1072,20 +1205,17 @@
 #define X_STEP_PIN         26
 #define X_DIR_PIN          25
 #define X_ENABLE_PIN       10
-#define X_MIN_PIN          0
-#define X_MAX_PIN          -1
+#define X_STOP_PIN         0
 
 #define Y_STEP_PIN         28
 #define Y_DIR_PIN          27
 #define Y_ENABLE_PIN       10
-#define Y_MIN_PIN          1
-#define Y_MAX_PIN          -1
+#define Y_STOP_PIN         1
 
 #define Z_STEP_PIN         23
 #define Z_DIR_PIN          22
 #define Z_ENABLE_PIN       10
-#define Z_MIN_PIN          2
-#define Z_MAX_PIN          -1
+#define Z_STOP_PIN         2
 
 #define E0_STEP_PIN         24
 #define E0_DIR_PIN          21
@@ -1131,6 +1261,179 @@
 
 #endif
 
+#if MOTHERBOARD == 301
+#define KNOWN_BOARD
+/*****************************************************************
+* Rambo Pin Assignments
+******************************************************************/
+
+#ifndef __AVR_ATmega2560__
+#error Oops!  Make sure you have 'Arduino Mega 2560' selected from the 'Tools -> Boards' menu.
+#endif
+
+#define X_STEP_PIN 37
+#define X_DIR_PIN 48
+#define X_MIN_PIN 12
+#define X_MAX_PIN 24
+#define X_ENABLE_PIN 29
+#define X_MS1_PIN 40
+#define X_MS2_PIN 41
+
+#define Y_STEP_PIN 36
+#define Y_DIR_PIN 49
+#define Y_MIN_PIN 11
+#define Y_MAX_PIN 23
+#define Y_ENABLE_PIN 28
+#define Y_MS1_PIN 69
+#define Y_MS2_PIN 39
+
+#define Z_STEP_PIN 35
+#define Z_DIR_PIN 47
+#define Z_MIN_PIN 10
+#define Z_MAX_PIN 30
+#define Z_ENABLE_PIN 27
+#define Z_MS1_PIN 68
+#define Z_MS2_PIN 67
+
+#define HEATER_BED_PIN 3
+#define TEMP_BED_PIN 2 
+
+#define HEATER_0_PIN  9
+#define TEMP_0_PIN 0
+
+#define HEATER_1_PIN 7
+#define TEMP_1_PIN 1
+
+#define HEATER_2_PIN -1
+#define TEMP_2_PIN -1
+
+#define E0_STEP_PIN         34
+#define E0_DIR_PIN          43
+#define E0_ENABLE_PIN       26
+#define E0_MS1_PIN 65
+#define E0_MS2_PIN 66
+
+#define E1_STEP_PIN         33
+#define E1_DIR_PIN          42
+#define E1_ENABLE_PIN       25
+#define E1_MS1_PIN 63
+#define E1_MS2_PIN 64
+
+#define DIGIPOTSS_PIN 38
+#define DIGIPOT_CHANNELS {4,5,3,0,1} // X Y Z E0 E1 digipot channels to stepper driver mapping
+
+#define SDPOWER            -1
+#define SDSS               53
+#define LED_PIN            13
+#define FAN_PIN            8
+#define PS_ON_PIN          4
+#define KILL_PIN           -1
+#define SUICIDE_PIN        -1  //PIN that has to be turned on right after start, to keep power flowing.
+
+#endif
+
+/****************************************************************************************
+* MegaTronics
+*
+****************************************************************************************/
+#if MOTHERBOARD == 70
+#define KNOWN_BOARD 1
+
+//////////////////FIX THIS//////////////
+
+ #ifndef __AVR_ATmega2560__
+ #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -> Boards' menu.
+ #endif
+
+
+
+
+#define X_STEP_PIN         26
+#define X_DIR_PIN          28
+#define X_ENABLE_PIN       24
+#define X_MIN_PIN          41
+#define X_MAX_PIN          37
+
+#define Y_STEP_PIN         60 // A6
+#define Y_DIR_PIN          61 // A7
+#define Y_ENABLE_PIN       22
+#define Y_MIN_PIN          14
+#define Y_MAX_PIN          15
+
+#define Z_STEP_PIN         54 // A0
+#define Z_DIR_PIN          55 // A1
+#define Z_ENABLE_PIN       56 // A2
+#define Z_MIN_PIN          18
+#define Z_MAX_PIN          19
+
+#define E0_STEP_PIN        31
+#define E0_DIR_PIN         32
+#define E0_ENABLE_PIN      38
+
+#define E1_STEP_PIN        34
+#define E1_DIR_PIN         36
+#define E1_ENABLE_PIN      30
+
+#define SDPOWER            -1
+#define SDSS               53
+#define LED_PIN            13
+
+
+#define FAN_PIN            7 // IO pin. Buffer needed
+#define PS_ON_PIN          12
+#define KILL_PIN           -1
+
+#define HEATER_0_PIN       9    // EXTRUDER 1
+#define HEATER_1_PIN       8    // EXTRUDER 2 (FAN On Sprinter)
+#define HEATER_2_PIN       -1  
+
+#if TEMP_SENSOR_0 == -1 
+#define TEMP_0_PIN         8   // ANALOG NUMBERING
+#else
+#define TEMP_0_PIN         13   // ANALOG NUMBERING
+
+#endif
+
+#define TEMP_1_PIN         15   // ANALOG NUMBERING
+#define TEMP_2_PIN         -1   // ANALOG NUMBERING
+#define HEATER_BED_PIN     10   // BED
+#define TEMP_BED_PIN       14   // ANALOG NUMBERING
+
+#define BEEPER 33			// Beeper on AUX-4
+
+
+#ifdef ULTRA_LCD
+
+  #ifdef NEWPANEL
+  //arduino pin which triggers an piezzo beeper
+    
+    #define LCD_PINS_RS 16 
+    #define LCD_PINS_ENABLE 17
+    #define LCD_PINS_D4 23
+    #define LCD_PINS_D5 25 
+    #define LCD_PINS_D6 27
+    #define LCD_PINS_D7 29
+    
+    //buttons are directly attached using AUX-2
+    #define BTN_EN1 59
+    #define BTN_EN2 64
+    #define BTN_ENC 43  //the click
+    
+    #define BLEN_C 2
+    #define BLEN_B 1
+    #define BLEN_A 0
+    
+    #define SDCARDDETECT -1		// Ramps does not use this port
+    
+      //encoder rotation values
+    #define encrot0 0
+    #define encrot1 2
+    #define encrot2 3
+    #define encrot3 1
+#endif
+#endif //ULTRA_LCD
+
+#endif
 
 #ifndef KNOWN_BOARD
 #error Unknown MOTHERBOARD value in configuration.h
@@ -1149,14 +1452,44 @@
   #define _E2_PINS
 #endif
 
+#ifdef X_STOP_PIN
+  #if X_HOME_DIR < 0
+    #define X_MIN_PIN X_STOP_PIN
+    #define X_MAX_PIN -1
+  #else
+    #define X_MIN_PIN -1
+    #define X_MAX_PIN X_STOP_PIN
+  #endif
+#endif
+
+#ifdef Y_STOP_PIN
+  #if Y_HOME_DIR < 0
+    #define Y_MIN_PIN Y_STOP_PIN
+    #define Y_MAX_PIN -1
+  #else
+    #define Y_MIN_PIN -1
+    #define Y_MAX_PIN Y_STOP_PIN
+  #endif
+#endif
+
+#ifdef Z_STOP_PIN
+  #if Z_HOME_DIR < 0
+    #define Z_MIN_PIN Z_STOP_PIN
+    #define Z_MAX_PIN -1
+  #else
+    #define Z_MIN_PIN -1
+    #define Z_MAX_PIN Z_STOP_PIN
+  #endif
+#endif
+
 #ifdef DISABLE_MAX_ENDSTOPS
 #define X_MAX_PIN          -1
 #define Y_MAX_PIN          -1
 #define Z_MAX_PIN          -1
 #endif
 
-#define SENSITIVE_PINS {0, 1, X_STEP_PIN, X_DIR_PIN, X_ENABLE_PIN, X_MIN_PIN, X_MAX_PIN, Y_STEP_PIN, Y_DIR_PIN, Y_ENABLE_PIN, Y_MIN_PIN, Y_MAX_PIN, Z_STEP_PIN, Z_DIR_PIN, Z_ENABLE_PIN, Z_MIN_PIN, Z_MAX_PIN, LED_PIN, PS_ON_PIN, \
+#define SENSITIVE_PINS {0, 1, X_STEP_PIN, X_DIR_PIN, X_ENABLE_PIN, X_MIN_PIN, X_MAX_PIN, Y_STEP_PIN, Y_DIR_PIN, Y_ENABLE_PIN, Y_MIN_PIN, Y_MAX_PIN, Z_STEP_PIN, Z_DIR_PIN, Z_ENABLE_PIN, Z_MIN_PIN, Z_MAX_PIN, PS_ON_PIN, \
                         HEATER_BED_PIN, FAN_PIN,                  \
                         _E0_PINS _E1_PINS _E2_PINS             \
-                        TEMP_0_PIN, TEMP_1_PIN, TEMP_2_PIN, TEMP_BED_PIN }
+                        analogInputToDigitalPin(TEMP_0_PIN), analogInputToDigitalPin(TEMP_1_PIN), analogInputToDigitalPin(TEMP_2_PIN), analogInputToDigitalPin(TEMP_BED_PIN) }
 #endif
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index 6c47e29..66809a1 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -80,8 +80,6 @@ long position[4];   //rescaled from extern when axis_steps_per_unit are changed
 static float previous_speed[4]; // Speed of previous path line segment
 static float previous_nominal_speed; // Nominal speed of previous path line segment
 
-extern volatile int extrudemultiply; // Sets extrude multiply factor (in percent)
-
 #ifdef AUTOTEMP
 float autotemp_max=250;
 float autotemp_min=210;
@@ -103,12 +101,11 @@ volatile unsigned char block_buffer_tail;           // Index of the block to pro
 bool allow_cold_extrude=false;
 #endif
 #ifdef XY_FREQUENCY_LIMIT
+#define MAX_FREQ_TIME (1000000.0/XY_FREQUENCY_LIMIT)
 // Used for the frequency limit
 static unsigned char old_direction_bits = 0;               // Old direction bits. Used for speed calculations
-static long x_segment_time[3]={
-  0,0,0};                     // Segment times (in us). Used for speed calculations
-static long y_segment_time[3]={
-  0,0,0};
+static long x_segment_time[3]={MAX_FREQ_TIME + 1,0,0};     // Segment times (in us). Used for speed calculations
+static long y_segment_time[3]={MAX_FREQ_TIME + 1,0,0};
 #endif
 
 // Returns the index of the next block in the ring buffer
@@ -191,10 +188,9 @@ void calculate_trapezoid_for_block(block_t *block, float entry_factor, float exi
   // have to use intersection_distance() to calculate when to abort acceleration and start braking
   // in order to reach the final_rate exactly at the end of this block.
   if (plateau_steps < 0) {
-    accelerate_steps = ceil(
-    intersection_distance(block->initial_rate, block->final_rate, acceleration, block->step_event_count));
+    accelerate_steps = ceil(intersection_distance(block->initial_rate, block->final_rate, acceleration, block->step_event_count));
     accelerate_steps = max(accelerate_steps,0); // Check limits due to numerical round-off
-    accelerate_steps = min(accelerate_steps,block->step_event_count);
+    accelerate_steps = min((uint32_t)accelerate_steps,block->step_event_count);//(We can cast here to unsigned, because the above line ensures that we are above zero)
     plateau_steps = 0;
   }
 
@@ -436,7 +432,8 @@ void getHighESpeed()
 }
 #endif
 
-void check_axes_activity() {
+void check_axes_activity()
+{
   unsigned char x_active = 0;
   unsigned char y_active = 0;  
   unsigned char z_active = 0;
@@ -445,10 +442,12 @@ void check_axes_activity() {
   unsigned char tail_fan_speed = 0;
   block_t *block;
 
-  if(block_buffer_tail != block_buffer_head) {
+  if(block_buffer_tail != block_buffer_head)
+  {
     uint8_t block_index = block_buffer_tail;
     tail_fan_speed = block_buffer[block_index].fan_speed;
-    while(block_index != block_buffer_head) {
+    while(block_index != block_buffer_head)
+    {
       block = &block_buffer[block_index];
       if(block->steps_x != 0) x_active++;
       if(block->steps_y != 0) y_active++;
@@ -458,29 +457,37 @@ void check_axes_activity() {
       block_index = (block_index+1) & (BLOCK_BUFFER_SIZE - 1);
     }
   }
-  else {
-#if FAN_PIN > -1
-    if (FanSpeed != 0){
-      analogWrite(FAN_PIN,FanSpeed); // If buffer is empty use current fan speed
+  else
+  {
+    #if FAN_PIN > -1
+    #ifndef FAN_SOFT_PWM
+    if (fanSpeed != 0){
+      analogWrite(FAN_PIN,fanSpeed); // If buffer is empty use current fan speed
     }
-#endif
+    #endif
+	#endif
   }
   if((DISABLE_X) && (x_active == 0)) disable_x();
   if((DISABLE_Y) && (y_active == 0)) disable_y();
   if((DISABLE_Z) && (z_active == 0)) disable_z();
-  if((DISABLE_E) && (e_active == 0)) { 
+  if((DISABLE_E) && (e_active == 0))
+  {
     disable_e0();
     disable_e1();
     disable_e2(); 
   }
 #if FAN_PIN > -1
-  if((FanSpeed == 0) && (fan_speed ==0)) {
+  #ifndef FAN_SOFT_PWM
+  if((fanSpeed == 0) && (fan_speed ==0))
+  {
     analogWrite(FAN_PIN, 0);
   }
 
-  if (FanSpeed != 0 && tail_fan_speed !=0) { 
+  if (fanSpeed != 0 && tail_fan_speed !=0)
+  {
     analogWrite(FAN_PIN,tail_fan_speed);
   }
+  #endif
 #endif
 #ifdef AUTOTEMP
   getHighESpeed();
@@ -499,10 +506,11 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
 
   // If the buffer is full: good! That means we are well ahead of the robot. 
   // Rest here until there is room in the buffer.
-  while(block_buffer_tail == next_buffer_head) { 
+  while(block_buffer_tail == next_buffer_head)
+  {
     manage_heater(); 
     manage_inactivity(); 
-    LCD_STATUS;
+    lcd_update();
   }
 
   // The target position of the tool in absolute steps
@@ -514,23 +522,26 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
   target[Z_AXIS] = lround(z*axis_steps_per_unit[Z_AXIS]);     
   target[E_AXIS] = lround(e*axis_steps_per_unit[E_AXIS]);
 
-#ifdef PREVENT_DANGEROUS_EXTRUDE
+  #ifdef PREVENT_DANGEROUS_EXTRUDE
   if(target[E_AXIS]!=position[E_AXIS])
+  {
     if(degHotend(active_extruder)<EXTRUDE_MINTEMP && !allow_cold_extrude)
     {
       position[E_AXIS]=target[E_AXIS]; //behave as if the move really took place, but ignore E part
       SERIAL_ECHO_START;
       SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
     }
-#ifdef PREVENT_LENGTHY_EXTRUDE
-  if(labs(target[E_AXIS]-position[E_AXIS])>axis_steps_per_unit[E_AXIS]*EXTRUDE_MAXLENGTH)
-  {
-    position[E_AXIS]=target[E_AXIS]; //behave as if the move really took place, but ignore E part
-    SERIAL_ECHO_START;
-    SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
+    
+    #ifdef PREVENT_LENGTHY_EXTRUDE
+    if(labs(target[E_AXIS]-position[E_AXIS])>axis_steps_per_unit[E_AXIS]*EXTRUDE_MAXLENGTH)
+    {
+      position[E_AXIS]=target[E_AXIS]; //behave as if the move really took place, but ignore E part
+      SERIAL_ECHO_START;
+      SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
+    }
+    #endif
   }
-#endif
-#endif
+  #endif
 
   // Prepare to set up new block
   block_t *block = &block_buffer[block_buffer_head];
@@ -548,24 +559,29 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
   block->step_event_count = max(block->steps_x, max(block->steps_y, max(block->steps_z, block->steps_e)));
 
   // Bail if this is a zero-length block
-  if (block->step_event_count <= dropsegments) { 
+  if (block->step_event_count <= dropsegments)
+  { 
     return; 
-  };
+  }
 
-  block->fan_speed = FanSpeed;
+  block->fan_speed = fanSpeed;
 
   // Compute direction bits for this block 
   block->direction_bits = 0;
-  if (target[X_AXIS] < position[X_AXIS]) { 
+  if (target[X_AXIS] < position[X_AXIS])
+  {
     block->direction_bits |= (1<<X_AXIS); 
   }
-  if (target[Y_AXIS] < position[Y_AXIS]) { 
+  if (target[Y_AXIS] < position[Y_AXIS])
+  {
     block->direction_bits |= (1<<Y_AXIS); 
   }
-  if (target[Z_AXIS] < position[Z_AXIS]) { 
+  if (target[Z_AXIS] < position[Z_AXIS])
+  {
     block->direction_bits |= (1<<Z_AXIS); 
   }
-  if (target[E_AXIS] < position[E_AXIS]) { 
+  if (target[E_AXIS] < position[E_AXIS])
+  {
     block->direction_bits |= (1<<E_AXIS); 
   }
 
@@ -579,16 +595,19 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
 #endif
 
   // Enable all
-  if(block->steps_e != 0) { 
+  if(block->steps_e != 0)
+  {
     enable_e0();
     enable_e1();
     enable_e2(); 
   }
 
-  if (block->steps_e == 0) {
+  if (block->steps_e == 0)
+  {
     if(feed_rate<mintravelfeedrate) feed_rate=mintravelfeedrate;
   }
-  else {
+  else
+  {
     if(feed_rate<minimumfeedrate) feed_rate=minimumfeedrate;
   } 
 
@@ -597,10 +616,12 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
   delta_mm[Y_AXIS] = (target[Y_AXIS]-position[Y_AXIS])/axis_steps_per_unit[Y_AXIS];
   delta_mm[Z_AXIS] = (target[Z_AXIS]-position[Z_AXIS])/axis_steps_per_unit[Z_AXIS];
   delta_mm[E_AXIS] = ((target[E_AXIS]-position[E_AXIS])/axis_steps_per_unit[E_AXIS])*extrudemultiply/100.0;
-  if ( block->steps_x <=dropsegments && block->steps_y <=dropsegments && block->steps_z <=dropsegments ) {
+  if ( block->steps_x <=dropsegments && block->steps_y <=dropsegments && block->steps_z <=dropsegments )
+  {
     block->millimeters = fabs(delta_mm[E_AXIS]);
   } 
-  else {
+  else
+  {
     block->millimeters = sqrt(square(delta_mm[X_AXIS]) + square(delta_mm[Y_AXIS]) + square(delta_mm[Z_AXIS]));
   }
   float inverse_millimeters = 1.0/block->millimeters;  // Inverse millimeters to remove multiple divides 
@@ -612,15 +633,21 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
 
   // slow down when de buffer starts to empty, rather than wait at the corner for a buffer refill
 #ifdef OLD_SLOWDOWN
-  if(moves_queued < (BLOCK_BUFFER_SIZE * 0.5) && moves_queued > 1) feed_rate = feed_rate*moves_queued / (BLOCK_BUFFER_SIZE * 0.5); 
+  if(moves_queued < (BLOCK_BUFFER_SIZE * 0.5) && moves_queued > 1)
+    feed_rate = feed_rate*moves_queued / (BLOCK_BUFFER_SIZE * 0.5); 
 #endif
 
 #ifdef SLOWDOWN
   //  segment time im micro seconds
   unsigned long segment_time = lround(1000000.0/inverse_second);
-  if ((moves_queued > 1) && (moves_queued < (BLOCK_BUFFER_SIZE * 0.5))) {
-    if (segment_time < minsegmenttime)  { // buffer is draining, add extra time.  The amount of time added increases if the buffer is still emptied more.
+  if ((moves_queued > 1) && (moves_queued < (BLOCK_BUFFER_SIZE * 0.5)))
+  {
+    if (segment_time < minsegmenttime)
+    { // buffer is draining, add extra time.  The amount of time added increases if the buffer is still emptied more.
       inverse_second=1000000.0/(segment_time+lround(2*(minsegmenttime-segment_time)/moves_queued));
+      #ifdef XY_FREQUENCY_LIMIT
+         segment_time = lround(1000000.0/inverse_second);
+      #endif
     }
   }
 #endif
@@ -633,7 +660,8 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
   // Calculate and limit speed in mm/sec for each axis
   float current_speed[4];
   float speed_factor = 1.0; //factor <=1 do decrease speed
-  for(int i=0; i < 4; i++) {
+  for(int i=0; i < 4; i++)
+  {
     current_speed[i] = delta_mm[i] * inverse_second;
     if(fabs(current_speed[i]) > max_feedrate[i])
       speed_factor = min(speed_factor, max_feedrate[i] / fabs(current_speed[i]));
@@ -642,23 +670,27 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
   // Max segement time in us.
 #ifdef XY_FREQUENCY_LIMIT
 #define MAX_FREQ_TIME (1000000.0/XY_FREQUENCY_LIMIT)
-
   // Check and limit the xy direction change frequency
   unsigned char direction_change = block->direction_bits ^ old_direction_bits;
   old_direction_bits = block->direction_bits;
-
-  if((direction_change & (1<<X_AXIS)) == 0) {
+  segment_time = lround((float)segment_time / speed_factor);
+  
+  if((direction_change & (1<<X_AXIS)) == 0)
+  {
     x_segment_time[0] += segment_time;
   }
-  else {
+  else
+  {
     x_segment_time[2] = x_segment_time[1];
     x_segment_time[1] = x_segment_time[0];
     x_segment_time[0] = segment_time;
   }
-  if((direction_change & (1<<Y_AXIS)) == 0) {
+  if((direction_change & (1<<Y_AXIS)) == 0)
+  {
     y_segment_time[0] += segment_time;
   }
-  else {
+  else
+  {
     y_segment_time[2] = y_segment_time[1];
     y_segment_time[1] = y_segment_time[0];
     y_segment_time[0] = segment_time;
@@ -666,12 +698,15 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
   long max_x_segment_time = max(x_segment_time[0], max(x_segment_time[1], x_segment_time[2]));
   long max_y_segment_time = max(y_segment_time[0], max(y_segment_time[1], y_segment_time[2]));
   long min_xy_segment_time =min(max_x_segment_time, max_y_segment_time);
-  if(min_xy_segment_time < MAX_FREQ_TIME) speed_factor = min(speed_factor, speed_factor * (float)min_xy_segment_time / (float)MAX_FREQ_TIME);
+  if(min_xy_segment_time < MAX_FREQ_TIME)
+    speed_factor = min(speed_factor, speed_factor * (float)min_xy_segment_time / (float)MAX_FREQ_TIME);
 #endif
 
   // Correct the speed  
-  if( speed_factor < 1.0) {
-    for(unsigned char i=0; i < 4; i++) {
+  if( speed_factor < 1.0)
+  {
+    for(unsigned char i=0; i < 4; i++)
+    {
       current_speed[i] *= speed_factor;
     }
     block->nominal_speed *= speed_factor;
@@ -680,10 +715,12 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
 
   // Compute and limit the acceleration rate for the trapezoid generator.  
   float steps_per_mm = block->step_event_count/block->millimeters;
-  if(block->steps_x == 0 && block->steps_y == 0 && block->steps_z == 0) {
+  if(block->steps_x == 0 && block->steps_y == 0 && block->steps_z == 0)
+  {
     block->acceleration_st = ceil(retract_acceleration * steps_per_mm); // convert to: acceleration steps/sec^2
   }
-  else {
+  else
+  {
     block->acceleration_st = ceil(acceleration * steps_per_mm); // convert to: acceleration steps/sec^2
     // Limit acceleration per axis
     if(((float)block->acceleration_st * (float)block->steps_x / (float)block->step_event_count) > axis_steps_per_sqr_second[X_AXIS])
diff --git a/Marlin/speed_lookuptable.h b/Marlin/speed_lookuptable.h
index 670e744..b7c00f1 100644
--- a/Marlin/speed_lookuptable.h
+++ b/Marlin/speed_lookuptable.h
@@ -75,7 +75,7 @@ const uint16_t speed_lookuptable_slow[256][2] PROGMEM = {\
 { 992, 4}, { 988, 4}, { 984, 4}, { 980, 4}, { 976, 4}, { 972, 4}, { 968, 3}, { 965, 3}
 };
 
-#else
+#elif F_CPU == 20000000
 
 const uint16_t speed_lookuptable_fast[256][2] PROGMEM = {
    {62500, 54055}, {8445, 3917}, {4528, 1434}, {3094, 745}, {2349, 456}, {1893, 307}, {1586, 222}, {1364, 167},
diff --git a/Marlin/stepper.cpp b/Marlin/stepper.cpp
index d5c8164..4ed8bef 100644
--- a/Marlin/stepper.cpp
+++ b/Marlin/stepper.cpp
@@ -27,8 +27,11 @@
 #include "temperature.h"
 #include "ultralcd.h"
 #include "language.h"
+#include "cardreader.h"
 #include "speed_lookuptable.h"
-
+#if DIGIPOTSS_PIN > -1
+#include <SPI.h>
+#endif
 
 
 //===========================================================================
@@ -52,8 +55,8 @@ volatile static unsigned long step_events_completed; // The number of step event
 #ifdef ADVANCE
   static long advance_rate, advance, final_advance = 0;
   static long old_advance = 0;
+  static long e_steps[3];
 #endif
-static long e_steps[3];
 static long acceleration_time, deceleration_time;
 //static unsigned long accelerate_until, decelerate_after, acceleration_rate, initial_rate, final_rate, nominal_rate;
 static unsigned short acc_step_rate; // needed for deccelaration start point
@@ -65,6 +68,9 @@ volatile long endstops_stepsTotal,endstops_stepsDone;
 static volatile bool endstop_x_hit=false;
 static volatile bool endstop_y_hit=false;
 static volatile bool endstop_z_hit=false;
+#ifdef ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
+bool abort_on_endstop_hit = false;
+#endif
 
 static bool old_x_min_endstop=false;
 static bool old_x_max_endstop=false;
@@ -76,7 +82,7 @@ static bool old_z_max_endstop=false;
 static bool check_endstops = true;
 
 volatile long count_position[NUM_AXIS] = { 0, 0, 0, 0};
-volatile char count_direction[NUM_AXIS] = { 1, 1, 1, 1};
+volatile signed char count_direction[NUM_AXIS] = { 1, 1, 1, 1};
 
 //===========================================================================
 //=============================functions         ============================
@@ -167,17 +173,31 @@ void checkHitEndstops()
    SERIAL_ECHOPGM(MSG_ENDSTOPS_HIT);
    if(endstop_x_hit) {
      SERIAL_ECHOPAIR(" X:",(float)endstops_trigsteps[X_AXIS]/axis_steps_per_unit[X_AXIS]);
+     LCD_MESSAGEPGM(MSG_ENDSTOPS_HIT "X");
    }
    if(endstop_y_hit) {
      SERIAL_ECHOPAIR(" Y:",(float)endstops_trigsteps[Y_AXIS]/axis_steps_per_unit[Y_AXIS]);
+     LCD_MESSAGEPGM(MSG_ENDSTOPS_HIT "Y");
    }
    if(endstop_z_hit) {
      SERIAL_ECHOPAIR(" Z:",(float)endstops_trigsteps[Z_AXIS]/axis_steps_per_unit[Z_AXIS]);
+     LCD_MESSAGEPGM(MSG_ENDSTOPS_HIT "Z");
    }
-   SERIAL_ECHOLN("");
+   SERIAL_ECHOLN("");
    endstop_x_hit=false;
    endstop_y_hit=false;
-   endstop_z_hit=false;
+   endstop_z_hit=false;
+#ifdef ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
+   if (abort_on_endstop_hit)
+   {
+     card.sdprinting = false;
+     card.closefile();
+     quickStop();
+     setTargetHotend0(0);
+     setTargetHotend1(0);
+     setTargetHotend2(0);
+   }
+#endif
  }
 }
 
@@ -476,10 +496,10 @@ ISR(TIMER1_COMPA_vect)
 
     
     for(int8_t i=0; i < step_loops; i++) { // Take multiple steps per interrupt (For high speed moves) 
-      #if MOTHERBOARD != 8 // !teensylu
+      #ifndef AT90USB
       MSerial.checkRx(); // Check for serial chars.
-      #endif 
-      
+      #endif
+
       #ifdef ADVANCE
       counter_e += current_block->steps_e;
       if (counter_e > 0) {
@@ -714,6 +734,9 @@ ISR(TIMER1_COMPA_vect)
 
 void st_init()
 {
+  digipot_init(); //Initialize Digipot Motor Current
+  microstep_init(); //Initialize Microstepping Pins
+  
   //Initialize Dir Pins
   #if X_DIR_PIN > -1
     SET_OUTPUT(X_DIR_PIN);
@@ -819,38 +842,36 @@ void st_init()
   #if (X_STEP_PIN > -1) 
     SET_OUTPUT(X_STEP_PIN);
     WRITE(X_STEP_PIN,INVERT_X_STEP_PIN);
-    if(!X_ENABLE_ON) WRITE(X_ENABLE_PIN,HIGH);
+    disable_x();
   #endif  
   #if (Y_STEP_PIN > -1) 
     SET_OUTPUT(Y_STEP_PIN);
     WRITE(Y_STEP_PIN,INVERT_Y_STEP_PIN);
-    if(!Y_ENABLE_ON) WRITE(Y_ENABLE_PIN,HIGH);
+    disable_y();
   #endif  
   #if (Z_STEP_PIN > -1) 
     SET_OUTPUT(Z_STEP_PIN);
     WRITE(Z_STEP_PIN,INVERT_Z_STEP_PIN);
-    if(!Z_ENABLE_ON) WRITE(Z_ENABLE_PIN,HIGH);
-    
     #if defined(Z_DUAL_STEPPER_DRIVERS) && (Z2_STEP_PIN > -1)
       SET_OUTPUT(Z2_STEP_PIN);
       WRITE(Z2_STEP_PIN,INVERT_Z_STEP_PIN);
-      if(!Z_ENABLE_ON) WRITE(Z2_ENABLE_PIN,HIGH);
     #endif
+    disable_z();
   #endif  
   #if (E0_STEP_PIN > -1) 
     SET_OUTPUT(E0_STEP_PIN);
     WRITE(E0_STEP_PIN,INVERT_E_STEP_PIN);
-    if(!E_ENABLE_ON) WRITE(E0_ENABLE_PIN,HIGH);
+    disable_e0();
   #endif  
   #if defined(E1_STEP_PIN) && (E1_STEP_PIN > -1) 
     SET_OUTPUT(E1_STEP_PIN);
     WRITE(E1_STEP_PIN,INVERT_E_STEP_PIN);
-    if(!E_ENABLE_ON) WRITE(E1_ENABLE_PIN,HIGH);
+    disable_e1();
   #endif  
   #if defined(E2_STEP_PIN) && (E2_STEP_PIN > -1) 
     SET_OUTPUT(E2_STEP_PIN);
     WRITE(E2_STEP_PIN,INVERT_E_STEP_PIN);
-    if(!E_ENABLE_ON) WRITE(E2_ENABLE_PIN,HIGH);
+    disable_e2();
   #endif  
 
   #ifdef CONTROLLERFAN_PIN
@@ -900,7 +921,7 @@ void st_synchronize()
     while( blocks_queued()) {
     manage_heater();
     manage_inactivity();
-    LCD_STATUS;
+    lcd_update();
   }
 }
 
@@ -933,7 +954,6 @@ long st_get_position(uint8_t axis)
 void finishAndDisableSteppers()
 {
   st_synchronize(); 
-  LCD_MESSAGEPGM(MSG_STEPPER_RELEASED);
   disable_x(); 
   disable_y(); 
   disable_z(); 
@@ -951,3 +971,100 @@ void quickStop()
   ENABLE_STEPPER_DRIVER_INTERRUPT();
 }
 
+void digitalPotWrite(int address, int value) // From Arduino DigitalPotControl example
+{
+  #if DIGIPOTSS_PIN > -1
+    digitalWrite(DIGIPOTSS_PIN,LOW); // take the SS pin low to select the chip
+    SPI.transfer(address); //  send in the address and value via SPI:
+    SPI.transfer(value);
+    digitalWrite(DIGIPOTSS_PIN,HIGH); // take the SS pin high to de-select the chip:
+    //delay(10);
+  #endif
+}
+
+void digipot_init() //Initialize Digipot Motor Current
+{
+  #if DIGIPOTSS_PIN > -1
+    const uint8_t digipot_motor_current[] = DIGIPOT_MOTOR_CURRENT;
+    
+    SPI.begin(); 
+    pinMode(DIGIPOTSS_PIN, OUTPUT);    
+    for(int i=0;i<=4;i++) 
+      //digitalPotWrite(digipot_ch[i], digipot_motor_current[i]);
+      digipot_current(i,digipot_motor_current[i]);
+  #endif
+}
+
+void digipot_current(uint8_t driver, int current)
+{
+  #if DIGIPOTSS_PIN > -1
+    const uint8_t digipot_ch[] = DIGIPOT_CHANNELS;
+    digitalPotWrite(digipot_ch[driver], current);
+  #endif
+}
+
+void microstep_init()
+{
+  #if X_MS1_PIN > -1
+  const uint8_t microstep_modes[] = MICROSTEP_MODES;
+  pinMode(X_MS2_PIN,OUTPUT);
+  pinMode(Y_MS2_PIN,OUTPUT);
+  pinMode(Z_MS2_PIN,OUTPUT);
+  pinMode(E0_MS2_PIN,OUTPUT);
+  pinMode(E1_MS2_PIN,OUTPUT);
+  for(int i=0;i<=4;i++) microstep_mode(i,microstep_modes[i]);
+  #endif
+}
+
+void microstep_ms(uint8_t driver, int8_t ms1, int8_t ms2)
+{
+  if(ms1 > -1) switch(driver)
+  {
+    case 0: digitalWrite( X_MS1_PIN,ms1); break;
+    case 1: digitalWrite( Y_MS1_PIN,ms1); break;
+    case 2: digitalWrite( Z_MS1_PIN,ms1); break;
+    case 3: digitalWrite(E0_MS1_PIN,ms1); break;
+    case 4: digitalWrite(E1_MS1_PIN,ms1); break;
+  }
+  if(ms2 > -1) switch(driver)
+  {
+    case 0: digitalWrite( X_MS2_PIN,ms2); break;
+    case 1: digitalWrite( Y_MS2_PIN,ms2); break;
+    case 2: digitalWrite( Z_MS2_PIN,ms2); break;
+    case 3: digitalWrite(E0_MS2_PIN,ms2); break;
+    case 4: digitalWrite(E1_MS2_PIN,ms2); break;
+  }
+}
+
+void microstep_mode(uint8_t driver, uint8_t stepping_mode)
+{
+  switch(stepping_mode)
+  {
+    case 1: microstep_ms(driver,MICROSTEP1); break;
+    case 2: microstep_ms(driver,MICROSTEP2); break;
+    case 4: microstep_ms(driver,MICROSTEP4); break;
+    case 8: microstep_ms(driver,MICROSTEP8); break;
+    case 16: microstep_ms(driver,MICROSTEP16); break;
+  }
+}
+
+void microstep_readings()
+{
+      SERIAL_PROTOCOLPGM("MS1,MS2 Pins\n");
+      SERIAL_PROTOCOLPGM("X: ");
+      SERIAL_PROTOCOL(   digitalRead(X_MS1_PIN));
+      SERIAL_PROTOCOLLN( digitalRead(X_MS2_PIN));
+      SERIAL_PROTOCOLPGM("Y: ");
+      SERIAL_PROTOCOL(   digitalRead(Y_MS1_PIN));
+      SERIAL_PROTOCOLLN( digitalRead(Y_MS2_PIN));
+      SERIAL_PROTOCOLPGM("Z: ");
+      SERIAL_PROTOCOL(   digitalRead(Z_MS1_PIN));
+      SERIAL_PROTOCOLLN( digitalRead(Z_MS2_PIN));
+      SERIAL_PROTOCOLPGM("E0: ");
+      SERIAL_PROTOCOL(   digitalRead(E0_MS1_PIN));
+      SERIAL_PROTOCOLLN( digitalRead(E0_MS2_PIN));
+      SERIAL_PROTOCOLPGM("E1: ");
+      SERIAL_PROTOCOL(   digitalRead(E1_MS1_PIN));
+      SERIAL_PROTOCOLLN( digitalRead(E1_MS2_PIN));
+}
+
diff --git a/Marlin/stepper.h b/Marlin/stepper.h
index 7671a65..6e60a33 100644
--- a/Marlin/stepper.h
+++ b/Marlin/stepper.h
@@ -25,7 +25,7 @@
 
 #if EXTRUDERS > 2
   #define WRITE_E_STEP(v) { if(current_block->active_extruder == 2) { WRITE(E2_STEP_PIN, v); } else { if(current_block->active_extruder == 1) { WRITE(E1_STEP_PIN, v); } else { WRITE(E0_STEP_PIN, v); }}}
-  #define NORM_E_DIR() { if(current_block->active_extruder == 2) { WRITE(!E2_DIR_PIN, INVERT_E2_DIR); } else { if(current_block->active_extruder == 1) { WRITE(!E1_DIR_PIN, INVERT_E1_DIR); } else { WRITE(E0_DIR_PIN, !INVERT_E0_DIR); }}}
+  #define NORM_E_DIR() { if(current_block->active_extruder == 2) { WRITE(E2_DIR_PIN, !INVERT_E2_DIR); } else { if(current_block->active_extruder == 1) { WRITE(E1_DIR_PIN, !INVERT_E1_DIR); } else { WRITE(E0_DIR_PIN, !INVERT_E0_DIR); }}}
   #define REV_E_DIR() { if(current_block->active_extruder == 2) { WRITE(E2_DIR_PIN, INVERT_E2_DIR); } else { if(current_block->active_extruder == 1) { WRITE(E1_DIR_PIN, INVERT_E1_DIR); } else { WRITE(E0_DIR_PIN, INVERT_E0_DIR); }}}
 #elif EXTRUDERS > 1
   #define WRITE_E_STEP(v) { if(current_block->active_extruder == 1) { WRITE(E1_STEP_PIN, v); } else { WRITE(E0_STEP_PIN, v); }}
@@ -37,6 +37,9 @@
   #define REV_E_DIR() WRITE(E0_DIR_PIN, INVERT_E0_DIR)
 #endif
 
+#ifdef ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
+extern bool abort_on_endstop_hit;
+#endif
 
 // Initialize and start the stepper motor subsystem
 void st_init();
@@ -68,4 +71,13 @@ void finishAndDisableSteppers();
 extern block_t *current_block;  // A pointer to the block currently being traced
 
 void quickStop();
+
+void digitalPotWrite(int address, int value);
+void microstep_ms(uint8_t driver, int8_t ms1, int8_t ms2);
+void microstep_mode(uint8_t driver, uint8_t stepping);
+void digipot_init();
+void digipot_current(uint8_t driver, int current);
+void microstep_init();
+void microstep_readings();
+
 #endif
diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index a0413f7..6093c99 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -37,19 +37,14 @@
 //===========================================================================
 //=============================public variables============================
 //===========================================================================
-int target_raw[EXTRUDERS] = { 0 };
-int target_raw_bed = 0;
-#ifdef BED_LIMIT_SWITCHING
-int target_bed_low_temp =0;  
-int target_bed_high_temp =0;
-#endif
-int current_raw[EXTRUDERS] = { 0 };
-int current_raw_bed = 0;
+int target_temperature[EXTRUDERS] = { 0 };
+int target_temperature_bed = 0;
+int current_temperature_raw[EXTRUDERS] = { 0 };
+float current_temperature[EXTRUDERS] = { 0 };
+int current_temperature_bed_raw = 0;
+float current_temperature_bed = 0;
 
 #ifdef PIDTEMP
-  // used external
-  float pid_setpoint[EXTRUDERS] = { 0.0 };
-  
   float Kp=DEFAULT_Kp;
   float Ki=(DEFAULT_Ki*PID_dT);
   float Kd=(DEFAULT_Kd/PID_dT);
@@ -57,6 +52,12 @@ int current_raw_bed = 0;
     float Kc=DEFAULT_Kc;
   #endif
 #endif //PIDTEMP
+
+#ifdef PIDTEMPBED
+  float bedKp=DEFAULT_bedKp;
+  float bedKi=(DEFAULT_bedKi*PID_dT);
+  float bedKd=(DEFAULT_bedKd/PID_dT);
+#endif //PIDTEMPBED
   
   
 //===========================================================================
@@ -64,9 +65,6 @@ int current_raw_bed = 0;
 //===========================================================================
 static volatile bool temp_meas_ready = false;
 
-static unsigned long  previous_millis_bed_heater;
-//static unsigned long previous_millis_heater;
-
 #ifdef PIDTEMP
   //static cannot be external:
   static float temp_iState[EXTRUDERS] = { 0 };
@@ -82,84 +80,123 @@ static unsigned long  previous_millis_bed_heater;
   // static float pid_output[EXTRUDERS];
   static bool pid_reset[EXTRUDERS];
 #endif //PIDTEMP
+#ifdef PIDTEMPBED
+  //static cannot be external:
+  static float temp_iState_bed = { 0 };
+  static float temp_dState_bed = { 0 };
+  static float pTerm_bed;
+  static float iTerm_bed;
+  static float dTerm_bed;
+  //int output;
+  static float pid_error_bed;
+  static float temp_iState_min_bed;
+  static float temp_iState_max_bed;
+#else //PIDTEMPBED
+	static unsigned long  previous_millis_bed_heater;
+#endif //PIDTEMPBED
   static unsigned char soft_pwm[EXTRUDERS];
-  
-#ifdef WATCHPERIOD
-  int watch_raw[EXTRUDERS] = { -1000 }; // the first value used for all
-  int watch_oldtemp[3] = {0,0,0};
-  unsigned long watchmillis = 0;
-#endif //WATCHPERIOD
-
-// Init min and max temp with extreme values to prevent false errors during startup
-  static int minttemp[EXTRUDERS] = { 0 };
-  static int maxttemp[EXTRUDERS] = { 16383 }; // the first value used for all
-  static int bed_minttemp = 0;
-  static int bed_maxttemp = 16383;
-  static void *heater_ttbl_map[EXTRUDERS] = { (void *)heater_0_temptable
-#if EXTRUDERS > 1
-                                            , (void *)heater_1_temptable
-#endif
-#if EXTRUDERS > 2
-                                            , (void *)heater_2_temptable
+  static unsigned char soft_pwm_bed;
+#ifdef FAN_SOFT_PWM
+  static unsigned char soft_pwm_fan;
 #endif
+
+
+  
 #if EXTRUDERS > 3
-  #error Unsupported number of extruders
-#endif
-  };
-  static int heater_ttbllen_map[EXTRUDERS] = { heater_0_temptable_len
-#if EXTRUDERS > 1
-                                             , heater_1_temptable_len
-#endif
-#if EXTRUDERS > 2
-                                             , heater_2_temptable_len
+# error Unsupported number of extruders
+#elif EXTRUDERS > 2
+# define ARRAY_BY_EXTRUDERS(v1, v2, v3) { v1, v2, v3 }
+#elif EXTRUDERS > 1
+# define ARRAY_BY_EXTRUDERS(v1, v2, v3) { v1, v2 }
+#else
+# define ARRAY_BY_EXTRUDERS(v1, v2, v3) { v1 }
 #endif
-#if EXTRUDERS > 3
-  #error Unsupported number of extruders
+
+// Init min and max temp with extreme values to prevent false errors during startup
+static int minttemp_raw[EXTRUDERS] = ARRAY_BY_EXTRUDERS( HEATER_0_RAW_LO_TEMP , HEATER_1_RAW_LO_TEMP , HEATER_2_RAW_LO_TEMP );
+static int maxttemp_raw[EXTRUDERS] = ARRAY_BY_EXTRUDERS( HEATER_0_RAW_HI_TEMP , HEATER_1_RAW_HI_TEMP , HEATER_2_RAW_HI_TEMP );
+static int minttemp[EXTRUDERS] = ARRAY_BY_EXTRUDERS( 0, 0, 0 );
+static int maxttemp[EXTRUDERS] = ARRAY_BY_EXTRUDERS( 16383, 16383, 16383 );
+//static int bed_minttemp_raw = HEATER_BED_RAW_LO_TEMP; /* No bed mintemp error implemented?!? */
+#ifdef BED_MAXTEMP
+static int bed_maxttemp_raw = HEATER_BED_RAW_HI_TEMP;
 #endif
-  };
+static void *heater_ttbl_map[EXTRUDERS] = ARRAY_BY_EXTRUDERS( (void *)HEATER_0_TEMPTABLE, (void *)HEATER_1_TEMPTABLE, (void *)HEATER_2_TEMPTABLE );
+static uint8_t heater_ttbllen_map[EXTRUDERS] = ARRAY_BY_EXTRUDERS( HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN );
+
+static float analog2temp(int raw, uint8_t e);
+static float analog2tempBed(int raw);
+static void updateTemperaturesFromRawValues();
+
+#ifdef WATCH_TEMP_PERIOD
+int watch_start_temp[EXTRUDERS] = ARRAY_BY_EXTRUDERS(0,0,0);
+unsigned long watchmillis[EXTRUDERS] = ARRAY_BY_EXTRUDERS(0,0,0);
+#endif //WATCH_TEMP_PERIOD
 
 //===========================================================================
 //=============================   functions      ============================
 //===========================================================================
 
-void PID_autotune(float temp)
+void PID_autotune(float temp, int extruder, int ncycles)
 {
-  float input;
+  float input = 0.0;
   int cycles=0;
   bool heating = true;
 
   unsigned long temp_millis = millis();
   unsigned long t1=temp_millis;
   unsigned long t2=temp_millis;
-  long t_high;
-  long t_low;
+  long t_high = 0;
+  long t_low = 0;
 
-  long bias=PID_MAX/2;
-  long d = PID_MAX/2;
+  long bias, d;
   float Ku, Tu;
   float Kp, Ki, Kd;
-  float max, min;
-  
+  float max = 0, min = 10000;
+
+	if ((extruder > EXTRUDERS)
+  #if (TEMP_BED_PIN <= -1)
+		||(extruder < 0)
+	#endif
+	){
+  	SERIAL_ECHOLN("PID Autotune failed. Bad extruder number.");
+  	return;
+	}
+	
   SERIAL_ECHOLN("PID Autotune start");
   
   disable_heater(); // switch off all heaters.
-  
-  soft_pwm[0] = PID_MAX/2;
-    
-  for(;;) {
+
+	if (extruder<0)
+	{
+	 	soft_pwm_bed = (MAX_BED_POWER)/2;
+		bias = d = (MAX_BED_POWER)/2;
+  }
+	else
+	{
+	  soft_pwm[extruder] = (PID_MAX)/2;
+		bias = d = (PID_MAX)/2;
+  }
+
+
+
+
+ for(;;) {
 
     if(temp_meas_ready == true) { // temp sample ready
-      CRITICAL_SECTION_START;
-      temp_meas_ready = false;
-      CRITICAL_SECTION_END;
-      input = analog2temp(current_raw[0], 0);
-      
+      updateTemperaturesFromRawValues();
+
+      input = (extruder<0)?current_temperature_bed:current_temperature[extruder];
+
       max=max(max,input);
       min=min(min,input);
       if(heating == true && input > temp) {
         if(millis() - t2 > 5000) { 
           heating=false;
-          soft_pwm[0] = (bias - d) >> 1;
+					if (extruder<0)
+						soft_pwm_bed = (bias - d) >> 1;
+					else
+						soft_pwm[extruder] = (bias - d) >> 1;
           t1=millis();
           t_high=t1 - t2;
           max=temp;
@@ -172,8 +209,8 @@ void PID_autotune(float temp)
           t_low=t2 - t1;
           if(cycles > 0) {
             bias += (d*(t_high - t_low))/(t_low + t_high);
-            bias = constrain(bias, 20 ,PID_MAX-20);
-            if(bias > PID_MAX/2) d = PID_MAX - 1 - bias;
+            bias = constrain(bias, 20 ,(extruder<0?(MAX_BED_POWER):(PID_MAX))-20);
+            if(bias > (extruder<0?(MAX_BED_POWER):(PID_MAX))/2) d = (extruder<0?(MAX_BED_POWER):(PID_MAX)) - 1 - bias;
             else d = bias;
 
             SERIAL_PROTOCOLPGM(" bias: "); SERIAL_PROTOCOL(bias);
@@ -210,7 +247,10 @@ void PID_autotune(float temp)
               */
             }
           }
-          soft_pwm[0] = (bias + d) >> 1;
+					if (extruder<0)
+						soft_pwm_bed = (bias + d) >> 1;
+					else
+						soft_pwm[extruder] = (bias + d) >> 1;
           cycles++;
           min=temp;
         }
@@ -221,21 +261,30 @@ void PID_autotune(float temp)
       return;
     }
     if(millis() - temp_millis > 2000) {
-      temp_millis = millis();
-      SERIAL_PROTOCOLPGM("ok T:");
-      SERIAL_PROTOCOL(degHotend(0));   
+			int p;
+			if (extruder<0){
+	      p=soft_pwm_bed;       
+	      SERIAL_PROTOCOLPGM("ok B:");
+			}else{
+	      p=soft_pwm[extruder];       
+	      SERIAL_PROTOCOLPGM("ok T:");
+			}
+			
+      SERIAL_PROTOCOL(input);   
       SERIAL_PROTOCOLPGM(" @:");
-      SERIAL_PROTOCOLLN(getHeaterPower(0));       
+      SERIAL_PROTOCOLLN(p);       
+
+      temp_millis = millis();
     }
     if(((millis() - t1) + (millis() - t2)) > (10L*60L*1000L*2L)) {
       SERIAL_PROTOCOLLNPGM("PID Autotune failed! timeout");
       return;
     }
-    if(cycles > 5) {
+    if(cycles > ncycles) {
       SERIAL_PROTOCOLLNPGM("PID Autotune finished ! Place the Kp, Ki and Kd constants in the configuration.h");
       return;
     }
-    LCD_STATUS;
+    lcd_update();
   }
 }
 
@@ -246,46 +295,40 @@ void updatePID()
      temp_iState_max[e] = PID_INTEGRAL_DRIVE_MAX / Ki;  
   }
 #endif
+#ifdef PIDTEMPBED
+  temp_iState_max_bed = PID_INTEGRAL_DRIVE_MAX / bedKi;  
+#endif
 }
   
 int getHeaterPower(int heater) {
+	if (heater<0)
+		return soft_pwm_bed;
   return soft_pwm[heater];
 }
 
 void manage_heater()
 {
-#ifdef HEATER_BED_DUTY_CYCLE_DIVIDER
-  static int bed_needs_heating=0;
-  static int bed_is_on=0;
-#endif
-
-  #ifdef USE_WATCHDOG
-    wd_reset();
-  #endif
-  
   float pid_input;
   float pid_output;
 
   if(temp_meas_ready != true)   //better readability
     return; 
 
-  CRITICAL_SECTION_START;
-  temp_meas_ready = false;
-  CRITICAL_SECTION_END;
+  updateTemperaturesFromRawValues();
 
   for(int e = 0; e < EXTRUDERS; e++) 
   {
 
   #ifdef PIDTEMP
-    pid_input = analog2temp(current_raw[e], e);
+    pid_input = current_temperature[e];
 
     #ifndef PID_OPENLOOP
-        pid_error[e] = pid_setpoint[e] - pid_input;
-        if(pid_error[e] > 10) {
+        pid_error[e] = target_temperature[e] - pid_input;
+        if(pid_error[e] > PID_FUNCTIONAL_RANGE) {
           pid_output = PID_MAX;
           pid_reset[e] = true;
         }
-        else if(pid_error[e] < -10) {
+        else if(pid_error[e] < -PID_FUNCTIONAL_RANGE) {
           pid_output = 0;
           pid_reset[e] = true;
         }
@@ -298,101 +341,136 @@ void manage_heater()
           temp_iState[e] += pid_error[e];
           temp_iState[e] = constrain(temp_iState[e], temp_iState_min[e], temp_iState_max[e]);
           iTerm[e] = Ki * temp_iState[e];
+
           //K1 defined in Configuration.h in the PID settings
           #define K2 (1.0-K1)
           dTerm[e] = (Kd * (pid_input - temp_dState[e]))*K2 + (K1 * dTerm[e]);
           temp_dState[e] = pid_input;
+
           pid_output = constrain(pTerm[e] + iTerm[e] - dTerm[e], 0, PID_MAX);
         }
+    #else 
+          pid_output = constrain(target_temperature[e], 0, PID_MAX);
     #endif //PID_OPENLOOP
     #ifdef PID_DEBUG
-    SERIAL_ECHOLN(" PIDDEBUG "<<e<<": Input "<<pid_input<<" Output "<<pid_output" pTerm "<<pTerm[e]<<" iTerm "<<iTerm[e]<<" dTerm "<<dTerm[e]);  
+    SERIAL_ECHO_START(" PIDDEBUG ");
+    SERIAL_ECHO(e);
+    SERIAL_ECHO(": Input ");
+    SERIAL_ECHO(pid_input);
+    SERIAL_ECHO(" Output ");
+    SERIAL_ECHO(pid_output);
+    SERIAL_ECHO(" pTerm ");
+    SERIAL_ECHO(pTerm[e]);
+    SERIAL_ECHO(" iTerm ");
+    SERIAL_ECHO(iTerm[e]);
+    SERIAL_ECHO(" dTerm ");
+    SERIAL_ECHOLN(dTerm[e]);  
     #endif //PID_DEBUG
   #else /* PID off */
     pid_output = 0;
-    if(current_raw[e] < target_raw[e]) {
+    if(current_temperature[e] < target_temperature[e]) {
       pid_output = PID_MAX;
     }
   #endif
 
     // Check if temperature is within the correct range
-    if((current_raw[e] > minttemp[e]) && (current_raw[e] < maxttemp[e])) 
+    if((current_temperature[e] > minttemp[e]) && (current_temperature[e] < maxttemp[e])) 
     {
       soft_pwm[e] = (int)pid_output >> 1;
     }
     else {
       soft_pwm[e] = 0;
     }
-  } // End extruder for loop
-  
-  #ifdef WATCHPERIOD
-    if(watchmillis && millis() - watchmillis > WATCHPERIOD){
-        if(watch_oldtemp[0] >= degHotend(active_extruder)){
-            setTargetHotend(0,active_extruder);
+
+    #ifdef WATCH_TEMP_PERIOD
+    if(watchmillis[e] && millis() - watchmillis[e] > WATCH_TEMP_PERIOD)
+    {
+        if(degHotend(e) < watch_start_temp[e] + WATCH_TEMP_INCREASE)
+        {
+            setTargetHotend(0, e);
             LCD_MESSAGEPGM("Heating failed");
             SERIAL_ECHO_START;
             SERIAL_ECHOLN("Heating failed");
         }else{
-            watchmillis = 0;
+            watchmillis[e] = 0;
         }
     }
-  #endif
+    #endif
+
+  } // End extruder for loop
   
-#ifdef HEATER_BED_DUTY_CYCLE_DIVIDER
-  if (bed_needs_heating){
-    if (bed_is_on==0)
-        WRITE(HEATER_BED_PIN,HIGH);
-    if (bed_is_on==1)
-        WRITE(HEATER_BED_PIN,LOW);
-    bed_is_on=(bed_is_on+1) % HEATER_BED_DUTY_CYCLE_DIVIDER;
-  }
-#endif
 
+  #ifndef PIDTEMPBED
   if(millis() - previous_millis_bed_heater < BED_CHECK_INTERVAL)
     return;
   previous_millis_bed_heater = millis();
+  #endif
+
+  #if TEMP_SENSOR_BED != 0
   
-  #if TEMP_BED_PIN > -1
-  
-    #ifdef HEATER_BED_DUTY_CYCLE_DIVIDER
-    bed_needs_heating=0;
-    #endif
+  #ifdef PIDTEMPBED
+    pid_input = current_temperature_bed;
+
+    #ifndef PID_OPENLOOP
+		  pid_error_bed = target_temperature_bed - pid_input;
+		  pTerm_bed = bedKp * pid_error_bed;
+		  temp_iState_bed += pid_error_bed;
+		  temp_iState_bed = constrain(temp_iState_bed, temp_iState_min_bed, temp_iState_max_bed);
+		  iTerm_bed = bedKi * temp_iState_bed;
 
-    #ifndef BED_LIMIT_SWITCHING
+		  //K1 defined in Configuration.h in the PID settings
+		  #define K2 (1.0-K1)
+		  dTerm_bed= (bedKd * (pid_input - temp_dState_bed))*K2 + (K1 * dTerm_bed);
+		  temp_dState_bed = pid_input;
+
+		  pid_output = constrain(pTerm_bed + iTerm_bed - dTerm_bed, 0, MAX_BED_POWER);
+
+    #else 
+      pid_output = constrain(target_temperature_bed, 0, MAX_BED_POWER);
+    #endif //PID_OPENLOOP
+
+	  if((current_temperature_bed > BED_MINTEMP) && (current_temperature_bed < BED_MAXTEMP)) 
+	  {
+	    soft_pwm_bed = (int)pid_output >> 1;
+	  }
+	  else {
+	    soft_pwm_bed = 0;
+	  }
+
+    #elif !defined(BED_LIMIT_SWITCHING)
       // Check if temperature is within the correct range
-      if((current_raw_bed > bed_minttemp) && (current_raw_bed < bed_maxttemp)) {
-        if(current_raw_bed >= target_raw_bed)
+      if((current_temperature_bed > BED_MINTEMP) && (current_temperature_bed < BED_MAXTEMP))
+      {
+        if(current_temperature_bed >= target_temperature_bed)
         {
-          WRITE(HEATER_BED_PIN,LOW);
+          soft_pwm_bed = 0;
         }
         else 
         {
-          #ifdef HEATER_BED_DUTY_CYCLE_DIVIDER
-          bed_needs_heating=1;
-          #endif
-          WRITE(HEATER_BED_PIN,HIGH);
+          soft_pwm_bed = MAX_BED_POWER>>1;
         }
       }
-      else {
+      else
+      {
+        soft_pwm_bed = 0;
         WRITE(HEATER_BED_PIN,LOW);
       }
     #else //#ifdef BED_LIMIT_SWITCHING
       // Check if temperature is within the correct band
-      if((current_raw_bed > bed_minttemp) && (current_raw_bed < bed_maxttemp)) {
-        if(current_raw_bed > target_bed_high_temp)
+      if((current_temperature_bed > BED_MINTEMP) && (current_temperature_bed < BED_MAXTEMP))
+      {
+        if(current_temperature_bed > target_temperature_bed + BED_HYSTERESIS)
         {
-          WRITE(HEATER_BED_PIN,LOW);
+          soft_pwm_bed = 0;
         }
-        else 
-          if(current_raw_bed <= target_bed_low_temp)
+        else if(current_temperature_bed <= target_temperature_bed - BED_HYSTERESIS)
         {
-          #ifdef HEATER_BED_DUTY_CYCLE_DIVIDER
-          bed_needs_heating=1;
-          #endif
-          WRITE(HEATER_BED_PIN,HIGH);
+          soft_pwm_bed = MAX_BED_POWER>>1;
         }
       }
-      else {
+      else
+      {
+        soft_pwm_bed = 0;
         WRITE(HEATER_BED_PIN,LOW);
       }
     #endif
@@ -400,87 +478,9 @@ void manage_heater()
 }
 
 #define PGM_RD_W(x)   (short)pgm_read_word(&x)
-// Takes hot end temperature value as input and returns corresponding raw value. 
-// For a thermistor, it uses the RepRap thermistor temp table.
-// This is needed because PID in hydra firmware hovers around a given analog value, not a temp value.
-// This function is derived from inversing the logic from a portion of getTemperature() in FiveD RepRap firmware.
-int temp2analog(int celsius, uint8_t e) {
-  if(e >= EXTRUDERS)
-  {
-      SERIAL_ERROR_START;
-      SERIAL_ERROR((int)e);
-      SERIAL_ERRORLNPGM(" - Invalid extruder number!");
-      kill();
-  }
-  #ifdef HEATER_0_USES_MAX6675
-    if (e == 0)
-    {
-      return celsius * 4;
-    }
-  #endif
-  if(heater_ttbl_map[e] != 0)
-  {
-    int raw = 0;
-    byte i;
-    short (*tt)[][2] = (short (*)[][2])(heater_ttbl_map[e]);
-
-    for (i=1; i<heater_ttbllen_map[e]; i++)
-    {
-      if (PGM_RD_W((*tt)[i][1]) < celsius)
-      {
-        raw = PGM_RD_W((*tt)[i-1][0]) + 
-          (celsius - PGM_RD_W((*tt)[i-1][1])) * 
-          (PGM_RD_W((*tt)[i][0]) - PGM_RD_W((*tt)[i-1][0])) /
-          (PGM_RD_W((*tt)[i][1]) - PGM_RD_W((*tt)[i-1][1]));  
-        break;
-      }
-    }
-
-    // Overflow: Set to last value in the table
-    if (i == heater_ttbllen_map[e]) raw = PGM_RD_W((*tt)[i-1][0]);
-
-    return (1023 * OVERSAMPLENR) - raw;
-  }
-  return ((celsius-TEMP_SENSOR_AD595_OFFSET)/TEMP_SENSOR_AD595_GAIN) * (1024.0 / (5.0 * 100.0) ) * OVERSAMPLENR;
-}
-
-// Takes bed temperature value as input and returns corresponding raw value. 
-// For a thermistor, it uses the RepRap thermistor temp table.
-// This is needed because PID in hydra firmware hovers around a given analog value, not a temp value.
-// This function is derived from inversing the logic from a portion of getTemperature() in FiveD RepRap firmware.
-int temp2analogBed(int celsius) {
-#ifdef BED_USES_THERMISTOR
-    int raw = 0;
-    byte i;
-    
-    for (i=1; i<bedtemptable_len; i++)
-    {
-      if (PGM_RD_W(bedtemptable[i][1]) < celsius)
-      {
-        raw = PGM_RD_W(bedtemptable[i-1][0]) + 
-          (celsius - PGM_RD_W(bedtemptable[i-1][1])) * 
-          (PGM_RD_W(bedtemptable[i][0]) - PGM_RD_W(bedtemptable[i-1][0])) /
-          (PGM_RD_W(bedtemptable[i][1]) - PGM_RD_W(bedtemptable[i-1][1]));
-      
-        break;
-      }
-    }
-
-    // Overflow: Set to last value in the table
-    if (i == bedtemptable_len) raw = PGM_RD_W(bedtemptable[i-1][0]);
-
-    return (1023 * OVERSAMPLENR) - raw;
-#elif defined BED_USES_AD595
-    return lround(((celsius-TEMP_SENSOR_AD595_OFFSET)/TEMP_SENSOR_AD595_GAIN) * (1024.0 * OVERSAMPLENR/ (5.0 * 100.0) ) );
-#else
-    #warning No heater-type defined for the bed.
-    return 0;
-#endif
-}
-
 // Derived from RepRap FiveD extruder::getTemperature()
 // For hot end temperature measurement.
-float analog2temp(int raw, uint8_t e) {
+static float analog2temp(int raw, uint8_t e) {
   if(e >= EXTRUDERS)
   {
       SERIAL_ERROR_START;
@@ -495,13 +495,12 @@ float analog2temp(int raw, uint8_t e) {
     }
   #endif
 
-  if(heater_ttbl_map[e] != 0)
+  if(heater_ttbl_map[e] != NULL)
   {
     float celsius = 0;
-    byte i;  
+    uint8_t i;
     short (*tt)[][2] = (short (*)[][2])(heater_ttbl_map[e]);
 
-    raw = (1023 * OVERSAMPLENR) - raw;
     for (i=1; i<heater_ttbllen_map[e]; i++)
     {
       if (PGM_RD_W((*tt)[i][0]) > raw)
@@ -524,50 +523,66 @@ float analog2temp(int raw, uint8_t e) {
 
 // Derived from RepRap FiveD extruder::getTemperature()
 // For bed temperature measurement.
-float analog2tempBed(int raw) {
+static float analog2tempBed(int raw) {
   #ifdef BED_USES_THERMISTOR
     float celsius = 0;
     byte i;
 
-    raw = (1023 * OVERSAMPLENR) - raw;
-
-    for (i=1; i<bedtemptable_len; i++)
+    for (i=1; i<BEDTEMPTABLE_LEN; i++)
     {
-      if (PGM_RD_W(bedtemptable[i][0]) > raw)
+      if (PGM_RD_W(BEDTEMPTABLE[i][0]) > raw)
       {
-        celsius  = PGM_RD_W(bedtemptable[i-1][1]) + 
-          (raw - PGM_RD_W(bedtemptable[i-1][0])) * 
-          (float)(PGM_RD_W(bedtemptable[i][1]) - PGM_RD_W(bedtemptable[i-1][1])) /
-          (float)(PGM_RD_W(bedtemptable[i][0]) - PGM_RD_W(bedtemptable[i-1][0]));
+        celsius  = PGM_RD_W(BEDTEMPTABLE[i-1][1]) + 
+          (raw - PGM_RD_W(BEDTEMPTABLE[i-1][0])) * 
+          (float)(PGM_RD_W(BEDTEMPTABLE[i][1]) - PGM_RD_W(BEDTEMPTABLE[i-1][1])) /
+          (float)(PGM_RD_W(BEDTEMPTABLE[i][0]) - PGM_RD_W(BEDTEMPTABLE[i-1][0]));
         break;
       }
     }
 
     // Overflow: Set to last value in the table
-    if (i == bedtemptable_len) celsius = PGM_RD_W(bedtemptable[i-1][1]);
+    if (i == BEDTEMPTABLE_LEN) celsius = PGM_RD_W(BEDTEMPTABLE[i-1][1]);
 
     return celsius;
   #elif defined BED_USES_AD595
     return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET;
   #else
-    #warning No heater-type defined for the bed.
     return 0;
   #endif
 }
 
+/* Called to get the raw values into the the actual temperatures. The raw values are created in interrupt context,
+    and this function is called from normal context as it is too slow to run in interrupts and will block the stepper routine otherwise */
+static void updateTemperaturesFromRawValues()
+{
+    for(uint8_t e=0;e<EXTRUDERS;e++)
+    {
+        current_temperature[e] = analog2temp(current_temperature_raw[e], e);
+    }
+    current_temperature_bed = analog2tempBed(current_temperature_bed_raw);
+
+    //Reset the watchdog after we know we have a temperature measurement.
+    watchdog_reset();
+
+    CRITICAL_SECTION_START;
+    temp_meas_ready = false;
+    CRITICAL_SECTION_END;
+}
+
 void tp_init()
 {
   // Finish init of mult extruder arrays 
   for(int e = 0; e < EXTRUDERS; e++) {
     // populate with the first value 
-#ifdef WATCHPERIOD
-    watch_raw[e] = watch_raw[0];
-#endif
     maxttemp[e] = maxttemp[0];
 #ifdef PIDTEMP
     temp_iState_min[e] = 0.0;
     temp_iState_max[e] = PID_INTEGRAL_DRIVE_MAX / Ki;
 #endif //PIDTEMP
+#ifdef PIDTEMPBED
+    temp_iState_min_bed = 0.0;
+    temp_iState_max_bed = PID_INTEGRAL_DRIVE_MAX / bedKi;
+#endif //PIDTEMPBED
   }
 
   #if (HEATER_0_PIN > -1) 
@@ -587,6 +602,9 @@ void tp_init()
     #ifdef FAST_PWM_FAN
     setPwmFrequency(FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
     #endif
+    #ifdef FAN_SOFT_PWM
+	soft_pwm_fan=(unsigned char)fanSpeed;
+	#endif
   #endif  
 
   #ifdef HEATER_0_USES_MAX6675
@@ -649,50 +667,101 @@ void tp_init()
   delay(250);
 
 #ifdef HEATER_0_MINTEMP
-  minttemp[0] = temp2analog(HEATER_0_MINTEMP, 0);
+  minttemp[0] = HEATER_0_MINTEMP;
+  while(analog2temp(minttemp_raw[0], 0) < HEATER_0_MINTEMP) {
+#if HEATER_0_RAW_LO_TEMP < HEATER_0_RAW_HI_TEMP
+    minttemp_raw[0] += OVERSAMPLENR;
+#else
+    minttemp_raw[0] -= OVERSAMPLENR;
+#endif
+  }
 #endif //MINTEMP
 #ifdef HEATER_0_MAXTEMP
-  maxttemp[0] = temp2analog(HEATER_0_MAXTEMP, 0);
+  maxttemp[0] = HEATER_0_MAXTEMP;
+  while(analog2temp(maxttemp_raw[0], 0) > HEATER_0_MAXTEMP) {
+#if HEATER_0_RAW_LO_TEMP < HEATER_0_RAW_HI_TEMP
+    maxttemp_raw[0] -= OVERSAMPLENR;
+#else
+    maxttemp_raw[0] += OVERSAMPLENR;
+#endif
+  }
 #endif //MAXTEMP
 
 #if (EXTRUDERS > 1) && defined(HEATER_1_MINTEMP)
-  minttemp[1] = temp2analog(HEATER_1_MINTEMP, 1);
+  minttemp[1] = HEATER_1_MINTEMP;
+  while(analog2temp(minttemp_raw[1], 1) > HEATER_1_MINTEMP) {
+#if HEATER_1_RAW_LO_TEMP < HEATER_1_RAW_HI_TEMP
+    minttemp_raw[1] += OVERSAMPLENR;
+#else
+    minttemp_raw[1] -= OVERSAMPLENR;
+#endif
+  }
 #endif // MINTEMP 1
 #if (EXTRUDERS > 1) && defined(HEATER_1_MAXTEMP)
-  maxttemp[1] = temp2analog(HEATER_1_MAXTEMP, 1);
+  maxttemp[1] = HEATER_1_MAXTEMP;
+  while(analog2temp(maxttemp_raw[1], 1) > HEATER_1_MAXTEMP) {
+#if HEATER_1_RAW_LO_TEMP < HEATER_1_RAW_HI_TEMP
+    maxttemp_raw[1] -= OVERSAMPLENR;
+#else
+    maxttemp_raw[1] += OVERSAMPLENR;
+#endif
+  }
 #endif //MAXTEMP 1
 
 #if (EXTRUDERS > 2) && defined(HEATER_2_MINTEMP)
-  minttemp[2] = temp2analog(HEATER_2_MINTEMP, 2);
+  minttemp[2] = HEATER_2_MINTEMP;
+  while(analog2temp(minttemp_raw[2], 2) > HEATER_2_MINTEMP) {
+#if HEATER_2_RAW_LO_TEMP < HEATER_2_RAW_HI_TEMP
+    minttemp_raw[2] += OVERSAMPLENR;
+#else
+    minttemp_raw[2] -= OVERSAMPLENR;
+#endif
+  }
 #endif //MINTEMP 2
 #if (EXTRUDERS > 2) && defined(HEATER_2_MAXTEMP)
-  maxttemp[2] = temp2analog(HEATER_2_MAXTEMP, 2);
+  maxttemp[2] = HEATER_2_MAXTEMP;
+  while(analog2temp(maxttemp_raw[2], 2) > HEATER_2_MAXTEMP) {
+#if HEATER_2_RAW_LO_TEMP < HEATER_2_RAW_HI_TEMP
+    maxttemp_raw[2] -= OVERSAMPLENR;
+#else
+    maxttemp_raw[2] += OVERSAMPLENR;
+#endif
+  }
 #endif //MAXTEMP 2
 
 #ifdef BED_MINTEMP
-  bed_minttemp = temp2analogBed(BED_MINTEMP);
+  /* No bed MINTEMP error implemented?!? */ /*
+  while(analog2tempBed(bed_minttemp_raw) < BED_MINTEMP) {
+#if HEATER_BED_RAW_LO_TEMP < HEATER_BED_RAW_HI_TEMP
+    bed_minttemp_raw += OVERSAMPLENR;
+#else
+    bed_minttemp_raw -= OVERSAMPLENR;
+#endif
+  }
+  */
 #endif //BED_MINTEMP
 #ifdef BED_MAXTEMP
-  bed_maxttemp = temp2analogBed(BED_MAXTEMP);
+  while(analog2tempBed(bed_maxttemp_raw) > BED_MAXTEMP) {
+#if HEATER_BED_RAW_LO_TEMP < HEATER_BED_RAW_HI_TEMP
+    bed_maxttemp_raw -= OVERSAMPLENR;
+#else
+    bed_maxttemp_raw += OVERSAMPLENR;
+#endif
+  }
 #endif //BED_MAXTEMP
 }
 
-
-
 void setWatch() 
 {  
-#ifdef WATCHPERIOD
-  int t = 0;
+#ifdef WATCH_TEMP_PERIOD
   for (int e = 0; e < EXTRUDERS; e++)
   {
-    if(isHeatingHotend(e))
-    watch_oldtemp[0] = degHotend(0);
+    if(degHotend(e) < degTargetHotend(e) - (WATCH_TEMP_INCREASE * 2))
     {
-      t = max(t,millis());
-      watch_raw[e] = current_raw[e];
+      watch_start_temp[e] = degHotend(e);
+      watchmillis[e] = millis();
     } 
   }
-  watchmillis = t;
 #endif 
 }
 
@@ -703,7 +772,7 @@ void disable_heater()
     setTargetHotend(0,i);
   setTargetBed(0);
   #if TEMP_0_PIN > -1
-  target_raw[0]=0;
+  target_temperature[0]=0;
   soft_pwm[0]=0;
    #if HEATER_0_PIN > -1  
      WRITE(HEATER_0_PIN,LOW);
@@ -711,7 +780,7 @@ void disable_heater()
   #endif
      
   #if TEMP_1_PIN > -1
-    target_raw[1]=0;
+    target_temperature[1]=0;
     soft_pwm[1]=0;
     #if HEATER_1_PIN > -1 
       WRITE(HEATER_1_PIN,LOW);
@@ -719,7 +788,7 @@ void disable_heater()
   #endif
       
   #if TEMP_2_PIN > -1
-    target_raw[2]=0;
+    target_temperature[2]=0;
     soft_pwm[2]=0;
     #if HEATER_2_PIN > -1  
       WRITE(HEATER_2_PIN,LOW);
@@ -727,7 +796,8 @@ void disable_heater()
   #endif 
 
   #if TEMP_BED_PIN > -1
-    target_raw_bed=0;
+    target_temperature_bed=0;
+    soft_pwm_bed=0;
     #if HEATER_BED_PIN > -1  
       WRITE(HEATER_BED_PIN,LOW);
     #endif
@@ -740,7 +810,11 @@ void max_temp_error(uint8_t e) {
     SERIAL_ERROR_START;
     SERIAL_ERRORLN((int)e);
     SERIAL_ERRORLNPGM(": Extruder switched off. MAXTEMP triggered !");
+    LCD_ALERTMESSAGEPGM("Err: MAXTEMP");
   }
+  #ifndef BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE
+  Stop();
+  #endif
 }
 
 void min_temp_error(uint8_t e) {
@@ -749,7 +823,11 @@ void min_temp_error(uint8_t e) {
     SERIAL_ERROR_START;
     SERIAL_ERRORLN((int)e);
     SERIAL_ERRORLNPGM(": Extruder switched off. MINTEMP triggered !");
+    LCD_ALERTMESSAGEPGM("Err: MINTEMP");
   }
+  #ifndef BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE
+  Stop();
+  #endif
 }
 
 void bed_max_temp_error(void) {
@@ -759,17 +837,21 @@ void bed_max_temp_error(void) {
   if(IsStopped() == false) {
     SERIAL_ERROR_START;
     SERIAL_ERRORLNPGM("Temperature heated bed switched off. MAXTEMP triggered !!");
+    LCD_ALERTMESSAGEPGM("Err: MAXTEMP BED");
   }
+  #ifndef BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE
+  Stop();
+  #endif
 }
 
-#define HEAT_INTERVAL 250
 #ifdef HEATER_0_USES_MAX6675
+#define MAX6675_HEAT_INTERVAL 250
 long max6675_previous_millis = -HEAT_INTERVAL;
 int max6675_temp = 2000;
 
 int read_max6675()
 {
-  if (millis() - max6675_previous_millis < HEAT_INTERVAL) 
+  if (millis() - max6675_previous_millis < MAX6675_HEAT_INTERVAL) 
     return max6675_temp;
   
   max6675_previous_millis = millis();
@@ -787,7 +869,8 @@ int read_max6675()
   WRITE(MAX6675_SS, 0);
   
   // ensure 100ns delay - a bit extra is fine
-  delay(1);
+  asm("nop");//50ns on 20Mhz, 62.5ns on 16Mhz
+  asm("nop");//50ns on 20Mhz, 62.5ns on 16Mhz
   
   // read MSB
   SPDR = 0;
@@ -830,8 +913,15 @@ ISR(TIMER0_COMPB_vect)
   static unsigned char temp_state = 0;
   static unsigned char pwm_count = 1;
   static unsigned char soft_pwm_0;
+  #if EXTRUDERS > 1
   static unsigned char soft_pwm_1;
+  #endif
+  #if EXTRUDERS > 2
   static unsigned char soft_pwm_2;
+  #endif
+  #if HEATER_BED_PIN > -1
+  static unsigned char soft_pwm_b;
+  #endif
   
   if(pwm_count == 0){
     soft_pwm_0 = soft_pwm[0];
@@ -844,6 +934,14 @@ ISR(TIMER0_COMPB_vect)
     soft_pwm_2 = soft_pwm[2];
     if(soft_pwm_2 > 0) WRITE(HEATER_2_PIN,1);
     #endif
+    #if HEATER_BED_PIN > -1
+    soft_pwm_b = soft_pwm_bed;
+    if(soft_pwm_b > 0) WRITE(HEATER_BED_PIN,1);
+    #endif
+    #ifdef FAN_SOFT_PWM
+    soft_pwm_fan =(unsigned char) fanSpeed;
+    if(soft_pwm_fan > 0) WRITE(FAN_PIN,1);
+    #endif
   }
   if(soft_pwm_0 <= pwm_count) WRITE(HEATER_0_PIN,0);
   #if EXTRUDERS > 1
@@ -852,6 +950,12 @@ ISR(TIMER0_COMPB_vect)
   #if EXTRUDERS > 2
   if(soft_pwm_2 <= pwm_count) WRITE(HEATER_2_PIN,0);
   #endif
+  #if HEATER_BED_PIN > -1
+  if(soft_pwm_b <= pwm_count) WRITE(HEATER_BED_PIN,0);
+  #endif
+  #ifdef FAN_SOFT_PWM
+  if(soft_pwm_fan <= pwm_count) WRITE(FAN_PIN,0);
+  #endif
   
   pwm_count++;
   pwm_count &= 0x7f;
@@ -867,9 +971,7 @@ ISR(TIMER0_COMPB_vect)
         ADMUX = ((1 << REFS0) | (TEMP_0_PIN & 0x07));
         ADCSRA |= 1<<ADSC; // Start conversion
       #endif
-      #ifdef ULTIPANEL
-        buttons_check();
-      #endif
+      lcd_buttons_update();
       temp_state = 1;
       break;
     case 1: // Measure TEMP_0
@@ -891,9 +993,7 @@ ISR(TIMER0_COMPB_vect)
         ADMUX = ((1 << REFS0) | (TEMP_BED_PIN & 0x07));
         ADCSRA |= 1<<ADSC; // Start conversion
       #endif
-      #ifdef ULTIPANEL
-        buttons_check();
-      #endif
+      lcd_buttons_update();
       temp_state = 3;
       break;
     case 3: // Measure TEMP_BED
@@ -912,9 +1012,7 @@ ISR(TIMER0_COMPB_vect)
         ADMUX = ((1 << REFS0) | (TEMP_1_PIN & 0x07));
         ADCSRA |= 1<<ADSC; // Start conversion
       #endif
-      #ifdef ULTIPANEL
-        buttons_check();
-      #endif
+      lcd_buttons_update();
       temp_state = 5;
       break;
     case 5: // Measure TEMP_1
@@ -933,9 +1031,7 @@ ISR(TIMER0_COMPB_vect)
         ADMUX = ((1 << REFS0) | (TEMP_2_PIN & 0x07));
         ADCSRA |= 1<<ADSC; // Start conversion
       #endif
-      #ifdef ULTIPANEL
-        buttons_check();
-      #endif
+      lcd_buttons_update();
       temp_state = 7;
       break;
     case 7: // Measure TEMP_2
@@ -953,33 +1049,17 @@ ISR(TIMER0_COMPB_vect)
     
   if(temp_count >= 16) // 8 ms * 16 = 128ms.
   {
-    #if defined(HEATER_0_USES_AD595) || defined(HEATER_0_USES_MAX6675)
-      current_raw[0] = raw_temp_0_value;
-    #else
-      current_raw[0] = 16383 - raw_temp_0_value;
-    #endif
-
-#if EXTRUDERS > 1    
-    #ifdef HEATER_1_USES_AD595
-      current_raw[1] = raw_temp_1_value;
-    #else
-      current_raw[1] = 16383 - raw_temp_1_value;
-    #endif
+    if (!temp_meas_ready) //Only update the raw values if they have been read. Else we could be updating them during reading.
+    {
+      current_temperature_raw[0] = raw_temp_0_value;
+#if EXTRUDERS > 1
+      current_temperature_raw[1] = raw_temp_1_value;
 #endif
-    
 #if EXTRUDERS > 2
-    #ifdef HEATER_2_USES_AD595
-      current_raw[2] = raw_temp_2_value;
-    #else
-      current_raw[2] = 16383 - raw_temp_2_value;
-    #endif
+      current_temperature_raw[2] = raw_temp_2_value;
 #endif
-    
-    #ifdef BED_USES_AD595
-      current_raw_bed = raw_temp_bed_value;
-    #else
-      current_raw_bed = 16383 - raw_temp_bed_value;
-    #endif
+      current_temperature_bed_raw = raw_temp_bed_value;
+    }
     
     temp_meas_ready = true;
     temp_count = 0;
@@ -988,34 +1068,63 @@ ISR(TIMER0_COMPB_vect)
     raw_temp_2_value = 0;
     raw_temp_bed_value = 0;
 
-    for(unsigned char e = 0; e < EXTRUDERS; e++) {
-       if(current_raw[e] >= maxttemp[e]) {
-          target_raw[e] = 0;
-          max_temp_error(e);
-          #ifndef BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE
-          {
-            Stop();;
-          }
-          #endif
-       }
-       if(current_raw[e] <= minttemp[e]) {
-          target_raw[e] = 0;
-          min_temp_error(e);
-          #ifndef BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE
-          {
-            Stop();
-          }
-          #endif
-       }
+#if HEATER_0_RAW_LO_TEMP > HEATER_0_RAW_HI_TEMP
+    if(current_temperature_raw[0] <= maxttemp_raw[0]) {
+#else
+    if(current_temperature_raw[0] >= maxttemp_raw[0]) {
+#endif
+        max_temp_error(0);
+    }
+#if HEATER_0_RAW_LO_TEMP > HEATER_0_RAW_HI_TEMP
+    if(current_temperature_raw[0] >= minttemp_raw[0]) {
+#else
+    if(current_temperature_raw[0] <= minttemp_raw[0]) {
+#endif
+        min_temp_error(0);
+    }
+#if EXTRUDERS > 1
+#if HEATER_1_RAW_LO_TEMP > HEATER_1_RAW_HI_TEMP
+    if(current_temperature_raw[1] <= maxttemp_raw[1]) {
+#else
+    if(current_temperature_raw[1] >= maxttemp_raw[1]) {
+#endif
+        max_temp_error(1);
+    }
+#if HEATER_1_RAW_LO_TEMP > HEATER_1_RAW_HI_TEMP
+    if(current_temperature_raw[1] >= minttemp_raw[1]) {
+#else
+    if(current_temperature_raw[1] <= minttemp_raw[1]) {
+#endif
+        min_temp_error(1);
     }
+#endif
+#if EXTRUDERS > 2
+#if HEATER_2_RAW_LO_TEMP > HEATER_2_RAW_HI_TEMP
+    if(current_temperature_raw[2] <= maxttemp_raw[2]) {
+#else
+    if(current_temperature_raw[2] >= maxttemp_raw[2]) {
+#endif
+        max_temp_error(2);
+    }
+#if HEATER_2_RAW_LO_TEMP > HEATER_2_RAW_HI_TEMP
+    if(current_temperature_raw[2] >= minttemp_raw[2]) {
+#else
+    if(current_temperature_raw[2] <= minttemp_raw[2]) {
+#endif
+        min_temp_error(2);
+    }
+#endif
   
-#if defined(BED_MAXTEMP) && (HEATER_BED_PIN > -1)
-    if(current_raw_bed >= bed_maxttemp) {
-       target_raw_bed = 0;
+  /* No bed MINTEMP error? */
+#if defined(BED_MAXTEMP) && (TEMP_SENSOR_BED != 0)
+# if HEATER_BED_RAW_LO_TEMP > HEATER_BED_RAW_HI_TEMP
+    if(current_temperature_bed_raw <= bed_maxttemp_raw) {
+#else
+    if(current_temperature_bed_raw >= bed_maxttemp_raw) {
+#endif
+       target_temperature_bed = 0;
        bed_max_temp_error();
-       Stop();
     }
 #endif
-  }
+  }  
 }
-
diff --git a/Marlin/temperature.h b/Marlin/temperature.h
index 1848c70..feffcbd 100644
--- a/Marlin/temperature.h
+++ b/Marlin/temperature.h
@@ -33,89 +33,60 @@ void manage_heater(); //it is critical that this is called periodically.
 
 //low leven conversion routines
 // do not use this routines and variables outsie of temperature.cpp
-int temp2analog(int celsius, uint8_t e);
-int temp2analogBed(int celsius);
-float analog2temp(int raw, uint8_t e);
-float analog2tempBed(int raw);
-extern int target_raw[EXTRUDERS];  
-extern int heatingtarget_raw[EXTRUDERS];  
-extern int current_raw[EXTRUDERS];
-extern int target_raw_bed;
-extern int current_raw_bed;
-#ifdef BED_LIMIT_SWITCHING
-  extern int target_bed_low_temp ;  
-  extern int target_bed_high_temp ;
-#endif
-extern float Kp,Ki,Kd,Kc;
+extern int target_temperature[EXTRUDERS];  
+extern float current_temperature[EXTRUDERS];
+extern int target_temperature_bed;
+extern float current_temperature_bed;
 
 #ifdef PIDTEMP
-  extern float pid_setpoint[EXTRUDERS];
+  extern float Kp,Ki,Kd,Kc;
+#endif
+#ifdef PIDTEMPBED
+  extern float bedKp,bedKi,bedKd;
 #endif
   
-// #ifdef WATCHPERIOD
-  extern int watch_raw[EXTRUDERS] ;
-//   extern unsigned long watchmillis;
-// #endif
-
-
 //high level conversion routines, for use outside of temperature.cpp
 //inline so that there is no performance decrease.
 //deg=degreeCelsius
 
 FORCE_INLINE float degHotend(uint8_t extruder) {  
-  return analog2temp(current_raw[extruder], extruder);
+  return current_temperature[extruder];
 };
 
 FORCE_INLINE float degBed() {
-  return analog2tempBed(current_raw_bed);
+  return current_temperature_bed;
 };
 
 FORCE_INLINE float degTargetHotend(uint8_t extruder) {  
-  return analog2temp(target_raw[extruder], extruder);
+  return target_temperature[extruder];
 };
 
 FORCE_INLINE float degTargetBed() {   
-  return analog2tempBed(target_raw_bed);
+  return target_temperature_bed;
 };
 
 FORCE_INLINE void setTargetHotend(const float &celsius, uint8_t extruder) {  
-  target_raw[extruder] = temp2analog(celsius, extruder);
-#ifdef PIDTEMP
-  pid_setpoint[extruder] = celsius;
-#endif //PIDTEMP
+  target_temperature[extruder] = celsius;
 };
 
 FORCE_INLINE void setTargetBed(const float &celsius) {  
-  
-  target_raw_bed = temp2analogBed(celsius);
-  #ifdef BED_LIMIT_SWITCHING
-    if(celsius>BED_HYSTERESIS)
-    {
-    target_bed_low_temp= temp2analogBed(celsius-BED_HYSTERESIS);
-    target_bed_high_temp= temp2analogBed(celsius+BED_HYSTERESIS);
-    }
-    else
-    { 
-      target_bed_low_temp=0;
-      target_bed_high_temp=0;
-    }
-  #endif
+  target_temperature_bed = celsius;
 };
 
 FORCE_INLINE bool isHeatingHotend(uint8_t extruder){  
-  return target_raw[extruder] > current_raw[extruder];
+  return target_temperature[extruder] > current_temperature[extruder];
 };
 
 FORCE_INLINE bool isHeatingBed() {
-  return target_raw_bed > current_raw_bed;
+  return target_temperature_bed > current_temperature_bed;
 };
 
 FORCE_INLINE bool isCoolingHotend(uint8_t extruder) {  
-  return target_raw[extruder] < current_raw[extruder];
+  return target_temperature[extruder] < current_temperature[extruder];
 };
 
 FORCE_INLINE bool isCoolingBed() {
-  return target_raw_bed < current_raw_bed;
+  return target_temperature_bed < current_temperature_bed;
 };
 
 #define degHotend0() degHotend(0)
@@ -163,7 +134,7 @@ FORCE_INLINE void autotempShutdown(){
  #endif
 }
 
-void PID_autotune(float temp);
+void PID_autotune(float temp, int extruder, int ncycles);
 
 #endif
-
+
diff --git a/Marlin/thermistortables.h b/Marlin/thermistortables.h
index 941b239..cdf591b 100644
--- a/Marlin/thermistortables.h
+++ b/Marlin/thermistortables.h
@@ -247,7 +247,8 @@ const short temptable_6[][2] PROGMEM = {
    {954*OVERSAMPLENR, 30},
    {970*OVERSAMPLENR, 25},
    {978*OVERSAMPLENR, 22},
-   {1008*OVERSAMPLENR, 3}
+   {1008*OVERSAMPLENR, 3},
+   {1023*OVERSAMPLENR, 0}  //to allow internal 0C
 };
 #endif
 
@@ -307,7 +308,8 @@ const short temptable_7[][2] PROGMEM = {
    {989*OVERSAMPLENR, 20},
    {994*OVERSAMPLENR, 15},
    {1001*OVERSAMPLENR, 10},
-   {1005*OVERSAMPLENR, 5}
+   {1005*OVERSAMPLENR, 5},
+   {1023*OVERSAMPLENR, 0}  //to allow internal 0C
 };
 #endif
 
@@ -459,49 +461,92 @@ const short temptable_55[][2] PROGMEM = {
 #define TT_NAME(_N) _TT_NAME(_N)
 
 #ifdef THERMISTORHEATER_0
-  #define heater_0_temptable TT_NAME(THERMISTORHEATER_0)
-  #define heater_0_temptable_len (sizeof(heater_0_temptable)/sizeof(*heater_0_temptable))
+# define HEATER_0_TEMPTABLE TT_NAME(THERMISTORHEATER_0)
+# define HEATER_0_TEMPTABLE_LEN (sizeof(HEATER_0_TEMPTABLE)/sizeof(*HEATER_0_TEMPTABLE))
 #else
-#ifdef HEATER_0_USES_THERMISTOR
-  #error No heater 0 thermistor table specified
-#else  // HEATER_0_USES_THERMISTOR
-  #define heater_0_temptable 0
-  #define heater_0_temptable_len 0
-#endif // HEATER_0_USES_THERMISTOR
+# ifdef HEATER_0_USES_THERMISTOR
+#  error No heater 0 thermistor table specified
+# else  // HEATER_0_USES_THERMISTOR
+#  define HEATER_0_TEMPTABLE NULL
+#  define HEATER_0_TEMPTABLE_LEN 0
+# endif // HEATER_0_USES_THERMISTOR
+#endif
+
+//Set the high and low raw values for the heater, this indicates which raw value is a high or low temperature
+#ifndef HEATER_0_RAW_HI_TEMP
+# ifdef HEATER_0_USES_THERMISTOR   //In case of a thermistor the highest temperature results in the lowest ADC value
+#  define HEATER_0_RAW_HI_TEMP 0
+#  define HEATER_0_RAW_LO_TEMP 16383
+# else                          //In case of an thermocouple the highest temperature results in the highest ADC value
+#  define HEATER_0_RAW_HI_TEMP 16383
+#  define HEATER_0_RAW_LO_TEMP 0
+# endif
 #endif
 
 #ifdef THERMISTORHEATER_1
-  #define heater_1_temptable TT_NAME(THERMISTORHEATER_1)
-  #define heater_1_temptable_len (sizeof(heater_1_temptable)/sizeof(*heater_1_temptable))
+# define HEATER_1_TEMPTABLE TT_NAME(THERMISTORHEATER_1)
+# define HEATER_1_TEMPTABLE_LEN (sizeof(HEATER_1_TEMPTABLE)/sizeof(*HEATER_1_TEMPTABLE))
 #else
-#ifdef HEATER_1_USES_THERMISTOR
-  #error No heater 1 thermistor table specified
-#else  // HEATER_1_USES_THERMISTOR
-  #define heater_1_temptable 0
-  #define heater_1_temptable_len 0
-#endif // HEATER_1_USES_THERMISTOR
+# ifdef HEATER_1_USES_THERMISTOR
+#  error No heater 1 thermistor table specified
+# else  // HEATER_1_USES_THERMISTOR
+#  define HEATER_1_TEMPTABLE NULL
+#  define HEATER_1_TEMPTABLE_LEN 0
+# endif // HEATER_1_USES_THERMISTOR
+#endif
+
+//Set the high and low raw values for the heater, this indicates which raw value is a high or low temperature
+#ifndef HEATER_1_RAW_HI_TEMP
+# ifdef HEATER_1_USES_THERMISTOR   //In case of a thermistor the highest temperature results in the lowest ADC value
+#  define HEATER_1_RAW_HI_TEMP 0
+#  define HEATER_1_RAW_LO_TEMP 16383
+# else                          //In case of an thermocouple the highest temperature results in the highest ADC value
+#  define HEATER_1_RAW_HI_TEMP 16383
+#  define HEATER_1_RAW_LO_TEMP 0
+# endif
 #endif
 
 #ifdef THERMISTORHEATER_2
-  #define heater_2_temptable TT_NAME(THERMISTORHEATER_2)
-  #define heater_2_temptable_len (sizeof(heater_2_temptable)/sizeof(*heater_2_temptable))
+# define HEATER_2_TEMPTABLE TT_NAME(THERMISTORHEATER_2)
+# define HEATER_2_TEMPTABLE_LEN (sizeof(HEATER_2_TEMPTABLE)/sizeof(*HEATER_2_TEMPTABLE))
 #else
-#ifdef HEATER_2_USES_THERMISTOR
-  #error No heater 2 thermistor table specified
-#else  // HEATER_2_USES_THERMISTOR
-  #define heater_2_temptable 0
-  #define heater_2_temptable_len 0
-#endif // HEATER_2_USES_THERMISTOR
+# ifdef HEATER_2_USES_THERMISTOR
+#  error No heater 2 thermistor table specified
+# else  // HEATER_2_USES_THERMISTOR
+#  define HEATER_2_TEMPTABLE NULL
+#  define HEATER_2_TEMPTABLE_LEN 0
+# endif // HEATER_2_USES_THERMISTOR
+#endif
+
+//Set the high and low raw values for the heater, this indicates which raw value is a high or low temperature
+#ifndef HEATER_2_RAW_HI_TEMP
+# ifdef HEATER_2_USES_THERMISTOR   //In case of a thermistor the highest temperature results in the lowest ADC value
+#  define HEATER_2_RAW_HI_TEMP 0
+#  define HEATER_2_RAW_LO_TEMP 16383
+# else                          //In case of an thermocouple the highest temperature results in the highest ADC value
+#  define HEATER_2_RAW_HI_TEMP 16383
+#  define HEATER_2_RAW_LO_TEMP 0
+# endif
 #endif
 
 #ifdef THERMISTORBED
-  #define bedtemptable TT_NAME(THERMISTORBED)
-  #define bedtemptable_len (sizeof(bedtemptable)/sizeof(*bedtemptable))
+# define BEDTEMPTABLE TT_NAME(THERMISTORBED)
+# define BEDTEMPTABLE_LEN (sizeof(BEDTEMPTABLE)/sizeof(*BEDTEMPTABLE))
 #else
-#ifdef BED_USES_THERMISTOR
-  #error No bed thermistor table specified
-#endif // BED_USES_THERMISTOR
+# ifdef BED_USES_THERMISTOR
+#  error No bed thermistor table specified
+# endif // BED_USES_THERMISTOR
 #endif
 
-#endif //THERMISTORTABLES_H_
+//Set the high and low raw values for the heater, this indicates which raw value is a high or low temperature
+#ifndef HEATER_BED_RAW_HI_TEMP
+# ifdef BED_USES_THERMISTOR   //In case of a thermistor the highest temperature results in the lowest ADC value
+#  define HEATER_BED_RAW_HI_TEMP 0
+#  define HEATER_BED_RAW_LO_TEMP 16383
+# else                          //In case of an thermocouple the highest temperature results in the highest ADC value
+#  define HEATER_BED_RAW_HI_TEMP 16383
+#  define HEATER_BED_RAW_LO_TEMP 0
+# endif
+#endif
 
+#endif //THERMISTORTABLES_H_
diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
new file mode 100644
index 0000000..3239835
--- /dev/null
+++ b/Marlin/ultralcd.cpp
@@ -0,0 +1,1035 @@
+#include "temperature.h"
+#include "ultralcd.h"
+#ifdef ULTRA_LCD
+#include "Marlin.h"
+#include "language.h"
+#include "cardreader.h"
+#include "temperature.h"
+#include "ConfigurationStore.h"
+
+/* Configuration settings */
+int plaPreheatHotendTemp;
+int plaPreheatHPBTemp;
+int plaPreheatFanSpeed;
+
+int absPreheatHotendTemp;
+int absPreheatHPBTemp;
+int absPreheatFanSpeed;
+/* !Configuration settings */
+
+//Function pointer to menu functions.
+typedef void (*menuFunc_t)();
+
+uint8_t lcd_status_message_level;
+char lcd_status_message[LCD_WIDTH+1] = WELCOME_MSG;
+
+#include "ultralcd_implementation_hitachi_HD44780.h"
+
+/** forward declerations **/
+/* Different menus */
+static void lcd_status_screen();
+#ifdef ULTIPANEL
+static void lcd_main_menu();
+static void lcd_tune_menu();
+static void lcd_prepare_menu();
+static void lcd_move_menu();
+static void lcd_control_menu();
+static void lcd_control_temperature_menu();
+static void lcd_control_temperature_preheat_pla_settings_menu();
+static void lcd_control_temperature_preheat_abs_settings_menu();
+static void lcd_control_motion_menu();
+static void lcd_control_retract_menu();
+static void lcd_sdcard_menu();
+
+static void lcd_quick_feedback();//Cause an LCD refresh, and give the user visual or audiable feedback that something has happend
+
+/* Different types of actions that can be used in menuitems. */
+static void menu_action_back(menuFunc_t data);
+static void menu_action_submenu(menuFunc_t data);
+static void menu_action_gcode(const char* pgcode);
+static void menu_action_function(menuFunc_t data);
+static void menu_action_sdfile(const char* filename, char* longFilename);
+static void menu_action_sddirectory(const char* filename, char* longFilename);
+static void menu_action_setting_edit_bool(const char* pstr, bool* ptr);
+static void menu_action_setting_edit_int3(const char* pstr, int* ptr, int minValue, int maxValue);
+static void menu_action_setting_edit_float3(const char* pstr, float* ptr, float minValue, float maxValue);
+static void menu_action_setting_edit_float32(const char* pstr, float* ptr, float minValue, float maxValue);
+static void menu_action_setting_edit_float5(const char* pstr, float* ptr, float minValue, float maxValue);
+static void menu_action_setting_edit_float51(const char* pstr, float* ptr, float minValue, float maxValue);
+static void menu_action_setting_edit_float52(const char* pstr, float* ptr, float minValue, float maxValue);
+static void menu_action_setting_edit_long5(const char* pstr, unsigned long* ptr, unsigned long minValue, unsigned long maxValue);
+
+#define ENCODER_STEPS_PER_MENU_ITEM 5
+
+/* Helper macros for menus */
+#define START_MENU() do { \
+    if (encoderPosition > 0x8000) encoderPosition = 0; \
+    if (encoderPosition / ENCODER_STEPS_PER_MENU_ITEM < currentMenuViewOffset) currentMenuViewOffset = encoderPosition / ENCODER_STEPS_PER_MENU_ITEM;\
+    uint8_t _lineNr = currentMenuViewOffset, _menuItemNr; \
+    for(uint8_t _drawLineNr = 0; _drawLineNr < LCD_HEIGHT; _drawLineNr++, _lineNr++) { \
+        _menuItemNr = 0;
+#define MENU_ITEM(type, label, args...) do { \
+    if (_menuItemNr == _lineNr) { \
+        if (lcdDrawUpdate) { \
+            const char* _label_pstr = PSTR(label); \
+            if ((encoderPosition / ENCODER_STEPS_PER_MENU_ITEM) == _menuItemNr) { \
+                lcd_implementation_drawmenu_ ## type ## _selected (_drawLineNr, _label_pstr , ## args ); \
+            }else{\
+                lcd_implementation_drawmenu_ ## type (_drawLineNr, _label_pstr , ## args ); \
+            }\
+        }\
+        if (LCD_CLICKED && (encoderPosition / ENCODER_STEPS_PER_MENU_ITEM) == _menuItemNr) {\
+            lcd_quick_feedback(); \
+            menu_action_ ## type ( args ); \
+            return;\
+        }\
+    }\
+    _menuItemNr++;\
+} while(0)
+#define MENU_ITEM_DUMMY() do { _menuItemNr++; } while(0)
+#define MENU_ITEM_EDIT(type, label, args...) MENU_ITEM(setting_edit_ ## type, label, PSTR(label) , ## args )
+#define END_MENU() \
+    if (encoderPosition / ENCODER_STEPS_PER_MENU_ITEM >= _menuItemNr) encoderPosition = _menuItemNr * ENCODER_STEPS_PER_MENU_ITEM - 1; \
+    if ((uint8_t)(encoderPosition / ENCODER_STEPS_PER_MENU_ITEM) >= currentMenuViewOffset + LCD_HEIGHT) { currentMenuViewOffset = (encoderPosition / ENCODER_STEPS_PER_MENU_ITEM) - LCD_HEIGHT + 1; lcdDrawUpdate = 1; _lineNr = currentMenuViewOffset - 1; _drawLineNr = -1; } \
+    } } while(0)
+
+/** Used variables to keep track of the menu */
+volatile uint8_t buttons;//Contains the bits of the currently pressed buttons.
+
+uint8_t currentMenuViewOffset;              /* scroll offset in the current menu */
+uint32_t blocking_enc;
+uint8_t lastEncoderBits;
+int8_t encoderDiff; /* encoderDiff is updated from interrupt context and added to encoderPosition every LCD update */
+uint32_t encoderPosition;
+#if (SDCARDDETECT > -1)
+bool lcd_oldcardstatus;
+#endif
+#endif//ULTIPANEL
+
+menuFunc_t currentMenu = lcd_status_screen; /* function pointer to the currently active menu */
+uint32_t lcd_next_update_millis;
+uint8_t lcd_status_update_delay;
+uint8_t lcdDrawUpdate = 2;                  /* Set to none-zero when the LCD needs to draw, decreased after every draw. Set to 2 in LCD routines so the LCD gets atleast 1 full redraw (first redraw is partial) */
+
+//prevMenu and prevEncoderPosition are used to store the previous menu location when editing settings.
+menuFunc_t prevMenu = NULL;
+uint16_t prevEncoderPosition;
+//Variables used when editing values.
+const char* editLabel;
+void* editValue;
+int32_t minEditValue, maxEditValue;
+
+/* Main status screen. It's up to the implementation specific part to show what is needed. As this is very display dependend */
+static void lcd_status_screen()
+{
+    if (lcd_status_update_delay)
+        lcd_status_update_delay--;
+    else
+        lcdDrawUpdate = 1;
+    if (lcdDrawUpdate)
+    {
+        lcd_implementation_status_screen();
+        lcd_status_update_delay = 10;   /* redraw the main screen every second. This is easier then trying keep track of all things that change on the screen */
+    }
+#ifdef ULTIPANEL
+    if (LCD_CLICKED)
+    {
+        currentMenu = lcd_main_menu;
+        lcd_quick_feedback();
+    }
+    feedmultiply += int(encoderPosition);
+    encoderPosition = 0;
+    if (feedmultiply < 10)
+        feedmultiply = 10;
+    if (feedmultiply > 999)
+        feedmultiply = 999;
+#endif//ULTIPANEL
+}
+
+#ifdef ULTIPANEL
+static void lcd_return_to_status()
+{
+    encoderPosition = 0;
+    currentMenu = lcd_status_screen;
+}
+
+static void lcd_sdcard_pause()
+{
+    card.pauseSDPrint();
+}
+static void lcd_sdcard_resume()
+{
+    card.startFileprint();
+}
+
+static void lcd_sdcard_stop()
+{
+    card.sdprinting = false;
+    card.closefile();
+    quickStop();
+    if(SD_FINISHED_STEPPERRELEASE)
+    {
+        enquecommand_P(PSTR(SD_FINISHED_RELEASECOMMAND));
+    }
+    autotempShutdown();
+}
+
+/* Menu implementation */
+static void lcd_main_menu()
+{
+    START_MENU();
+    MENU_ITEM(back, MSG_WATCH, lcd_status_screen);
+    if (IS_SD_PRINTING)
+    {
+        MENU_ITEM(submenu, MSG_TUNE, lcd_tune_menu);
+    }else{
+        MENU_ITEM(submenu, MSG_PREPARE, lcd_prepare_menu);
+    }
+    MENU_ITEM(submenu, MSG_CONTROL, lcd_control_menu);
+#ifdef SDSUPPORT
+    if (card.cardOK)
+    {
+        if (card.isFileOpen())
+        {
+            if (card.sdprinting)
+                MENU_ITEM(function, MSG_PAUSE_PRINT, lcd_sdcard_pause);
+            else
+                MENU_ITEM(function, MSG_RESUME_PRINT, lcd_sdcard_resume);
+            MENU_ITEM(function, MSG_STOP_PRINT, lcd_sdcard_stop);
+        }else{
+            MENU_ITEM(submenu, MSG_CARD_MENU, lcd_sdcard_menu);
+        }
+    }else{
+        MENU_ITEM(submenu, MSG_NO_CARD, lcd_sdcard_menu);
+    }
+#endif
+    END_MENU();
+}
+
+#ifdef SDSUPPORT
+static void lcd_autostart_sd()
+{
+    card.lastnr=0;
+    card.setroot();
+    card.checkautostart(true);
+}
+#endif
+
+void lcd_preheat_pla()
+{
+    setTargetHotend0(plaPreheatHotendTemp);
+    setTargetHotend1(plaPreheatHotendTemp);
+    setTargetHotend2(plaPreheatHotendTemp);
+    setTargetBed(plaPreheatHPBTemp);
+#if FAN_PIN > -1
+    fanSpeed = plaPreheatFanSpeed;
+    analogWrite(FAN_PIN,  fanSpeed);
+#endif
+    lcd_return_to_status();
+}
+
+void lcd_preheat_abs()
+{
+    setTargetHotend0(absPreheatHotendTemp);
+    setTargetHotend1(absPreheatHotendTemp);
+    setTargetHotend2(absPreheatHotendTemp);
+    setTargetBed(absPreheatHPBTemp);
+#if FAN_PIN > -1
+    fanSpeed = absPreheatFanSpeed;
+    analogWrite(FAN_PIN,  fanSpeed);
+#endif
+    lcd_return_to_status();
+}
+
+static void lcd_tune_menu()
+{
+    START_MENU();
+    MENU_ITEM(back, MSG_MAIN, lcd_main_menu);
+    MENU_ITEM_EDIT(int3, MSG_SPEED, &feedmultiply, 10, 999);
+    MENU_ITEM_EDIT(int3, MSG_NOZZLE, &target_temperature[0], 0, HEATER_0_MAXTEMP - 15);
+#if TEMP_SENSOR_1 != 0
+    MENU_ITEM_EDIT(int3, MSG_NOZZLE1, &target_temperature[1], 0, HEATER_1_MAXTEMP - 15);
+#endif
+#if TEMP_SENSOR_2 != 0
+    MENU_ITEM_EDIT(int3, MSG_NOZZLE2, &target_temperature[2], 0, HEATER_2_MAXTEMP - 15);
+#endif
+#if TEMP_SENSOR_BED != 0
+    MENU_ITEM_EDIT(int3, MSG_BED, &target_temperature_bed, 0, BED_MAXTEMP - 15);
+#endif
+    MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &fanSpeed, 0, 255);
+    MENU_ITEM_EDIT(int3, MSG_FLOW, &extrudemultiply, 10, 999);
+    END_MENU();
+}
+
+static void lcd_prepare_menu()
+{
+    START_MENU();
+    MENU_ITEM(back, MSG_MAIN, lcd_main_menu);
+#ifdef SDSUPPORT
+    //MENU_ITEM(function, MSG_AUTOSTART, lcd_autostart_sd);
+#endif
+    MENU_ITEM(gcode, MSG_DISABLE_STEPPERS, PSTR("M84"));
+    MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
+    //MENU_ITEM(gcode, MSG_SET_ORIGIN, PSTR("G92 X0 Y0 Z0"));
+    MENU_ITEM(function, MSG_PREHEAT_PLA, lcd_preheat_pla);
+    MENU_ITEM(function, MSG_PREHEAT_ABS, lcd_preheat_abs);
+    MENU_ITEM(gcode, MSG_COOLDOWN, PSTR("M104 S0\nM140 S0"));
+    MENU_ITEM(submenu, MSG_MOVE_AXIS, lcd_move_menu);
+    END_MENU();
+}
+
+float move_menu_scale;
+static void lcd_move_menu_axis();
+
+static void lcd_move_x()
+{
+    if (encoderPosition != 0)
+    {
+        current_position[X_AXIS] += float((int)encoderPosition) * move_menu_scale;
+        if (current_position[X_AXIS] < X_MIN_POS)
+            current_position[X_AXIS] = X_MIN_POS;
+        if (current_position[X_AXIS] > X_MAX_POS)
+            current_position[X_AXIS] = X_MAX_POS;
+        encoderPosition = 0;
+        plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], 600, active_extruder);
+        lcdDrawUpdate = 1;
+    }
+    if (lcdDrawUpdate)
+    {
+        lcd_implementation_drawedit(PSTR("X"), ftostr31(current_position[X_AXIS]));
+    }
+    if (LCD_CLICKED)
+    {
+        lcd_quick_feedback();
+        currentMenu = lcd_move_menu_axis;
+        encoderPosition = 0;
+    }
+}
+static void lcd_move_y()
+{
+    if (encoderPosition != 0)
+    {
+        current_position[Y_AXIS] += float((int)encoderPosition) * move_menu_scale;
+        if (current_position[Y_AXIS] < Y_MIN_POS)
+            current_position[Y_AXIS] = Y_MIN_POS;
+        if (current_position[Y_AXIS] > Y_MAX_POS)
+            current_position[Y_AXIS] = Y_MAX_POS;
+        encoderPosition = 0;
+        plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], 600, active_extruder);
+        lcdDrawUpdate = 1;
+    }
+    if (lcdDrawUpdate)
+    {
+        lcd_implementation_drawedit(PSTR("Y"), ftostr31(current_position[Y_AXIS]));
+    }
+    if (LCD_CLICKED)
+    {
+        lcd_quick_feedback();
+        currentMenu = lcd_move_menu_axis;
+        encoderPosition = 0;
+    }
+}
+static void lcd_move_z()
+{
+    if (encoderPosition != 0)
+    {
+        current_position[Z_AXIS] += float((int)encoderPosition) * move_menu_scale;
+        if (current_position[Z_AXIS] < Z_MIN_POS)
+            current_position[Z_AXIS] = Z_MIN_POS;
+        if (current_position[Z_AXIS] > Z_MAX_POS)
+            current_position[Z_AXIS] = Z_MAX_POS;
+        encoderPosition = 0;
+        plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], 60, active_extruder);
+        lcdDrawUpdate = 1;
+    }
+    if (lcdDrawUpdate)
+    {
+        lcd_implementation_drawedit(PSTR("Z"), ftostr31(current_position[Z_AXIS]));
+    }
+    if (LCD_CLICKED)
+    {
+        lcd_quick_feedback();
+        currentMenu = lcd_move_menu_axis;
+        encoderPosition = 0;
+    }
+}
+static void lcd_move_e()
+{
+    if (encoderPosition != 0)
+    {
+        current_position[E_AXIS] += float((int)encoderPosition) * move_menu_scale;
+        encoderPosition = 0;
+        plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], 20, active_extruder);
+        lcdDrawUpdate = 1;
+    }
+    if (lcdDrawUpdate)
+    {
+        lcd_implementation_drawedit(PSTR("Extruder"), ftostr31(current_position[E_AXIS]));
+    }
+    if (LCD_CLICKED)
+    {
+        lcd_quick_feedback();
+        currentMenu = lcd_move_menu_axis;
+        encoderPosition = 0;
+    }
+}
+
+static void lcd_move_menu_axis()
+{
+    START_MENU();
+    MENU_ITEM(back, MSG_MOVE_AXIS, lcd_move_menu);
+    MENU_ITEM(submenu, "Move X", lcd_move_x);
+    MENU_ITEM(submenu, "Move Y", lcd_move_y);
+    if (move_menu_scale < 10.0)
+    {
+        MENU_ITEM(submenu, "Move Z", lcd_move_z);
+        MENU_ITEM(submenu, "Extruder", lcd_move_e);
+    }
+    END_MENU();
+}
+
+static void lcd_move_menu_10mm()
+{
+    move_menu_scale = 10.0;
+    lcd_move_menu_axis();
+}
+static void lcd_move_menu_1mm()
+{
+    move_menu_scale = 1.0;
+    lcd_move_menu_axis();
+}
+static void lcd_move_menu_01mm()
+{
+    move_menu_scale = 0.1;
+    lcd_move_menu_axis();
+}
+
+static void lcd_move_menu()
+{
+    START_MENU();
+    MENU_ITEM(back, MSG_PREPARE, lcd_prepare_menu);
+    MENU_ITEM(submenu, "Move 10mm", lcd_move_menu_10mm);
+    MENU_ITEM(submenu, "Move 1mm", lcd_move_menu_1mm);
+    MENU_ITEM(submenu, "Move 0.1mm", lcd_move_menu_01mm);
+    //TODO:X,Y,Z,E
+    END_MENU();
+}
+
+static void lcd_control_menu()
+{
+    START_MENU();
+    MENU_ITEM(back, MSG_MAIN, lcd_main_menu);
+    MENU_ITEM(submenu, MSG_TEMPERATURE, lcd_control_temperature_menu);
+    MENU_ITEM(submenu, MSG_MOTION, lcd_control_motion_menu);
+#ifdef FWRETRACT
+    MENU_ITEM(submenu, MSG_RETRACT, lcd_control_retract_menu);
+#endif
+#ifdef EEPROM_SETTINGS
+    MENU_ITEM(function, MSG_STORE_EPROM, Config_StoreSettings);
+    MENU_ITEM(function, MSG_LOAD_EPROM, Config_RetrieveSettings);
+#endif
+    MENU_ITEM(function, MSG_RESTORE_FAILSAFE, Config_ResetDefault);
+    END_MENU();
+}
+
+static void lcd_control_temperature_menu()
+{
+    START_MENU();
+    MENU_ITEM(back, MSG_CONTROL, lcd_control_menu);
+    MENU_ITEM_EDIT(int3, MSG_NOZZLE, &target_temperature[0], 0, HEATER_0_MAXTEMP - 15);
+#if TEMP_SENSOR_1 != 0
+    MENU_ITEM_EDIT(int3, MSG_NOZZLE1, &target_temperature[1], 0, HEATER_1_MAXTEMP - 15);
+#endif
+#if TEMP_SENSOR_2 != 0
+    MENU_ITEM_EDIT(int3, MSG_NOZZLE2, &target_temperature[2], 0, HEATER_2_MAXTEMP - 15);
+#endif
+#if TEMP_SENSOR_BED != 0
+    MENU_ITEM_EDIT(int3, MSG_BED, &target_temperature_bed, 0, BED_MAXTEMP - 15);
+#endif
+    MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &fanSpeed, 0, 255);
+#ifdef AUTOTEMP
+    MENU_ITEM_EDIT(bool, MSG_AUTOTEMP, &autotemp_enabled);
+    MENU_ITEM_EDIT(float3, MSG_MIN, &autotemp_min, 0, HEATER_0_MAXTEMP - 15);
+    MENU_ITEM_EDIT(float3, MSG_MAX, &autotemp_max, 0, HEATER_0_MAXTEMP - 15);
+    MENU_ITEM_EDIT(float32, MSG_FACTOR, &autotemp_factor, 0.0, 1.0);
+#endif
+#ifdef PIDTEMP
+    MENU_ITEM_EDIT(float52, MSG_PID_P, &Kp, 1, 9990);
+//TODO, I and D should have a PID_dT multiplier (Ki = PID_I * PID_dT, Kd = PID_D / PID_dT)
+    MENU_ITEM_EDIT(float52, MSG_PID_I, &Ki, 1, 9990);
+    MENU_ITEM_EDIT(float52, MSG_PID_D, &Kd, 1, 9990);
+# ifdef PID_ADD_EXTRUSION_RATE
+    MENU_ITEM_EDIT(float3, MSG_PID_C, &Kc, 1, 9990);
+# endif//PID_ADD_EXTRUSION_RATE
+#endif//PIDTEMP
+    MENU_ITEM(submenu, MSG_PREHEAT_PLA_SETTINGS, lcd_control_temperature_preheat_pla_settings_menu);
+    MENU_ITEM(submenu, MSG_PREHEAT_ABS_SETTINGS, lcd_control_temperature_preheat_abs_settings_menu);
+    END_MENU();
+}
+
+static void lcd_control_temperature_preheat_pla_settings_menu()
+{
+    START_MENU();
+    MENU_ITEM(back, MSG_TEMPERATURE, lcd_control_temperature_menu);
+    MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &plaPreheatFanSpeed, 0, 255);
+    MENU_ITEM_EDIT(int3, MSG_NOZZLE, &plaPreheatHotendTemp, 0, HEATER_0_MAXTEMP - 15);
+#if TEMP_SENSOR_BED != 0
+    MENU_ITEM_EDIT(int3, MSG_BED, &plaPreheatHPBTemp, 0, BED_MAXTEMP - 15);
+#endif
+#ifdef EEPROM_SETTINGS
+    MENU_ITEM(function, MSG_STORE_EPROM, Config_StoreSettings);
+#endif
+    END_MENU();
+}
+
+static void lcd_control_temperature_preheat_abs_settings_menu()
+{
+    START_MENU();
+    MENU_ITEM(back, MSG_TEMPERATURE, lcd_control_temperature_menu);
+    MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &absPreheatFanSpeed, 0, 255);
+    MENU_ITEM_EDIT(int3, MSG_NOZZLE, &absPreheatHotendTemp, 0, HEATER_0_MAXTEMP - 15);
+#if TEMP_SENSOR_BED != 0
+    MENU_ITEM_EDIT(int3, MSG_BED, &absPreheatHPBTemp, 0, BED_MAXTEMP - 15);
+#endif
+#ifdef EEPROM_SETTINGS
+    MENU_ITEM(function, MSG_STORE_EPROM, Config_StoreSettings);
+#endif
+    END_MENU();
+}
+
+static void lcd_control_motion_menu()
+{
+    START_MENU();
+    MENU_ITEM(back, MSG_CONTROL, lcd_control_menu);
+    MENU_ITEM_EDIT(float5, MSG_ACC, &acceleration, 500, 99000);
+    MENU_ITEM_EDIT(float3, MSG_VXY_JERK, &max_xy_jerk, 1, 990);
+    MENU_ITEM_EDIT(float3, MSG_VMAX MSG_X, &max_feedrate[X_AXIS], 1, 999);
+    MENU_ITEM_EDIT(float3, MSG_VMAX MSG_Y, &max_feedrate[Y_AXIS], 1, 999);
+    MENU_ITEM_EDIT(float3, MSG_VMAX MSG_Z, &max_feedrate[Z_AXIS], 1, 999);
+    MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E, &max_feedrate[E_AXIS], 1, 999);
+    MENU_ITEM_EDIT(float3, MSG_VMIN, &minimumfeedrate, 0, 999);
+    MENU_ITEM_EDIT(float3, MSG_VTRAV_MIN, &mintravelfeedrate, 0, 999);
+    MENU_ITEM_EDIT(long5, MSG_AMAX MSG_X, &max_acceleration_units_per_sq_second[X_AXIS], 100, 99000);
+    MENU_ITEM_EDIT(long5, MSG_AMAX MSG_Y, &max_acceleration_units_per_sq_second[Y_AXIS], 100, 99000);
+    MENU_ITEM_EDIT(long5, MSG_AMAX MSG_Z, &max_acceleration_units_per_sq_second[Z_AXIS], 100, 99000);
+    MENU_ITEM_EDIT(long5, MSG_AMAX MSG_E, &max_acceleration_units_per_sq_second[E_AXIS], 100, 99000);
+    MENU_ITEM_EDIT(float5, MSG_A_RETRACT, &retract_acceleration, 100, 99000);
+    MENU_ITEM_EDIT(float52, MSG_XSTEPS, &axis_steps_per_unit[X_AXIS], 5, 9999);
+    MENU_ITEM_EDIT(float52, MSG_YSTEPS, &axis_steps_per_unit[Y_AXIS], 5, 9999);
+    MENU_ITEM_EDIT(float51, MSG_ZSTEPS, &axis_steps_per_unit[Z_AXIS], 5, 9999);
+    MENU_ITEM_EDIT(float51, MSG_ESTEPS, &axis_steps_per_unit[E_AXIS], 5, 9999);    
+#ifdef ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
+    MENU_ITEM_EDIT(bool, "Endstop abort", &abort_on_endstop_hit);
+#endif
+    END_MENU();
+}
+
+#ifdef FWRETRACT
+static void lcd_control_retract_menu()
+{
+    START_MENU();
+    MENU_ITEM(back, MSG_CONTROL, lcd_control_menu);
+    MENU_ITEM_EDIT(bool, MSG_AUTORETRACT, &autoretract_enabled);
+    MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT, &retract_length, 0, 100);
+    MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACTF, &retract_feedrate, 1, 999);
+    MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_ZLIFT, &retract_zlift, 0, 999);
+    MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER, &retract_recover_length, 0, 100);
+    MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACT_RECOVERF, &retract_recover_feedrate, 1, 999);
+    END_MENU();
+}
+#endif
+
+#if SDCARDDETECT == -1
+static void lcd_sd_refresh()
+{
+    card.initsd();
+    currentMenuViewOffset = 0;
+}
+#endif
+static void lcd_sd_updir()
+{
+    card.updir();
+    currentMenuViewOffset = 0;
+}
+
+void lcd_sdcard_menu()
+{
+    uint16_t fileCnt = card.getnrfilenames();
+    START_MENU();
+    MENU_ITEM(back, MSG_MAIN, lcd_main_menu);
+    card.getWorkDirName();
+    if(card.filename[0]=='/')
+    {
+#if SDCARDDETECT == -1
+        MENU_ITEM(function, LCD_STR_REFRESH MSG_REFRESH, lcd_sd_refresh);
+#endif
+    }else{
+        MENU_ITEM(function, LCD_STR_FOLDER "..", lcd_sd_updir);
+    }
+    
+    for(uint16_t i=0;i<fileCnt;i++)
+    {
+        if (_menuItemNr == _lineNr)
+        {
+            card.getfilename(i);
+            if (card.filenameIsDir)
+            {
+                MENU_ITEM(sddirectory, MSG_CARD_MENU, card.filename, card.longFilename);
+            }else{
+                MENU_ITEM(sdfile, MSG_CARD_MENU, card.filename, card.longFilename);
+            }
+        }else{
+            MENU_ITEM_DUMMY();
+        }
+    }
+    END_MENU();
+}
+
+#define menu_edit_type(_type, _name, _strFunc, scale) \
+    void menu_edit_ ## _name () \
+    { \
+        if ((int32_t)encoderPosition < minEditValue) \
+            encoderPosition = minEditValue; \
+        if ((int32_t)encoderPosition > maxEditValue) \
+            encoderPosition = maxEditValue; \
+        if (lcdDrawUpdate) \
+            lcd_implementation_drawedit(editLabel, _strFunc(((_type)encoderPosition) / scale)); \
+        if (LCD_CLICKED) \
+        { \
+            *((_type*)editValue) = ((_type)encoderPosition) / scale; \
+            lcd_quick_feedback(); \
+            currentMenu = prevMenu; \
+            encoderPosition = prevEncoderPosition; \
+        } \
+    } \
+    static void menu_action_setting_edit_ ## _name (const char* pstr, _type* ptr, _type minValue, _type maxValue) \
+    { \
+        prevMenu = currentMenu; \
+        prevEncoderPosition = encoderPosition; \
+         \
+        lcdDrawUpdate = 2; \
+        currentMenu = menu_edit_ ## _name; \
+         \
+        editLabel = pstr; \
+        editValue = ptr; \
+        minEditValue = minValue * scale; \
+        maxEditValue = maxValue * scale; \
+        encoderPosition = (*ptr) * scale; \
+    }
+menu_edit_type(int, int3, itostr3, 1)
+menu_edit_type(float, float3, ftostr3, 1)
+menu_edit_type(float, float32, ftostr32, 100)
+menu_edit_type(float, float5, ftostr5, 0.01)
+menu_edit_type(float, float51, ftostr51, 10)
+menu_edit_type(float, float52, ftostr52, 100)
+menu_edit_type(unsigned long, long5, ftostr5, 0.01)
+
+/** End of menus **/
+
+static void lcd_quick_feedback()
+{
+    lcdDrawUpdate = 2;
+    blocking_enc = millis() + 500;
+    lcd_implementation_quick_feedback();
+}
+
+/** Menu action functions **/
+static void menu_action_back(menuFunc_t data)
+{
+    currentMenu = data;
+    encoderPosition = 0;
+}
+static void menu_action_submenu(menuFunc_t data)
+{
+    currentMenu = data;
+    encoderPosition = 0;
+}
+static void menu_action_gcode(const char* pgcode)
+{
+    enquecommand_P(pgcode);
+}
+static void menu_action_function(menuFunc_t data)
+{
+    (*data)();
+}
+static void menu_action_sdfile(const char* filename, char* longFilename)
+{
+    char cmd[30];
+    char* c;
+    sprintf_P(cmd, PSTR("M23 %s"), filename);
+    for(c = &cmd[4]; *c; c++)
+        *c = tolower(*c);
+    enquecommand(cmd);
+    enquecommand_P(PSTR("M24"));
+    lcd_return_to_status();
+}
+static void menu_action_sddirectory(const char* filename, char* longFilename)
+{
+    card.chdir(filename);
+    encoderPosition = 0;
+}
+static void menu_action_setting_edit_bool(const char* pstr, bool* ptr)
+{
+    *ptr = !(*ptr);
+}
+#endif//ULTIPANEL
+
+/** LCD API **/
+void lcd_init()
+{
+    lcd_implementation_init();
+
+#ifdef NEWPANEL
+    pinMode(BTN_EN1,INPUT);
+    pinMode(BTN_EN2,INPUT); 
+    pinMode(BTN_ENC,INPUT); 
+    pinMode(SDCARDDETECT,INPUT);
+    WRITE(BTN_EN1,HIGH);
+    WRITE(BTN_EN2,HIGH);
+    WRITE(BTN_ENC,HIGH);
+#else
+    pinMode(SHIFT_CLK,OUTPUT);
+    pinMode(SHIFT_LD,OUTPUT);
+    pinMode(SHIFT_EN,OUTPUT);
+    pinMode(SHIFT_OUT,INPUT);
+    WRITE(SHIFT_OUT,HIGH);
+    WRITE(SHIFT_LD,HIGH); 
+    WRITE(SHIFT_EN,LOW);
+#endif//!NEWPANEL
+#if (SDCARDDETECT > -1)
+    WRITE(SDCARDDETECT, HIGH);
+    lcd_oldcardstatus = IS_SD_INSERTED;
+#endif//(SDCARDDETECT > -1)
+    lcd_buttons_update();
+    encoderDiff = 0;
+}
+
+void lcd_update()
+{
+    static unsigned long timeoutToStatus = 0;
+    
+    lcd_buttons_update();
+    
+    #if (SDCARDDETECT > -1)
+    if((IS_SD_INSERTED != lcd_oldcardstatus))
+    {
+        lcdDrawUpdate = 2;
+        lcd_oldcardstatus = IS_SD_INSERTED;
+        lcd_implementation_init(); // to maybe revive the lcd if static electricty killed it.
+        
+        if(lcd_oldcardstatus)
+        {
+            card.initsd();
+            LCD_MESSAGEPGM(MSG_SD_INSERTED);
+        }
+        else
+        {
+            card.release();
+            LCD_MESSAGEPGM(MSG_SD_REMOVED);
+        }
+    }
+    #endif//CARDINSERTED
+    
+    if (lcd_next_update_millis < millis())
+    {
+#ifdef ULTIPANEL
+        if (encoderDiff)
+        {
+            lcdDrawUpdate = 1;
+            encoderPosition += encoderDiff;
+            encoderDiff = 0;
+            timeoutToStatus = millis() + LCD_TIMEOUT_TO_STATUS;
+        }
+        if (LCD_CLICKED)
+            timeoutToStatus = millis() + LCD_TIMEOUT_TO_STATUS;
+#endif//ULTIPANEL
+        
+        (*currentMenu)();
+#ifdef ULTIPANEL
+        if(timeoutToStatus < millis() && currentMenu != lcd_status_screen)
+        {
+            lcd_return_to_status();
+            lcdDrawUpdate = 2;
+        }
+#endif//ULTIPANEL
+        if (lcdDrawUpdate == 2)
+            lcd_implementation_clear();
+        if (lcdDrawUpdate)
+            lcdDrawUpdate--;
+        lcd_next_update_millis = millis() + 100;
+    }
+}
+
+void lcd_setstatus(const char* message)
+{
+    if (lcd_status_message_level > 0)
+        return;
+    strncpy(lcd_status_message, message, LCD_WIDTH);
+    lcdDrawUpdate = 2;
+}
+void lcd_setstatuspgm(const char* message)
+{
+    if (lcd_status_message_level > 0)
+        return;
+    strncpy_P(lcd_status_message, message, LCD_WIDTH);
+    lcdDrawUpdate = 2;
+}
+void lcd_setalertstatuspgm(const char* message)
+{
+    lcd_setstatuspgm(message);
+    lcd_status_message_level = 1;
+#ifdef ULTIPANEL
+    lcd_return_to_status();
+#endif//ULTIPANEL
+}
+void lcd_reset_alert_level()
+{
+    lcd_status_message_level = 0;
+}
+
+#ifdef ULTIPANEL
+/* Warning: This function is called from interrupt context */
+void lcd_buttons_update()
+{
+#ifdef NEWPANEL
+    uint8_t newbutton=0;
+    if(READ(BTN_EN1)==0)  newbutton|=EN_A;
+    if(READ(BTN_EN2)==0)  newbutton|=EN_B;
+    if((blocking_enc<millis()) && (READ(BTN_ENC)==0))
+        newbutton |= EN_C;
+    buttons = newbutton;
+#else   //read it from the shift register
+    uint8_t newbutton=0;
+    WRITE(SHIFT_LD,LOW);
+    WRITE(SHIFT_LD,HIGH);
+    unsigned char tmp_buttons=0;
+    for(int8_t i=0;i<8;i++)
+    { 
+        newbutton = newbutton>>1;
+        if(READ(SHIFT_OUT))
+            newbutton|=(1<<7);
+        WRITE(SHIFT_CLK,HIGH);
+        WRITE(SHIFT_CLK,LOW);
+    }
+    buttons=~newbutton; //invert it, because a pressed switch produces a logical 0
+#endif//!NEWPANEL
+
+    //manage encoder rotation
+    uint8_t enc=0;
+    if(buttons&EN_A)
+        enc|=(1<<0);
+    if(buttons&EN_B)
+        enc|=(1<<1);
+    if(enc != lastEncoderBits)
+    {
+        switch(enc)
+        {
+        case encrot0:
+            if(lastEncoderBits==encrot3)
+                encoderDiff++;
+            else if(lastEncoderBits==encrot1)
+                encoderDiff--;
+            break;
+        case encrot1:
+            if(lastEncoderBits==encrot0)
+                encoderDiff++;
+            else if(lastEncoderBits==encrot2)
+                encoderDiff--;
+            break;
+        case encrot2:
+            if(lastEncoderBits==encrot1)
+                encoderDiff++;
+            else if(lastEncoderBits==encrot3)
+                encoderDiff--;
+            break;
+        case encrot3:
+            if(lastEncoderBits==encrot2)
+                encoderDiff++;
+            else if(lastEncoderBits==encrot0)
+                encoderDiff--;
+            break;
+        }
+    }
+    lastEncoderBits = enc;
+}
+#endif//ULTIPANEL
+
+/********************************/
+/** Float conversion utilities **/
+/********************************/
+//  convert float to string with +123.4 format
+char conv[8];
+char *ftostr3(const float &x)
+{
+  return itostr3((int)x);
+}
+
+char *itostr2(const uint8_t &x)
+{
+  //sprintf(conv,"%5.1f",x);
+  int xx=x;
+  conv[0]=(xx/10)%10+'0';
+  conv[1]=(xx)%10+'0';
+  conv[2]=0;
+  return conv;
+}
+
+//  convert float to string with +123.4 format
+char *ftostr31(const float &x)
+{
+  int xx=x*10;
+  conv[0]=(xx>=0)?'+':'-';
+  xx=abs(xx);
+  conv[1]=(xx/1000)%10+'0';
+  conv[2]=(xx/100)%10+'0';
+  conv[3]=(xx/10)%10+'0';
+  conv[4]='.';
+  conv[5]=(xx)%10+'0';
+  conv[6]=0;
+  return conv;
+}
+
+char *ftostr32(const float &x)
+{
+  long xx=x*100;
+  if (xx >= 0)
+    conv[0]=(xx/10000)%10+'0';
+  else
+    conv[0]='-';
+  xx=abs(xx);
+  conv[1]=(xx/1000)%10+'0';
+  conv[2]=(xx/100)%10+'0';
+  conv[3]='.';
+  conv[4]=(xx/10)%10+'0';
+  conv[5]=(xx)%10+'0';
+  conv[6]=0;
+  return conv;
+}
+
+char *itostr31(const int &xx)
+{
+  conv[0]=(xx>=0)?'+':'-';
+  conv[1]=(xx/1000)%10+'0';
+  conv[2]=(xx/100)%10+'0';
+  conv[3]=(xx/10)%10+'0';
+  conv[4]='.';
+  conv[5]=(xx)%10+'0';
+  conv[6]=0;
+  return conv;
+}
+
+char *itostr3(const int &xx)
+{
+  if (xx >= 100)
+    conv[0]=(xx/100)%10+'0';
+  else
+    conv[0]=' ';
+  if (xx >= 10)
+    conv[1]=(xx/10)%10+'0';
+  else
+    conv[1]=' ';
+  conv[2]=(xx)%10+'0';
+  conv[3]=0;
+  return conv;
+}
+
+char *itostr3left(const int &xx)
+{
+  if (xx >= 100)
+  {
+    conv[0]=(xx/100)%10+'0';
+    conv[1]=(xx/10)%10+'0';
+    conv[2]=(xx)%10+'0';
+    conv[3]=0;
+  }
+  else if (xx >= 10)
+  {
+    conv[0]=(xx/10)%10+'0';
+    conv[1]=(xx)%10+'0';
+    conv[2]=0;
+  }
+  else
+  {
+    conv[0]=(xx)%10+'0';
+    conv[1]=0;
+  }
+  return conv;
+}
+
+char *itostr4(const int &xx)
+{
+  if (xx >= 1000)
+    conv[0]=(xx/1000)%10+'0';
+  else
+    conv[0]=' ';
+  if (xx >= 100)
+    conv[1]=(xx/100)%10+'0';
+  else
+    conv[1]=' ';
+  if (xx >= 10)
+    conv[2]=(xx/10)%10+'0';
+  else
+    conv[2]=' ';
+  conv[3]=(xx)%10+'0';
+  conv[4]=0;
+  return conv;
+}
+
+//  convert float to string with 12345 format
+char *ftostr5(const float &x)
+{
+  long xx=abs(x);
+  if (xx >= 10000)
+    conv[0]=(xx/10000)%10+'0';
+  else
+    conv[0]=' ';
+  if (xx >= 1000)
+    conv[1]=(xx/1000)%10+'0';
+  else
+    conv[1]=' ';
+  if (xx >= 100)
+    conv[2]=(xx/100)%10+'0';
+  else
+    conv[2]=' ';
+  if (xx >= 10)
+    conv[3]=(xx/10)%10+'0';
+  else
+    conv[3]=' ';
+  conv[4]=(xx)%10+'0';
+  conv[5]=0;
+  return conv;
+}
+
+//  convert float to string with +1234.5 format
+char *ftostr51(const float &x)
+{
+  long xx=x*10;
+  conv[0]=(xx>=0)?'+':'-';
+  xx=abs(xx);
+  conv[1]=(xx/10000)%10+'0';
+  conv[2]=(xx/1000)%10+'0';
+  conv[3]=(xx/100)%10+'0';
+  conv[4]=(xx/10)%10+'0';
+  conv[5]='.';
+  conv[6]=(xx)%10+'0';
+  conv[7]=0;
+  return conv;
+}
+
+//  convert float to string with +123.45 format
+char *ftostr52(const float &x)
+{
+  long xx=x*100;
+  conv[0]=(xx>=0)?'+':'-';
+  xx=abs(xx);
+  conv[1]=(xx/10000)%10+'0';
+  conv[2]=(xx/1000)%10+'0';
+  conv[3]=(xx/100)%10+'0';
+  conv[4]='.';
+  conv[5]=(xx/10)%10+'0';
+  conv[6]=(xx)%10+'0';
+  conv[7]=0;
+  return conv;
+}
+
+#endif //ULTRA_LCD
diff --git a/Marlin/ultralcd.h b/Marlin/ultralcd.h
index d44c2c3..df7746a 100644
--- a/Marlin/ultralcd.h
+++ b/Marlin/ultralcd.h
@@ -1,37 +1,45 @@
 #ifndef ULTRALCD_H
 #define ULTRALCD_H
+
 #include "Marlin.h"
+
 #ifdef ULTRA_LCD
-  #include <LiquidCrystal.h>
-  void lcd_status();
+
+  void lcd_update();
   void lcd_init();
-  void lcd_status(const char* message);
-  void beep();
-  void buttons_init();
-  void buttons_check();
+  void lcd_setstatus(const char* message);
+  void lcd_setstatuspgm(const char* message);
+  void lcd_setalertstatuspgm(const char* message);
+  void lcd_reset_alert_level();
+
+  #define LCD_MESSAGEPGM(x) lcd_setstatuspgm(PSTR(x))
+  #define LCD_ALERTMESSAGEPGM(x) lcd_setalertstatuspgm(PSTR(x))
 
   #define LCD_UPDATE_INTERVAL 100
-  #define STATUSTIMEOUT 15000
-  extern LiquidCrystal lcd;
-  extern volatile char buttons;  //the last checked buttons in a bit array.
-  
+  #define LCD_TIMEOUT_TO_STATUS 15000
+
+  #ifdef ULTIPANEL
+  void lcd_buttons_update();
+  extern volatile uint8_t buttons;  //the last checked buttons in a bit array.
+  #else
+  FORCE_INLINE void lcd_buttons_update() {}
+  #endif
+
+  extern int plaPreheatHotendTemp;
+  extern int plaPreheatHPBTemp;
+  extern int plaPreheatFanSpeed;
+
+  extern int absPreheatHotendTemp;
+  extern int absPreheatHPBTemp;
+  extern int absPreheatFanSpeed;
+    
   #ifdef NEWPANEL
     #define EN_C (1<<BLEN_C)
     #define EN_B (1<<BLEN_B)
     #define EN_A (1<<BLEN_A)
-    
-    #define CLICKED (buttons&EN_C)
-    #define BLOCK {blocking=millis()+blocktime;}
-    #if (SDCARDDETECT > -1)
-      #ifdef SDCARDDETECTINVERTED 
-        #define CARDINSERTED (READ(SDCARDDETECT)!=0)
-      #else
-        #define CARDINSERTED (READ(SDCARDDETECT)==0)
-      #endif
-    #endif  //SDCARDTETECTINVERTED
 
+    #define LCD_CLICKED (buttons&EN_C)
   #else
-
     //atomatic, do not change
     #define B_LE (1<<BL_LE)
     #define B_UP (1<<BL_UP)
@@ -42,131 +50,31 @@
     #define EN_B (1<<BLEN_B)
     #define EN_A (1<<BLEN_A)
     
-    #define CLICKED ((buttons&B_MI)||(buttons&B_ST))
-    #define BLOCK {blocking[BL_MI]=millis()+blocktime;blocking[BL_ST]=millis()+blocktime;}
-    
-  #endif
-
-
-    
-  // blocking time for recognizing a new keypress of one key, ms
-  #define blocktime 500
-  #define lcdslow 5
-    
-  enum MainStatus{Main_Status, Main_Menu, Main_Prepare,Sub_PrepareMove, Main_Control, Main_SD,Sub_TempControl,Sub_MotionControl,Sub_RetractControl, Sub_PreheatPLASettings, Sub_PreheatABSSettings};
+    #define LCD_CLICKED ((buttons&B_MI)||(buttons&B_ST))
+  #endif//NEWPANEL
 
-  class MainMenu{
-  public:
-    MainMenu();
-    void update();
-    int8_t activeline;
-    MainStatus status;
-    uint8_t displayStartingRow;
-    
-    void showStatus();
-    void showMainMenu();
-    void showPrepare();
-    void showTune();
-    void showControl();
-    void showControlMotion();
-    void showControlTemp();
-    void showControlRetract();
-    void showAxisMove();
-    void showSD();
-	void showPLAsettings();
-	void showABSsettings();
-    bool force_lcd_update;
-    long lastencoderpos;
-    int8_t lineoffset;
-    int8_t lastlineoffset;
-    
-    bool linechanging;
-    
-    bool tune;
-    
-  private:
-    FORCE_INLINE void updateActiveLines(const uint8_t &maxlines,volatile long &encoderpos)
-    {
-      if(linechanging) return; // an item is changint its value, do not switch lines hence
-      lastlineoffset=lineoffset; 
-      long curencoderpos=encoderpos;  
-      force_lcd_update=false;
-      if(  (abs(curencoderpos-lastencoderpos)<lcdslow) ) 
-      { 
-        lcd.setCursor(0,activeline);lcd.print((activeline+lineoffset)?' ':' '); 
-        if(curencoderpos<0)  
-        {  
-          lineoffset--; 
-          if(lineoffset<0) lineoffset=0; 
-          curencoderpos=lcdslow-1;
-        } 
-        if(curencoderpos>(LCD_HEIGHT-1+1)*lcdslow) 
-        { 
-          lineoffset++; 
-          curencoderpos=(LCD_HEIGHT-1)*lcdslow; 
-          if(lineoffset>(maxlines+1-LCD_HEIGHT)) 
-            lineoffset=maxlines+1-LCD_HEIGHT; 
-          if(curencoderpos>maxlines*lcdslow) 
-            curencoderpos=maxlines*lcdslow; 
-        } 
-        lastencoderpos=encoderpos=curencoderpos;
-        activeline=curencoderpos/lcdslow;
-        if(activeline<0) activeline=0;
-        if(activeline>LCD_HEIGHT-1) activeline=LCD_HEIGHT-1;
-        if(activeline>maxlines) 
-        {
-          activeline=maxlines;
-          curencoderpos=maxlines*lcdslow;
-        }
-        if(lastlineoffset!=lineoffset)
-          force_lcd_update=true;
-        lcd.setCursor(0,activeline);lcd.print((activeline+lineoffset)?'>':'\003');    
-      } 
-    }
-    
-    FORCE_INLINE void clearIfNecessary()
-    {
-      if(lastlineoffset!=lineoffset ||force_lcd_update)
-      {
-        force_lcd_update=true;
-         lcd.clear();
-      } 
-    }
-  };
-
-  //conversion routines, could need some overworking
-  char *ftostr51(const float &x);
-  char *ftostr52(const float &x);
-  char *ftostr31(const float &x);
-  char *ftostr3(const float &x);
-
-
-  #define LCD_INIT lcd_init();
-  #define LCD_MESSAGE(x) lcd_status(x);
-  #define LCD_MESSAGEPGM(x) lcd_statuspgm(MYPGM(x));
-  #define LCD_ALERTMESSAGEPGM(x) lcd_alertstatuspgm(MYPGM(x));
-  #define LCD_STATUS lcd_status()
 #else //no lcd
-  #define LCD_INIT
-  #define LCD_STATUS
-  #define LCD_MESSAGE(x)
-  #define LCD_MESSAGEPGM(x)
-  #define LCD_ALERTMESSAGEPGM(x)
-  FORCE_INLINE void lcd_status() {};
+  FORCE_INLINE void lcd_update() {}
+  FORCE_INLINE void lcd_init() {}
+  FORCE_INLINE void lcd_setstatus(const char* message) {}
+  FORCE_INLINE void lcd_buttons_update() {}
+  FORCE_INLINE void lcd_reset_alert_level() {}
 
-  #define CLICKED false
-  #define BLOCK ;
+  #define LCD_MESSAGEPGM(x) 
+  #define LCD_ALERTMESSAGEPGM(x) 
 #endif 
-  
-void lcd_statuspgm(const char* message);
-void lcd_alertstatuspgm(const char* message);
-  
-char *ftostr3(const float &x);
+
 char *itostr2(const uint8_t &x);
-char *ftostr31(const float &x);
-char *ftostr32(const float &x);
 char *itostr31(const int &xx);
 char *itostr3(const int &xx);
+char *itostr3left(const int &xx);
 char *itostr4(const int &xx);
+
+char *ftostr3(const float &x);
+char *ftostr31(const float &x);
+char *ftostr32(const float &x);
+char *ftostr5(const float &x);
 char *ftostr51(const float &x);
+char *ftostr52(const float &x);
+
 #endif //ULTRALCD
diff --git a/Marlin/ultralcd.pde b/Marlin/ultralcd.pde
deleted file mode 100644
index 5cfbc32..0000000
--- a/Marlin/ultralcd.pde
+++ /dev/null
@@ -1,3050 +0,0 @@
-#include "language.h"
-#include "temperature.h"
-#include "ultralcd.h"
-#ifdef ULTRA_LCD
-#include "Marlin.h"
-#include "language.h"
-#include "temperature.h"
-#include "EEPROMwrite.h"
-#include <LiquidCrystal.h>
-//===========================================================================
-//=============================imported variables============================
-//===========================================================================
-
-extern volatile int feedmultiply;
-extern volatile bool feedmultiplychanged;
-
-extern volatile int extrudemultiply;
-
-extern long position[4];   
-#ifdef SDSUPPORT
-#include "cardreader.h"
-extern CardReader card;
-#endif
-
-//===========================================================================
-//=============================public variables============================
-//===========================================================================
-volatile char buttons=0;  //the last checked buttons in a bit array.
-long encoderpos=0;
-short lastenc=0;
-
-
-//===========================================================================
-//=============================private  variables============================
-//===========================================================================
-static char messagetext[LCD_WIDTH]="";
-
-//return for string conversion routines
-static char conv[8];
-
-LiquidCrystal lcd(LCD_PINS_RS, LCD_PINS_ENABLE, LCD_PINS_D4, LCD_PINS_D5,LCD_PINS_D6,LCD_PINS_D7);  //RS,Enable,D4,D5,D6,D7 
-
-static unsigned long previous_millis_lcd=0;
-//static long previous_millis_buttons=0;
-
-
-#ifdef NEWPANEL
- static long blocking=0;
-#else
- static long blocking[8]={0,0,0,0,0,0,0,0};
-#endif
- 
-static MainMenu menu;
-
-
-void lcdProgMemprint(const char *str)
-{
-  char ch=pgm_read_byte(str);
-  while(ch)
-  {
-    lcd.print(ch);
-    ch=pgm_read_byte(++str);
-  }
-}
-#define lcdprintPGM(x) lcdProgMemprint(MYPGM(x))
-
-
-//===========================================================================
-//=============================functions         ============================
-//===========================================================================
-
-int intround(const float &x){return int(0.5+x);}
-
-void lcd_status(const char* message)
-{
-  strncpy(messagetext,message,LCD_WIDTH);
-  messagetext[strlen(message)]=0;
-}
-
-void lcd_statuspgm(const char* message)
-{
-  char ch=pgm_read_byte(message);
-  char *target=messagetext;
-  uint8_t cnt=0;
-  while(ch &&cnt<LCD_WIDTH)
-  {
-    *target=ch;
-    target++;
-    cnt++;
-    ch=pgm_read_byte(++message);
-  }
-  *target=0;
-}
-
-void lcd_alertstatuspgm(const char* message)
-{
-  lcd_statuspgm(message); 
-  menu.showStatus(); 
-}
-
-FORCE_INLINE void clear()
-{
-  lcd.clear();
-}
-
-
-void lcd_init()
-{
-  //beep();
-  #ifdef ULTIPANEL
-    buttons_init();
-  #endif
-  
-  byte Degree[8] =
-  {
-    B01100,
-    B10010,
-    B10010,
-    B01100,
-    B00000,
-    B00000,
-    B00000,
-    B00000
-  };
-  byte Thermometer[8] =
-  {
-    B00100,
-    B01010,
-    B01010,
-    B01010,
-    B01010,
-    B10001,
-    B10001,
-    B01110
-  };
-  byte uplevel[8]={
-    B00100,
-    B01110,
-    B11111,
-    B00100,
-    B11100,
-    B00000,
-    B00000,
-    B00000
-  }; //thanks joris
-  byte refresh[8]={
-    B00000,
-    B00110,
-    B11001,
-    B11000,
-    B00011,
-    B10011,
-    B01100,
-    B00000,
-  }; //thanks joris
-  byte folder [8]={
-    B00000,
-    B11100,
-    B11111,
-    B10001,
-    B10001,
-    B11111,
-    B00000,
-    B00000
-  }; //thanks joris
-  lcd.begin(LCD_WIDTH, LCD_HEIGHT);
-  lcd.createChar(1,Degree);
-  lcd.createChar(2,Thermometer);
-  lcd.createChar(3,uplevel);
-  lcd.createChar(4,refresh);
-  lcd.createChar(5,folder);
-  LCD_MESSAGEPGM(WELCOME_MSG);
-}
-
-
-void beep()
-{
-  //return;
-  #ifdef ULTIPANEL
-	#if (BEEPER > -1)
-	{
-		pinMode(BEEPER,OUTPUT);
-		for(int8_t i=0;i<20;i++){
-		WRITE(BEEPER,HIGH);
-		delay(5);
-		WRITE(BEEPER,LOW);
-		delay(5);
-		}
-	}
-        #endif
-  #endif
-}
-
-void beepshort()
-{
-  //return;
-  #ifdef ULTIPANEL
-	#if (BEEPER > -1)
-	{
-		pinMode(BEEPER,OUTPUT);
-		for(int8_t i=0;i<10;i++){
-		WRITE(BEEPER,HIGH);
-		delay(3);
-		WRITE(BEEPER,LOW);
-		delay(3);
-		}
-	}
-        #endif
-  #endif  
-}
-
-void lcd_status()
-{
-  #ifdef ULTIPANEL
-    static uint8_t oldbuttons=0;
-    //static long previous_millis_buttons=0;
-    //static long previous_lcdinit=0;
-  //  buttons_check(); // Done in temperature interrupt
-    //previous_millis_buttons=millis();
-    long ms=millis();
-    for(int8_t i=0; i<8; i++) {
-      #ifndef NEWPANEL
-      if((blocking[i]>ms))
-        buttons &= ~(1<<i);
-      #else
-      if((blocking>ms))
-        buttons &= ~(1<<i);        
-      #endif
-    }
-    if((buttons==oldbuttons) &&  ((millis() - previous_millis_lcd) < LCD_UPDATE_INTERVAL)   )
-      return;
-    oldbuttons=buttons;
-  #else
-  
-    if(((millis() - previous_millis_lcd) < LCD_UPDATE_INTERVAL)   )
-      return;
-  #endif
-    
-  previous_millis_lcd=millis();
-  menu.update();
-}
-#ifdef ULTIPANEL  
-
-
-void buttons_init()
-{
-  #ifdef NEWPANEL
-    pinMode(BTN_EN1,INPUT);
-    pinMode(BTN_EN2,INPUT); 
-    pinMode(BTN_ENC,INPUT); 
-    pinMode(SDCARDDETECT,INPUT);
-    WRITE(BTN_EN1,HIGH);
-    WRITE(BTN_EN2,HIGH);
-    WRITE(BTN_ENC,HIGH);
-    #if (SDCARDDETECT > -1)
-    {
-      WRITE(SDCARDDETECT,HIGH);
-    }
-    #endif
-  #else
-    pinMode(SHIFT_CLK,OUTPUT);
-    pinMode(SHIFT_LD,OUTPUT);
-    pinMode(SHIFT_EN,OUTPUT);
-    pinMode(SHIFT_OUT,INPUT);
-    WRITE(SHIFT_OUT,HIGH);
-    WRITE(SHIFT_LD,HIGH); 
-    WRITE(SHIFT_EN,LOW); 
-  #endif
-}
-
-
-void buttons_check()
-{
-  
-  #ifdef NEWPANEL
-    uint8_t newbutton=0;
-    if(READ(BTN_EN1)==0)  newbutton|=EN_A;
-    if(READ(BTN_EN2)==0)  newbutton|=EN_B;
-    if((blocking<millis()) &&(READ(BTN_ENC)==0))
-      newbutton|=EN_C;
-    buttons=newbutton;
-  #else   //read it from the shift register
-    uint8_t newbutton=0;
-    WRITE(SHIFT_LD,LOW);
-    WRITE(SHIFT_LD,HIGH);
-    unsigned char tmp_buttons=0;
-    for(int8_t i=0;i<8;i++)
-    { 
-      newbutton = newbutton>>1;
-      if(READ(SHIFT_OUT))
-        newbutton|=(1<<7);
-      WRITE(SHIFT_CLK,HIGH);
-      WRITE(SHIFT_CLK,LOW);
-    }
-    buttons=~newbutton; //invert it, because a pressed switch produces a logical 0
-  #endif
-  
-  //manage encoder rotation
-  char enc=0;
-  if(buttons&EN_A)
-    enc|=(1<<0);
-  if(buttons&EN_B)
-    enc|=(1<<1);
-  if(enc!=lastenc)
-	{
-    switch(enc)
-    {
-    case encrot0:
-      if(lastenc==encrot3)
-        encoderpos++;
-      else if(lastenc==encrot1)
-        encoderpos--;
-      break;
-    case encrot1:
-      if(lastenc==encrot0)
-        encoderpos++;
-      else if(lastenc==encrot2)
-        encoderpos--;
-      break;
-    case encrot2:
-      if(lastenc==encrot1)
-        encoderpos++;
-      else if(lastenc==encrot3)
-        encoderpos--;
-      break;
-    case encrot3:
-      if(lastenc==encrot2)
-        encoderpos++;
-      else if(lastenc==encrot0)
-        encoderpos--;
-      break;
-    default:
-      ;
-    }
-  }
-  lastenc=enc;
-}
-
-#endif
-
-MainMenu::MainMenu()
-{
-  status=Main_Status;
-  displayStartingRow=0;
-  activeline=0;
-  force_lcd_update=true;
-  linechanging=false;
-  tune=false;
-}
-
-void MainMenu::showStatus()
-{ 
-#if LCD_HEIGHT==4
-  static int olddegHotEnd0=-1;
-  static int oldtargetHotEnd0=-1;
-  //force_lcd_update=true;
-  if(force_lcd_update)  //initial display of content
-  {
-    encoderpos=feedmultiply;
-    clear();
-    lcd.setCursor(0,0);lcdprintPGM("\002---/---\001 ");
-    #if defined BED_USES_THERMISTOR || defined BED_USES_AD595 
-      lcd.setCursor(10,0);lcdprintPGM("B---/---\001 ");
-    #elif EXTRUDERS > 1
-      lcd.setCursor(10,0);lcdprintPGM("\002---/---\001 ");
-    #endif
-  }
-    
-  int tHotEnd0=intround(degHotend0());
-  if((tHotEnd0!=olddegHotEnd0)||force_lcd_update)
-  {
-    lcd.setCursor(1,0);
-    lcd.print(ftostr3(tHotEnd0));
-    olddegHotEnd0=tHotEnd0;
-  }
-  int ttHotEnd0=intround(degTargetHotend0());
-  if((ttHotEnd0!=oldtargetHotEnd0)||force_lcd_update)
-  {
-    lcd.setCursor(5,0);
-    lcd.print(ftostr3(ttHotEnd0));
-    oldtargetHotEnd0=ttHotEnd0;
-  }
-  #if defined BED_USES_THERMISTOR || defined BED_USES_AD595 
-    static int oldtBed=-1;
-    static int oldtargetBed=-1; 
-    int tBed=intround(degBed());
-    if((tBed!=oldtBed)||force_lcd_update)
-    {
-      lcd.setCursor(11,0);
-      lcd.print(ftostr3(tBed));
-      oldtBed=tBed;
-    }
-    int targetBed=intround(degTargetBed());
-    if((targetBed!=oldtargetBed)||force_lcd_update)
-    {
-      lcd.setCursor(15,0);
-      lcd.print(ftostr3(targetBed));
-      oldtargetBed=targetBed;
-    }
-  #elif EXTRUDERS > 1
-    static int olddegHotEnd1=-1;
-    static int oldtargetHotEnd1=-1;
-    int tHotEnd1=intround(degHotend1());
-    if((tHotEnd1!=olddegHotEnd1)||force_lcd_update)
-    {
-      lcd.setCursor(11,0);
-      lcd.print(ftostr3(tHotEnd1));
-      olddegHotEnd1=tHotEnd1;
-    }
-    int ttHotEnd1=intround(degTargetHotend1());
-    if((ttHotEnd1!=oldtargetHotEnd1)||force_lcd_update)
-    {
-      lcd.setCursor(15,0);
-      lcd.print(ftostr3(ttHotEnd1));
-      oldtargetHotEnd1=ttHotEnd1;
-    }
-  #endif
-  //starttime=2;
-  static uint16_t oldtime=0;
-  if(starttime!=0)
-  {
-    lcd.setCursor(0,1);
-    uint16_t time=millis()/60000-starttime/60000;
-    
-    if(starttime!=oldtime)
-    {
-      lcd.print(itostr2(time/60));lcdprintPGM("h ");lcd.print(itostr2(time%60));lcdprintPGM("m");
-      oldtime=time;
-    }
-  }
-  static int oldzpos=0;
-  int currentz=current_position[2]*100;
-  if((currentz!=oldzpos)||force_lcd_update)
-  {
-    lcd.setCursor(10,1);
-    lcdprintPGM("Z:");lcd.print(ftostr52(current_position[2]));
-    oldzpos=currentz;
-  }
-  
-  static int oldfeedmultiply=0;
-  int curfeedmultiply=feedmultiply;
-  
-  if(feedmultiplychanged == true) {
-    feedmultiplychanged = false;
-    encoderpos = curfeedmultiply;
-  }
-  
-  if(encoderpos!=curfeedmultiply||force_lcd_update)
-  {
-   curfeedmultiply=encoderpos;
-   if(curfeedmultiply<10)
-     curfeedmultiply=10;
-   if(curfeedmultiply>999)
-     curfeedmultiply=999;
-   feedmultiply=curfeedmultiply;
-   encoderpos=curfeedmultiply;
-  }
-  
-  if((curfeedmultiply!=oldfeedmultiply)||force_lcd_update)
-  {
-   oldfeedmultiply=curfeedmultiply;
-   lcd.setCursor(0,2);
-   lcd.print(itostr3(curfeedmultiply));lcdprintPGM("% ");
-  }
-  
-  if(messagetext[0]!='\0')
-  {
-    lcd.setCursor(0,LCD_HEIGHT-1);
-    lcd.print(messagetext);
-    uint8_t n=strlen(messagetext);
-    for(int8_t i=0;i<LCD_WIDTH-n;i++)
-      lcd.print(" ");
-    messagetext[0]='\0';
-  }
-#ifdef SDSUPPORT
-  static uint8_t oldpercent=101;
-  uint8_t percent=card.percentDone();
-  if(oldpercent!=percent ||force_lcd_update)
-  {
-     lcd.setCursor(10,2);
-    lcd.print(itostr3((int)percent));
-    lcdprintPGM("%SD");
-  }
-#endif
-#else //smaller LCDS----------------------------------
-  static int olddegHotEnd0=-1;
-  static int oldtargetHotEnd0=-1;
-  if(force_lcd_update)  //initial display of content
-  {
-    encoderpos=feedmultiply;
-    lcd.setCursor(0,0);lcdprintPGM("\002---/---\001 ");
-  }
-    
-  int tHotEnd0=intround(degHotend0());
-  int ttHotEnd0=intround(degTargetHotend0());
-
-
-  if((abs(tHotEnd0-olddegHotEnd0)>1)||force_lcd_update)
-  {
-    lcd.setCursor(1,0);
-    lcd.print(ftostr3(tHotEnd0));
-    olddegHotEnd0=tHotEnd0;
-  }
-  if((ttHotEnd0!=oldtargetHotEnd0)||force_lcd_update)
-  {
-    lcd.setCursor(5,0);
-    lcd.print(ftostr3(ttHotEnd0));
-    oldtargetHotEnd0=ttHotEnd0;
-  }
-
-  if(messagetext[0]!='\0')
-  {
-    lcd.setCursor(0,LCD_HEIGHT-1);
-    lcd.print(messagetext);
-    uint8_t n=strlen(messagetext);
-    for(int8_t i=0;i<LCD_WIDTH-n;i++)
-      lcd.print(" ");
-    messagetext[0]='\0';
-  }
-
-#endif
-  force_lcd_update=false;
-}
-
-enum {ItemP_exit, ItemP_autostart,ItemP_disstep,ItemP_home, ItemP_origin, ItemP_preheat_pla, ItemP_preheat_abs, ItemP_cooldown,/*ItemP_extrude,*/ItemP_move};
-
-//any action must not contain a ',' character anywhere, or this breaks:
-#define MENUITEM(repaint_action, click_action) \
-  {\
-    if(force_lcd_update)  { lcd.setCursor(0,line);  repaint_action; } \
-    if((activeline==line) && CLICKED) {click_action} \
-  }
-  
-void MainMenu::showPrepare()
-{
-#ifdef ULTIPANEL
- uint8_t line=0;
- clearIfNecessary();
- for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
- {
-   //Serial.println((int)(line-lineoffset));
-  switch(i)
-  {
-    case ItemP_exit:
-      MENUITEM(  lcdprintPGM(MSG_MAIN)  ,  BLOCK;status=Main_Menu;beepshort(); ) ;
-      break;
-    case ItemP_autostart:
-      MENUITEM(  lcdprintPGM(MSG_AUTOSTART)  ,  BLOCK;
-#ifdef SDSUPPORT
-          card.lastnr=0;card.setroot();card.checkautostart(true);
-#endif
-          beepshort(); ) ;
-      break;
-    case ItemP_disstep:
-      MENUITEM(  lcdprintPGM(MSG_DISABLE_STEPPERS)  ,  BLOCK;enquecommand("M84");beepshort(); ) ;
-      break;
-    case ItemP_home:
-      MENUITEM(  lcdprintPGM(MSG_AUTO_HOME)  ,  BLOCK;enquecommand("G28");beepshort(); ) ;
-      break;
-    case ItemP_origin:
-      MENUITEM(  lcdprintPGM(MSG_SET_ORIGIN)  ,  BLOCK;enquecommand("G92 X0 Y0 Z0");beepshort(); ) ;
-      break;
-    case ItemP_preheat_pla:
-		MENUITEM(  lcdprintPGM(MSG_PREHEAT_PLA)  ,  BLOCK;setTargetHotend0(plaPreheatHotendTemp);setTargetBed(plaPreheatHPBTemp);
-      #if FAN_PIN > -1
-		FanSpeed = plaPreheatFanSpeed;
-        analogWrite(FAN_PIN,  FanSpeed);
-      #endif
-      beepshort(); );
-      break;
-    case ItemP_preheat_abs:
-      MENUITEM(  lcdprintPGM(MSG_PREHEAT_ABS)  ,  BLOCK;setTargetHotend0(absPreheatHotendTemp);setTargetBed(absPreheatHPBTemp); 
-      #if FAN_PIN > -1
-	  	FanSpeed = absPreheatFanSpeed;
-        analogWrite(FAN_PIN,  FanSpeed);
-      #endif
-      beepshort(); );
-      break;
-    case ItemP_cooldown:
-      MENUITEM(  lcdprintPGM(MSG_COOLDOWN)  ,  BLOCK;setTargetHotend0(0);setTargetHotend1(0);setTargetHotend2(0);setTargetBed(0);beepshort(); ) ;
-      break;
-//    case ItemP_extrude:
-  //    MENUITEM(  lcdprintPGM(" Extrude")  ,  BLOCK;enquecommand("G92 E0");enquecommand("G1 F700 E50");beepshort(); ) ;
-    //  break;
-    case ItemP_move:
-      MENUITEM(  lcdprintPGM(MSG_MOVE_AXIS) , BLOCK;status=Sub_PrepareMove;beepshort(); );
-      break;
-        default:   
-      break;
-  }
-  line++;
- }
- updateActiveLines(ItemP_move,encoderpos);
-#endif
-}
-
-enum {
-  ItemAM_exit,
-  ItemAM_X, ItemAM_Y, ItemAM_Z, ItemAM_E, ItemAM_ERetract
-};
-
-void MainMenu::showAxisMove()
-{
-   uint8_t line=0;
-   int oldencoderpos=0;
-   clearIfNecessary();
-   for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
-   {
-     switch(i)
-      {
-          case ItemAM_exit:
-          MENUITEM(  lcdprintPGM(MSG_PREPARE_ALT)  ,  BLOCK;status=Main_Prepare;beepshort(); ) ;
-          break;
-          case ItemAM_X:
-          {
-	 	  //oldencoderpos=0;
-                  if(force_lcd_update)
-                  {
-                    lcd.setCursor(0,line);lcdprintPGM(" X:");
-                    lcd.setCursor(11,line);lcd.print(ftostr52(current_position[X_AXIS]));
-                  }
-      
-                  if((activeline!=line) )
-                  break;
-                  
-                  if(CLICKED) 
-                  {
-                    linechanging=!linechanging;
-                    if(linechanging)
-                    {
-			enquecommand("G91");
-                    }
-                    else
-                    {
-		      enquecommand("G90");
-                      encoderpos=activeline*lcdslow;
-                      beepshort();
-                    }
-                    BLOCK;
-                  }
-                  if(linechanging)
-                  {
-                    if (encoderpos >0) 
-                   { 
-		    	enquecommand("G1 F700 X0.1");
-			oldencoderpos=encoderpos;
-                        encoderpos=0;
-		    }
-		  
-		    else if (encoderpos < 0)
-                    {
-		    	enquecommand("G1 F700 X-0.1");
-			oldencoderpos=encoderpos;
-                        encoderpos=0;
-		    }
-                    lcd.setCursor(11,line);lcd.print(ftostr52(current_position[X_AXIS]));
-                  }
-          }
-          break;
-          case ItemAM_Y:
-            {
-                  if(force_lcd_update)
-                  {
-                    lcd.setCursor(0,line);lcdprintPGM(" Y:");
-                    lcd.setCursor(11,line);lcd.print(ftostr52(current_position[Y_AXIS]));
-                  }
-      
-                  if((activeline!=line) )
-                  break;
-                  
-                  if(CLICKED) 
-                  {
-                    linechanging=!linechanging;
-                    if(linechanging)
-                    {
-			enquecommand("G91");
-                    }
-                    else
-                    {
-		      enquecommand("G90");
-                      encoderpos=activeline*lcdslow;
-                      beepshort();
-                    }
-                    BLOCK;
-                  }
-                  if(linechanging)
-                  {
-                    if (encoderpos >0) 
-                   { 
-		    	enquecommand("G1 F700 Y0.1");
-			oldencoderpos=encoderpos;
-                        encoderpos=0;
-		    }
-		  
-		    else if (encoderpos < 0)
-                    {
-		    	enquecommand("G1 F700 Y-0.1");
-			oldencoderpos=encoderpos;
-                        encoderpos=0;
-		    }
-                    lcd.setCursor(11,line);lcd.print(ftostr52(current_position[Y_AXIS]));
-                  }
-          }
-          break;
-          case ItemAM_Z:
-          {
-                  if(force_lcd_update)
-                  {
-                    lcd.setCursor(0,line);lcdprintPGM(" Z:");
-                    lcd.setCursor(11,line);lcd.print(ftostr52(current_position[Z_AXIS]));
-                  }
-      
-                  if((activeline!=line) )
-                  break;
-                  
-                   if(CLICKED) 
-                  {
-                    linechanging=!linechanging;
-                    if(linechanging)
-                    {
-			enquecommand("G91");
-                    }
-                    else
-                    {
-		      enquecommand("G90");
-                      encoderpos=activeline*lcdslow;
-                      beepshort();
-                    }
-                    BLOCK;
-                  }
-                  if(linechanging)
-                  {
-                    if (encoderpos >0) 
-                   { 
-		    	enquecommand("G1 F70 Z0.1");
-			oldencoderpos=encoderpos;
-                        encoderpos=0;
-		    }
-		  
-		    else if (encoderpos < 0)
-                    {
-		    	enquecommand("G1 F70 Z-0.1");
-			oldencoderpos=encoderpos;
-                        encoderpos=0;
-		    }
-                    lcd.setCursor(11,line);lcd.print(ftostr52(current_position[Z_AXIS]));
-                  }
-          }
-          break;
-          case ItemAM_E:
-          // ErikDB: TODO: this length should be changed for volumetric.
-          MENUITEM(  lcdprintPGM(MSG_EXTRUDE)  ,  BLOCK;enquecommand("G92 E0");enquecommand("G1 F70 E1");beepshort(); ) ;
-          break;
-          case ItemAM_ERetract:
-              // ErikDB: TODO: this length should be changed for volumetric.
-              MENUITEM(  lcdprintPGM(MSG_RETRACT)  ,  BLOCK;enquecommand("G92 E0");enquecommand("G1 F700 E-1");beepshort(); ) ;
-              break;
-          default:
-          break;
-      }
-      line++;
-   }
-   updateActiveLines(ItemAM_ERetract,encoderpos);
-}
-
-enum {ItemT_exit,ItemT_speed,ItemT_flow,ItemT_nozzle,
-#if (HEATER_BED_PIN > -1)
-ItemT_bed,
-#endif
-ItemT_fan};
-
-void MainMenu::showTune()
-{ 
-  uint8_t line=0;
-  clearIfNecessary();
- for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
- {
-   //Serial.println((int)(line-lineoffset));
-  switch(i)
-  {
-  case ItemT_exit:
-      MENUITEM(  lcdprintPGM(MSG_MAIN)  ,  BLOCK;status=Main_Menu;beepshort(); ) ;
-      break;
-  case ItemT_speed:
-    {
-      if(force_lcd_update)
-      {
-        lcd.setCursor(0,line);lcdprintPGM(MSG_SPEED);
-        lcd.setCursor(13,line);lcd.print(ftostr3(feedmultiply));
-      }
-      
-      if((activeline!=line) )
-        break;
-      
-      if(CLICKED) //AnalogWrite(FAN_PIN,  fanpwm);
-      {
-        linechanging=!linechanging;
-        if(linechanging)
-        {
-            encoderpos=feedmultiply;
-        }
-        else
-        {
-          encoderpos=activeline*lcdslow;
-          beepshort();
-        }
-        BLOCK;
-      }
-      if(linechanging)
-      {
-        if(encoderpos<1) encoderpos=1;
-        if(encoderpos>400) encoderpos=400;
-        feedmultiply = encoderpos;
-        feedmultiplychanged=true;
-        lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-      }
-      
-    }break;
-    case ItemT_nozzle:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_NOZZLE);
-          lcd.setCursor(13,line);lcd.print(ftostr3(intround(degTargetHotend0())));
-        } 
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=intround(degTargetHotend0());
-          }
-          else
-          {
-            setTargetHotend0(encoderpos);
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>260) encoderpos=260;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-      }break;
-      #if (HEATER_BED_PIN > -1)
-      case ItemT_bed:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_BED);
-          lcd.setCursor(13,line);lcd.print(ftostr3(intround(degTargetBed())));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=intround(degTargetBed());
-          }
-          else
-          {
-            setTargetBed(encoderpos);
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>260) encoderpos=260;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-      }break;
-      #endif
-
-      
-      case ItemT_fan:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_FAN_SPEED);
-          lcd.setCursor(13,line);lcd.print(ftostr3(FanSpeed));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED) //nalogWrite(FAN_PIN,  fanpwm);
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=FanSpeed;
-          }
-          else
-          {
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>255) encoderpos=255;
-          FanSpeed=encoderpos;
-            analogWrite(FAN_PIN,  FanSpeed);
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-        
-      }break;
-      case ItemT_flow://axis_steps_per_unit[i] = code_value();
-         {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_FLOW);
-          lcd.setCursor(13,line);lcd.print(ftostr52(axis_steps_per_unit[E_AXIS]));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)(axis_steps_per_unit[E_AXIS]*100.0);
-          }
-          else
-          {
-            float factor=float(encoderpos)/100.0/float(axis_steps_per_unit[E_AXIS]);
-            position[E_AXIS]=lround(position[E_AXIS]*factor);
-            //current_position[E_AXIS]*=factor;
-            axis_steps_per_unit[E_AXIS]= encoderpos/100.0;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<5) encoderpos=5;
-          if(encoderpos>999999) encoderpos=999999;
-          lcd.setCursor(13,line);lcd.print(ftostr52(encoderpos/100.0));
-        }
-        
-      }break; 
-    default:   
-      break;
-  }
-  line++;
- }
- updateActiveLines(ItemT_fan,encoderpos);
-}
-
-//does not work
-// #define MENUCHANGEITEM(repaint_action,  enter_action, accept_action,  change_action) \
-//   {\
-//     if(force_lcd_update)  { lcd.setCursor(0,line);  repaint_action; } \
-//     if(activeline==line)  \
-//     { \
-//       if(CLICKED) \
-//       { \
-//         linechanging=!linechanging; \
-//         if(linechanging)  {enter_action;} \
-//         else {accept_action;} \
-//       }  \
-//       else \
-//       if(linechanging) {change_action};}\
-//   }
-//   
-
-enum {
-  ItemCT_exit,ItemCT_nozzle0,
-#ifdef AUTOTEMP
-  ItemCT_autotempactive,
-  ItemCT_autotempmin,ItemCT_autotempmax,ItemCT_autotempfact,
-#endif
-#if EXTRUDERS > 1
-  ItemCT_nozzle1,
-#endif
-#if EXTRUDERS > 2
-  ItemCT_nozzle2,
-#endif
-#if defined BED_USES_THERMISTOR || defined BED_USES_AD595
-ItemCT_bed,
-#endif  
-  ItemCT_fan,
-  ItemCT_PID_P,ItemCT_PID_I,ItemCT_PID_D,ItemCT_PID_C,
-  ItemCT_PLA_PreHeat_Setting, 
-  ItemCT_ABS_PreHeat_Setting,
-};
-
-void MainMenu::showControlTemp()
-{
-  uint8_t line=0;
- clearIfNecessary();
- for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
- {
-  switch(i)
-  {
-    case ItemCT_exit:
-      MENUITEM(  lcdprintPGM(MSG_CONTROL)  ,  BLOCK;status=Main_Control;beepshort(); ) ;
-      break;
-    case ItemCT_nozzle0:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_NOZZLE);
-          lcd.setCursor(13,line);lcd.print(ftostr3(intround(degTargetHotend0())));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=intround(degTargetHotend0());
-          }
-          else
-          {
-            setTargetHotend0(encoderpos);
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>260) encoderpos=260;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-        
-      }break;
-    #if EXTRUDERS > 1
-    case ItemCT_nozzle1:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_NOZZLE1);
-          lcd.setCursor(13,line);lcd.print(ftostr3(intround(degTargetHotend1())));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=intround(degTargetHotend1());
-          }
-          else
-          {
-            setTargetHotend1(encoderpos);
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>260) encoderpos=260;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-        
-      }break;
-    #endif
-    #if EXTRUDERS > 2
-    case ItemCT_nozzle2:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_NOZZLE2);
-          lcd.setCursor(13,line);lcd.print(ftostr3(intround(degTargetHotend2())));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=intround(degTargetHotend2());
-          }
-          else
-          {
-            setTargetHotend1(encoderpos);
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>260) encoderpos=260;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-        
-      }break;
-    #endif
-    #ifdef AUTOTEMP
-    case ItemCT_autotempmin:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_MIN);
-          lcd.setCursor(13,line);lcd.print(ftostr3(autotemp_min));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=intround(autotemp_min);
-          }
-          else
-          {
-            autotemp_min=encoderpos;
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>260) encoderpos=260;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-        
-      }break;  
-    case ItemCT_autotempmax:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_MAX);
-          lcd.setCursor(13,line);lcd.print(ftostr3(autotemp_max));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=intround(autotemp_max);
-          }
-          else
-          {
-            autotemp_max=encoderpos;
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>260) encoderpos=260;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-        
-      }break;  
-    case ItemCT_autotempfact:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_FACTOR);
-          lcd.setCursor(13,line);lcd.print(ftostr32(autotemp_factor));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=intround(autotemp_factor*100);
-          }
-          else
-          {
-            autotemp_max=encoderpos;
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>99) encoderpos=99;
-          lcd.setCursor(13,line);lcd.print(ftostr32(encoderpos/100.));
-        }
-        
-      }break;
-    case ItemCT_autotempactive:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_AUTOTEMP);
-          lcd.setCursor(13,line);
-          if(autotemp_enabled)
-            lcdprintPGM(MSG_ON);
-          else
-            lcdprintPGM(MSG_OFF);
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          autotemp_enabled=!autotemp_enabled;
-          lcd.setCursor(13,line);
-          if(autotemp_enabled)
-            lcdprintPGM(MSG_ON);
-          else
-            lcdprintPGM(MSG_OFF);
-          BLOCK;
-        }
-        
-      }break;  
-    #endif //autotemp
-    #if defined BED_USES_THERMISTOR || defined BED_USES_AD595
-    case ItemCT_bed:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_BED);
-          lcd.setCursor(13,line);lcd.print(ftostr3(intround(degTargetBed())));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=intround(degTargetBed());
-          }
-          else
-          {
-            setTargetBed(encoderpos);
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>260) encoderpos=260;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-      }break;
-    #endif
-    case ItemCT_fan:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_FAN_SPEED);
-          lcd.setCursor(13,line);lcd.print(ftostr3(FanSpeed));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED) //nalogWrite(FAN_PIN,  fanpwm);
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=FanSpeed;
-          }
-          else
-          {
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>255) encoderpos=255;
-          FanSpeed=encoderpos;
-            analogWrite(FAN_PIN,  FanSpeed);
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-        
-      }break;
-    #ifdef PIDTEMP
-    case ItemCT_PID_P: 
-      {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(" PID-P: ");
-          lcd.setCursor(13,line);lcd.print(itostr4(Kp));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)Kp;
-          }
-          else
-          {
-            Kp= encoderpos;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<1) encoderpos=1;
-          if(encoderpos>9990) encoderpos=9990;
-          lcd.setCursor(13,line);lcd.print(itostr4(encoderpos));
-        }
-        
-      }break;
-    case ItemCT_PID_I: 
-      {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_PID_I);
-          lcd.setCursor(13,line);lcd.print(ftostr51(Ki/PID_dT));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)(Ki*10/PID_dT);
-          }
-          else
-          {
-            Ki= encoderpos/10.*PID_dT;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>9990) encoderpos=9990;
-          lcd.setCursor(13,line);lcd.print(ftostr51(encoderpos/10.));
-        }
-        
-      }break;
-    case ItemCT_PID_D: 
-      {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_PID_D);
-          lcd.setCursor(13,line);lcd.print(itostr4(Kd*PID_dT));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)(Kd/5./PID_dT);
-          }
-          else
-          {
-            Kd= encoderpos;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>9990) encoderpos=9990;
-          lcd.setCursor(13,line);lcd.print(itostr4(encoderpos));
-        }
-       
-      }break;   
-    case ItemCT_PID_C: 
-      #ifdef PID_ADD_EXTRUSION_RATE
-      {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_PID_C);
-          lcd.setCursor(13,line);lcd.print(itostr3(Kc));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)Kc;
-          }
-          else
-          {
-            Kc= encoderpos;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>990) encoderpos=990;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-        
-      }
-      #endif
-    #endif
-      break;
-	  case ItemCT_PLA_PreHeat_Setting:
-        MENUITEM(  lcdprintPGM(MSG_PREHEAT_PLA_SETTINGS)  ,  BLOCK;status=Sub_PreheatPLASettings;beepshort(); ) ;
-	  break;
-	  case ItemCT_ABS_PreHeat_Setting:
-        MENUITEM(  lcdprintPGM(MSG_PREHEAT_ABS_SETTINGS)  ,  BLOCK;status=Sub_PreheatABSSettings;beepshort(); ) ;
-	  break;
-    default:   
-      break;
-  }
-  line++;
- }
-
-  updateActiveLines(ItemCT_ABS_PreHeat_Setting,encoderpos);
-}
-
-
-enum {
-  ItemCM_exit, 
-  ItemCM_acc, ItemCM_xyjerk, 
-  ItemCM_vmaxx, ItemCM_vmaxy, ItemCM_vmaxz, ItemCM_vmaxe, 
-  ItemCM_vtravmin,ItemCM_vmin,  
-  ItemCM_amaxx, ItemCM_amaxy, ItemCM_amaxz, ItemCM_amaxe, 
-  ItemCM_aret, ItemCM_xsteps,ItemCM_ysteps, ItemCM_zsteps, ItemCM_esteps
-};
-
-
-
-void MainMenu::showControlMotion()
-{
- uint8_t line=0;
- clearIfNecessary();
- for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
- {
-  switch(i)
-  {
-    case ItemCM_exit:
-      MENUITEM(  lcdprintPGM(MSG_CONTROL)  ,  BLOCK;status=Main_Control;beepshort(); ) ;
-      break;
-    case ItemCM_acc:
-    {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_ACC);
-          lcd.setCursor(13,line);lcd.print(itostr3(acceleration/100));lcdprintPGM("00");
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)acceleration/100;
-          }
-          else
-          {
-            acceleration= encoderpos*100;
-            encoderpos=activeline*lcdslow;
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<5) encoderpos=5;
-          if(encoderpos>990) encoderpos=990;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));lcdprintPGM("00");
-        }
-        
-      }break;
-    case ItemCM_xyjerk: //max_xy_jerk
-      {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_VXY_JERK);
-          lcd.setCursor(13,line);lcd.print(itostr3(max_xy_jerk));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)max_xy_jerk;
-          }
-          else
-          {
-            max_xy_jerk= encoderpos;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<1) encoderpos=1;
-          if(encoderpos>990) encoderpos=990;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-        
-      }break;
-      
-    case ItemCM_vmaxx:
-    case ItemCM_vmaxy:
-    case ItemCM_vmaxz:
-    case ItemCM_vmaxe:
-      {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_VMAX);
-          if(i==ItemCM_vmaxx)lcdprintPGM(MSG_X);
-          if(i==ItemCM_vmaxy)lcdprintPGM(MSG_Y);
-          if(i==ItemCM_vmaxz)lcdprintPGM(MSG_Z);
-          if(i==ItemCM_vmaxe)lcdprintPGM(MSG_E);
-          lcd.setCursor(13,line);lcd.print(itostr3(max_feedrate[i-ItemCM_vmaxx]));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)max_feedrate[i-ItemCM_vmaxx];
-          }
-          else
-          {
-            max_feedrate[i-ItemCM_vmaxx]= encoderpos;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<1) encoderpos=1;
-          if(encoderpos>990) encoderpos=990;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-        
-      }break;
-    
-    case ItemCM_vmin:
-    {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_VMIN);
-          lcd.setCursor(13,line);lcd.print(itostr3(minimumfeedrate));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)(minimumfeedrate);
-          }
-          else
-          {
-            minimumfeedrate= encoderpos;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>990) encoderpos=990;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-        
-      }break;
-    case ItemCM_vtravmin:
-    {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_VTRAV_MIN);
-          lcd.setCursor(13,line);lcd.print(itostr3(mintravelfeedrate));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)mintravelfeedrate;
-          }
-          else
-          {
-            mintravelfeedrate= encoderpos;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>990) encoderpos=990;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-        
-      }break;
-    
-    case ItemCM_amaxx:      
-    case ItemCM_amaxy:
-    case ItemCM_amaxz:
-    case ItemCM_amaxe:
-    {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(" Amax ");
-          if(i==ItemCM_amaxx)lcdprintPGM(MSG_X);
-          if(i==ItemCM_amaxy)lcdprintPGM(MSG_Y);
-          if(i==ItemCM_amaxz)lcdprintPGM(MSG_Z);
-          if(i==ItemCM_amaxe)lcdprintPGM(MSG_E);
-          lcd.setCursor(13,line);lcd.print(itostr3(max_acceleration_units_per_sq_second[i-ItemCM_amaxx]/100));lcdprintPGM("00");
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)max_acceleration_units_per_sq_second[i-ItemCM_amaxx]/100;
-          }
-          else
-          {
-            max_acceleration_units_per_sq_second[i-ItemCM_amaxx]= encoderpos*100;
-            encoderpos=activeline*lcdslow;
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<1) encoderpos=1;
-          if(encoderpos>990) encoderpos=990;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));lcdprintPGM("00");
-        }
-        
-      }break;
-     
-    
-    case ItemCM_aret://float retract_acceleration = 7000;
-    {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_A_RETRACT);
-          lcd.setCursor(13,line);lcd.print(ftostr3(retract_acceleration/100));lcdprintPGM("00");
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)retract_acceleration/100;
-          }
-          else
-          {
-            retract_acceleration= encoderpos*100;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<10) encoderpos=10;
-          if(encoderpos>990) encoderpos=990;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));lcdprintPGM("00");
-        }
-        
-      }break;
-       case ItemCM_xsteps://axis_steps_per_unit[i] = code_value();
-         {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_XSTEPS);
-          lcd.setCursor(11,line);lcd.print(ftostr52(axis_steps_per_unit[X_AXIS]));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)(axis_steps_per_unit[X_AXIS]*100.0);
-          }
-          else
-          {
-            float factor=float(encoderpos)/100.0/float(axis_steps_per_unit[X_AXIS]);
-            position[X_AXIS]=lround(position[X_AXIS]*factor);
-            //current_position[X_AXIS]*=factor;
-            axis_steps_per_unit[X_AXIS]= encoderpos/100.0;
-            encoderpos=activeline*lcdslow;
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<5) encoderpos=5;
-          if(encoderpos>999999) encoderpos=999999;
-          lcd.setCursor(11,line);lcd.print(ftostr52(encoderpos/100.0));
-        }
-        
-      }break;
-       case ItemCM_ysteps://axis_steps_per_unit[i] = code_value();
-         {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_YSTEPS);
-          lcd.setCursor(11,line);lcd.print(ftostr52(axis_steps_per_unit[Y_AXIS]));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)(axis_steps_per_unit[Y_AXIS]*100.0);
-          }
-          else
-          {
-            float factor=float(encoderpos)/100.0/float(axis_steps_per_unit[Y_AXIS]);
-            position[Y_AXIS]=lround(position[Y_AXIS]*factor);
-            //current_position[Y_AXIS]*=factor;
-            axis_steps_per_unit[Y_AXIS]= encoderpos/100.0;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<5) encoderpos=5;
-          if(encoderpos>999999) encoderpos=999999;
-          lcd.setCursor(11,line);lcd.print(ftostr52(encoderpos/100.0));
-        }
-        
-      }break;
-       case ItemCM_zsteps://axis_steps_per_unit[i] = code_value();
-         {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_ZSTEPS);
-          lcd.setCursor(11,line);lcd.print(ftostr52(axis_steps_per_unit[Z_AXIS]));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)(axis_steps_per_unit[Z_AXIS]*100.0);
-          }
-          else
-          {
-            float factor=float(encoderpos)/100.0/float(axis_steps_per_unit[Z_AXIS]);
-            position[Z_AXIS]=lround(position[Z_AXIS]*factor);
-            //current_position[Z_AXIS]*=factor;
-            axis_steps_per_unit[Z_AXIS]= encoderpos/100.0;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<5) encoderpos=5;
-          if(encoderpos>999999) encoderpos=999999;
-          lcd.setCursor(11,line);lcd.print(ftostr52(encoderpos/100.0));
-        }
-        
-      }break;
-      
-    case ItemCM_esteps://axis_steps_per_unit[i] = code_value();
-         {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_ESTEPS);
-          lcd.setCursor(11,line);lcd.print(ftostr52(axis_steps_per_unit[E_AXIS]));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)(axis_steps_per_unit[E_AXIS]*100.0);
-          }
-          else
-          {
-            float factor=float(encoderpos)/100.0/float(axis_steps_per_unit[E_AXIS]);
-            position[E_AXIS]=lround(position[E_AXIS]*factor);
-            //current_position[E_AXIS]*=factor;
-            axis_steps_per_unit[E_AXIS]= encoderpos/100.0;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<5) encoderpos=5;
-          if(encoderpos>999999) encoderpos=999999;
-          lcd.setCursor(11,line);lcd.print(ftostr52(encoderpos/100.0));
-        }
-        
-      }break; 
-    default:   
-      break;
-  }
-  line++;
- }
- updateActiveLines(ItemCM_esteps,encoderpos);
-}
-
-
-enum {
-  ItemR_exit,
-  ItemR_autoretract,
-  ItemR_retract_length,ItemR_retract_feedrate,ItemR_retract_zlift,
-  ItemR_unretract_length,ItemR_unretract_feedrate,
-  
-};
-
-
-
-void MainMenu::showControlRetract()
-{
-#ifdef FWRETRACT
- uint8_t line=0;
- clearIfNecessary();
- for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
- {
-  switch(i)
-  {
-    case ItemR_exit:
-      MENUITEM(  lcdprintPGM(MSG_CONTROL)  ,  BLOCK;status=Main_Control;beepshort(); ) ;
-      break;
-    
-      //float retract_length=2, retract_feedrate=1200, retract_zlift=0.4;
-  //float retract_recover_length=0, retract_recover_feedrate=500;
-      case ItemR_autoretract:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_AUTORETRACT);
-          lcd.setCursor(13,line);
-          if(autoretract_enabled)
-            lcdprintPGM(MSG_ON);
-          else
-            lcdprintPGM(MSG_OFF);
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          autoretract_enabled=!autoretract_enabled;
-          lcd.setCursor(13,line);
-          if(autoretract_enabled)
-            lcdprintPGM(MSG_ON);
-          else
-            lcdprintPGM(MSG_OFF);
-          BLOCK;
-        }
-        
-      }break;  
-    
-      case ItemR_retract_length:
-    {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_CONTROL_RETRACT);
-          lcd.setCursor(13,line);lcd.print(ftostr52(retract_length));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)(retract_length*100);
-          }
-          else
-          {
-            retract_length= encoderpos/100.;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<1) encoderpos=1;
-          if(encoderpos>990) encoderpos=990;
-          lcd.setCursor(13,line);lcd.print(ftostr52(encoderpos/100.));
-        }
-        
-      }break;
-      case ItemR_retract_feedrate:
-    {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_CONTROL_RETRACTF);
-          lcd.setCursor(13,line);lcd.print(itostr4(retract_feedrate));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)(retract_feedrate/5);
-          }
-          else
-          {
-            retract_feedrate= encoderpos*5.;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<1) encoderpos=1;
-          if(encoderpos>990) encoderpos=990;
-          lcd.setCursor(13,line);lcd.print(itostr4(encoderpos*5));
-        }
-        
-      }break;
-      case ItemR_retract_zlift://float retract_acceleration = 7000;
-    {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_CONTROL_RETRACT_ZLIFT);
-          lcd.setCursor(13,line);lcd.print(ftostr52(retract_zlift));;
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)(retract_zlift*10);
-          }
-          else
-          {
-            retract_zlift= encoderpos/10.;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>990) encoderpos=990;
-          lcd.setCursor(13,line);lcd.print(ftostr52(encoderpos/10.));
-        }
-        
-      }break;
-      case ItemR_unretract_length:
-    {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_CONTROL_RETRACT_RECOVER);
-          lcd.setCursor(13,line);lcd.print(ftostr52(retract_recover_length));;
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)(retract_recover_length*100);
-          }
-          else
-          {
-            retract_recover_length= encoderpos/100.;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>990) encoderpos=990;
-          lcd.setCursor(13,line);lcd.print(ftostr52(encoderpos/100.));
-        }
-        
-      }break;
-      
-      case ItemR_unretract_feedrate:
-    {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_CONTROL_RETRACT_RECOVERF);
-          lcd.setCursor(13,line);lcd.print(itostr4(retract_recover_feedrate));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(long)retract_recover_feedrate/5;
-          }
-          else
-          {
-            retract_recover_feedrate= encoderpos*5.;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<1) encoderpos=1;
-          if(encoderpos>990) encoderpos=990;
-          lcd.setCursor(13,line);lcd.print(itostr4(encoderpos*5));
-        }
-        
-      }break;
-    
-    default:   
-      break;
-  }
-  line++;
- }
- updateActiveLines(ItemR_unretract_feedrate,encoderpos);
-#endif
-}
-
-
-
-enum {
-  ItemC_exit,ItemC_temp,ItemC_move,
-#ifdef FWRETRACT
-  ItemC_rectract,
-#endif
-  ItemC_store, ItemC_load,ItemC_failsafe
-};
-
-void MainMenu::showControl()
-{
- uint8_t line=0;
- clearIfNecessary();
- for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
- {
-  switch(i)
-  {
-    case ItemC_exit:
-      MENUITEM(  lcdprintPGM(MSG_MAIN_WIDE)  ,  BLOCK;status=Main_Menu;beepshort(); ) ;
-      break;
-    case ItemC_temp:
-      MENUITEM(  lcdprintPGM(MSG_TEMPERATURE_WIDE)  ,  BLOCK;status=Sub_TempControl;beepshort(); ) ;
-      break;
-   case ItemC_move:
-      MENUITEM(  lcdprintPGM(MSG_MOTION_WIDE)  ,  BLOCK;status=Sub_MotionControl;beepshort(); ) ;
-      break;
-#ifdef FWRETRACT
-    case ItemC_rectract:
-      MENUITEM(  lcdprintPGM(MSG_RECTRACT_WIDE)  ,  BLOCK;status=Sub_RetractControl;beepshort(); ) ;
-      break;
-#endif
-    case ItemC_store:
-    {
-      if(force_lcd_update)
-      {
-        lcd.setCursor(0,line);lcdprintPGM(MSG_STORE_EPROM);
-      }
-      if((activeline==line) && CLICKED)
-      {
-        //enquecommand("M84");
-        beepshort();
-        BLOCK;
-        EEPROM_StoreSettings();
-      }
-    }break;
-    case ItemC_load:
-    {
-      if(force_lcd_update)
-      {
-        lcd.setCursor(0,line);lcdprintPGM(MSG_LOAD_EPROM);
-      }
-      if((activeline==line) && CLICKED)
-      {
-        //enquecommand("M84");
-        beepshort();
-        BLOCK;
-        EEPROM_RetrieveSettings();
-      }
-    }break;
-    case ItemC_failsafe:
-    {
-      if(force_lcd_update)
-      {
-        lcd.setCursor(0,line);lcdprintPGM(MSG_RESTORE_FAILSAFE);
-      }
-      if((activeline==line) && CLICKED)
-      {
-        //enquecommand("M84");
-        beepshort();
-        BLOCK;
-        EEPROM_RetrieveSettings(true);
-      }
-    }break;
-    default:   
-      break;
-  }
-  line++;
- }
- updateActiveLines(ItemC_failsafe,encoderpos);
-}
-
-
-
-
-
-void MainMenu::showSD()
-{
-#ifdef SDSUPPORT
- uint8_t line=0;
-
- clearIfNecessary();
- static uint8_t nrfiles=0;
- if(force_lcd_update)
- {
-  if(card.cardOK)
-  {
-    nrfiles=card.getnrfilenames();
-  }
-  else
-  {
-    nrfiles=0;
-    lineoffset=0;
-  }
- }
- bool enforceupdate=false;
- for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
- {
-  switch(i)
-  {
-    case 0:
-      MENUITEM(  lcdprintPGM(MSG_MAIN)  ,  BLOCK;status=Main_Menu;beepshort(); ) ;
-      break;
-//     case 1:
-//       {
-//         if(force_lcd_update)
-//         {
-//           lcd.setCursor(0,line);
-//            #ifdef CARDINSERTED
-//           if(CARDINSERTED)
-//           #else
-//           if(true)
-//           #endif
-//           {
-//             lcdprintPGM(" \004Refresh");
-//           }
-//           else
-//           {
-//             lcdprintPGM(" \004Insert Card");
-//           }
-//           
-//         }
-//         if((activeline==line) && CLICKED)
-//         {
-//           BLOCK;
-//           beepshort();
-//           card.initsd();
-//           force_lcd_update=true;
-//            nrfiles=card.getnrfilenames();
-//         }
-//       }break;
-    case 1:
-      MENUITEM(  lcd.print(" ");card.getWorkDirName();
-	  if(card.filename[0]=='/') lcdprintPGM(MSG_REFRESH);
-	  else {
-		  lcd.print("\005");
-		  lcd.print(card.filename);
-		  lcd.print("/..");
-			}  ,  
-	BLOCK;
-			if(SDCARDDETECT == -1) card.initsd();
-			card.updir();
-			enforceupdate=true;
-			lineoffset=0;
-			beepshort(); ) ;
-      
-      break;
-    default:
-    {
-      #define FIRSTITEM 2
-      if(i-FIRSTITEM<nrfiles)
-      {
-        if(force_lcd_update)
-        {
-          card.getfilename(i-FIRSTITEM);
-          //Serial.print("Filenr:");Serial.println(i-2);
-          lcd.setCursor(0,line);lcdprintPGM(" ");
-          if(card.filenameIsDir) lcd.print("\005");
-          if (card.longFilename[0])
-          {
-            card.longFilename[LCD_WIDTH-1] = '\0';
-            lcd.print(card.longFilename);
-          }
-          else
-          {
-            lcd.print(card.filename);
-          }
-        }
-        if((activeline==line) && CLICKED)
-        {
-          BLOCK
-          card.getfilename(i-FIRSTITEM);
-          if(card.filenameIsDir)
-          {
-            for(int8_t i=0;i<strlen(card.filename);i++)
-              card.filename[i]=tolower(card.filename[i]);
-            card.chdir(card.filename);
-            lineoffset=0;
-            enforceupdate=true;
-          }
-          else
-          {
-            char cmd[30];
-            for(int8_t i=0;i<strlen(card.filename);i++)
-              card.filename[i]=tolower(card.filename[i]);
-            sprintf(cmd,"M23 %s",card.filename);
-            //sprintf(cmd,"M115");
-            enquecommand(cmd);
-            enquecommand("M24");
-            beep(); 
-            status=Main_Status;
-            if (card.longFilename[0])
-            {
-              card.longFilename[LCD_WIDTH-1] = '\0';
-              lcd_status(card.longFilename);
-            }
-            else
-            {
-              lcd_status(card.filename);
-            }
-          }
-        } 
-      }
-      
-    }
-      break;
-  }
-  line++;
- }
- updateActiveLines(FIRSTITEM+nrfiles-1,encoderpos);
- if(enforceupdate)
- {
-   force_lcd_update=true;
-   enforceupdate=false;
- }
-#endif
-}
-
-
-enum {ItemM_watch, ItemM_prepare, ItemM_control, ItemM_file, ItemM_pause};
-void MainMenu::showMainMenu()
-{
-
-  #ifndef ULTIPANEL
-    force_lcd_update=false;
-  #endif
-  if(tune)
-  {
-    if(!(movesplanned() || IS_SD_PRINTING))
-    {
-      force_lcd_update=true;
-      tune=false;
-    }
-  }
-  else 
-  {
-    if(movesplanned() || IS_SD_PRINTING)
-    {
-      force_lcd_update=true;
-      tune=true;
-    }
-  } 
-  clearIfNecessary();
-  uint8_t line=0;
-  for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
-  {
-    switch(i)
-    { 
-      case ItemM_watch:
-        MENUITEM(  lcdprintPGM(MSG_WATCH)  ,  BLOCK;status=Main_Status;beepshort(); ) ;
-       break;
-      case ItemM_prepare:
-        MENUITEM(  if(!tune) lcdprintPGM(MSG_PREPARE);else  lcdprintPGM(MSG_TUNE); ,  BLOCK;status=Main_Prepare;beepshort(); ) ;
-      break;
-       
-      case ItemM_control:
-        MENUITEM(  lcdprintPGM(MSG_CONTROL_ARROW)  ,  BLOCK;status=Main_Control;beepshort(); ) ;
-      break;
-      #ifdef SDSUPPORT
-      case ItemM_file:    
-      {
-        if(force_lcd_update) 
-        {
-          lcd.setCursor(0,line);
-          #ifdef CARDINSERTED
-            if(CARDINSERTED)
-          #else
-            if(true)
-          #endif
-          {
-            if(card.sdprinting)
-              lcdprintPGM(MSG_STOP_PRINT);
-            else
-              lcdprintPGM(MSG_CARD_MENU);
-          }
-          else
-          {
-           lcdprintPGM(MSG_NO_CARD); 
-          }
-        }
-        #ifdef CARDINSERTED
-          if(CARDINSERTED)
-        #endif
-        if((activeline==line)&&CLICKED)
-        {
-          card.printingHasFinished();
-          BLOCK;
-          status=Main_SD;
-          beepshort();
-        }
-      }break;
-        case ItemM_pause:
-        {
-            if(force_lcd_update)
-            {
-                lcd.setCursor(0,line);
-#ifdef CARDINSERTED
-                if(CARDINSERTED)
-#else
-                    if(true)
-#endif
-                    {
-                        if(card.sdprinting)
-                            lcdprintPGM(MSG_PAUSE_PRINT);
-                        else
-                            lcdprintPGM(MSG_RESUME_PRINT);
-                    }
-                    else
-                    {
-                        //lcdprintPGM(MSG_NO_CARD);
-                    }
-            }
-#ifdef CARDINSERTED
-            if(CARDINSERTED)
-#endif
-                if((activeline==line) && CLICKED)
-                {
-                    if(card.sdprinting)
-                    {
-                        card.pauseSDPrint();
-                        beepshort();
-                        status = Main_Status;
-                    }
-                    else
-                    {
-                        card.startFileprint();
-                        starttime=millis();
-                        beepshort();
-                        status = Main_Status;
-                    }
-                }
-        }break;
-      #else
-      case ItemM_file:
-        break;
-        case ItemM_pause:
-            break;
-      #endif
-      default:
-        SERIAL_ERROR_START;
-        SERIAL_ERRORLNPGM(MSG_SERIAL_ERROR_MENU_STRUCTURE);
-      break;
-    }
-    line++;
-  }
-    
-    uint8_t numberOfLines = 4;
-#ifdef SDSUPPORT
-    numberOfLines = 4;
-#else
-    numberOfLines = 3;
-#endif
-    updateActiveLines(numberOfLines,encoderpos);
-}
-
-void MainMenu::update()
-{
-  static MainStatus oldstatus=Main_Menu;  //init automatically causes foce_lcd_update=true
-  static long timeoutToStatus=0;
-  static bool oldcardstatus=false;
-  #ifdef CARDINSERTED
-    if((CARDINSERTED != oldcardstatus))
-    {
-      force_lcd_update=true;
-      oldcardstatus=CARDINSERTED;
-      lcd_init(); // to maybe revive the lcd if static electricty killed it.
-      //Serial.println("echo: SD CHANGE");
-      if(CARDINSERTED)
-      {
-        card.initsd();
-        LCD_MESSAGEPGM(MSG_SD_INSERTED);
-      }
-      else
-      {
-        card.release();
-        LCD_MESSAGEPGM(MSG_SD_REMOVED);
-      }
-    }
-  #endif
- 
-  if(status!=oldstatus)
-  {
-    force_lcd_update=true;
-    encoderpos=0;
-    lineoffset=0;
-    
-    oldstatus=status;
-  }
-  if( (encoderpos!=lastencoderpos) || CLICKED)
-    timeoutToStatus=millis()+STATUSTIMEOUT;
-
-  switch(status)
-  { 
-      case Main_Status: 
-      {  
-        showStatus();
-        if(CLICKED)
-        {
-           linechanging=false;
-           BLOCK
-           status=Main_Menu;
-           timeoutToStatus=millis()+STATUSTIMEOUT;
-        }
-      }break;
-      case Main_Menu: 
-      {
-        showMainMenu();
-        linechanging=false;
-      }break;
-      case Main_Prepare: 
-      {
-        if(tune)
-        {
-          showTune();
-        }
-        else
-        {
-          showPrepare(); 
-        }
-      }break;
-      case Sub_PrepareMove:
-      {        
-            showAxisMove();
-      }break;
-      case Main_Control:
-      {
-        showControl(); 
-      }break;
-      case Sub_MotionControl:
-      {
-        showControlMotion(); 
-      }break;
-      case Sub_RetractControl:
-      {
-        showControlRetract(); 
-      }break;
-      case Sub_TempControl:
-      {
-        showControlTemp(); 
-      }break;
-      case Main_SD: 
-      {
-        showSD();
-      }break;
-	  case Sub_PreheatPLASettings: 
-      {
-        showPLAsettings();
-      }break;
-	  case Sub_PreheatABSSettings: 
-      {
-        showABSsettings();
-      }break;
-  }
-  
-  if(timeoutToStatus<millis())
-    status=Main_Status;
-  //force_lcd_update=false;
-  lastencoderpos=encoderpos;
-}
-
-enum {
-	ItemPLAPreHeat_Exit, 
-	ItemPLAPreHeat_set_PLA_FanSpeed, 
-	ItemPLAPreHeat_set_nozzle, 
-	ItemPLAPreHeat_set_HPB,
-	ItemPLAPreHeat_Store_Eprom
-	};
-  
-void MainMenu::showPLAsettings()
-{
-#ifdef ULTIPANEL
- uint8_t line=0;
- clearIfNecessary();
- for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
- {
-  switch(i)
-  {
-
-	case ItemPLAPreHeat_Exit:
-      MENUITEM(  lcdprintPGM(MSG_TEMPERATURE_RTN)  ,  BLOCK;status=Sub_TempControl;beepshort(); ) ;
-      break;
-
-    case ItemPLAPreHeat_set_PLA_FanSpeed:
-       {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_FAN_SPEED);
-          lcd.setCursor(13,line);lcd.print(ftostr3(plaPreheatFanSpeed));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED) 
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-			  encoderpos=plaPreheatFanSpeed;
-          }
-          else
-          {
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>255) encoderpos=255;
-          plaPreheatFanSpeed=encoderpos;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-      }break;
-
-    case ItemPLAPreHeat_set_nozzle:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_NOZZLE);
-          lcd.setCursor(13,line);lcd.print(ftostr3(plaPreheatHotendTemp));
-        } 
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=plaPreheatHotendTemp;
-          }
-          else
-          {
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>260) encoderpos=260;
-		  plaPreheatHotendTemp = encoderpos;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-      }break;
-
-    case ItemPLAPreHeat_set_HPB:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_BED);
-          lcd.setCursor(13,line);lcd.print(ftostr3(plaPreheatHPBTemp));
-        } 
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=plaPreheatHPBTemp;
-          }
-          else
-          {
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>250) encoderpos=150;
-		  plaPreheatHPBTemp = encoderpos;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-      }break;
-	case ItemPLAPreHeat_Store_Eprom:
-    {
-      if(force_lcd_update)
-      {
-        lcd.setCursor(0,line);lcdprintPGM(MSG_STORE_EPROM);
-      }
-      if((activeline==line) && CLICKED)
-      {
-        //enquecommand("M84");
-        beepshort();
-        BLOCK;
-        EEPROM_StoreSettings();
-      }
-    }break;
-      default:   
-      break;
-  }
-  line++;
- }
- updateActiveLines(ItemPLAPreHeat_Store_Eprom,encoderpos);
-#endif
-}
-
-enum {
-	ItemABSPreHeat_Exit, 
-	ItemABSPreHeat_set_FanSpeed, 
-	ItemABSPreHeat_set_nozzle, 
-	ItemABSPreHeat_set_HPB,
-	ItemABSPreHeat_Store_Eprom
-	};
-
-void MainMenu::showABSsettings()
-{
-#ifdef ULTIPANEL
- uint8_t line=0;
- clearIfNecessary();
- for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
- {
-  switch(i)
-  {
-
-	case ItemABSPreHeat_Exit:
-      MENUITEM(  lcdprintPGM(MSG_TEMPERATURE_RTN)  ,  BLOCK;status=Sub_TempControl;beepshort(); ) ;
-      break;
-
-    case ItemABSPreHeat_set_FanSpeed:
-       {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_FAN_SPEED);
-          lcd.setCursor(13,line);lcd.print(ftostr3(absPreheatFanSpeed));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED) 
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-			  encoderpos=absPreheatFanSpeed;
-          }
-          else
-          {
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>255) encoderpos=255;
-          absPreheatFanSpeed=encoderpos;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-      }break;
-
-    case ItemABSPreHeat_set_nozzle:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_NOZZLE);
-          lcd.setCursor(13,line);lcd.print(ftostr3(absPreheatHotendTemp));
-        } 
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=absPreheatHotendTemp;
-          }
-          else
-          {
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>260) encoderpos=260;
-		  absPreheatHotendTemp = encoderpos;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-      }break;
-
-    case ItemABSPreHeat_set_HPB:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(MSG_BED);
-          lcd.setCursor(13,line);lcd.print(ftostr3(absPreheatHPBTemp));
-        } 
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=absPreheatHPBTemp;
-          }
-          else
-          {
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>250) encoderpos=150;
-		  absPreheatHPBTemp = encoderpos;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-      }break;
-	case ItemABSPreHeat_Store_Eprom:
-    {
-      if(force_lcd_update)
-      {
-        lcd.setCursor(0,line);lcdprintPGM(MSG_STORE_EPROM);
-      }
-      if((activeline==line) && CLICKED)
-      {
-        //enquecommand("M84");
-        beepshort();
-        BLOCK;
-        EEPROM_StoreSettings();
-      }
-    }break;
-      default:   
-      break;
-  }
-  line++;
- }
- updateActiveLines(ItemABSPreHeat_Store_Eprom,encoderpos);
-#endif
-}
-
-//**********************************************************************************************************
-//  convert float to string with +123.4 format
-char *ftostr3(const float &x)
-{
-  //sprintf(conv,"%5.1f",x);
-  int xx=x;
-  conv[0]=(xx/100)%10+'0';
-  conv[1]=(xx/10)%10+'0';
-  conv[2]=(xx)%10+'0';
-  conv[3]=0;
-  return conv;
-}
-
-char *itostr2(const uint8_t &x)
-{
-  //sprintf(conv,"%5.1f",x);
-  int xx=x;
-  conv[0]=(xx/10)%10+'0';
-  conv[1]=(xx)%10+'0';
-  conv[2]=0;
-  return conv;
-}
-
-//  convert float to string with +123.4 format
-char *ftostr31(const float &x)
-{
-  int xx=x*10;
-  conv[0]=(xx>=0)?'+':'-';
-  xx=abs(xx);
-  conv[1]=(xx/1000)%10+'0';
-  conv[2]=(xx/100)%10+'0';
-  conv[3]=(xx/10)%10+'0';
-  conv[4]='.';
-  conv[5]=(xx)%10+'0';
-  conv[6]=0;
-  return conv;
-}
-
-char *ftostr32(const float &x)
-{
-  long xx=x*100;
-  conv[0]=(xx>=0)?'+':'-';
-  xx=abs(xx);
-  conv[1]=(xx/100)%10+'0';
-  conv[2]='.';
-  conv[3]=(xx/10)%10+'0';
-  conv[4]=(xx)%10+'0';
-  conv[6]=0;
-  return conv;
-}
-
-char *itostr31(const int &xx)
-{
-  conv[0]=(xx>=0)?'+':'-';
-  conv[1]=(xx/1000)%10+'0';
-  conv[2]=(xx/100)%10+'0';
-  conv[3]=(xx/10)%10+'0';
-  conv[4]='.';
-  conv[5]=(xx)%10+'0';
-  conv[6]=0;
-  return conv;
-}
-
-char *itostr3(const int &xx)
-{
-  conv[0]=(xx/100)%10+'0';
-  conv[1]=(xx/10)%10+'0';
-  conv[2]=(xx)%10+'0';
-  conv[3]=0;
-  return conv;
-}
-
-char *itostr4(const int &xx)
-{
-  conv[0]=(xx/1000)%10+'0';
-  conv[1]=(xx/100)%10+'0';
-  conv[2]=(xx/10)%10+'0';
-  conv[3]=(xx)%10+'0';
-  conv[4]=0;
-  return conv;
-}
-
-//  convert float to string with +1234.5 format
-char *ftostr51(const float &x)
-{
-  long xx=x*10;
-  conv[0]=(xx>=0)?'+':'-';
-  xx=abs(xx);
-  conv[1]=(xx/10000)%10+'0';
-  conv[2]=(xx/1000)%10+'0';
-  conv[3]=(xx/100)%10+'0';
-  conv[4]=(xx/10)%10+'0';
-  conv[5]='.';
-  conv[6]=(xx)%10+'0';
-  conv[7]=0;
-  return conv;
-}
-
-//  convert float to string with +123.45 format
-char *ftostr52(const float &x)
-{
-  long xx=x*100;
-  conv[0]=(xx>=0)?'+':'-';
-  xx=abs(xx);
-  conv[1]=(xx/10000)%10+'0';
-  conv[2]=(xx/1000)%10+'0';
-  conv[3]=(xx/100)%10+'0';
-  conv[4]='.';
-  conv[5]=(xx/10)%10+'0';
-  conv[6]=(xx)%10+'0';
-  conv[7]=0;
-  return conv;
-}
-
-#endif //ULTRA_LCD
-
-
diff --git a/Marlin/ultralcd_implementation_hitachi_HD44780.h b/Marlin/ultralcd_implementation_hitachi_HD44780.h
new file mode 100644
index 0000000..58d75bd
--- /dev/null
+++ b/Marlin/ultralcd_implementation_hitachi_HD44780.h
@@ -0,0 +1,476 @@
+#ifndef ULTRA_LCD_IMPLEMENTATION_HITACHI_HD44780_H
+#define ULTRA_LCD_IMPLEMENTATION_HITACHI_HD44780_H
+
+/**
+* Implementation of the LCD display routines for a hitachi HD44780 display. These are common LCD character displays.
+* When selecting the rusian language, a slightly different LCD implementation is used to handle UTF8 characters.
+**/
+
+#if LANGUAGE_CHOICE == 6
+#include "LiquidCrystalRus.h"
+#define LCD_CLASS LiquidCrystalRus
+#else
+#include <LiquidCrystal.h>
+#define LCD_CLASS LiquidCrystal
+#endif
+
+/* Custom characters defined in the first 8 characters of the LCD */
+#define LCD_STR_BEDTEMP     "\x00"
+#define LCD_STR_DEGREE      "\x01"
+#define LCD_STR_THERMOMETER "\x02"
+#define LCD_STR_UPLEVEL     "\x03"
+#define LCD_STR_REFRESH     "\x04"
+#define LCD_STR_FOLDER      "\x05"
+#define LCD_STR_FEEDRATE    "\x06"
+#define LCD_STR_CLOCK       "\x07"
+#define LCD_STR_ARROW_RIGHT "\x7E"  /* from the default character set */
+
+LCD_CLASS lcd(LCD_PINS_RS, LCD_PINS_ENABLE, LCD_PINS_D4, LCD_PINS_D5,LCD_PINS_D6,LCD_PINS_D7);  //RS,Enable,D4,D5,D6,D7
+static void lcd_implementation_init()
+{
+    byte bedTemp[8] =
+    {
+        B00000,
+        B11111,
+        B10101,
+        B10001,
+        B10101,
+        B11111,
+        B00000,
+        B00000
+    }; //thanks Sonny Mounicou
+    byte degree[8] =
+    {
+        B01100,
+        B10010,
+        B10010,
+        B01100,
+        B00000,
+        B00000,
+        B00000,
+        B00000
+    };
+    byte thermometer[8] =
+    {
+        B00100,
+        B01010,
+        B01010,
+        B01010,
+        B01010,
+        B10001,
+        B10001,
+        B01110
+    };
+    byte uplevel[8]={
+        B00100,
+        B01110,
+        B11111,
+        B00100,
+        B11100,
+        B00000,
+        B00000,
+        B00000
+    }; //thanks joris
+    byte refresh[8]={
+        B00000,
+        B00110,
+        B11001,
+        B11000,
+        B00011,
+        B10011,
+        B01100,
+        B00000,
+    }; //thanks joris
+    byte folder [8]={
+        B00000,
+        B11100,
+        B11111,
+        B10001,
+        B10001,
+        B11111,
+        B00000,
+        B00000
+    }; //thanks joris
+    byte feedrate [8]={
+        B11100,
+        B10000,
+        B11000,
+        B10111,
+        B00101,
+        B00110,
+        B00101,
+        B00000
+    }; //thanks Sonny Mounicou
+    byte clock [8]={
+        B00000,
+        B01110,
+        B10011,
+        B10101,
+        B10001,
+        B01110,
+        B00000,
+        B00000
+    }; //thanks Sonny Mounicou
+    lcd.begin(LCD_WIDTH, LCD_HEIGHT);
+    lcd.createChar(LCD_STR_BEDTEMP[0], bedTemp);
+    lcd.createChar(LCD_STR_DEGREE[0], degree);
+    lcd.createChar(LCD_STR_THERMOMETER[0], thermometer);
+    lcd.createChar(LCD_STR_UPLEVEL[0], uplevel);
+    lcd.createChar(LCD_STR_REFRESH[0], refresh);
+    lcd.createChar(LCD_STR_FOLDER[0], folder);
+    lcd.createChar(LCD_STR_FEEDRATE[0], feedrate);
+    lcd.createChar(LCD_STR_CLOCK[0], clock);
+    lcd.clear();
+}
+static void lcd_implementation_clear()
+{
+    lcd.clear();
+}
+/* Arduino < 1.0.0 is missing a function to print PROGMEM strings, so we need to implement our own */
+static void lcd_printPGM(const char* str)
+{
+    char c;
+    while((c = pgm_read_byte(str++)) != '\0')
+    {
+        lcd.write(c);
+    }
+}
+/*
+Possible status screens:
+16x2   |0123456789012345|
+       |000/000 B000/000|
+       |Status line.....|
+
+16x4   |0123456789012345|
+       |000/000 B000/000|
+       |SD100%    Z000.0|
+       |F100%     T--:--|
+       |Status line.....|
+
+20x2   |01234567890123456789|
+       |T000/000D B000/000D |
+       |Status line.........|
+
+20x4   |01234567890123456789|
+       |T000/000D B000/000D |
+       |X+000.0 Y+000.0 Z+000.0|
+       |F100%  SD100% T--:--|
+       |Status line.........|
+
+20x4   |01234567890123456789|
+       |T000/000D B000/000D |
+       |T000/000D     Z000.0|
+       |F100%  SD100% T--:--|
+       |Status line.........|
+*/
+static void lcd_implementation_status_screen()
+{
+    int tHotend=int(degHotend(0) + 0.5);
+    int tTarget=int(degTargetHotend(0) + 0.5);
+
+#if LCD_WIDTH < 20
+    lcd.setCursor(0, 0);
+    lcd.print(itostr3(tHotend));
+    lcd.print('/');
+    lcd.print(itostr3left(tTarget));
+
+# if EXTRUDERS > 1 || TEMP_SENSOR_BED != 0
+    //If we have an 2nd extruder or heated bed, show that in the top right corner
+    lcd.setCursor(8, 0);
+#  if EXTRUDERS > 1
+    tHotend = int(degHotend(1) + 0.5);
+    tTarget = int(degTargetHotend(1) + 0.5);
+    lcd.print(LCD_STR_THERMOMETER[0]);
+#  else//Heated bed
+    tHotend=int(degBed() + 0.5);
+    tTarget=int(degTargetBed() + 0.5);
+    lcd.print(LCD_STR_BEDTEMP[0]);
+#  endif
+    lcd.print(itostr3(tHotend));
+    lcd.print('/');
+    lcd.print(itostr3left(tTarget));
+# endif//EXTRUDERS > 1 || TEMP_SENSOR_BED != 0
+
+#else//LCD_WIDTH > 19
+    lcd.setCursor(0, 0);
+    lcd.print(LCD_STR_THERMOMETER[0]);
+    lcd.print(itostr3(tHotend));
+    lcd.print('/');
+    lcd.print(itostr3left(tTarget));
+    lcd_printPGM(PSTR(LCD_STR_DEGREE " "));
+    if (tTarget < 10)
+        lcd.print(' ');
+
+# if EXTRUDERS > 1 || TEMP_SENSOR_BED != 0
+    //If we have an 2nd extruder or heated bed, show that in the top right corner
+    lcd.setCursor(10, 0);
+#  if EXTRUDERS > 1
+    tHotend = int(degHotend(1) + 0.5);
+    tTarget = int(degTargetHotend(1) + 0.5);
+    lcd.print(LCD_STR_THERMOMETER[0]);
+#  else//Heated bed
+    tHotend=int(degBed() + 0.5);
+    tTarget=int(degTargetBed() + 0.5);
+    lcd.print(LCD_STR_BEDTEMP[0]);
+#  endif
+    lcd.print(itostr3(tHotend));
+    lcd.print('/');
+    lcd.print(itostr3left(tTarget));
+    lcd_printPGM(PSTR(LCD_STR_DEGREE " "));
+    if (tTarget < 10)
+        lcd.print(' ');
+# endif//EXTRUDERS > 1 || TEMP_SENSOR_BED != 0
+#endif//LCD_WIDTH > 19
+
+#if LCD_HEIGHT > 2
+//Lines 2 for 4 line LCD
+# if LCD_WIDTH < 20
+#  ifdef SDSUPPORT
+    lcd.setCursor(0, 2);
+    lcd_printPGM(PSTR("SD"));
+    if (IS_SD_PRINTING)
+        lcd.print(itostr3(card.percentDone()));
+    else
+        lcd_printPGM(PSTR("---"));
+    lcd.print('%');
+#  endif//SDSUPPORT
+# else//LCD_WIDTH > 19
+#  if EXTRUDERS > 1 && TEMP_SENSOR_BED != 0
+    //If we both have a 2nd extruder and a heated bed, show the heated bed temp on the 2nd line on the left, as the first line is filled with extruder temps
+    tHotend=int(degBed() + 0.5);
+    tTarget=int(degTargetBed() + 0.5);
+
+    lcd.setCursor(0, 1);
+    lcd.print(LCD_STR_BEDTEMP[0]);
+    lcd.print(itostr3(tHotend));
+    lcd.print('/');
+    lcd.print(itostr3left(tTarget));
+    lcd_printPGM(PSTR(LCD_STR_DEGREE " "));
+    if (tTarget < 10)
+        lcd.print(' ');
+#  else
+    lcd.setCursor(0,1);
+    lcd.print('X');
+    lcd.print(ftostr3(current_position[X_AXIS]));
+    lcd_printPGM(PSTR(" Y"));
+    lcd.print(ftostr3(current_position[Y_AXIS]));
+#  endif//EXTRUDERS > 1 || TEMP_SENSOR_BED != 0
+# endif//LCD_WIDTH > 19
+    lcd.setCursor(LCD_WIDTH - 8, 1);
+    lcd.print('Z');
+    lcd.print(ftostr32(current_position[Z_AXIS]));
+#endif//LCD_HEIGHT > 2
+
+#if LCD_HEIGHT > 3
+    lcd.setCursor(0, 2);
+    lcd.print(LCD_STR_FEEDRATE[0]);
+    lcd.print(itostr3(feedmultiply));
+    lcd.print('%');
+# if LCD_WIDTH > 19
+#  ifdef SDSUPPORT
+    lcd.setCursor(7, 2);
+    lcd_printPGM(PSTR("SD"));
+    if (IS_SD_PRINTING)
+        lcd.print(itostr3(card.percentDone()));
+    else
+        lcd_printPGM(PSTR("---"));
+    lcd.print('%');
+#  endif//SDSUPPORT
+# endif//LCD_WIDTH > 19
+    lcd.setCursor(LCD_WIDTH - 6, 2);
+    lcd.print(LCD_STR_CLOCK[0]);
+    if(starttime != 0)
+    {
+        uint16_t time = millis()/60000 - starttime/60000;
+        lcd.print(itostr2(time/60));
+        lcd.print(':');
+        lcd.print(itostr2(time%60));
+    }else{
+        lcd_printPGM(PSTR("--:--"));
+    }
+#endif
+
+    //Status message line on the last line
+    lcd.setCursor(0, LCD_HEIGHT - 1);
+    lcd.print(lcd_status_message);
+}
+static void lcd_implementation_drawmenu_generic(uint8_t row, const char* pstr, char pre_char, char post_char)
+{
+    char c;
+    uint8_t n = LCD_WIDTH - 1 - 2;
+    lcd.setCursor(0, row);
+    lcd.print(pre_char);
+    while((c = pgm_read_byte(pstr)) != '\0')
+    {
+        lcd.print(c);
+        pstr++;
+        n--;
+    }
+    while(n--)
+        lcd.print(' ');
+    lcd.print(post_char);
+    lcd.print(' ');
+}
+static void lcd_implementation_drawmenu_setting_edit_generic(uint8_t row, const char* pstr, char pre_char, char* data)
+{
+    char c;
+    uint8_t n = LCD_WIDTH - 1 - 2 - strlen(data);
+    lcd.setCursor(0, row);
+    lcd.print(pre_char);
+    while((c = pgm_read_byte(pstr)) != '\0')
+    {
+        lcd.print(c);
+        pstr++;
+        n--;
+    }
+    lcd.print(':');
+    while(n--)
+        lcd.print(' ');
+    lcd.print(data);
+}
+static void lcd_implementation_drawmenu_setting_edit_generic_P(uint8_t row, const char* pstr, char pre_char, const char* data)
+{
+    char c;
+    uint8_t n = LCD_WIDTH - 1 - 2 - strlen_P(data);
+    lcd.setCursor(0, row);
+    lcd.print(pre_char);
+    while((c = pgm_read_byte(pstr)) != '\0')
+    {
+        lcd.print(c);
+        pstr++;
+        n--;
+    }
+    lcd.print(':');
+    while(n--)
+        lcd.print(' ');
+    lcd_printPGM(data);
+}
+#define lcd_implementation_drawmenu_setting_edit_int3_selected(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '>', itostr3(*(data)))
+#define lcd_implementation_drawmenu_setting_edit_int3(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', itostr3(*(data)))
+#define lcd_implementation_drawmenu_setting_edit_float3_selected(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '>', ftostr3(*(data)))
+#define lcd_implementation_drawmenu_setting_edit_float3(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', ftostr3(*(data)))
+#define lcd_implementation_drawmenu_setting_edit_float32_selected(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '>', ftostr32(*(data)))
+#define lcd_implementation_drawmenu_setting_edit_float32(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', ftostr32(*(data)))
+#define lcd_implementation_drawmenu_setting_edit_float5_selected(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '>', ftostr5(*(data)))
+#define lcd_implementation_drawmenu_setting_edit_float5(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', ftostr5(*(data)))
+#define lcd_implementation_drawmenu_setting_edit_float52_selected(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '>', ftostr52(*(data)))
+#define lcd_implementation_drawmenu_setting_edit_float52(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', ftostr52(*(data)))
+#define lcd_implementation_drawmenu_setting_edit_float51_selected(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '>', ftostr51(*(data)))
+#define lcd_implementation_drawmenu_setting_edit_float51(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', ftostr51(*(data)))
+#define lcd_implementation_drawmenu_setting_edit_long5_selected(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '>', ftostr5(*(data)))
+#define lcd_implementation_drawmenu_setting_edit_long5(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', ftostr5(*(data)))
+#define lcd_implementation_drawmenu_setting_edit_bool_selected(row, pstr, pstr2, data) lcd_implementation_drawmenu_setting_edit_generic_P(row, pstr, '>', (*(data))?PSTR(MSG_ON):PSTR(MSG_OFF))
+#define lcd_implementation_drawmenu_setting_edit_bool(row, pstr, pstr2, data) lcd_implementation_drawmenu_setting_edit_generic_P(row, pstr, ' ', (*(data))?PSTR(MSG_ON):PSTR(MSG_OFF))
+void lcd_implementation_drawedit(const char* pstr, char* value)
+{
+    lcd.setCursor(1, 1);
+    lcd_printPGM(pstr);
+    lcd.print(':');
+    lcd.setCursor(19 - strlen(value), 1);
+    lcd.print(value);
+}
+static void lcd_implementation_drawmenu_sdfile_selected(uint8_t row, const char* pstr, const char* filename, char* longFilename)
+{
+    char c;
+    uint8_t n = LCD_WIDTH - 1;
+    lcd.setCursor(0, row);
+    lcd.print('>');
+    if (longFilename[0] != '\0')
+    {
+        filename = longFilename;
+        longFilename[LCD_WIDTH-1] = '\0';
+    }
+    while((c = *filename) != '\0')
+    {
+        lcd.print(c);
+        filename++;
+        n--;
+    }
+    while(n--)
+        lcd.print(' ');
+}
+static void lcd_implementation_drawmenu_sdfile(uint8_t row, const char* pstr, const char* filename, char* longFilename)
+{
+    char c;
+    uint8_t n = LCD_WIDTH - 1;
+    lcd.setCursor(0, row);
+    lcd.print(' ');
+    if (longFilename[0] != '\0')
+    {
+        filename = longFilename;
+        longFilename[LCD_WIDTH-1] = '\0';
+    }
+    while((c = *filename) != '\0')
+    {
+        lcd.print(c);
+        filename++;
+        n--;
+    }
+    while(n--)
+        lcd.print(' ');
+}
+static void lcd_implementation_drawmenu_sddirectory_selected(uint8_t row, const char* pstr, const char* filename, char* longFilename)
+{
+    char c;
+    uint8_t n = LCD_WIDTH - 2;
+    lcd.setCursor(0, row);
+    lcd.print('>');
+    lcd.print(LCD_STR_FOLDER[0]);
+    if (longFilename[0] != '\0')
+    {
+        filename = longFilename;
+        longFilename[LCD_WIDTH-2] = '\0';
+    }
+    while((c = *filename) != '\0')
+    {
+        lcd.print(c);
+        filename++;
+        n--;
+    }
+    while(n--)
+        lcd.print(' ');
+}
+static void lcd_implementation_drawmenu_sddirectory(uint8_t row, const char* pstr, const char* filename, char* longFilename)
+{
+    char c;
+    uint8_t n = LCD_WIDTH - 2;
+    lcd.setCursor(0, row);
+    lcd.print(' ');
+    lcd.print(LCD_STR_FOLDER[0]);
+    if (longFilename[0] != '\0')
+    {
+        filename = longFilename;
+        longFilename[LCD_WIDTH-2] = '\0';
+    }
+    while((c = *filename) != '\0')
+    {
+        lcd.print(c);
+        filename++;
+        n--;
+    }
+    while(n--)
+        lcd.print(' ');
+}
+#define lcd_implementation_drawmenu_back_selected(row, pstr, data) lcd_implementation_drawmenu_generic(row, pstr, LCD_STR_UPLEVEL[0], LCD_STR_UPLEVEL[0])
+#define lcd_implementation_drawmenu_back(row, pstr, data) lcd_implementation_drawmenu_generic(row, pstr, ' ', LCD_STR_UPLEVEL[0])
+#define lcd_implementation_drawmenu_submenu_selected(row, pstr, data) lcd_implementation_drawmenu_generic(row, pstr, '>', LCD_STR_ARROW_RIGHT[0])
+#define lcd_implementation_drawmenu_submenu(row, pstr, data) lcd_implementation_drawmenu_generic(row, pstr, ' ', LCD_STR_ARROW_RIGHT[0])
+#define lcd_implementation_drawmenu_gcode_selected(row, pstr, gcode) lcd_implementation_drawmenu_generic(row, pstr, '>', ' ')
+#define lcd_implementation_drawmenu_gcode(row, pstr, gcode) lcd_implementation_drawmenu_generic(row, pstr, ' ', ' ')
+#define lcd_implementation_drawmenu_function_selected(row, pstr, data) lcd_implementation_drawmenu_generic(row, pstr, '>', ' ')
+#define lcd_implementation_drawmenu_function(row, pstr, data) lcd_implementation_drawmenu_generic(row, pstr, ' ', ' ')
+
+static void lcd_implementation_quick_feedback()
+{
+#if BEEPER > -1
+    SET_OUTPUT(BEEPER);
+    for(int8_t i=0;i<10;i++)
+    {
+		WRITE(BEEPER,HIGH);
+		delay(3);
+		WRITE(BEEPER,LOW);
+		delay(3);
+    }
+#endif
+}
+#endif//ULTRA_LCD_IMPLEMENTATION_HITACHI_HD44780_H
diff --git a/Marlin/watchdog.cpp b/Marlin/watchdog.cpp
new file mode 100644
index 0000000..b378ca7
--- /dev/null
+++ b/Marlin/watchdog.cpp
@@ -0,0 +1,56 @@
+#include "Marlin.h"
+
+#ifdef USE_WATCHDOG
+#include <avr/wdt.h>
+
+#include "watchdog.h"
+#include "ultralcd.h"
+
+//===========================================================================
+//=============================private variables  ============================
+//===========================================================================
+
+//===========================================================================
+//=============================functinos         ============================
+//===========================================================================
+
+
+/// intialise watch dog with a 4 sec interrupt time
+void watchdog_init()
+{
+#ifdef WATCHDOG_RESET_MANUAL
+    //We enable the watchdog timer, but only for the interrupt.
+    //Take care, as this requires the correct order of operation, with interrupts disabled. See the datasheet of any AVR chip for details.
+    wdt_reset();
+    _WD_CONTROL_REG = _BV(_WD_CHANGE_BIT) | _BV(WDE);
+    _WD_CONTROL_REG = _BV(WDIE) | WDTO_4S;
+#else
+    wdt_enable(WDTO_4S);
+#endif
+}
+
+/// reset watchdog. MUST be called every 1s after init or avr will reset.
+void watchdog_reset() 
+{
+    wdt_reset();
+}
+
+//===========================================================================
+//=============================ISR               ============================
+//===========================================================================
+
+//Watchdog timer interrupt, called if main program blocks >1sec and manual reset is enabled.
+#ifdef WATCHDOG_RESET_MANUAL
+ISR(WDT_vect)
+{ 
+    //TODO: This message gets overwritten by the kill() call
+    LCD_ALERTMESSAGEPGM("ERR:Please Reset");//16 characters so it fits on a 16x2 display
+    lcd_update();
+    SERIAL_ERROR_START;
+    SERIAL_ERRORLNPGM("Something is wrong, please turn off the printer.");
+    kill(); //kill blocks
+    while(1); //wait for user or serial reset
+}
+#endif//RESET_MANUAL
+
+#endif//USE_WATCHDOG
diff --git a/Marlin/watchdog.h b/Marlin/watchdog.h
index 937379b..7f78453 100644
--- a/Marlin/watchdog.h
+++ b/Marlin/watchdog.h
@@ -1,16 +1,17 @@
 #ifndef WATCHDOG_H
 #define WATCHDOG_H
+
 #include "Marlin.h"
-#ifdef USE_WATCHDOG
 
+#ifdef USE_WATCHDOG
   // intialise watch dog with a 1 sec interrupt time
-  void wd_init();
-  // pad the dog/reset watchdog. MUST be called at least every second after the first wd_init or avr will go into emergency procedures..
-  void wd_reset();
-
+  void watchdog_init();
+  // pad the dog/reset watchdog. MUST be called at least every second after the first watchdog_init or avr will go into emergency procedures..
+  void watchdog_reset();
 #else
-  FORCE_INLINE void wd_init() {};
-  FORCE_INLINE void wd_reset() {};
+  //If we do not have a watchdog, then we can have empty functions which are optimized away.
+  FORCE_INLINE void watchdog_init() {};
+  FORCE_INLINE void watchdog_reset() {};
 #endif
 
 #endif
diff --git a/Marlin/watchdog.pde b/Marlin/watchdog.pde
deleted file mode 100644
index 356e374..0000000
--- a/Marlin/watchdog.pde
+++ /dev/null
@@ -1,63 +0,0 @@
-#ifdef USE_WATCHDOG
-#include "Marlin.h"
-#include "watchdog.h"
-
-//===========================================================================
-//=============================private variables  ============================
-//===========================================================================
-
-static volatile uint8_t timeout_seconds=0;
-
-void(* ctrlaltdelete) (void) = 0; //does not work on my atmega2560
-
-//===========================================================================
-//=============================functinos         ============================
-//===========================================================================
-
-
-/// intialise watch dog with a 1 sec interrupt time
-void wd_init() 
-{
-  WDTCSR |= (1<<WDCE )|(1<<WDE ); //allow changes
-  WDTCSR = (1<<WDCE )|(1<<WDE )|(1<<WDP3 )|(1<<WDP0); // Reset after 8 sec.
-//  WDTCSR = (1<<WDIF)|(1<<WDIE)| (1<<WDCE )|(1<<WDE )|  (1<<WDP3) | (1<<WDP0);
-}
-
-/// reset watchdog. MUST be called every 1s after init or avr will reset.
-void wd_reset() 
-{
-  wdt_reset();
-}
-
-//===========================================================================
-//=============================ISR               ============================
-//===========================================================================
-
-//Watchdog timer interrupt, called if main program blocks >1sec
-ISR(WDT_vect) 
-{ 
-  if(timeout_seconds++ >= WATCHDOG_TIMEOUT)
-  {
- 
-    #ifdef RESET_MANUAL
-      LCD_MESSAGEPGM("Please Reset!");
-      LCD_STATUS;
-      SERIAL_ERROR_START;
-      SERIAL_ERRORLNPGM("Something is wrong, please turn off the printer.");
-    #else
-      LCD_MESSAGEPGM("Timeout, resetting!");
-      LCD_STATUS;
-    #endif 
-    //disable watchdog, it will survife reboot.
-    WDTCSR |= (1<<WDCE) | (1<<WDE);
-    WDTCSR = 0;
-    #ifdef RESET_MANUAL
-      kill(); //kill blocks
-      while(1); //wait for user or serial reset
-    #else
-      ctrlaltdelete();
-    #endif
-  }
-}
-
-#endif /* USE_WATCHDOG */
diff --git a/Marlin/wiring.h b/Marlin/wiring.h
deleted file mode 100644
index 904d2eb..0000000
--- a/Marlin/wiring.h
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
- * fixed by this patch:
- * http://code.google.com/p/arduino/issues/detail?id=604
- * */
-/*
-  wiring.h - Partial implementation of the Wiring API for the ATmega8.
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id$
-*/
-
-#ifndef Wiring_h
-#define Wiring_h
-
-#include <avr/io.h>
-#include <stdlib.h>
-#include "binary.h"
-
-#ifdef __cplusplus
-extern "C"{
-#endif
-
-#define HIGH 0x1
-#define LOW  0x0
-
-#define INPUT 0x0
-#define OUTPUT 0x1
-
-#define true 0x1
-#define false 0x0
-
-#define PI 3.1415926535897932384626433832795
-#define HALF_PI 1.5707963267948966192313216916398
-#define TWO_PI 6.283185307179586476925286766559
-#define DEG_TO_RAD 0.017453292519943295769236907684886
-#define RAD_TO_DEG 57.295779513082320876798154814105
-
-#define SERIAL  0x0
-#define DISPLAY 0x1
-
-#define LSBFIRST 0
-#define MSBFIRST 1
-
-#define CHANGE 1
-#define FALLING 2
-#define RISING 3
-
-#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
-#define INTERNAL1V1 2
-#define INTERNAL2V56 3
-#else
-#define INTERNAL 3
-#endif
-#define DEFAULT 1
-#define EXTERNAL 0
-
-// undefine stdlib's abs if encountered
-#ifdef abs
-#undef abs
-#endif
-
-#define min(a,b) ((a)<(b)?(a):(b))
-#define max(a,b) ((a)>(b)?(a):(b))
-#define abs(x) ((x)>0?(x):-(x))
-#define constrain(amt,low,high) ((amt)<(low)?(low):((amt)>(high)?(high):(amt)))
-#if __AVR_LIBC_VERSION__ < 10701UL
-#define round(x)     ((x)>=0?(long)((x)+0.5):(long)((x)-0.5))
-#endif
-#define radians(deg) ((deg)*DEG_TO_RAD)
-#define degrees(rad) ((rad)*RAD_TO_DEG)
-#define sq(x) ((x)*(x))
-
-#define interrupts() sei()
-#define noInterrupts() cli()
-
-#define clockCyclesPerMicrosecond() ( F_CPU / 1000000L )
-#define clockCyclesToMicroseconds(a) ( ((a) * 1000L) / (F_CPU / 1000L) )
-#define microsecondsToClockCycles(a) ( ((a) * (F_CPU / 1000L)) / 1000L )
-
-#define lowByte(w) ((uint8_t) ((w) & 0xff))
-#define highByte(w) ((uint8_t) ((w) >> 8))
-
-#define bitRead(value, bit) (((value) >> (bit)) & 0x01)
-#define bitSet(value, bit) ((value) |= (1UL << (bit)))
-#define bitClear(value, bit) ((value) &= ~(1UL << (bit)))
-#define bitWrite(value, bit, bitvalue) (bitvalue ? bitSet(value, bit) : bitClear(value, bit))
-
-
-typedef unsigned int word;
-
-#define bit(b) (1UL << (b))
-
-typedef uint8_t boolean;
-typedef uint8_t byte;
-
-void init(void);
-
-void pinMode(uint8_t, uint8_t);
-void digitalWrite(uint8_t, uint8_t);
-int digitalRead(uint8_t);
-int analogRead(uint8_t);
-void analogReference(uint8_t mode);
-void analogWrite(uint8_t, int);
-
-unsigned long millis(void);
-unsigned long micros(void);
-void delay(unsigned long);
-void delayMicroseconds(unsigned int us);
-unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout);
-
-void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val);
-uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder);
-
-void attachInterrupt(uint8_t, void (*)(void), int mode);
-void detachInterrupt(uint8_t);
-
-void setup(void);
-void loop(void);
-
-#ifdef __cplusplus
-} // extern "C"
-#endif
-
-#endif
diff --git a/README.md b/README.md
index fb2c189..309fdd1 100644
--- a/README.md
+++ b/README.md
@@ -45,6 +45,7 @@ Features:
 *   Heater power reporting. Useful for PID monitoring.
 *   PID tuning
 *   CoreXY kinematics (www.corexy.com/theory.html)
+*   Configurable serial port to support connection of wireless adaptors.
 
 The default baudrate is 250000. This baudrate has less jitter and hence errors than the usual 115200 baud, but is less supported by drivers and host-environments.
 
@@ -183,11 +184,11 @@ MISC:
 Configuring and compilation:
 ============================
 
-Install the arduino software IDE/toolset v22
+Install the arduino software IDE/toolset v23 (Some configurations also work with 1.x.x)
    http://www.arduino.cc/en/Main/Software
 
-For gen6 and sanguinololu the Sanguino directory in the Marlin dir needs to be copied to the arduino environment.
-  copy Marlin\sanguino <arduino home>\hardware\Sanguino
+For gen6/gen7 and sanguinololu the Sanguino directory in the Marlin dir needs to be copied to the arduino environment.
+  copy ArduinoAddons\Arduino_x.x.x\sanguino <arduino home>\hardware\Sanguino
 
 Install Ultimaker's RepG 25 build
     http://software.ultimaker.com

